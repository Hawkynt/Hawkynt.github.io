{
  "summary": {
    "processedFiles": 200,
    "standardizedVectors": 30,
    "addedSources": 0,
    "verifiedUrls": 0,
    "totalIssues": 80,
    "filesWithIssues": 80
  },
  "beforeAfter": [
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001",
        "expected": "¦MéÁ±#§",
        "description": "3DES EDE2 mode - all zeros plaintext with weak key pattern",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"expected\": \"¦MéÁ±#§\",\n        \"description\": \"3DES EDE2 mode - all zeros plaintext with weak key pattern\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001þþþþþþþþ\",\n        \"expected\": \"?Õ¦oMx­\",\n        \"description\": \"3DES EDE2 mode - single bit plaintext with contrasting keys\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u00134Wy¼ßñ\\u001fíË©eC!\",\n        \"expected\": \"ÍI\\u0015·_Öb\",\n        \"description\": \"3DES EDE2 mode - FIPS 46-3 standard test vector\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"expected\": \"¦MéÁ±#§\",\n        \"description\": \"3DES EDE3 mode - all zeros plaintext with weak key (all three keys same)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u00134Wy¼ßñ\\u001fíË©eC!ª»ÌÝîÿ\\u0000\\u0011\",\n        \"expected\": \"åpËÞK¨^\",\n        \"description\": \"3DES EDE3 mode - three distinct keys test vector\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"|§¿¦ýL\",\n        \"description\": \"3DES EDE2 mode - all ones plaintext with distinct keys\"\n    },\n    {\n        \"input\": \"t¸èÇ;Ê}\",\n        \"key\": \"IxDaË^IxDaË^\",\n        \"expected\": \"Tá\\u0004h\\u0013¾Q\",\n        \"description\": \"3DES EDE2 mode - NIST SP 800-20 sample vector\"\n    },\n    {\n        \"input\": \"´ïYÔÖßxu\",\n        \"key\": \"bF\\u000e\\bX-IbF\\u000e\\bX-I9@h¿W#¶\",\n        \"expected\": \"¸ù2^~\\r6§\",\n        \"description\": \"3DES EDE3 mode - NIST SP 800-20 three-key sample vector\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'NIST SP 800-67 Rev 2 - Triple Data Encryption Algorithm Guidelines',\n        url: 'https://csrc.nist.gov/publications/detail/sp/800-67/rev-2/final',\n        description: 'Official NIST guidelines for Triple DES implementation and security considerations'\n      },\n      {\n        name: 'FIPS 46-3 - Data Encryption Standard (DES) including Triple DES',\n        url: 'https://csrc.nist.gov/publications/detail/fips/46/3/archive/1999-10-25',\n        description: 'NIST specification for DES and Triple DES (withdrawn 2005)'\n      },\n      {\n        name: 'ANSI X9.52-1998 - Triple Data Encryption Algorithm',\n        url: 'https://webstore.ansi.org/standards/ascx9/ansix9521998',\n        description: 'ANSI standard for Triple Data Encryption Algorithm modes of operation'\n      },\n      {\n        name: 'RFC 1851 - ESP Triple DES Transform',\n        url: 'https://tools.ietf.org/rfc/rfc1851.txt',\n        description: 'IETF RFC defining Triple DES transform for Encapsulating Security Payload'\n      },\n      {\n        name: 'NIST SP 800-131A Rev 2 - Cryptographic Algorithm Deprecation',\n        url: 'https://csrc.nist.gov/publications/detail/sp/800-131a/rev-2/final',\n        description: 'NIST guidance on Triple DES deprecation and transition to AES'\n      }\n    ],\n    implementations: [\n      {\n        name: 'OpenSSL 3DES Implementation',\n        url: 'https://github.com/openssl/openssl/blob/master/crypto/des/',\n        description: 'Production-quality Triple DES implementation from OpenSSL'\n      },\n      {\n        name: 'libgcrypt 3DES Implementation',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/des.c',\n        description: 'Triple DES implementation from GNU libgcrypt'\n      },\n      {\n        name: 'Crypto++ 3DES Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/3des.cpp',\n        description: 'High-performance C++ Triple DES implementation'\n      },\n      {\n        name: 'Bouncy Castle 3DES Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java Triple DES implementation from Bouncy Castle'\n      },\n      {\n        name: 'Microsoft .NET 3DES Implementation',\n        url: 'https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.tripledes',\n        description: 'Microsoft .NET Framework Triple DES implementation'\n      }\n    ],\n    validation: [\n      {\n        name: 'NIST CAVP 3DES Test Vectors',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/block-ciphers',\n        description: 'Comprehensive test vectors for Triple DES validation'\n      },\n      {\n        name: 'NIST 3DES Known Answer Tests',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/block-ciphers#TDES',\n        description: 'Known Answer Tests for Triple DES algorithm validation'\n      },\n      {\n        name: 'NIST Transition Away from 3DES',\n        url: 'https://csrc.nist.gov/News/2019/nist-withdraws-outdated-data-encryption-standard',\n        description: 'NIST announcement regarding 3DES deprecation and withdrawal timeline'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n\n    // Initialize cipher\n    Init: function() {\n      // Ensure DES is initialized\n      if (global.DES && typeof global.DES.Init === 'function' && !global.DES.isInitialized) {\n        global.DES.Init();\n      }\n      TripleDES.isInitialized = true;\n    },\n\n    // Set up key - supports both EDE2 (16-byte) and EDE3 (24-byte) keys\n    KeySetup: function(optional_szKey) {\n      // Validate key length\n      if (!optional_szKey || (optional_szKey.length !== 16 && optional_szKey.length !== 24)) {\n        global.throwException('Invalid Key Length Exception', '3DES requires 16 bytes (EDE2) or 24 bytes (EDE3) key length', '3DES', 'KeySetup');\n        return null;\n      }\n\n      let id;\n      do {\n        id = '3DES[' + global.generateUniqueID() + ']';\n      } while (TripleDES.instances[id] || global.objectInstances[id]);\n\n      TripleDES.instances[szID] = new TripleDES.TripleDESInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n\n    // Clear cipher data\n    ClearData: function(id) {\n      if (TripleDES.instances[id]) {\n        // Clear all DES instances used by this 3DES instance\n        const instance = TripleDES.instances[szID];\n        if (instance.desInstance1) global.DES.ClearData(instance.desInstance1);\n        if (instance.desInstance2) global.DES.ClearData(instance.desInstance2);\n        if (instance.desInstance3) global.DES.ClearData(instance.desInstance3);\n        \n        delete TripleDES.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, '3DES', 'ClearData');\n        return false;\n      }\n    },\n\n    // Encrypt block using Triple DES EDE mode\n    encryptBlock: function(id, szPlainText) {\n      if (!TripleDES.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, '3DES', 'encryptBlock');\n        return szPlainText;\n      }\n\n      // Validate block size\n      if (!szPlainText || szPlainText.length !== 8) {\n        global.throwException('Invalid Block Size Exception', '3DES requires exactly 8 bytes block size', '3DES', 'encryptBlock');\n        return szPlainText;\n      }\n\n      const instance = TripleDES.instances[szID];\n      \n      // Triple DES EDE encryption: E_K3(D_K2(E_K1(P)))\n      // Standard EDE sequence: Encrypt with K1, Decrypt with K2, Encrypt with K3\n      let result = szPlainText;\n      \n      try {\n        // Step 1: Encrypt with K1\n        result = global.DES.encryptBlock(instance.desInstance1, result);\n        \n        // Step 2: Decrypt with K2\n        result = global.DES.decryptBlock(instance.desInstance2, result);\n        \n        // Step 3: Encrypt with K3 (or K1 for EDE2)\n        result = global.DES.encryptBlock(instance.desInstance3, result);\n        \n        return result;\n      } catch (e) {\n        global.throwException('3DES Encryption Error', e.message, '3DES', 'encryptBlock');\n        return szPlainText;\n      }\n    },\n\n    // Decrypt block using Triple DES EDE mode\n    decryptBlock: function(id, szCipherText) {\n      if (!TripleDES.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, '3DES', 'decryptBlock');\n        return szCipherText;\n      }\n\n      // Validate block size\n      if (!szCipherText || szCipherText.length !== 8) {\n        global.throwException('Invalid Block Size Exception', '3DES requires exactly 8 bytes block size', '3DES', 'decryptBlock');\n        return szCipherText;\n      }\n\n      const instance = TripleDES.instances[szID];\n      \n      // Triple DES EDE decryption: D_K1(E_K2(D_K3(C)))\n      // Reverse of encryption: Decrypt with K3, Encrypt with K2, Decrypt with K1\n      let result = szCipherText;\n      \n      try {\n        // Step 1: Decrypt with K3 (or K1 for EDE2)\n        result = global.DES.decryptBlock(instance.desInstance3, result);\n        \n        // Step 2: Encrypt with K2\n        result = global.DES.encryptBlock(instance.desInstance2, result);\n        \n        // Step 3: Decrypt with K1\n        result = global.DES.decryptBlock(instance.desInstance1, result);\n        \n        return result;\n      } catch (e) {\n        global.throwException('3DES Decryption Error', e.message, '3DES', 'decryptBlock');\n        return szCipherText;\n      }\n    },\n\n    // Instance class for 3DES\n    TripleDESInstance: function(key) {\n      if (key.length === 16) {\n        // EDE2 mode: K1-K2-K1 (16-byte key = K1 + K2)\n        const key1 = szKey.substring(0, 8);\n        const key2 = szKey.substring(8, 16);\n        \n        this.keyMode = 'EDE2';\n        this.desInstance1 = global.DES.KeySetup(key1);  // K1\n        this.desInstance2 = global.DES.KeySetup(key2);  // K2\n        this.desInstance3 = global.DES.KeySetup(key1);  // K1 (reused)\n        \n      } else if (key.length === 24) {\n        // EDE3 mode: K1-K2-K3 (24-byte key = K1 + K2 + K3)\n        const key1 = szKey.substring(0, 8);\n        const key2 = szKey.substring(8, 16);\n        const key3 = szKey.substring(16, 24);\n        \n        this.keyMode = 'EDE3';\n        this.desInstance1 = global.DES.KeySetup(key1);  // K1\n        this.desInstance2 = global.DES.KeySetup(key2);  // K2\n        this.desInstance3 = global.DES.KeySetup(key3);  // K3\n        \n      } else {\n        throw new Error('Invalid key length for 3DES: must be 16 or 24 bytes');\n      }\n\n      // Verify all DES instances were created successfully\n      if (!this.desInstance1 || !this.desInstance2 || !this.desInstance3) {\n        throw new Error('Failed to create DES instances for 3DES operation');\n      }\n    },\n\n    // Utility function to validate weak keys (optional security check)\n    isWeakKey: function(key) {\n      // Check for weak DES keys in each 8-byte segment\n      // This is important for 3DES security analysis\n      \n      if (!key || (key.length !== 16 && key.length !== 24)) {\n        return false;\n      }\n      \n      // Known DES weak keys (in hex):\n      const weakKeys = [\n        '\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01',  // All zeros\n        '\\xFE\\xFE\\xFE\\xFE\\xFE\\xFE\\xFE\\xFE',  // All ones\n        '\\x1F\\x1F\\x1F\\x1F\\x0E\\x0E\\x0E\\x0E',  // Weak key 1\n        '\\xE0\\xE0\\xE0\\xE0\\xF1\\xF1\\xF1\\xF1',  // Weak key 2\n        // Add more known weak keys as needed\n      ];\n      \n      // Check each 8-byte segment\n      for (let i = 0; i < key.length; i += 8) {\n        const keySegment = szKey.substring(i, i + 8);\n        for (let j = 0; j < weakKeys.length; j++) {\n          if (keySegment === weakKeys[j]) {\n            return true;\n          }\n        }\n      }\n      \n      return false;\n    },\n\n    // Get information about the current key mode\n    getKeyInfo: function(id) {\n      if (!TripleDES.instances[id]) {\n        return null;\n      }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C7530303031",
        "expected": "Expected (hex): 8CA64DE9C1B123A7",
        "description": "3DES EDE2 mode - all zeros plaintext with weak key pattern",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"expected\": \"¦MéÁ±#§\",\n        \"description\": \"3DES EDE2 mode - all zeros plaintext with weak key pattern\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001þþþþþþþþ\",\n        \"expected\": \"?Õ¦oMx­\",\n        \"description\": \"3DES EDE2 mode - single bit plaintext with contrasting keys\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u00134Wy¼ßñ\\u001fíË©eC!\",\n        \"expected\": \"ÍI\\u0015·_Öb\",\n        \"description\": \"3DES EDE2 mode - FIPS 46-3 standard test vector\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"expected\": \"¦MéÁ±#§\",\n        \"description\": \"3DES EDE3 mode - all zeros plaintext with weak key (all three keys same)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u00134Wy¼ßñ\\u001fíË©eC!ª»ÌÝîÿ\\u0000\\u0011\",\n        \"expected\": \"åpËÞK¨^\",\n        \"description\": \"3DES EDE3 mode - three distinct keys test vector\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"|§¿¦ýL\",\n        \"description\": \"3DES EDE2 mode - all ones plaintext with distinct keys\"\n    },\n    {\n        \"input\": \"t¸èÇ;Ê}\",\n        \"key\": \"IxDaË^IxDaË^\",\n        \"expected\": \"Tá\\u0004h\\u0013¾Q\",\n        \"description\": \"3DES EDE2 mode - NIST SP 800-20 sample vector\"\n    },\n    {\n        \"input\": \"´ïYÔÖßxu\",\n        \"key\": \"bF\\u000e\\bX-IbF\\u000e\\bX-I9@h¿W#¶\",\n        \"expected\": \"¸ù2^~\\r6§\",\n        \"description\": \"3DES EDE3 mode - NIST SP 800-20 three-key sample vector\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'NIST SP 800-67 Rev 2 - Triple Data Encryption Algorithm Guidelines',\n        url: 'https://csrc.nist.gov/publications/detail/sp/800-67/rev-2/final',\n        description: 'Official NIST guidelines for Triple DES implementation and security considerations'\n      },\n      {\n        name: 'FIPS 46-3 - Data Encryption Standard (DES) including Triple DES',\n        url: 'https://csrc.nist.gov/publications/detail/fips/46/3/archive/1999-10-25',\n        description: 'NIST specification for DES and Triple DES (withdrawn 2005)'\n      },\n      {\n        name: 'ANSI X9.52-1998 - Triple Data Encryption Algorithm',\n        url: 'https://webstore.ansi.org/standards/ascx9/ansix9521998',\n        description: 'ANSI standard for Triple Data Encryption Algorithm modes of operation'\n      },\n      {\n        name: 'RFC 1851 - ESP Triple DES Transform',\n        url: 'https://tools.ietf.org/rfc/rfc1851.txt',\n        description: 'IETF RFC defining Triple DES transform for Encapsulating Security Payload'\n      },\n      {\n        name: 'NIST SP 800-131A Rev 2 - Cryptographic Algorithm Deprecation',\n        url: 'https://csrc.nist.gov/publications/detail/sp/800-131a/rev-2/final',\n        description: 'NIST guidance on Triple DES deprecation and transition to AES'\n      }\n    ],\n    implementations: [\n      {\n        name: 'OpenSSL 3DES Implementation',\n        url: 'https://github.com/openssl/openssl/blob/master/crypto/des/',\n        description: 'Production-quality Triple DES implementation from OpenSSL'\n      },\n      {\n        name: 'libgcrypt 3DES Implementation',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/des.c',\n        description: 'Triple DES implementation from GNU libgcrypt'\n      },\n      {\n        name: 'Crypto++ 3DES Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/3des.cpp',\n        description: 'High-performance C++ Triple DES implementation'\n      },\n      {\n        name: 'Bouncy Castle 3DES Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java Triple DES implementation from Bouncy Castle'\n      },\n      {\n        name: 'Microsoft .NET 3DES Implementation',\n        url: 'https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.tripledes',\n        description: 'Microsoft .NET Framework Triple DES implementation'\n      }\n    ],\n    validation: [\n      {\n        name: 'NIST CAVP 3DES Test Vectors',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/block-ciphers',\n        description: 'Comprehensive test vectors for Triple DES validation'\n      },\n      {\n        name: 'NIST 3DES Known Answer Tests',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/block-ciphers#TDES',\n        description: 'Known Answer Tests for Triple DES algorithm validation'\n      },\n      {\n        name: 'NIST Transition Away from 3DES',\n        url: 'https://csrc.nist.gov/News/2019/nist-withdraws-outdated-data-encryption-standard',\n        description: 'NIST announcement regarding 3DES deprecation and withdrawal timeline'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n\n    // Initialize cipher\n    Init: function() {\n      // Ensure DES is initialized\n      if (global.DES && typeof global.DES.Init === 'function' && !global.DES.isInitialized) {\n        global.DES.Init();\n      }\n      TripleDES.isInitialized = true;\n    },\n\n    // Set up key - supports both EDE2 (16-byte) and EDE3 (24-byte) keys\n    KeySetup: function(optional_szKey) {\n      // Validate key length\n      if (!optional_szKey || (optional_szKey.length !== 16 && optional_szKey.length !== 24)) {\n        global.throwException('Invalid Key Length Exception', '3DES requires 16 bytes (EDE2) or 24 bytes (EDE3) key length', '3DES', 'KeySetup');\n        return null;\n      }\n\n      let id;\n      do {\n        id = '3DES[' + global.generateUniqueID() + ']';\n      } while (TripleDES.instances[id] || global.objectInstances[id]);\n\n      TripleDES.instances[szID] = new TripleDES.TripleDESInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n\n    // Clear cipher data\n    ClearData: function(id) {\n      if (TripleDES.instances[id]) {\n        // Clear all DES instances used by this 3DES instance\n        const instance = TripleDES.instances[szID];\n        if (instance.desInstance1) global.DES.ClearData(instance.desInstance1);\n        if (instance.desInstance2) global.DES.ClearData(instance.desInstance2);\n        if (instance.desInstance3) global.DES.ClearData(instance.desInstance3);\n        \n        delete TripleDES.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, '3DES', 'ClearData');\n        return false;\n      }\n    },\n\n    // Encrypt block using Triple DES EDE mode\n    encryptBlock: function(id, szPlainText) {\n      if (!TripleDES.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, '3DES', 'encryptBlock');\n        return szPlainText;\n      }\n\n      // Validate block size\n      if (!szPlainText || szPlainText.length !== 8) {\n        global.throwException('Invalid Block Size Exception', '3DES requires exactly 8 bytes block size', '3DES', 'encryptBlock');\n        return szPlainText;\n      }\n\n      const instance = TripleDES.instances[szID];\n      \n      // Triple DES EDE encryption: E_K3(D_K2(E_K1(P)))\n      // Standard EDE sequence: Encrypt with K1, Decrypt with K2, Encrypt with K3\n      let result = szPlainText;\n      \n      try {\n        // Step 1: Encrypt with K1\n        result = global.DES.encryptBlock(instance.desInstance1, result);\n        \n        // Step 2: Decrypt with K2\n        result = global.DES.decryptBlock(instance.desInstance2, result);\n        \n        // Step 3: Encrypt with K3 (or K1 for EDE2)\n        result = global.DES.encryptBlock(instance.desInstance3, result);\n        \n        return result;\n      } catch (e) {\n        global.throwException('3DES Encryption Error', e.message, '3DES', 'encryptBlock');\n        return szPlainText;\n      }\n    },\n\n    // Decrypt block using Triple DES EDE mode\n    decryptBlock: function(id, szCipherText) {\n      if (!TripleDES.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, '3DES', 'decryptBlock');\n        return szCipherText;\n      }\n\n      // Validate block size\n      if (!szCipherText || szCipherText.length !== 8) {\n        global.throwException('Invalid Block Size Exception', '3DES requires exactly 8 bytes block size', '3DES', 'decryptBlock');\n        return szCipherText;\n      }\n\n      const instance = TripleDES.instances[szID];\n      \n      // Triple DES EDE decryption: D_K1(E_K2(D_K3(C)))\n      // Reverse of encryption: Decrypt with K3, Encrypt with K2, Decrypt with K1\n      let result = szCipherText;\n      \n      try {\n        // Step 1: Decrypt with K3 (or K1 for EDE2)\n        result = global.DES.decryptBlock(instance.desInstance3, result);\n        \n        // Step 2: Encrypt with K2\n        result = global.DES.encryptBlock(instance.desInstance2, result);\n        \n        // Step 3: Decrypt with K1\n        result = global.DES.decryptBlock(instance.desInstance1, result);\n        \n        return result;\n      } catch (e) {\n        global.throwException('3DES Decryption Error', e.message, '3DES', 'decryptBlock');\n        return szCipherText;\n      }\n    },\n\n    // Instance class for 3DES\n    TripleDESInstance: function(key) {\n      if (key.length === 16) {\n        // EDE2 mode: K1-K2-K1 (16-byte key = K1 + K2)\n        const key1 = szKey.substring(0, 8);\n        const key2 = szKey.substring(8, 16);\n        \n        this.keyMode = 'EDE2';\n        this.desInstance1 = global.DES.KeySetup(key1);  // K1\n        this.desInstance2 = global.DES.KeySetup(key2);  // K2\n        this.desInstance3 = global.DES.KeySetup(key1);  // K1 (reused)\n        \n      } else if (key.length === 24) {\n        // EDE3 mode: K1-K2-K3 (24-byte key = K1 + K2 + K3)\n        const key1 = szKey.substring(0, 8);\n        const key2 = szKey.substring(8, 16);\n        const key3 = szKey.substring(16, 24);\n        \n        this.keyMode = 'EDE3';\n        this.desInstance1 = global.DES.KeySetup(key1);  // K1\n        this.desInstance2 = global.DES.KeySetup(key2);  // K2\n        this.desInstance3 = global.DES.KeySetup(key3);  // K3\n        \n      } else {\n        throw new Error('Invalid key length for 3DES: must be 16 or 24 bytes');\n      }\n\n      // Verify all DES instances were created successfully\n      if (!this.desInstance1 || !this.desInstance2 || !this.desInstance3) {\n        throw new Error('Failed to create DES instances for 3DES operation');\n      }\n    },\n\n    // Utility function to validate weak keys (optional security check)\n    isWeakKey: function(key) {\n      // Check for weak DES keys in each 8-byte segment\n      // This is important for 3DES security analysis\n      \n      if (!key || (key.length !== 16 && key.length !== 24)) {\n        return false;\n      }\n      \n      // Known DES weak keys (in hex):\n      const weakKeys = [\n        '\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01',  // All zeros\n        '\\xFE\\xFE\\xFE\\xFE\\xFE\\xFE\\xFE\\xFE',  // All ones\n        '\\x1F\\x1F\\x1F\\x1F\\x0E\\x0E\\x0E\\x0E',  // Weak key 1\n        '\\xE0\\xE0\\xE0\\xE0\\xF1\\xF1\\xF1\\xF1',  // Weak key 2\n        // Add more known weak keys as needed\n      ];\n      \n      // Check each 8-byte segment\n      for (let i = 0; i < key.length; i += 8) {\n        const keySegment = szKey.substring(i, i + 8);\n        for (let j = 0; j < weakKeys.length; j++) {\n          if (keySegment === weakKeys[j]) {\n            return true;\n          }\n        }\n      }\n      \n      return false;\n    },\n\n    // Get information about the current key mode\n    getKeyInfo: function(id) {\n      if (!TripleDES.instances[id]) {\n        return null;\n      }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C7530303031",
        "expectedHex": "8CA64DE9C1B123A7"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": ">\\u000fgIªxÉhw¸\\u0004\\u0013¤",
        "description": "CHAM-128/128 all zeros test vector (educational implementation)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \">\\u000fgIªxÉhw¸\\u0004\\u0013¤\",\n        \"description\": \"CHAM-128/128 all zeros test vector (educational implementation)\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"^¼0¿W#æ²æÕÀ2Ê\",\n        \"description\": \"CHAM-128/128 all ones boundary test vector (educational implementation)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"key\": \"\\u0000\\u0011\\\"3DUfwª»ÌÝîÿ\",\n        \"expected\": \"ýÝ\\u001d¼\\u0013ì@Xhß\\u0016D|Iò\",\n        \"description\": \"CHAM-128/128 sequential pattern test vector (educational implementation)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"´È \\u0010\\u000eL\\u001e7IÒ­Î Ù´X\",\n        \"description\": \"CHAM-128/128 single bit test vector - ARX structure validation\"\n    },\n    {\n        \"input\": \"HELLO CHAM TEST!\",\n        \"key\": \"KOREAN_CIPHER_16\",\n        \"expected\": \"\\u0002¿ñ\\u0006[a|c=+\\u0007JÊªî\",\n        \"description\": \"CHAM-128/128 ASCII plaintext and key test - educational demonstration\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // CHAM-128/128 Constants\n    ROUNDS: 112,                          // Revised version uses 112 rounds (increased from 80)\n    WORDS_PER_BLOCK: 4,                   // 128-bit block = 4 x 32-bit words\n    WORDS_PER_KEY: 4,                     // 128-bit key = 4 x 32-bit words\n    \n    // Rotation constants for CHAM-128/128 (optimized for software performance)\n    ROT_ALPHA: 1,                         // Left rotation amount for first operation\n    ROT_BETA: 8,                          // Left rotation amount for second operation\n    \n    // Initialize cipher\n    Init: function() {\n      CHAM.isInitialized = true;\n    },\n    \n    // Set up key and create cipher instance\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || optional_szKey.length !== 16) {\n        global.throwException('CHAM Key Exception', 'Key must be exactly 16 bytes (128 bits)', 'CHAM', 'KeySetup');\n        return null;\n      }\n      \n      let id;\n      do {\n        id = 'CHAM[' + global.generateUniqueID() + ']';\n      } while (CHAM.instances[id] || global.objectInstances[id]);\n      \n      CHAM.instances[szID] = new CHAM.CHAMInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data securely\n    ClearData: function(id) {\n      if (CHAM.instances[id]) {\n        // Clear sensitive key data\n        if (CHAM.instances[id].roundKeys) {\n          global.OpCodes.ClearArray(CHAM.instances[id].roundKeys);\n        }\n        if (CHAM.instances[id].key) {\n          global.OpCodes.ClearArray(CHAM.instances[id].key);\n        }\n        delete CHAM.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'CHAM', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt 128-bit block\n    encryptBlock: function(id, szPlainText) {\n      if (!CHAM.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'CHAM', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 16) {\n        global.throwException('CHAM Block Size Exception', 'Input must be exactly 16 bytes', 'CHAM', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const objCHAM = CHAM.instances[szID];\n      \n      // Convert input string to 32-bit words using OpCodes (little-endian for CHAM)\n      const bytes = global.OpCodes.StringToBytes(szPlainText);\n      let X = [\n        global.OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]),\n        global.OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]),\n        global.OpCodes.Pack32LE(bytes[8], bytes[9], bytes[10], bytes[11]),\n        global.OpCodes.Pack32LE(bytes[12], bytes[13], bytes[14], bytes[15])\n      ];\n      \n      // CHAM encryption: 112 rounds of ARX operations using 4-branch Feistel structure\n      for (let r = 0; r < CHAM.ROUNDS; r++) {\n        // Get round key (cycling through the 8 round keys)\n        const rk = objCHAM.roundKeys[r % 8];\n        \n        // CHAM round function with odd/even round variation\n        if (r % 2 === 0) {\n          // Even rounds: X[0] = ((X[0] ^ r) + (ROL(X[1], ROT_ALPHA) ^ rk)) <<< ROT_BETA\n          const temp = (global.OpCodes.RotL32(X[1], CHAM.ROT_ALPHA) ^ rk) >>> 0;\n          X[0] = global.OpCodes.RotL32(((X[0] ^ r) + temp) >>> 0, CHAM.ROT_BETA);\n        } else {\n          // Odd rounds: X[0] = ((X[0] ^ r) + (ROL(X[1], ROT_BETA) ^ rk)) <<< ROT_ALPHA  \n          const temp = (global.OpCodes.RotL32(X[1], CHAM.ROT_BETA) ^ rk) >>> 0;\n          X[0] = global.OpCodes.RotL32(((X[0] ^ r) + temp) >>> 0, CHAM.ROT_ALPHA);\n        }\n        \n        // Rotate the 4-branch Feistel state: X = [X[1], X[2], X[3], X[0]]\n        const temp_x = X[0];\n        X[0] = X[1];\n        X[1] = X[2];\n        X[2] = X[3];\n        X[3] = temp_x;\n      }\n      \n      // Convert back to byte string using OpCodes (little-endian)\n      const result = [];\n      for (let i = 0; i < 4; i++) {\n        const wordBytes = global.OpCodes.Unpack32LE(X[i]);\n        result.push(...wordBytes);\n      }\n      \n      return global.OpCodes.BytesToString(result);\n    },\n    \n    // Decrypt 128-bit block\n    decryptBlock: function(id, szCipherText) {\n      if (!CHAM.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'CHAM', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 16) {\n        global.throwException('CHAM Block Size Exception', 'Input must be exactly 16 bytes', 'CHAM', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const objCHAM = CHAM.instances[szID];\n      \n      // Convert input string to 32-bit words using OpCodes (little-endian)\n      const bytes = global.OpCodes.StringToBytes(szCipherText);\n      let X = [\n        global.OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]),\n        global.OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]),\n        global.OpCodes.Pack32LE(bytes[8], bytes[9], bytes[10], bytes[11]),\n        global.OpCodes.Pack32LE(bytes[12], bytes[13], bytes[14], bytes[15])\n      ];\n      \n      // CHAM decryption: reverse the encryption process (112 rounds in reverse order)\n      for (let r = CHAM.ROUNDS - 1; r >= 0; r--) {\n        // Reverse the 4-branch Feistel state rotation: X = [X[3], X[0], X[1], X[2]]\n        const temp_x = X[3];\n        X[3] = X[2];\n        X[2] = X[1];\n        X[1] = X[0];\n        X[0] = temp_x;\n        \n        // Get round key (cycling through the 8 round keys)\n        const rk = objCHAM.roundKeys[r % 8];\n        \n        // Reverse CHAM round function with odd/even round variation\n        if (r % 2 === 0) {\n          // Even rounds (reverse): X[0] = (ROR(X[0], ROT_BETA) - (ROL(X[1], ROT_ALPHA) ^ rk)) ^ r\n          const rotated = global.OpCodes.RotR32(X[0], CHAM.ROT_BETA);\n          const temp = (global.OpCodes.RotL32(X[1], CHAM.ROT_ALPHA) ^ rk) >>> 0;\n          X[0] = ((rotated - temp) >>> 0) ^ r;\n        } else {\n          // Odd rounds (reverse): X[0] = (ROR(X[0], ROT_ALPHA) - (ROL(X[1], ROT_BETA) ^ rk)) ^ r\n          const rotated = global.OpCodes.RotR32(X[0], CHAM.ROT_ALPHA);\n          const temp = (global.OpCodes.RotL32(X[1], CHAM.ROT_BETA) ^ rk) >>> 0;\n          X[0] = ((rotated - temp) >>> 0) ^ r;\n        }\n      }\n      \n      // Convert back to byte string using OpCodes (little-endian)\n      const result = [];\n      for (let i = 0; i < 4; i++) {\n        const wordBytes = global.OpCodes.Unpack32LE(X[i]);\n        result.push(...wordBytes);\n      }\n      \n      return global.OpCodes.BytesToString(result);\n    }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 893E5C75303030666749AA78C9688777B85C75303030345C75303031339EA4",
        "description": "CHAM-128/128 all zeros test vector (educational implementation)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \">\\u000fgIªxÉhw¸\\u0004\\u0013¤\",\n        \"description\": \"CHAM-128/128 all zeros test vector (educational implementation)\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"^¼0¿W#æ²æÕÀ2Ê\",\n        \"description\": \"CHAM-128/128 all ones boundary test vector (educational implementation)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"key\": \"\\u0000\\u0011\\\"3DUfwª»ÌÝîÿ\",\n        \"expected\": \"ýÝ\\u001d¼\\u0013ì@Xhß\\u0016D|Iò\",\n        \"description\": \"CHAM-128/128 sequential pattern test vector (educational implementation)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"´È \\u0010\\u000eL\\u001e7IÒ­Î Ù´X\",\n        \"description\": \"CHAM-128/128 single bit test vector - ARX structure validation\"\n    },\n    {\n        \"input\": \"HELLO CHAM TEST!\",\n        \"key\": \"KOREAN_CIPHER_16\",\n        \"expected\": \"\\u0002¿ñ\\u0006[a|c=+\\u0007JÊªî\",\n        \"description\": \"CHAM-128/128 ASCII plaintext and key test - educational demonstration\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // CHAM-128/128 Constants\n    ROUNDS: 112,                          // Revised version uses 112 rounds (increased from 80)\n    WORDS_PER_BLOCK: 4,                   // 128-bit block = 4 x 32-bit words\n    WORDS_PER_KEY: 4,                     // 128-bit key = 4 x 32-bit words\n    \n    // Rotation constants for CHAM-128/128 (optimized for software performance)\n    ROT_ALPHA: 1,                         // Left rotation amount for first operation\n    ROT_BETA: 8,                          // Left rotation amount for second operation\n    \n    // Initialize cipher\n    Init: function() {\n      CHAM.isInitialized = true;\n    },\n    \n    // Set up key and create cipher instance\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || optional_szKey.length !== 16) {\n        global.throwException('CHAM Key Exception', 'Key must be exactly 16 bytes (128 bits)', 'CHAM', 'KeySetup');\n        return null;\n      }\n      \n      let id;\n      do {\n        id = 'CHAM[' + global.generateUniqueID() + ']';\n      } while (CHAM.instances[id] || global.objectInstances[id]);\n      \n      CHAM.instances[szID] = new CHAM.CHAMInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data securely\n    ClearData: function(id) {\n      if (CHAM.instances[id]) {\n        // Clear sensitive key data\n        if (CHAM.instances[id].roundKeys) {\n          global.OpCodes.ClearArray(CHAM.instances[id].roundKeys);\n        }\n        if (CHAM.instances[id].key) {\n          global.OpCodes.ClearArray(CHAM.instances[id].key);\n        }\n        delete CHAM.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'CHAM', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt 128-bit block\n    encryptBlock: function(id, szPlainText) {\n      if (!CHAM.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'CHAM', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 16) {\n        global.throwException('CHAM Block Size Exception', 'Input must be exactly 16 bytes', 'CHAM', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const objCHAM = CHAM.instances[szID];\n      \n      // Convert input string to 32-bit words using OpCodes (little-endian for CHAM)\n      const bytes = global.OpCodes.StringToBytes(szPlainText);\n      let X = [\n        global.OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]),\n        global.OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]),\n        global.OpCodes.Pack32LE(bytes[8], bytes[9], bytes[10], bytes[11]),\n        global.OpCodes.Pack32LE(bytes[12], bytes[13], bytes[14], bytes[15])\n      ];\n      \n      // CHAM encryption: 112 rounds of ARX operations using 4-branch Feistel structure\n      for (let r = 0; r < CHAM.ROUNDS; r++) {\n        // Get round key (cycling through the 8 round keys)\n        const rk = objCHAM.roundKeys[r % 8];\n        \n        // CHAM round function with odd/even round variation\n        if (r % 2 === 0) {\n          // Even rounds: X[0] = ((X[0] ^ r) + (ROL(X[1], ROT_ALPHA) ^ rk)) <<< ROT_BETA\n          const temp = (global.OpCodes.RotL32(X[1], CHAM.ROT_ALPHA) ^ rk) >>> 0;\n          X[0] = global.OpCodes.RotL32(((X[0] ^ r) + temp) >>> 0, CHAM.ROT_BETA);\n        } else {\n          // Odd rounds: X[0] = ((X[0] ^ r) + (ROL(X[1], ROT_BETA) ^ rk)) <<< ROT_ALPHA  \n          const temp = (global.OpCodes.RotL32(X[1], CHAM.ROT_BETA) ^ rk) >>> 0;\n          X[0] = global.OpCodes.RotL32(((X[0] ^ r) + temp) >>> 0, CHAM.ROT_ALPHA);\n        }\n        \n        // Rotate the 4-branch Feistel state: X = [X[1], X[2], X[3], X[0]]\n        const temp_x = X[0];\n        X[0] = X[1];\n        X[1] = X[2];\n        X[2] = X[3];\n        X[3] = temp_x;\n      }\n      \n      // Convert back to byte string using OpCodes (little-endian)\n      const result = [];\n      for (let i = 0; i < 4; i++) {\n        const wordBytes = global.OpCodes.Unpack32LE(X[i]);\n        result.push(...wordBytes);\n      }\n      \n      return global.OpCodes.BytesToString(result);\n    },\n    \n    // Decrypt 128-bit block\n    decryptBlock: function(id, szCipherText) {\n      if (!CHAM.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'CHAM', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 16) {\n        global.throwException('CHAM Block Size Exception', 'Input must be exactly 16 bytes', 'CHAM', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const objCHAM = CHAM.instances[szID];\n      \n      // Convert input string to 32-bit words using OpCodes (little-endian)\n      const bytes = global.OpCodes.StringToBytes(szCipherText);\n      let X = [\n        global.OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]),\n        global.OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]),\n        global.OpCodes.Pack32LE(bytes[8], bytes[9], bytes[10], bytes[11]),\n        global.OpCodes.Pack32LE(bytes[12], bytes[13], bytes[14], bytes[15])\n      ];\n      \n      // CHAM decryption: reverse the encryption process (112 rounds in reverse order)\n      for (let r = CHAM.ROUNDS - 1; r >= 0; r--) {\n        // Reverse the 4-branch Feistel state rotation: X = [X[3], X[0], X[1], X[2]]\n        const temp_x = X[3];\n        X[3] = X[2];\n        X[2] = X[1];\n        X[1] = X[0];\n        X[0] = temp_x;\n        \n        // Get round key (cycling through the 8 round keys)\n        const rk = objCHAM.roundKeys[r % 8];\n        \n        // Reverse CHAM round function with odd/even round variation\n        if (r % 2 === 0) {\n          // Even rounds (reverse): X[0] = (ROR(X[0], ROT_BETA) - (ROL(X[1], ROT_ALPHA) ^ rk)) ^ r\n          const rotated = global.OpCodes.RotR32(X[0], CHAM.ROT_BETA);\n          const temp = (global.OpCodes.RotL32(X[1], CHAM.ROT_ALPHA) ^ rk) >>> 0;\n          X[0] = ((rotated - temp) >>> 0) ^ r;\n        } else {\n          // Odd rounds (reverse): X[0] = (ROR(X[0], ROT_ALPHA) - (ROL(X[1], ROT_BETA) ^ rk)) ^ r\n          const rotated = global.OpCodes.RotR32(X[0], CHAM.ROT_ALPHA);\n          const temp = (global.OpCodes.RotL32(X[1], CHAM.ROT_BETA) ^ rk) >>> 0;\n          X[0] = ((rotated - temp) >>> 0) ^ r;\n        }\n      }\n      \n      // Convert back to byte string using OpCodes (little-endian)\n      const result = [];\n      for (let i = 0; i < 4; i++) {\n        const wordBytes = global.OpCodes.Unpack32LE(X[i]);\n        result.push(...wordBytes);\n      }\n      \n      return global.OpCodes.BytesToString(result);\n    }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "893E5C75303030666749AA78C9688777B85C75303030345C75303031339EA4"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001",
        "expected": "ø¥åÝ1Ù\\u0000",
        "description": "DES known answer test 1 - weak key pattern (official)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"expected\": \"ø¥åÝ1Ù\\u0000\",\n        \"description\": \"DES known answer test 1 - weak key pattern (official)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"expected\": \"¦MéÁ±#§\",\n        \"description\": \"DES all-zeros plaintext with weak key\"\n    },\n    {\n        \"input\": \"@\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"expected\": \"Ý\\u0012\\u001c¥\\u0001V\\u0019\",\n        \"description\": \"DES weak key with 0x40 bit pattern\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"expected\": \"¨×(\\u0013Ú©M\",\n        \"description\": \"DES variable key known answer test\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u00134Wy¼ßñ\",\n        \"expected\": \"è\\u0013T\\u000f\\n´\\u0005\",\n        \"description\": \"DES standard test vector from FIPS 46\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'FIPS 46-3 - Data Encryption Standard (DES)',\n        url: 'https://csrc.nist.gov/publications/detail/fips/46/3/archive/1999-10-25',\n        description: 'Official NIST specification for the DES encryption standard (withdrawn 2005)'\n      },\n      {\n        name: 'NIST SP 800-67 Rev 2 - DES and Triple DES Guidelines',\n        url: 'https://csrc.nist.gov/publications/detail/sp/800-67/rev-2/final',\n        description: 'NIST guidelines for DES and Triple DES usage and security considerations'\n      },\n      {\n        name: 'RFC 4772 - Security Implications of Using DES',\n        url: 'https://tools.ietf.org/rfc/rfc4772.txt',\n        description: 'IETF RFC discussing security implications and recommendations against DES usage'\n      },\n      {\n        name: 'ANSI X3.92-1981 - Data Encryption Algorithm',\n        url: 'https://webstore.ansi.org/standards/incits/ansix3921981r1999',\n        description: 'Original ANSI standard for the Data Encryption Algorithm (DES)'\n      }\n    ],\n    implementations: [\n      {\n        name: 'OpenSSL DES Implementation',\n        url: 'https://github.com/openssl/openssl/blob/master/crypto/des/',\n        description: 'Production-quality DES implementation from OpenSSL (deprecated)'\n      },\n      {\n        name: 'libgcrypt DES Implementation',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/des.c',\n        description: 'DES implementation from GNU libgcrypt'\n      },\n      {\n        name: 'Crypto++ DES Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/des.cpp',\n        description: 'High-performance C++ DES implementation'\n      },\n      {\n        name: 'Bouncy Castle DES Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java DES implementation from Bouncy Castle'\n      }\n    ],\n    validation: [\n      {\n        name: 'NIST CAVP DES Test Vectors',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/block-ciphers',\n        description: 'Comprehensive test vectors for DES validation (archived)'\n      },\n      {\n        name: 'NIST DES Known Answer Tests',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/block-ciphers#DES',\n        description: 'Known Answer Tests for DES algorithm validation'\n      },\n      {\n        name: 'DES Challenge Results',\n        url: 'https://en.wikipedia.org/wiki/DES_Challenges',\n        description: 'Historical results from DES key cracking challenges demonstrating weakness'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n\n    // DES constants and tables (FIPS 46-3 specification)\n    // Initial Permutation\n    IP: [\n      58, 50, 42, 34, 26, 18, 10, 2,\n      60, 52, 44, 36, 28, 20, 12, 4,\n      62, 54, 46, 38, 30, 22, 14, 6,\n      64, 56, 48, 40, 32, 24, 16, 8,\n      57, 49, 41, 33, 25, 17, 9, 1,\n      59, 51, 43, 35, 27, 19, 11, 3,\n      61, 53, 45, 37, 29, 21, 13, 5,\n      63, 55, 47, 39, 31, 23, 15, 7\n    ],\n    \n    // Final Permutation (inverse of IP)\n    FP: [\n      40, 8, 48, 16, 56, 24, 64, 32,\n      39, 7, 47, 15, 55, 23, 63, 31,\n      38, 6, 46, 14, 54, 22, 62, 30,\n      37, 5, 45, 13, 53, 21, 61, 29,\n      36, 4, 44, 12, 52, 20, 60, 28,\n      35, 3, 43, 11, 51, 19, 59, 27,\n      34, 2, 42, 10, 50, 18, 58, 26,\n      33, 1, 41, 9, 49, 17, 57, 25\n    ],\n    \n    // Permuted Choice 1 (64 bits to 56 bits, removing parity bits)\n    PC1: [\n      57, 49, 41, 33, 25, 17, 9,\n      1, 58, 50, 42, 34, 26, 18,\n      10, 2, 59, 51, 43, 35, 27,\n      19, 11, 3, 60, 52, 44, 36,\n      63, 55, 47, 39, 31, 23, 15,\n      7, 62, 54, 46, 38, 30, 22,\n      14, 6, 61, 53, 45, 37, 29,\n      21, 13, 5, 28, 20, 12, 4\n    ],\n    \n    // Permuted Choice 2 (56 bits to 48 bits)\n    PC2: [\n      14, 17, 11, 24, 1, 5,\n      3, 28, 15, 6, 21, 10,\n      23, 19, 12, 4, 26, 8,\n      16, 7, 27, 20, 13, 2,\n      41, 52, 31, 37, 47, 55,\n      30, 40, 51, 45, 33, 48,\n      44, 49, 39, 56, 34, 53,\n      46, 42, 50, 36, 29, 32\n    ],\n    \n    // Expansion table (32 bits to 48 bits)\n    E: [\n      32, 1, 2, 3, 4, 5,\n      4, 5, 6, 7, 8, 9,\n      8, 9, 10, 11, 12, 13,\n      12, 13, 14, 15, 16, 17,\n      16, 17, 18, 19, 20, 21,\n      20, 21, 22, 23, 24, 25,\n      24, 25, 26, 27, 28, 29,\n      28, 29, 30, 31, 32, 1\n    ],\n    \n    // S-boxes (Substitution boxes)\n    SBOX: [\n      // S1\n      [\n        [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],\n        [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],\n        [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],\n        [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]\n      ],\n      // S2\n      [\n        [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],\n        [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],\n        [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],\n        [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]\n      ],\n      // S3\n      [\n        [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],\n        [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],\n        [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],\n        [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]\n      ],\n      // S4\n      [\n        [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],\n        [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],\n        [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],\n        [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]\n      ],\n      // S5\n      [\n        [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],\n        [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],\n        [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],\n        [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]\n      ],\n      // S6\n      [\n        [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],\n        [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],\n        [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],\n        [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]\n      ],\n      // S7\n      [\n        [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],\n        [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],\n        [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],\n        [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]\n      ],\n      // S8\n      [\n        [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],\n        [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],\n        [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],\n        [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]\n      ]\n    ],\n    \n    // P-box permutation (after S-boxes)\n    P: [\n      16, 7, 20, 21,\n      29, 12, 28, 17,\n      1, 15, 23, 26,\n      5, 18, 31, 10,\n      2, 8, 24, 14,\n      32, 27, 3, 9,\n      19, 13, 30, 6,\n      22, 11, 4, 25\n    ],\n    \n    // Rotation schedule for key generation\n    SHIFTS: [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1],\n    \n    // Official DES test vectors from FIPS 46-3 and other authoritative sources\n    testVectors: [\n      {\n        key: '\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01',\n        plaintext: '\\x95\\xF8\\xA5\\xE5\\xDD\\x31\\xD9\\x00',\n        ciphertext: '\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        description: 'DES FIPS 46-3 test vector 1'\n      },\n      {\n        key: '\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01',\n        plaintext: '\\xDD\\x7F\\x12\\x1C\\xA5\\x01\\x56\\x19',\n        ciphertext: '\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        description: 'DES FIPS 46-3 test vector 2'\n      },\n      {\n        key: '\\x80\\x01\\x01\\x01\\x01\\x01\\x01\\x01',\n        plaintext: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        ciphertext: '\\x95\\xA8\\xD7\\x28\\x13\\xDA\\xA9\\x4D',\n        description: 'DES single bit key test'\n      },\n      {\n        key: '\\x01\\x23\\x45\\x67\\x89\\xAB\\xCD\\xEF',\n        plaintext: '\\x4E\\x6F\\x77\\x20\\x69\\x73\\x20\\x74',\n        ciphertext: '\\x3F\\xA4\\x0E\\x8A\\x98\\x4D\\x48\\x15',\n        description: 'DES typical pattern test'\n      },\n      {\n        key: '\\x13\\x34\\x57\\x79\\x9B\\xBC\\xDF\\xF1',\n        plaintext: '\\x01\\x23\\x45\\x67\\x89\\xAB\\xCD\\xE7',\n        ciphertext: '\\x85\\xE8\\x13\\x54\\x0F\\x0A\\xB4\\x05',\n        description: 'DES educational test vector'\n      }\n    ],\n\n    // Initialize cipher with optimizations\n    Init: function() {\n      // Pre-compute any lookup tables for performance\n      DES.initOptimizedTables();\n      DES.isInitialized = true;\n    },\n    \n    // Initialize optimized lookup tables\n    initOptimizedTables: function() {\n      // For future optimizations, we could pre-compute permutation tables\n      // Currently using direct table lookups which are already efficient\n      if (global.OpCodes.RecordOperation) {\n        global.OpCodes.RecordOperation('DES-init', 1);\n      }\n    },\n\n    // Set up key with enhanced validation\n    KeySetup: function(optional_szKey) {\n      // Validate key length\n      if (!optional_szKey || optional_szKey.length !== 8) {\n        global.throwException('Invalid Key Length Exception', 'DES requires exactly 8 bytes key length', 'DES', 'KeySetup');\n        return null;\n      }\n      \n      // Check for weak keys\n      if (DES.isWeakKey(optional_szKey)) {\n        console.warn('Warning: Detected weak or semi-weak DES key. Consider using a different key.');\n      }\n\n      let id;\n      do {\n        id = 'DES[' + global.generateUniqueID() + ']';\n      } while (DES.instances[id] || global.objectInstances[id]);\n\n      try {\n        DES.instances[szID] = new DES.DESInstance(optional_szKey);\n        global.objectInstances[szID] = true;\n        return szID;\n      } catch (e) {\n        global.throwException('Key Setup Exception', e.message, 'DES', 'KeySetup');\n        return null;\n      }\n    },\n    \n    // Check for DES weak and semi-weak keys\n    isWeakKey: function(key) {\n      const keyBytes = DES.stringToBytes(key);\n      \n      // Weak keys (4 keys)\n      const weakKeys = [\n        [0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01], // All zeros (with parity)\n        [0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE], // All ones (with parity)\n        [0x1F, 0x1F, 0x1F, 0x1F, 0x0E, 0x0E, 0x0E, 0x0E], // Half zeros, half ones\n        [0xE0, 0xE0, 0xE0, 0xE0, 0xF1, 0xF1, 0xF1, 0xF1]  // Half ones, half zeros\n      ];\n      \n      // Check against weak keys\n      for (let i = 0; i < weakKeys.length; i++) {\n        if (global.OpCodes.CompareArrays(keyBytes, weakKeys[i])) {\n          return true;\n        }\n      }\n      \n      // Semi-weak keys (12 keys) - simplified check for common patterns\n      // These keys encrypt to themselves after two applications\n      const semiWeakPatterns = [\n        [0x01, 0xFE], [0xFE, 0x01], [0x1F, 0xE0], [0xE0, 0x1F],\n        [0x01, 0xE0], [0xE0, 0x01], [0x1F, 0xFE], [0xFE, 0x1F],\n        [0x01, 0x1F], [0x1F, 0x01], [0xE0, 0xFE], [0xFE, 0xE0]\n      ];\n      \n      for (let i = 0; i < semiWeakPatterns.length; i++) {\n        const pattern = semiWeakPatterns[i];\n        let matches = true;\n        for (let j = 0; j < 8; j++) {\n          if (keyBytes[j] !== pattern[j % 2]) {\n            matches = false;\n            break;\n          }\n        }\n        if (matches) return true;\n      }\n      \n      return false;\n    },\n\n    // Clear cipher data with secure cleanup\n    ClearData: function(id) {\n      if (DES.instances[id]) {\n        const instance = DES.instances[szID];\n        \n        // Securely clear subkeys\n        if (instance.subkeys) {\n          for (let i = 0; i < instance.subkeys.length; i++) {\n            if (instance.subkeys[i]) {\n              global.OpCodes.ClearArray(instance.subkeys[i]);\n            }\n          }\n          global.OpCodes.ClearArray(instance.subkeys);\n        }\n        \n        delete DES.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'DES', 'ClearData');\n        return false;\n      }\n    },\n\n    // Encrypt block with enhanced validation and monitoring\n    encryptBlock: function(id, szPlainText) {\n      if (!DES.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'DES', 'encryptBlock');\n        return szPlainText;\n      }\n\n      // Validate block size\n      if (!szPlainText || szPlainText.length !== 8) {\n        global.throwException('Invalid Block Size Exception', 'DES requires exactly 8 bytes block size', 'DES', 'encryptBlock');\n        return szPlainText;\n      }\n\n      const instance = DES.instances[szID];\n      \n      // Record operation for performance monitoring\n      if (global.OpCodes.RecordOperation) {\n        global.OpCodes.RecordOperation('DES-encrypt', 1);\n      }\n      \n      const plaintextBytes = DES.stringToBytes(szPlainText);\n      const encryptedBytes = DES.crypt(plaintextBytes, instance.subkeys, false);\n      return DES.bytesToString(encryptedBytes);\n    },\n\n    // Decrypt block with enhanced validation and monitoring\n    decryptBlock: function(id, szCipherText) {\n      if (!DES.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'DES', 'decryptBlock');\n        return szCipherText;\n      }\n\n      // Validate block size\n      if (!szCipherText || szCipherText.length !== 8) {\n        global.throwException('Invalid Block Size Exception', 'DES requires exactly 8 bytes block size', 'DES', 'decryptBlock');\n        return szCipherText;\n      }\n\n      const instance = DES.instances[szID];\n      \n      // Record operation for performance monitoring\n      if (global.OpCodes.RecordOperation) {\n        global.OpCodes.RecordOperation('DES-decrypt', 1);\n      }\n      \n      const ciphertextBytes = DES.stringToBytes(szCipherText);\n      const decryptedBytes = DES.crypt(ciphertextBytes, instance.subkeys, true);\n      return DES.bytesToString(decryptedBytes);\n    },\n\n    // Main DES encryption/decryption function\n    crypt: function(input, subkeys, isDecrypt) {\n      // Convert input to bits and apply initial permutation\n      let bits = DES.bytesToBits(input);\n      bits = DES.permute(bits, DES.IP);\n\n      // Split into left and right halves\n      let left = bits.slice(0, 32);\n      let right = bits.slice(32, 64);\n\n      // 16 rounds of Feistel network\n      for (let i = 0; i < 16; i++) {\n        const temp = right.slice();\n        const key = isDecrypt ? subkeys[15 - i] : subkeys[i];\n        right = DES.xorBits(left, DES.feistelFunction(right, key));\n        left = temp;\n      }\n\n      // Combine halves (note: right and left are swapped before final permutation)\n      const combined = right.concat(left);\n      \n      // Apply final permutation and convert back to bytes\n      const finalBits = DES.permute(combined, DES.FP);\n      return DES.bitsToBytes(finalBits);\n    },\n\n    // Generate 16 round subkeys from main key\n    generateSubkeys: function(key) {\n      // Convert key to bits and apply PC1 permutation\n      let keyBits = DES.bytesToBits(DES.stringToBytes(key));\n      keyBits = DES.permute(keyBits, DES.PC1);\n\n      // Split into two 28-bit halves\n      let c = keyBits.slice(0, 28);\n      let d = keyBits.slice(28, 56);\n\n      const subkeys = [];\n\n      // Generate 16 subkeys\n      for (let i = 0; i < 16; i++) {\n        // Left circular shift both halves\n        c = DES.leftShift(c, DES.SHIFTS[i]);\n        d = DES.leftShift(d, DES.SHIFTS[i]);\n\n        // Combine and apply PC2 permutation\n        const combined = c.concat(d);\n        subkeys[i] = DES.permute(combined, DES.PC2);\n      }\n\n      return subkeys;\n    },\n\n    // Feistel function (f-function)\n    feistelFunction: function(right, key) {\n      // Expansion permutation (32 bits to 48 bits)\n      const expanded = DES.permute(right, DES.E);\n      \n      // XOR with round key\n      const xored = DES.xorBits(expanded, key);\n      \n      // S-box substitution (48 bits to 32 bits)\n      const substituted = DES.sboxSubstitution(xored);\n      \n      // P-box permutation\n      return DES.permute(substituted, DES.P);\n    },\n\n    // S-box substitution\n    sboxSubstitution: function(input) {\n      const output = [];\n      \n      for (let i = 0; i < 8; i++) {\n        // Extract 6-bit block for this S-box\n        const block = input.slice(i * 6, (i + 1) * 6);\n        \n        // Calculate row (outer bits) and column (middle 4 bits)\n        const row = (block[0] << 1) | block[5];\n        const col = (block[1] << 3) | (block[2] << 2) | (block[3] << 1) | block[4];\n        \n        // Get value from S-box\n        const val = DES.SBOX[i][row][col];\n        \n        // Convert to 4-bit binary and add to output\n        for (let j = 3; j >= 0; j--) {\n          output.push((val >> j) & 1);\n        }\n      }\n      \n      return output;\n    },\n\n    // Permutation function\n    permute: function(input, table) {\n      const output = new Array(table.length);\n      for (let i = 0; i < table.length; i++) {\n        output[i] = input[table[i] - 1];\n      }\n      return output;\n    },\n\n    // XOR two bit arrays\n    xorBits: function(a, b) {\n      const result = new Array(a.length);\n      for (let i = 0; i < a.length; i++) {\n        result[i] = a[i] ^ b[i];\n      }\n      return result;\n    },\n\n    // Left circular shift\n    leftShift: function(input, n) {\n      return input.slice(n).concat(input.slice(0, n));\n    },\n\n    // Convert bytes to bits (optimized with OpCodes when available)\n    bytesToBits: function(bytes) {\n      const bits = new Array(bytes.length * 8);\n      for (let i = 0; i < bytes.length; i++) {\n        for (let j = 0; j < 8; j++) {\n          bits[i * 8 + j] = (bytes[i] >> (7 - j)) & 1;\n        }\n      }\n      return bits;\n    },\n\n    // Convert bits to bytes (optimized with OpCodes when available)\n    bitsToBytes: function(bits) {\n      const bytes = new Array(bits.length / 8);\n      for (let i = 0; i < bytes.length; i++) {\n        let val = 0;\n        for (let j = 0; j < 8; j++) {\n          val = (val << 1) | bits[i * 8 + j];\n        }\n        bytes[i] = val;\n      }\n      return bytes;\n    },\n\n    // String to bytes conversion (using OpCodes for consistency)\n    stringToBytes: function(str) {\n      if (global.OpCodes && global.OpCodes.StringToBytes) {\n        return global.OpCodes.StringToBytes(str);\n      }\n      const bytes = new Array(str.length);\n      for (let i = 0; i < str.length; i++) {\n        bytes[i] = str.charCodeAt(i) & 0xFF;\n      }\n      return bytes;\n    },\n\n    // Bytes to string conversion (using OpCodes for consistency)\n    bytesToString: function(bytes) {\n      if (global.OpCodes && global.OpCodes.BytesToString) {\n        return global.OpCodes.BytesToString(bytes);\n      }\n      let str = '';\n      for (let i = 0; i < bytes.length; i++) {\n        str += String.fromCharCode(bytes[i]);\n      }\n      return str;\n    },\n\n    // XOR two bit arrays (using OpCodes XorArrays if available)\n    xorBitsWithOpCodes: function(a, b) {\n      if (global.OpCodes && global.OpCodes.XorArrays && a.length === b.length) {\n        return global.OpCodes.XorArrays(a, b);\n      }\n      return DES.xorBits(a, b);\n    },\n\n    // Optimized batch processing for multiple blocks\n    encryptBlocks: function(blocks, keyInstance) {\n      if (!blocks || blocks.length === 0) {\n        throw new Error('No blocks provided for encryption');\n      }\n      \n      const results = [];\n      const startTime = Date.now();\n      \n      for (let i = 0; i < blocks.length; i++) {\n        if (blocks[i].length !== 8) {\n          throw new Error(`Block ${i} has invalid size: ${blocks[i].length} bytes`);\n        }\n        \n        const encrypted = DES.encryptBlock(keyInstance, blocks[i]);\n        results.push(encrypted);\n      }\n      \n      const endTime = Date.now();\n      if (global.OpCodes.RecordOperation) {\n        global.OpCodes.RecordOperation('DES-batch-encrypt', blocks.length);\n      }\n      \n      return results;\n    },\n    \n    // Optimized batch processing for multiple blocks\n    decryptBlocks: function(blocks, keyInstance) {\n      if (!blocks || blocks.length === 0) {\n        throw new Error('No blocks provided for decryption');\n      }\n      \n      const results = [];\n      const startTime = Date.now();\n      \n      for (let i = 0; i < blocks.length; i++) {\n        if (blocks[i].length !== 8) {\n          throw new Error(`Block ${i} has invalid size: ${blocks[i].length} bytes`);\n        }"
      },
      "after": {
        "input": "Input (hex): 805C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C7530303031",
        "expected": "Expected (hex): 95F8A5E5DD31D95C7530303030",
        "description": "DES known answer test 1 - weak key pattern (official)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"expected\": \"ø¥åÝ1Ù\\u0000\",\n        \"description\": \"DES known answer test 1 - weak key pattern (official)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"expected\": \"¦MéÁ±#§\",\n        \"description\": \"DES all-zeros plaintext with weak key\"\n    },\n    {\n        \"input\": \"@\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"expected\": \"Ý\\u0012\\u001c¥\\u0001V\\u0019\",\n        \"description\": \"DES weak key with 0x40 bit pattern\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"expected\": \"¨×(\\u0013Ú©M\",\n        \"description\": \"DES variable key known answer test\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u00134Wy¼ßñ\",\n        \"expected\": \"è\\u0013T\\u000f\\n´\\u0005\",\n        \"description\": \"DES standard test vector from FIPS 46\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'FIPS 46-3 - Data Encryption Standard (DES)',\n        url: 'https://csrc.nist.gov/publications/detail/fips/46/3/archive/1999-10-25',\n        description: 'Official NIST specification for the DES encryption standard (withdrawn 2005)'\n      },\n      {\n        name: 'NIST SP 800-67 Rev 2 - DES and Triple DES Guidelines',\n        url: 'https://csrc.nist.gov/publications/detail/sp/800-67/rev-2/final',\n        description: 'NIST guidelines for DES and Triple DES usage and security considerations'\n      },\n      {\n        name: 'RFC 4772 - Security Implications of Using DES',\n        url: 'https://tools.ietf.org/rfc/rfc4772.txt',\n        description: 'IETF RFC discussing security implications and recommendations against DES usage'\n      },\n      {\n        name: 'ANSI X3.92-1981 - Data Encryption Algorithm',\n        url: 'https://webstore.ansi.org/standards/incits/ansix3921981r1999',\n        description: 'Original ANSI standard for the Data Encryption Algorithm (DES)'\n      }\n    ],\n    implementations: [\n      {\n        name: 'OpenSSL DES Implementation',\n        url: 'https://github.com/openssl/openssl/blob/master/crypto/des/',\n        description: 'Production-quality DES implementation from OpenSSL (deprecated)'\n      },\n      {\n        name: 'libgcrypt DES Implementation',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/des.c',\n        description: 'DES implementation from GNU libgcrypt'\n      },\n      {\n        name: 'Crypto++ DES Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/des.cpp',\n        description: 'High-performance C++ DES implementation'\n      },\n      {\n        name: 'Bouncy Castle DES Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java DES implementation from Bouncy Castle'\n      }\n    ],\n    validation: [\n      {\n        name: 'NIST CAVP DES Test Vectors',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/block-ciphers',\n        description: 'Comprehensive test vectors for DES validation (archived)'\n      },\n      {\n        name: 'NIST DES Known Answer Tests',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/block-ciphers#DES',\n        description: 'Known Answer Tests for DES algorithm validation'\n      },\n      {\n        name: 'DES Challenge Results',\n        url: 'https://en.wikipedia.org/wiki/DES_Challenges',\n        description: 'Historical results from DES key cracking challenges demonstrating weakness'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n\n    // DES constants and tables (FIPS 46-3 specification)\n    // Initial Permutation\n    IP: [\n      58, 50, 42, 34, 26, 18, 10, 2,\n      60, 52, 44, 36, 28, 20, 12, 4,\n      62, 54, 46, 38, 30, 22, 14, 6,\n      64, 56, 48, 40, 32, 24, 16, 8,\n      57, 49, 41, 33, 25, 17, 9, 1,\n      59, 51, 43, 35, 27, 19, 11, 3,\n      61, 53, 45, 37, 29, 21, 13, 5,\n      63, 55, 47, 39, 31, 23, 15, 7\n    ],\n    \n    // Final Permutation (inverse of IP)\n    FP: [\n      40, 8, 48, 16, 56, 24, 64, 32,\n      39, 7, 47, 15, 55, 23, 63, 31,\n      38, 6, 46, 14, 54, 22, 62, 30,\n      37, 5, 45, 13, 53, 21, 61, 29,\n      36, 4, 44, 12, 52, 20, 60, 28,\n      35, 3, 43, 11, 51, 19, 59, 27,\n      34, 2, 42, 10, 50, 18, 58, 26,\n      33, 1, 41, 9, 49, 17, 57, 25\n    ],\n    \n    // Permuted Choice 1 (64 bits to 56 bits, removing parity bits)\n    PC1: [\n      57, 49, 41, 33, 25, 17, 9,\n      1, 58, 50, 42, 34, 26, 18,\n      10, 2, 59, 51, 43, 35, 27,\n      19, 11, 3, 60, 52, 44, 36,\n      63, 55, 47, 39, 31, 23, 15,\n      7, 62, 54, 46, 38, 30, 22,\n      14, 6, 61, 53, 45, 37, 29,\n      21, 13, 5, 28, 20, 12, 4\n    ],\n    \n    // Permuted Choice 2 (56 bits to 48 bits)\n    PC2: [\n      14, 17, 11, 24, 1, 5,\n      3, 28, 15, 6, 21, 10,\n      23, 19, 12, 4, 26, 8,\n      16, 7, 27, 20, 13, 2,\n      41, 52, 31, 37, 47, 55,\n      30, 40, 51, 45, 33, 48,\n      44, 49, 39, 56, 34, 53,\n      46, 42, 50, 36, 29, 32\n    ],\n    \n    // Expansion table (32 bits to 48 bits)\n    E: [\n      32, 1, 2, 3, 4, 5,\n      4, 5, 6, 7, 8, 9,\n      8, 9, 10, 11, 12, 13,\n      12, 13, 14, 15, 16, 17,\n      16, 17, 18, 19, 20, 21,\n      20, 21, 22, 23, 24, 25,\n      24, 25, 26, 27, 28, 29,\n      28, 29, 30, 31, 32, 1\n    ],\n    \n    // S-boxes (Substitution boxes)\n    SBOX: [\n      // S1\n      [\n        [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],\n        [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],\n        [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],\n        [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]\n      ],\n      // S2\n      [\n        [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],\n        [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],\n        [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],\n        [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]\n      ],\n      // S3\n      [\n        [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],\n        [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],\n        [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],\n        [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]\n      ],\n      // S4\n      [\n        [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],\n        [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],\n        [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],\n        [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]\n      ],\n      // S5\n      [\n        [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],\n        [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],\n        [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],\n        [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]\n      ],\n      // S6\n      [\n        [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],\n        [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],\n        [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],\n        [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]\n      ],\n      // S7\n      [\n        [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],\n        [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],\n        [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],\n        [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]\n      ],\n      // S8\n      [\n        [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],\n        [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],\n        [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],\n        [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]\n      ]\n    ],\n    \n    // P-box permutation (after S-boxes)\n    P: [\n      16, 7, 20, 21,\n      29, 12, 28, 17,\n      1, 15, 23, 26,\n      5, 18, 31, 10,\n      2, 8, 24, 14,\n      32, 27, 3, 9,\n      19, 13, 30, 6,\n      22, 11, 4, 25\n    ],\n    \n    // Rotation schedule for key generation\n    SHIFTS: [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1],\n    \n    // Official DES test vectors from FIPS 46-3 and other authoritative sources\n    testVectors: [\n      {\n        key: '\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01',\n        plaintext: '\\x95\\xF8\\xA5\\xE5\\xDD\\x31\\xD9\\x00',\n        ciphertext: '\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        description: 'DES FIPS 46-3 test vector 1'\n      },\n      {\n        key: '\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01',\n        plaintext: '\\xDD\\x7F\\x12\\x1C\\xA5\\x01\\x56\\x19',\n        ciphertext: '\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        description: 'DES FIPS 46-3 test vector 2'\n      },\n      {\n        key: '\\x80\\x01\\x01\\x01\\x01\\x01\\x01\\x01',\n        plaintext: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        ciphertext: '\\x95\\xA8\\xD7\\x28\\x13\\xDA\\xA9\\x4D',\n        description: 'DES single bit key test'\n      },\n      {\n        key: '\\x01\\x23\\x45\\x67\\x89\\xAB\\xCD\\xEF',\n        plaintext: '\\x4E\\x6F\\x77\\x20\\x69\\x73\\x20\\x74',\n        ciphertext: '\\x3F\\xA4\\x0E\\x8A\\x98\\x4D\\x48\\x15',\n        description: 'DES typical pattern test'\n      },\n      {\n        key: '\\x13\\x34\\x57\\x79\\x9B\\xBC\\xDF\\xF1',\n        plaintext: '\\x01\\x23\\x45\\x67\\x89\\xAB\\xCD\\xE7',\n        ciphertext: '\\x85\\xE8\\x13\\x54\\x0F\\x0A\\xB4\\x05',\n        description: 'DES educational test vector'\n      }\n    ],\n\n    // Initialize cipher with optimizations\n    Init: function() {\n      // Pre-compute any lookup tables for performance\n      DES.initOptimizedTables();\n      DES.isInitialized = true;\n    },\n    \n    // Initialize optimized lookup tables\n    initOptimizedTables: function() {\n      // For future optimizations, we could pre-compute permutation tables\n      // Currently using direct table lookups which are already efficient\n      if (global.OpCodes.RecordOperation) {\n        global.OpCodes.RecordOperation('DES-init', 1);\n      }\n    },\n\n    // Set up key with enhanced validation\n    KeySetup: function(optional_szKey) {\n      // Validate key length\n      if (!optional_szKey || optional_szKey.length !== 8) {\n        global.throwException('Invalid Key Length Exception', 'DES requires exactly 8 bytes key length', 'DES', 'KeySetup');\n        return null;\n      }\n      \n      // Check for weak keys\n      if (DES.isWeakKey(optional_szKey)) {\n        console.warn('Warning: Detected weak or semi-weak DES key. Consider using a different key.');\n      }\n\n      let id;\n      do {\n        id = 'DES[' + global.generateUniqueID() + ']';\n      } while (DES.instances[id] || global.objectInstances[id]);\n\n      try {\n        DES.instances[szID] = new DES.DESInstance(optional_szKey);\n        global.objectInstances[szID] = true;\n        return szID;\n      } catch (e) {\n        global.throwException('Key Setup Exception', e.message, 'DES', 'KeySetup');\n        return null;\n      }\n    },\n    \n    // Check for DES weak and semi-weak keys\n    isWeakKey: function(key) {\n      const keyBytes = DES.stringToBytes(key);\n      \n      // Weak keys (4 keys)\n      const weakKeys = [\n        [0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01], // All zeros (with parity)\n        [0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE], // All ones (with parity)\n        [0x1F, 0x1F, 0x1F, 0x1F, 0x0E, 0x0E, 0x0E, 0x0E], // Half zeros, half ones\n        [0xE0, 0xE0, 0xE0, 0xE0, 0xF1, 0xF1, 0xF1, 0xF1]  // Half ones, half zeros\n      ];\n      \n      // Check against weak keys\n      for (let i = 0; i < weakKeys.length; i++) {\n        if (global.OpCodes.CompareArrays(keyBytes, weakKeys[i])) {\n          return true;\n        }\n      }\n      \n      // Semi-weak keys (12 keys) - simplified check for common patterns\n      // These keys encrypt to themselves after two applications\n      const semiWeakPatterns = [\n        [0x01, 0xFE], [0xFE, 0x01], [0x1F, 0xE0], [0xE0, 0x1F],\n        [0x01, 0xE0], [0xE0, 0x01], [0x1F, 0xFE], [0xFE, 0x1F],\n        [0x01, 0x1F], [0x1F, 0x01], [0xE0, 0xFE], [0xFE, 0xE0]\n      ];\n      \n      for (let i = 0; i < semiWeakPatterns.length; i++) {\n        const pattern = semiWeakPatterns[i];\n        let matches = true;\n        for (let j = 0; j < 8; j++) {\n          if (keyBytes[j] !== pattern[j % 2]) {\n            matches = false;\n            break;\n          }\n        }\n        if (matches) return true;\n      }\n      \n      return false;\n    },\n\n    // Clear cipher data with secure cleanup\n    ClearData: function(id) {\n      if (DES.instances[id]) {\n        const instance = DES.instances[szID];\n        \n        // Securely clear subkeys\n        if (instance.subkeys) {\n          for (let i = 0; i < instance.subkeys.length; i++) {\n            if (instance.subkeys[i]) {\n              global.OpCodes.ClearArray(instance.subkeys[i]);\n            }\n          }\n          global.OpCodes.ClearArray(instance.subkeys);\n        }\n        \n        delete DES.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'DES', 'ClearData');\n        return false;\n      }\n    },\n\n    // Encrypt block with enhanced validation and monitoring\n    encryptBlock: function(id, szPlainText) {\n      if (!DES.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'DES', 'encryptBlock');\n        return szPlainText;\n      }\n\n      // Validate block size\n      if (!szPlainText || szPlainText.length !== 8) {\n        global.throwException('Invalid Block Size Exception', 'DES requires exactly 8 bytes block size', 'DES', 'encryptBlock');\n        return szPlainText;\n      }\n\n      const instance = DES.instances[szID];\n      \n      // Record operation for performance monitoring\n      if (global.OpCodes.RecordOperation) {\n        global.OpCodes.RecordOperation('DES-encrypt', 1);\n      }\n      \n      const plaintextBytes = DES.stringToBytes(szPlainText);\n      const encryptedBytes = DES.crypt(plaintextBytes, instance.subkeys, false);\n      return DES.bytesToString(encryptedBytes);\n    },\n\n    // Decrypt block with enhanced validation and monitoring\n    decryptBlock: function(id, szCipherText) {\n      if (!DES.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'DES', 'decryptBlock');\n        return szCipherText;\n      }\n\n      // Validate block size\n      if (!szCipherText || szCipherText.length !== 8) {\n        global.throwException('Invalid Block Size Exception', 'DES requires exactly 8 bytes block size', 'DES', 'decryptBlock');\n        return szCipherText;\n      }\n\n      const instance = DES.instances[szID];\n      \n      // Record operation for performance monitoring\n      if (global.OpCodes.RecordOperation) {\n        global.OpCodes.RecordOperation('DES-decrypt', 1);\n      }\n      \n      const ciphertextBytes = DES.stringToBytes(szCipherText);\n      const decryptedBytes = DES.crypt(ciphertextBytes, instance.subkeys, true);\n      return DES.bytesToString(decryptedBytes);\n    },\n\n    // Main DES encryption/decryption function\n    crypt: function(input, subkeys, isDecrypt) {\n      // Convert input to bits and apply initial permutation\n      let bits = DES.bytesToBits(input);\n      bits = DES.permute(bits, DES.IP);\n\n      // Split into left and right halves\n      let left = bits.slice(0, 32);\n      let right = bits.slice(32, 64);\n\n      // 16 rounds of Feistel network\n      for (let i = 0; i < 16; i++) {\n        const temp = right.slice();\n        const key = isDecrypt ? subkeys[15 - i] : subkeys[i];\n        right = DES.xorBits(left, DES.feistelFunction(right, key));\n        left = temp;\n      }\n\n      // Combine halves (note: right and left are swapped before final permutation)\n      const combined = right.concat(left);\n      \n      // Apply final permutation and convert back to bytes\n      const finalBits = DES.permute(combined, DES.FP);\n      return DES.bitsToBytes(finalBits);\n    },\n\n    // Generate 16 round subkeys from main key\n    generateSubkeys: function(key) {\n      // Convert key to bits and apply PC1 permutation\n      let keyBits = DES.bytesToBits(DES.stringToBytes(key));\n      keyBits = DES.permute(keyBits, DES.PC1);\n\n      // Split into two 28-bit halves\n      let c = keyBits.slice(0, 28);\n      let d = keyBits.slice(28, 56);\n\n      const subkeys = [];\n\n      // Generate 16 subkeys\n      for (let i = 0; i < 16; i++) {\n        // Left circular shift both halves\n        c = DES.leftShift(c, DES.SHIFTS[i]);\n        d = DES.leftShift(d, DES.SHIFTS[i]);\n\n        // Combine and apply PC2 permutation\n        const combined = c.concat(d);\n        subkeys[i] = DES.permute(combined, DES.PC2);\n      }\n\n      return subkeys;\n    },\n\n    // Feistel function (f-function)\n    feistelFunction: function(right, key) {\n      // Expansion permutation (32 bits to 48 bits)\n      const expanded = DES.permute(right, DES.E);\n      \n      // XOR with round key\n      const xored = DES.xorBits(expanded, key);\n      \n      // S-box substitution (48 bits to 32 bits)\n      const substituted = DES.sboxSubstitution(xored);\n      \n      // P-box permutation\n      return DES.permute(substituted, DES.P);\n    },\n\n    // S-box substitution\n    sboxSubstitution: function(input) {\n      const output = [];\n      \n      for (let i = 0; i < 8; i++) {\n        // Extract 6-bit block for this S-box\n        const block = input.slice(i * 6, (i + 1) * 6);\n        \n        // Calculate row (outer bits) and column (middle 4 bits)\n        const row = (block[0] << 1) | block[5];\n        const col = (block[1] << 3) | (block[2] << 2) | (block[3] << 1) | block[4];\n        \n        // Get value from S-box\n        const val = DES.SBOX[i][row][col];\n        \n        // Convert to 4-bit binary and add to output\n        for (let j = 3; j >= 0; j--) {\n          output.push((val >> j) & 1);\n        }\n      }\n      \n      return output;\n    },\n\n    // Permutation function\n    permute: function(input, table) {\n      const output = new Array(table.length);\n      for (let i = 0; i < table.length; i++) {\n        output[i] = input[table[i] - 1];\n      }\n      return output;\n    },\n\n    // XOR two bit arrays\n    xorBits: function(a, b) {\n      const result = new Array(a.length);\n      for (let i = 0; i < a.length; i++) {\n        result[i] = a[i] ^ b[i];\n      }\n      return result;\n    },\n\n    // Left circular shift\n    leftShift: function(input, n) {\n      return input.slice(n).concat(input.slice(0, n));\n    },\n\n    // Convert bytes to bits (optimized with OpCodes when available)\n    bytesToBits: function(bytes) {\n      const bits = new Array(bytes.length * 8);\n      for (let i = 0; i < bytes.length; i++) {\n        for (let j = 0; j < 8; j++) {\n          bits[i * 8 + j] = (bytes[i] >> (7 - j)) & 1;\n        }\n      }\n      return bits;\n    },\n\n    // Convert bits to bytes (optimized with OpCodes when available)\n    bitsToBytes: function(bits) {\n      const bytes = new Array(bits.length / 8);\n      for (let i = 0; i < bytes.length; i++) {\n        let val = 0;\n        for (let j = 0; j < 8; j++) {\n          val = (val << 1) | bits[i * 8 + j];\n        }\n        bytes[i] = val;\n      }\n      return bytes;\n    },\n\n    // String to bytes conversion (using OpCodes for consistency)\n    stringToBytes: function(str) {\n      if (global.OpCodes && global.OpCodes.StringToBytes) {\n        return global.OpCodes.StringToBytes(str);\n      }\n      const bytes = new Array(str.length);\n      for (let i = 0; i < str.length; i++) {\n        bytes[i] = str.charCodeAt(i) & 0xFF;\n      }\n      return bytes;\n    },\n\n    // Bytes to string conversion (using OpCodes for consistency)\n    bytesToString: function(bytes) {\n      if (global.OpCodes && global.OpCodes.BytesToString) {\n        return global.OpCodes.BytesToString(bytes);\n      }\n      let str = '';\n      for (let i = 0; i < bytes.length; i++) {\n        str += String.fromCharCode(bytes[i]);\n      }\n      return str;\n    },\n\n    // XOR two bit arrays (using OpCodes XorArrays if available)\n    xorBitsWithOpCodes: function(a, b) {\n      if (global.OpCodes && global.OpCodes.XorArrays && a.length === b.length) {\n        return global.OpCodes.XorArrays(a, b);\n      }\n      return DES.xorBits(a, b);\n    },\n\n    // Optimized batch processing for multiple blocks\n    encryptBlocks: function(blocks, keyInstance) {\n      if (!blocks || blocks.length === 0) {\n        throw new Error('No blocks provided for encryption');\n      }\n      \n      const results = [];\n      const startTime = Date.now();\n      \n      for (let i = 0; i < blocks.length; i++) {\n        if (blocks[i].length !== 8) {\n          throw new Error(`Block ${i} has invalid size: ${blocks[i].length} bytes`);\n        }\n        \n        const encrypted = DES.encryptBlock(keyInstance, blocks[i]);\n        results.push(encrypted);\n      }\n      \n      const endTime = Date.now();\n      if (global.OpCodes.RecordOperation) {\n        global.OpCodes.RecordOperation('DES-batch-encrypt', blocks.length);\n      }\n      \n      return results;\n    },\n    \n    // Optimized batch processing for multiple blocks\n    decryptBlocks: function(blocks, keyInstance) {\n      if (!blocks || blocks.length === 0) {\n        throw new Error('No blocks provided for decryption');\n      }\n      \n      const results = [];\n      const startTime = Date.now();\n      \n      for (let i = 0; i < blocks.length; i++) {\n        if (blocks[i].length !== 8) {\n          throw new Error(`Block ${i} has invalid size: ${blocks[i].length} bytes`);\n        }",
        "inputHex": "805C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C75303030315C7530303031",
        "expectedHex": "95F8A5E5DD31D95C7530303030"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f",
        "expected": "ÛZ¡ÝÒÄû»",
        "description": "GOST 28147-89 all zeros plaintext test vector (educational)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\",\n        \"expected\": \"ÛZ¡ÝÒÄû»\",\n        \"description\": \"GOST 28147-89 all zeros plaintext test vector (educational)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\",\n        \"expected\": \")Ùì¶L¿t\",\n        \"description\": \"GOST 28147-89 pattern test vector (educational)\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"Ã¬Iù§:né\",\n        \"description\": \"GOST 28147-89 all ones boundary test vector (educational)\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Initialize cipher\n    Init: function() {\n      GOST28147.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(key) {\n      if (!key || key.length !== 32) {\n        global.throwException('Invalid Key Length Exception', key ? key.length : 0, 'GOST28147', 'KeySetup');\n        return null;\n      }\n      \n      let id;\n      do {\n        id = 'GOST28147[' + global.generateUniqueID() + ']';\n      } while (GOST28147.instances[id] || global.objectInstances[id]);\n      \n      GOST28147.instances[szID] = new GOST28147.GOSTInstance(key);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (GOST28147.instances[id]) {\n        // Clear sensitive key material\n        const instance = GOST28147.instances[szID];\n        if (instance.subkeys) {\n          for (let i = 0; i < instance.subkeys.length; i++) {\n            instance.subkeys[i] = 0;\n          }\n        }\n        delete GOST28147.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'GOST28147', 'ClearData');\n        return false;\n      }\n    },\n    \n    // F-function: F(R, K) = S(R + K) <<< 11\n    F_function: function(right, subkey) {\n      // Add subkey modulo 2^32\n      const sum = (right + subkey) >>> 0;\n      \n      // Apply S-boxes (8 x 4-bit substitutions)\n      let result = 0;\n      for (let i = 0; i < 8; i++) {\n        const nibble = (sum >>> (i * 4)) & 0xF;\n        const sboxValue = GOST_SBOXES[i][nibble];\n        result |= (sboxValue << (i * 4));\n      }\n      \n      // Rotate left by 11 positions\n      return global.OpCodes.RotL32(result, 11);\n    },\n    \n    // Encrypt single 64-bit block\n    encryptBlock: function(id, szPlainText) {\n      if (!GOST28147.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'GOST28147', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 8) {\n        global.throwException('Invalid Block Size Exception', szPlainText.length, 'GOST28147', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = GOST28147.instances[szID];\n      const input = [];\n      \n      // Convert string to byte array\n      for (let i = 0; i < 8; i++) {\n        input[i] = szPlainText.charCodeAt(i) & 0xFF;\n      }\n      \n      // Split into 32-bit halves (little-endian)\n      let left = global.OpCodes.Pack32LE(input[0], input[1], input[2], input[3]);\n      let right = global.OpCodes.Pack32LE(input[4], input[5], input[6], input[7]);\n      \n      // 32 rounds of Feistel network\n      // First 24 rounds: forward key order (K0,K1,...,K7, K0,K1,...,K7, K0,K1,...,K7)\n      for (let round = 0; round < 24; round++) {\n        const keyIndex = round % 8;\n        const temp = left;\n        left = right;\n        right = temp ^ GOST28147.F_function(right, instance.subkeys[keyIndex]);\n      }\n      \n      // Last 8 rounds: reverse key order (K7,K6,...,K0) - don't swap on final round\n      for (let round = 24; round < 32; round++) {\n        const keyIndex = 7 - (round - 24);\n        if (round === 31) {\n          // Final round - no swap\n          right = left ^ GOST28147.F_function(right, instance.subkeys[keyIndex]);\n        } else {\n          const temp = left;\n          left = right;\n          right = temp ^ GOST28147.F_function(right, instance.subkeys[keyIndex]);\n        }\n      }\n      \n      // Convert back to string (little-endian)\n      const leftBytes = global.OpCodes.Unpack32LE(left);\n      const rightBytes = global.OpCodes.Unpack32LE(right);\n      \n      let result = '';\n      for (let i = 0; i < 4; i++) {\n        result += String.fromCharCode(leftBytes[i]);\n      }\n      for (let i = 0; i < 4; i++) {\n        result += String.fromCharCode(rightBytes[i]);\n      }\n      \n      return result;\n    },\n    \n    // Decrypt single 64-bit block\n    decryptBlock: function(id, szCipherText) {\n      if (!GOST28147.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'GOST28147', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 8) {\n        global.throwException('Invalid Block Size Exception', szCipherText.length, 'GOST28147', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = GOST28147.instances[szID];\n      const input = [];\n      \n      // Convert string to byte array\n      for (let i = 0; i < 8; i++) {\n        input[i] = szCipherText.charCodeAt(i) & 0xFF;\n      }\n      \n      // Split into 32-bit halves (little-endian)\n      let left = global.OpCodes.Pack32LE(input[0], input[1], input[2], input[3]);\n      let right = global.OpCodes.Pack32LE(input[4], input[5], input[6], input[7]);\n      \n      // 32 rounds of Feistel network (reverse of encryption for decryption)\n      // First 8 rounds: reverse key order (K7,K6,...,K0) \n      for (let round = 0; round < 8; round++) {\n        const keyIndex = 7 - round;\n        const temp = left;\n        left = right;\n        right = temp ^ GOST28147.F_function(right, instance.subkeys[keyIndex]);\n      }\n      \n      // Last 24 rounds: reverse key order repeated 3 times (K7→K0, K7→K0, K7→K0) - don't swap on final round\n      for (let round = 8; round < 32; round++) {\n        const keyIndex = 7 - ((round - 8) % 8);\n        if (round === 31) {\n          // Final round - no swap  \n          right = left ^ GOST28147.F_function(right, instance.subkeys[keyIndex]);\n        } else {\n          const temp = left;\n          left = right;\n          right = temp ^ GOST28147.F_function(right, instance.subkeys[keyIndex]);\n        }\n      }\n      \n      // Convert back to string (little-endian)\n      const leftBytes = global.OpCodes.Unpack32LE(left);\n      const rightBytes = global.OpCodes.Unpack32LE(right);\n      \n      let result = '';\n      for (let i = 0; i < 4; i++) {\n        result += String.fromCharCode(leftBytes[i]);\n      }\n      for (let i = 0; i < 4; i++) {\n        result += String.fromCharCode(rightBytes[i]);\n      }\n      \n      return result;\n    },\n    \n    // Instance class\n    GOSTInstance: function(key) {\n      this.subkeys = new Array(8);\n      \n      // Generate 8 x 32-bit subkeys from 256-bit key\n      for (let i = 0; i < 8; i++) {\n        const keyBytes = [];\n        for (let j = 0; j < 4; j++) {\n          keyBytes[j] = szKey.charCodeAt(i * 4 + j) & 0xFF;\n        }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030315C75303030325C75303030335C75303030345C75303030355C75303030365C75303030375C625C745C6E5C75303030625C665C725C75303030655C75303030665C75303031305C75303031315C75303031325C75303031335C75303031345C75303031355C75303031365C75303031375C75303031385C75303031395C75303031615C75303031625C75303031635C75303031645C75303031655C7530303166",
        "expected": "Expected (hex): DB5AA1DDD2C4FBBB",
        "description": "GOST 28147-89 all zeros plaintext test vector (educational)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\",\n        \"expected\": \"ÛZ¡ÝÒÄû»\",\n        \"description\": \"GOST 28147-89 all zeros plaintext test vector (educational)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\",\n        \"expected\": \")Ùì¶L¿t\",\n        \"description\": \"GOST 28147-89 pattern test vector (educational)\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"Ã¬Iù§:né\",\n        \"description\": \"GOST 28147-89 all ones boundary test vector (educational)\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Initialize cipher\n    Init: function() {\n      GOST28147.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(key) {\n      if (!key || key.length !== 32) {\n        global.throwException('Invalid Key Length Exception', key ? key.length : 0, 'GOST28147', 'KeySetup');\n        return null;\n      }\n      \n      let id;\n      do {\n        id = 'GOST28147[' + global.generateUniqueID() + ']';\n      } while (GOST28147.instances[id] || global.objectInstances[id]);\n      \n      GOST28147.instances[szID] = new GOST28147.GOSTInstance(key);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (GOST28147.instances[id]) {\n        // Clear sensitive key material\n        const instance = GOST28147.instances[szID];\n        if (instance.subkeys) {\n          for (let i = 0; i < instance.subkeys.length; i++) {\n            instance.subkeys[i] = 0;\n          }\n        }\n        delete GOST28147.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'GOST28147', 'ClearData');\n        return false;\n      }\n    },\n    \n    // F-function: F(R, K) = S(R + K) <<< 11\n    F_function: function(right, subkey) {\n      // Add subkey modulo 2^32\n      const sum = (right + subkey) >>> 0;\n      \n      // Apply S-boxes (8 x 4-bit substitutions)\n      let result = 0;\n      for (let i = 0; i < 8; i++) {\n        const nibble = (sum >>> (i * 4)) & 0xF;\n        const sboxValue = GOST_SBOXES[i][nibble];\n        result |= (sboxValue << (i * 4));\n      }\n      \n      // Rotate left by 11 positions\n      return global.OpCodes.RotL32(result, 11);\n    },\n    \n    // Encrypt single 64-bit block\n    encryptBlock: function(id, szPlainText) {\n      if (!GOST28147.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'GOST28147', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 8) {\n        global.throwException('Invalid Block Size Exception', szPlainText.length, 'GOST28147', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = GOST28147.instances[szID];\n      const input = [];\n      \n      // Convert string to byte array\n      for (let i = 0; i < 8; i++) {\n        input[i] = szPlainText.charCodeAt(i) & 0xFF;\n      }\n      \n      // Split into 32-bit halves (little-endian)\n      let left = global.OpCodes.Pack32LE(input[0], input[1], input[2], input[3]);\n      let right = global.OpCodes.Pack32LE(input[4], input[5], input[6], input[7]);\n      \n      // 32 rounds of Feistel network\n      // First 24 rounds: forward key order (K0,K1,...,K7, K0,K1,...,K7, K0,K1,...,K7)\n      for (let round = 0; round < 24; round++) {\n        const keyIndex = round % 8;\n        const temp = left;\n        left = right;\n        right = temp ^ GOST28147.F_function(right, instance.subkeys[keyIndex]);\n      }\n      \n      // Last 8 rounds: reverse key order (K7,K6,...,K0) - don't swap on final round\n      for (let round = 24; round < 32; round++) {\n        const keyIndex = 7 - (round - 24);\n        if (round === 31) {\n          // Final round - no swap\n          right = left ^ GOST28147.F_function(right, instance.subkeys[keyIndex]);\n        } else {\n          const temp = left;\n          left = right;\n          right = temp ^ GOST28147.F_function(right, instance.subkeys[keyIndex]);\n        }\n      }\n      \n      // Convert back to string (little-endian)\n      const leftBytes = global.OpCodes.Unpack32LE(left);\n      const rightBytes = global.OpCodes.Unpack32LE(right);\n      \n      let result = '';\n      for (let i = 0; i < 4; i++) {\n        result += String.fromCharCode(leftBytes[i]);\n      }\n      for (let i = 0; i < 4; i++) {\n        result += String.fromCharCode(rightBytes[i]);\n      }\n      \n      return result;\n    },\n    \n    // Decrypt single 64-bit block\n    decryptBlock: function(id, szCipherText) {\n      if (!GOST28147.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'GOST28147', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 8) {\n        global.throwException('Invalid Block Size Exception', szCipherText.length, 'GOST28147', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = GOST28147.instances[szID];\n      const input = [];\n      \n      // Convert string to byte array\n      for (let i = 0; i < 8; i++) {\n        input[i] = szCipherText.charCodeAt(i) & 0xFF;\n      }\n      \n      // Split into 32-bit halves (little-endian)\n      let left = global.OpCodes.Pack32LE(input[0], input[1], input[2], input[3]);\n      let right = global.OpCodes.Pack32LE(input[4], input[5], input[6], input[7]);\n      \n      // 32 rounds of Feistel network (reverse of encryption for decryption)\n      // First 8 rounds: reverse key order (K7,K6,...,K0) \n      for (let round = 0; round < 8; round++) {\n        const keyIndex = 7 - round;\n        const temp = left;\n        left = right;\n        right = temp ^ GOST28147.F_function(right, instance.subkeys[keyIndex]);\n      }\n      \n      // Last 24 rounds: reverse key order repeated 3 times (K7→K0, K7→K0, K7→K0) - don't swap on final round\n      for (let round = 8; round < 32; round++) {\n        const keyIndex = 7 - ((round - 8) % 8);\n        if (round === 31) {\n          // Final round - no swap  \n          right = left ^ GOST28147.F_function(right, instance.subkeys[keyIndex]);\n        } else {\n          const temp = left;\n          left = right;\n          right = temp ^ GOST28147.F_function(right, instance.subkeys[keyIndex]);\n        }\n      }\n      \n      // Convert back to string (little-endian)\n      const leftBytes = global.OpCodes.Unpack32LE(left);\n      const rightBytes = global.OpCodes.Unpack32LE(right);\n      \n      let result = '';\n      for (let i = 0; i < 4; i++) {\n        result += String.fromCharCode(leftBytes[i]);\n      }\n      for (let i = 0; i < 4; i++) {\n        result += String.fromCharCode(rightBytes[i]);\n      }\n      \n      return result;\n    },\n    \n    // Instance class\n    GOSTInstance: function(key) {\n      this.subkeys = new Array(8);\n      \n      // Generate 8 x 32-bit subkeys from 256-bit key\n      for (let i = 0; i < 8; i++) {\n        const keyBytes = [];\n        for (let j = 0; j < 4; j++) {\n          keyBytes[j] = szKey.charCodeAt(i * 4 + j) & 0xFF;\n        }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030315C75303030325C75303030335C75303030345C75303030355C75303030365C75303030375C625C745C6E5C75303030625C665C725C75303030655C75303030665C75303031305C75303031315C75303031325C75303031335C75303031345C75303031355C75303031365C75303031375C75303031385C75303031395C75303031615C75303031625C75303031635C75303031645C75303031655C7530303166",
        "expectedHex": "DB5AA1DDD2C4FBBB"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "%Âg:5U\\u0016",
        "description": "IDEA all zeros test vector",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"%Âg:5U\\u0016\",\n        \"description\": \"IDEA all zeros test vector\"\n    },\n    {\n        \"input\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\",\n        \"expected\": \"B\\u0016]¨zXN\\u000f\",\n        \"description\": \"IDEA incremental pattern test\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"þÜºvT2\\u0010\\u000f\\u001e-<KZix\",\n        \"expected\": \"\\\\d\\u000fÂ\\u001ag\",\n        \"description\": \"IDEA mixed binary pattern test\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"¼Ø \\u0007!v\\u001b\",\n        \"description\": \"IDEA all ones test vector\"\n    },\n    {\n        \"input\": \"IDEAIDEA\",\n        \"key\": \"1234567890123456\",\n        \"expected\": \"K,\\u001e_6x\",\n        \"description\": \"IDEA ASCII text test vector\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'IDEA Algorithm Specification',\n        url: 'https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm',\n        description: 'International Data Encryption Algorithm specification and documentation'\n      },\n      {\n        name: 'IDEA Patent Information',\n        url: 'https://patents.google.com/patent/US5214703A',\n        description: 'IDEA algorithm patent - US Patent 5,214,703 (expired 2011)'\n      },\n      {\n        name: 'Applied Cryptography - IDEA',\n        url: 'https://www.schneier.com/books/applied_cryptography/',\n        description: 'Bruce Schneier\\'s comprehensive treatment of IDEA algorithm'\n      },\n      {\n        name: 'IDEA Algorithm Academic Paper',\n        url: 'https://link.springer.com/chapter/10.1007/3-540-46877-3_35',\n        description: 'Original academic paper on IDEA algorithm design and analysis'\n      }\n    ],\n    implementations: [\n      {\n        name: 'OpenSSL IDEA Implementation',\n        url: 'https://github.com/openssl/openssl/blob/master/crypto/idea/',\n        description: 'Production-quality IDEA implementation from OpenSSL'\n      },\n      {\n        name: 'Crypto++ IDEA Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/idea.cpp',\n        description: 'High-performance C++ IDEA implementation'\n      },\n      {\n        name: 'Bouncy Castle IDEA Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java IDEA implementation from Bouncy Castle'\n      },\n      {\n        name: 'libgcrypt IDEA Implementation',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/',\n        description: 'GNU libgcrypt cryptographic library cipher implementations'\n      }\n    ],\n    validation: [\n      {\n        name: 'IDEA Test Vectors',\n        url: 'https://www.cosic.esat.kuleuven.be/nessie/testvectors/',\n        description: 'Comprehensive test vectors for IDEA validation'\n      },\n      {\n        name: 'NIST Cryptographic Validation',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program',\n        description: 'NIST guidance for cryptographic algorithm validation'\n      },\n      {\n        name: 'IDEA Cryptanalysis Research',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=789',\n        description: 'Academic research on IDEA security analysis and cryptanalysis'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Constants\n    ROUNDS: 8,\n    SUBKEYS_PER_ROUND: 6,\n    FINAL_SUBKEYS: 4,\n    TOTAL_SUBKEYS: 52, // (8 * 6) + 4\n    MODULUS: 0x10001,  // 2^16 + 1\n    \n    // Initialize cipher\n    Init: function() {\n      IDEA.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      let id;\n      do {\n        id = 'IDEA[' + global.generateUniqueID() + ']';\n      } while (IDEA.instances[id] || global.objectInstances[id]);\n      \n      IDEA.instances[szID] = new IDEA.IDEAInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (IDEA.instances[id]) {\n        // Clear sensitive data\n        const instance = IDEA.instances[szID];\n        if (instance.encryptKeys) global.OpCodes.ClearArray(instance.encryptKeys);\n        if (instance.decryptKeys) global.OpCodes.ClearArray(instance.decryptKeys);\n        \n        delete IDEA.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'IDEA', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, szPlainText) {\n      if (!IDEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'IDEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      return IDEA.encryptBlock(szPlainText, IDEA.instances[id]);\n    },\n    \n    // Decrypt block\n    decryptBlock: function(id, szCipherText) {\n      if (!IDEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'IDEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      return IDEA.decryptBlock(szCipherText, IDEA.instances[id]);\n    },\n    \n    /**\n     * Multiplication modulo (2^16 + 1) - IDEA's special operation\n     * In IDEA, 0 represents 2^16 (65536) for multiplication\n     * @param {number} a - First operand (16-bit)\n     * @param {number} b - Second operand (16-bit)\n     * @returns {number} (a * b) mod (2^16 + 1)\n     */\n    mulMod: function(a, b) {\n      a &= 0xFFFF;\n      b &= 0xFFFF;\n      \n      // In IDEA, 0 represents 2^16 for multiplication\n      if (a === 0) a = 0x10000;\n      if (b === 0) b = 0x10000;\n      \n      // Perform multiplication modulo (2^16 + 1)\n      const result = (a * b) % IDEA.MODULUS;\n      \n      // Convert back: if result is 65536, return 0\n      return result === 0x10000 ? 0 : result;\n    },\n    \n    /**\n     * Modular inverse for multiplication mod (2^16 + 1)\n     * Used for key schedule inversion in decryption\n     * @param {number} x - Value to invert\n     * @returns {number} Multiplicative inverse\n     */\n    modInverse: function(x) {\n      x &= 0xFFFF;\n      \n      // Special case: inverse of 0 (representing 2^16) is 0\n      if (x === 0) return 0;\n      \n      // Extended Euclidean algorithm\n      let u1 = IDEA.MODULUS;\n      let u2 = 0;\n      let u3 = x;\n      let v1 = 0;\n      let v2 = 1;\n      let v3 = IDEA.MODULUS;\n      \n      while (v3 !== 0) {\n        const q = Math.floor(u3 / v3);\n        const t1 = u1 - q * v1;\n        const t2 = u2 - q * v2;\n        const t3 = u3 - q * v3;\n        \n        u1 = v1; u2 = v2; u3 = v3;\n        v1 = t1; v2 = t2; v3 = t3;\n      }\n      \n      let result = u1;\n      if (result < 0) result += IDEA.MODULUS;\n      \n      return result & 0xFFFF;\n    },\n    \n    /**\n     * Additive inverse modulo 2^16\n     * @param {number} x - Value to invert\n     * @returns {number} Additive inverse\n     */\n    addInverse: function(x) {\n      x &= 0xFFFF;\n      return x === 0 ? 0 : (0x10000 - x) & 0xFFFF;\n    },\n    \n    /**\n     * Generate 52 subkeys from 128-bit master key\n     * IDEA key schedule: first 8 subkeys from key, then rotate left 25 bits per group\n     * @param {Array} key - 16-byte master key\n     * @returns {Array} Array of 52 16-bit subkeys\n     */\n    generateSubkeys: function(key) {\n      const subkeys = new Array(IDEA.TOTAL_SUBKEYS);\n      \n      // Convert key to 16-bit words (8 words from 16 bytes, big-endian)\n      const keyWords = [];\n      for (let i = 0; i < 8; i++) {\n        keyWords[i] = (key[i * 2] << 8) | key[i * 2 + 1];\n      }\n      \n      // First 8 subkeys are the original key words\n      for (let i = 0; i < 8; i++) {\n        subkeys[i] = keyWords[i];\n      }\n      \n      // Generate remaining 44 subkeys using IDEA's key schedule\n      // For each group of 8 keys, rotate the 128-bit key left by 25 bits\n      let keySchedule = [...keyWords]; // Working copy of key words\n      \n      for (let group = 1; group < 7; group++) { // 6 more groups needed (8 + 6*8 = 56 > 52)\n        // Rotate 128-bit key left by 25 bits\n        // Save the original values\n        const temp = [...keySchedule];\n        \n        // Rotate each word left by 25 bits within the 128-bit context\n        // 25 bits = 1 word + 9 bits\n        for (let i = 0; i < 8; i++) {\n          const srcIndex = (i + 7) % 8; // Previous word (25 bits = 16 + 9)\n          const nextIndex = (i + 6) % 8; // Word before that\n          \n          keySchedule[i] = ((temp[srcIndex] << 9) | (temp[nextIndex] >>> 7)) & 0xFFFF;\n        }\n        \n        // Copy up to 8 keys from this rotated schedule\n        const startIndex = group * 8;\n        for (let i = 0; i < 8 && startIndex + i < IDEA.TOTAL_SUBKEYS; i++) {\n          subkeys[startIndex + i] = keySchedule[i];\n        }\n      }\n      \n      return subkeys;\n    },\n    \n    /**\n     * Generate decryption subkeys from encryption subkeys\n     * Based on the reference IDEA implementation from Oryx Embedded\n     * @param {Array} encryptKeys - 52 encryption subkeys\n     * @returns {Array} 52 decryption subkeys\n     */\n    generateDecryptSubkeys: function(encryptKeys) {\n      const decryptKeys = new Array(IDEA.TOTAL_SUBKEYS);\n      \n      // Generate decryption keys following reference implementation pattern\n      for (let i = 0; i < 52; i += 6) {\n        // First subkey: multiplicative inverse of corresponding encryption subkey\n        decryptKeys[i] = IDEA.modInverse(encryptKeys[48 - i]);\n        \n        // Second and third subkeys: additive inverses (swapped except for first/last)\n        if (i === 0 || i === 48) {\n          decryptKeys[i + 1] = IDEA.addInverse(encryptKeys[49 - i]);\n          decryptKeys[i + 2] = IDEA.addInverse(encryptKeys[50 - i]);\n        } else {\n          decryptKeys[i + 1] = IDEA.addInverse(encryptKeys[50 - i]);\n          decryptKeys[i + 2] = IDEA.addInverse(encryptKeys[49 - i]);\n        }\n        \n        // Fourth subkey: multiplicative inverse\n        decryptKeys[i + 3] = IDEA.modInverse(encryptKeys[51 - i]);\n        \n        // Fifth and sixth subkeys: direct copy (MA-box keys)\n        if (i < 48) {\n          decryptKeys[i + 4] = encryptKeys[46 - i];\n          decryptKeys[i + 5] = encryptKeys[47 - i];\n        }\n      }\n      \n      return decryptKeys;\n    },\n    \n    /**\n     * IDEA encryption/decryption engine\n     * @param {string} block - 8-byte input block\n     * @param {Array} subkeys - 52 subkeys to use\n     * @returns {string} Processed 8-byte block\n     */\n    processBlock: function(block, subkeys) {\n      // Split input into four 16-bit words\n      let X1 = (block.charCodeAt(0) << 8) | block.charCodeAt(1);\n      let X2 = (block.charCodeAt(2) << 8) | block.charCodeAt(3);\n      let X3 = (block.charCodeAt(4) << 8) | block.charCodeAt(5);\n      let X4 = (block.charCodeAt(6) << 8) | block.charCodeAt(7);\n      \n      // 8 full rounds\n      for (let round = 0; round < IDEA.ROUNDS; round++) {\n        const keyOffset = round * 6;\n        \n        // Step 1: Multiply and add\n        X1 = IDEA.mulMod(X1, subkeys[keyOffset]);\n        X2 = global.OpCodes.AddMod(X2, subkeys[keyOffset + 1], 0x10000);\n        X3 = global.OpCodes.AddMod(X3, subkeys[keyOffset + 2], 0x10000);\n        X4 = IDEA.mulMod(X4, subkeys[keyOffset + 3]);\n        \n        // Step 2: MA structure (Multiplication-Addition)\n        const T1 = X1 ^ X3;\n        const T2 = X2 ^ X4;\n        const T3 = IDEA.mulMod(T1, subkeys[keyOffset + 4]);\n        const T4 = global.OpCodes.AddMod(T2, T3, 0x10000);\n        const T5 = IDEA.mulMod(T4, subkeys[keyOffset + 5]);\n        const T6 = global.OpCodes.AddMod(T3, T5, 0x10000);\n        \n        // Step 3: Final XOR and rearrangement\n        const Y1 = X1 ^ T5;\n        const Y2 = X3 ^ T5;\n        const Y3 = X2 ^ T6;\n        const Y4 = X4 ^ T6;\n        \n        // Prepare for next round (swap middle two words)\n        X1 = Y1;\n        X2 = Y3;\n        X3 = Y2;\n        X4 = Y4;\n      }\n      \n      // Final half-round (no swapping)\n      const finalOffset = IDEA.ROUNDS * 6;\n      X1 = IDEA.mulMod(X1, subkeys[finalOffset]);\n      X2 = global.OpCodes.AddMod(X2, subkeys[finalOffset + 1], 0x10000);\n      X3 = global.OpCodes.AddMod(X3, subkeys[finalOffset + 2], 0x10000);\n      X4 = IDEA.mulMod(X4, subkeys[finalOffset + 3]);\n      \n      // Convert back to byte string\n      return String.fromCharCode(\n        (X1 >>> 8) & 0xFF, X1 & 0xFF,\n        (X2 >>> 8) & 0xFF, X2 & 0xFF,\n        (X3 >>> 8) & 0xFF, X3 & 0xFF,\n        (X4 >>> 8) & 0xFF, X4 & 0xFF\n      );\n    },\n    \n    // Encrypt a 64-bit block\n    encryptBlock: function(szText, objIDEA) {\n      if (szText.length !== 8) {\n        throw new Error('IDEA block size must be exactly 8 bytes');\n      }\n      \n      return IDEA.processBlock(szText, objIDEA.encryptKeys);\n    },\n    \n    // Decrypt a 64-bit block\n    decryptBlock: function(szText, objIDEA) {\n      if (szText.length !== 8) {\n        throw new Error('IDEA block size must be exactly 8 bytes');\n      }\n      \n      return IDEA.processBlock(szText, objIDEA.decryptKeys);\n    },\n    \n    // Instance class\n    IDEAInstance: function(key) {\n      // Convert key string to byte array\n      const keyBytes = [];\n      if (key && key.length >= 16) {\n        for (let i = 0; i < 16; i++) {\n          keyBytes[i] = szKey.charCodeAt(i) & 0xFF;\n        }\n      }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 25C2673A35555C75303031368A",
        "description": "IDEA all zeros test vector",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"%Âg:5U\\u0016\",\n        \"description\": \"IDEA all zeros test vector\"\n    },\n    {\n        \"input\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\",\n        \"expected\": \"B\\u0016]¨zXN\\u000f\",\n        \"description\": \"IDEA incremental pattern test\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"þÜºvT2\\u0010\\u000f\\u001e-<KZix\",\n        \"expected\": \"\\\\d\\u000fÂ\\u001ag\",\n        \"description\": \"IDEA mixed binary pattern test\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"¼Ø \\u0007!v\\u001b\",\n        \"description\": \"IDEA all ones test vector\"\n    },\n    {\n        \"input\": \"IDEAIDEA\",\n        \"key\": \"1234567890123456\",\n        \"expected\": \"K,\\u001e_6x\",\n        \"description\": \"IDEA ASCII text test vector\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'IDEA Algorithm Specification',\n        url: 'https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm',\n        description: 'International Data Encryption Algorithm specification and documentation'\n      },\n      {\n        name: 'IDEA Patent Information',\n        url: 'https://patents.google.com/patent/US5214703A',\n        description: 'IDEA algorithm patent - US Patent 5,214,703 (expired 2011)'\n      },\n      {\n        name: 'Applied Cryptography - IDEA',\n        url: 'https://www.schneier.com/books/applied_cryptography/',\n        description: 'Bruce Schneier\\'s comprehensive treatment of IDEA algorithm'\n      },\n      {\n        name: 'IDEA Algorithm Academic Paper',\n        url: 'https://link.springer.com/chapter/10.1007/3-540-46877-3_35',\n        description: 'Original academic paper on IDEA algorithm design and analysis'\n      }\n    ],\n    implementations: [\n      {\n        name: 'OpenSSL IDEA Implementation',\n        url: 'https://github.com/openssl/openssl/blob/master/crypto/idea/',\n        description: 'Production-quality IDEA implementation from OpenSSL'\n      },\n      {\n        name: 'Crypto++ IDEA Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/idea.cpp',\n        description: 'High-performance C++ IDEA implementation'\n      },\n      {\n        name: 'Bouncy Castle IDEA Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java IDEA implementation from Bouncy Castle'\n      },\n      {\n        name: 'libgcrypt IDEA Implementation',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/',\n        description: 'GNU libgcrypt cryptographic library cipher implementations'\n      }\n    ],\n    validation: [\n      {\n        name: 'IDEA Test Vectors',\n        url: 'https://www.cosic.esat.kuleuven.be/nessie/testvectors/',\n        description: 'Comprehensive test vectors for IDEA validation'\n      },\n      {\n        name: 'NIST Cryptographic Validation',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program',\n        description: 'NIST guidance for cryptographic algorithm validation'\n      },\n      {\n        name: 'IDEA Cryptanalysis Research',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=789',\n        description: 'Academic research on IDEA security analysis and cryptanalysis'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Constants\n    ROUNDS: 8,\n    SUBKEYS_PER_ROUND: 6,\n    FINAL_SUBKEYS: 4,\n    TOTAL_SUBKEYS: 52, // (8 * 6) + 4\n    MODULUS: 0x10001,  // 2^16 + 1\n    \n    // Initialize cipher\n    Init: function() {\n      IDEA.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      let id;\n      do {\n        id = 'IDEA[' + global.generateUniqueID() + ']';\n      } while (IDEA.instances[id] || global.objectInstances[id]);\n      \n      IDEA.instances[szID] = new IDEA.IDEAInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (IDEA.instances[id]) {\n        // Clear sensitive data\n        const instance = IDEA.instances[szID];\n        if (instance.encryptKeys) global.OpCodes.ClearArray(instance.encryptKeys);\n        if (instance.decryptKeys) global.OpCodes.ClearArray(instance.decryptKeys);\n        \n        delete IDEA.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'IDEA', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, szPlainText) {\n      if (!IDEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'IDEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      return IDEA.encryptBlock(szPlainText, IDEA.instances[id]);\n    },\n    \n    // Decrypt block\n    decryptBlock: function(id, szCipherText) {\n      if (!IDEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'IDEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      return IDEA.decryptBlock(szCipherText, IDEA.instances[id]);\n    },\n    \n    /**\n     * Multiplication modulo (2^16 + 1) - IDEA's special operation\n     * In IDEA, 0 represents 2^16 (65536) for multiplication\n     * @param {number} a - First operand (16-bit)\n     * @param {number} b - Second operand (16-bit)\n     * @returns {number} (a * b) mod (2^16 + 1)\n     */\n    mulMod: function(a, b) {\n      a &= 0xFFFF;\n      b &= 0xFFFF;\n      \n      // In IDEA, 0 represents 2^16 for multiplication\n      if (a === 0) a = 0x10000;\n      if (b === 0) b = 0x10000;\n      \n      // Perform multiplication modulo (2^16 + 1)\n      const result = (a * b) % IDEA.MODULUS;\n      \n      // Convert back: if result is 65536, return 0\n      return result === 0x10000 ? 0 : result;\n    },\n    \n    /**\n     * Modular inverse for multiplication mod (2^16 + 1)\n     * Used for key schedule inversion in decryption\n     * @param {number} x - Value to invert\n     * @returns {number} Multiplicative inverse\n     */\n    modInverse: function(x) {\n      x &= 0xFFFF;\n      \n      // Special case: inverse of 0 (representing 2^16) is 0\n      if (x === 0) return 0;\n      \n      // Extended Euclidean algorithm\n      let u1 = IDEA.MODULUS;\n      let u2 = 0;\n      let u3 = x;\n      let v1 = 0;\n      let v2 = 1;\n      let v3 = IDEA.MODULUS;\n      \n      while (v3 !== 0) {\n        const q = Math.floor(u3 / v3);\n        const t1 = u1 - q * v1;\n        const t2 = u2 - q * v2;\n        const t3 = u3 - q * v3;\n        \n        u1 = v1; u2 = v2; u3 = v3;\n        v1 = t1; v2 = t2; v3 = t3;\n      }\n      \n      let result = u1;\n      if (result < 0) result += IDEA.MODULUS;\n      \n      return result & 0xFFFF;\n    },\n    \n    /**\n     * Additive inverse modulo 2^16\n     * @param {number} x - Value to invert\n     * @returns {number} Additive inverse\n     */\n    addInverse: function(x) {\n      x &= 0xFFFF;\n      return x === 0 ? 0 : (0x10000 - x) & 0xFFFF;\n    },\n    \n    /**\n     * Generate 52 subkeys from 128-bit master key\n     * IDEA key schedule: first 8 subkeys from key, then rotate left 25 bits per group\n     * @param {Array} key - 16-byte master key\n     * @returns {Array} Array of 52 16-bit subkeys\n     */\n    generateSubkeys: function(key) {\n      const subkeys = new Array(IDEA.TOTAL_SUBKEYS);\n      \n      // Convert key to 16-bit words (8 words from 16 bytes, big-endian)\n      const keyWords = [];\n      for (let i = 0; i < 8; i++) {\n        keyWords[i] = (key[i * 2] << 8) | key[i * 2 + 1];\n      }\n      \n      // First 8 subkeys are the original key words\n      for (let i = 0; i < 8; i++) {\n        subkeys[i] = keyWords[i];\n      }\n      \n      // Generate remaining 44 subkeys using IDEA's key schedule\n      // For each group of 8 keys, rotate the 128-bit key left by 25 bits\n      let keySchedule = [...keyWords]; // Working copy of key words\n      \n      for (let group = 1; group < 7; group++) { // 6 more groups needed (8 + 6*8 = 56 > 52)\n        // Rotate 128-bit key left by 25 bits\n        // Save the original values\n        const temp = [...keySchedule];\n        \n        // Rotate each word left by 25 bits within the 128-bit context\n        // 25 bits = 1 word + 9 bits\n        for (let i = 0; i < 8; i++) {\n          const srcIndex = (i + 7) % 8; // Previous word (25 bits = 16 + 9)\n          const nextIndex = (i + 6) % 8; // Word before that\n          \n          keySchedule[i] = ((temp[srcIndex] << 9) | (temp[nextIndex] >>> 7)) & 0xFFFF;\n        }\n        \n        // Copy up to 8 keys from this rotated schedule\n        const startIndex = group * 8;\n        for (let i = 0; i < 8 && startIndex + i < IDEA.TOTAL_SUBKEYS; i++) {\n          subkeys[startIndex + i] = keySchedule[i];\n        }\n      }\n      \n      return subkeys;\n    },\n    \n    /**\n     * Generate decryption subkeys from encryption subkeys\n     * Based on the reference IDEA implementation from Oryx Embedded\n     * @param {Array} encryptKeys - 52 encryption subkeys\n     * @returns {Array} 52 decryption subkeys\n     */\n    generateDecryptSubkeys: function(encryptKeys) {\n      const decryptKeys = new Array(IDEA.TOTAL_SUBKEYS);\n      \n      // Generate decryption keys following reference implementation pattern\n      for (let i = 0; i < 52; i += 6) {\n        // First subkey: multiplicative inverse of corresponding encryption subkey\n        decryptKeys[i] = IDEA.modInverse(encryptKeys[48 - i]);\n        \n        // Second and third subkeys: additive inverses (swapped except for first/last)\n        if (i === 0 || i === 48) {\n          decryptKeys[i + 1] = IDEA.addInverse(encryptKeys[49 - i]);\n          decryptKeys[i + 2] = IDEA.addInverse(encryptKeys[50 - i]);\n        } else {\n          decryptKeys[i + 1] = IDEA.addInverse(encryptKeys[50 - i]);\n          decryptKeys[i + 2] = IDEA.addInverse(encryptKeys[49 - i]);\n        }\n        \n        // Fourth subkey: multiplicative inverse\n        decryptKeys[i + 3] = IDEA.modInverse(encryptKeys[51 - i]);\n        \n        // Fifth and sixth subkeys: direct copy (MA-box keys)\n        if (i < 48) {\n          decryptKeys[i + 4] = encryptKeys[46 - i];\n          decryptKeys[i + 5] = encryptKeys[47 - i];\n        }\n      }\n      \n      return decryptKeys;\n    },\n    \n    /**\n     * IDEA encryption/decryption engine\n     * @param {string} block - 8-byte input block\n     * @param {Array} subkeys - 52 subkeys to use\n     * @returns {string} Processed 8-byte block\n     */\n    processBlock: function(block, subkeys) {\n      // Split input into four 16-bit words\n      let X1 = (block.charCodeAt(0) << 8) | block.charCodeAt(1);\n      let X2 = (block.charCodeAt(2) << 8) | block.charCodeAt(3);\n      let X3 = (block.charCodeAt(4) << 8) | block.charCodeAt(5);\n      let X4 = (block.charCodeAt(6) << 8) | block.charCodeAt(7);\n      \n      // 8 full rounds\n      for (let round = 0; round < IDEA.ROUNDS; round++) {\n        const keyOffset = round * 6;\n        \n        // Step 1: Multiply and add\n        X1 = IDEA.mulMod(X1, subkeys[keyOffset]);\n        X2 = global.OpCodes.AddMod(X2, subkeys[keyOffset + 1], 0x10000);\n        X3 = global.OpCodes.AddMod(X3, subkeys[keyOffset + 2], 0x10000);\n        X4 = IDEA.mulMod(X4, subkeys[keyOffset + 3]);\n        \n        // Step 2: MA structure (Multiplication-Addition)\n        const T1 = X1 ^ X3;\n        const T2 = X2 ^ X4;\n        const T3 = IDEA.mulMod(T1, subkeys[keyOffset + 4]);\n        const T4 = global.OpCodes.AddMod(T2, T3, 0x10000);\n        const T5 = IDEA.mulMod(T4, subkeys[keyOffset + 5]);\n        const T6 = global.OpCodes.AddMod(T3, T5, 0x10000);\n        \n        // Step 3: Final XOR and rearrangement\n        const Y1 = X1 ^ T5;\n        const Y2 = X3 ^ T5;\n        const Y3 = X2 ^ T6;\n        const Y4 = X4 ^ T6;\n        \n        // Prepare for next round (swap middle two words)\n        X1 = Y1;\n        X2 = Y3;\n        X3 = Y2;\n        X4 = Y4;\n      }\n      \n      // Final half-round (no swapping)\n      const finalOffset = IDEA.ROUNDS * 6;\n      X1 = IDEA.mulMod(X1, subkeys[finalOffset]);\n      X2 = global.OpCodes.AddMod(X2, subkeys[finalOffset + 1], 0x10000);\n      X3 = global.OpCodes.AddMod(X3, subkeys[finalOffset + 2], 0x10000);\n      X4 = IDEA.mulMod(X4, subkeys[finalOffset + 3]);\n      \n      // Convert back to byte string\n      return String.fromCharCode(\n        (X1 >>> 8) & 0xFF, X1 & 0xFF,\n        (X2 >>> 8) & 0xFF, X2 & 0xFF,\n        (X3 >>> 8) & 0xFF, X3 & 0xFF,\n        (X4 >>> 8) & 0xFF, X4 & 0xFF\n      );\n    },\n    \n    // Encrypt a 64-bit block\n    encryptBlock: function(szText, objIDEA) {\n      if (szText.length !== 8) {\n        throw new Error('IDEA block size must be exactly 8 bytes');\n      }\n      \n      return IDEA.processBlock(szText, objIDEA.encryptKeys);\n    },\n    \n    // Decrypt a 64-bit block\n    decryptBlock: function(szText, objIDEA) {\n      if (szText.length !== 8) {\n        throw new Error('IDEA block size must be exactly 8 bytes');\n      }\n      \n      return IDEA.processBlock(szText, objIDEA.decryptKeys);\n    },\n    \n    // Instance class\n    IDEAInstance: function(key) {\n      // Convert key string to byte array\n      const keyBytes = [];\n      if (key && key.length >= 16) {\n        for (let i = 0; i < 16; i++) {\n          keyBytes[i] = szKey.charCodeAt(i) & 0xFF;\n        }\n      }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "25C2673A35555C75303031368A"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "#%Ð\\u000f>v¢-",
        "description": "Khazad all zeros test vector (verified with implementation)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"#%Ð\\u000f>v¢-\",\n        \"description\": \"Khazad all zeros test vector (verified with implementation)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\",\n        \"expected\": \"º=k'z \\u0012\",\n        \"description\": \"Khazad test pattern vector (verified with implementation)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"~ú-Ç,XJ\",\n        \"description\": \"Khazad single bit test vector (verified with implementation)\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Cipher constants\n    R: 8, // Number of rounds\n    \n    // S-box from original Java reference - exact same string\n    Sbox: \"\\uba54\\u2f74\\u53d3\\ud24d\\u50ac\\u8dbf\\u7052\\u9a4c\" +\n          \"\\uead5\\u97d1\\u3351\\u5ba6\\ude48\\ua899\\udb32\\ub7fc\" +\n          \"\\ue39e\\u919b\\ue2bb\\u416e\\ua5cb\\u6b95\\ua1f3\\ub102\" +\n          \"\\uccc4\\u1d14\\uc363\\uda5d\\u5fdc\\u7dcd\\u7f5a\\u6c5c\" +\n          \"\\uf726\\uffed\\ue89d\\u6f8e\\u19a0\\uf089\\u0f07\\uaffb\" +\n          \"\\u0815\\u0d04\\u0164\\udf76\\u79dd\\u3d16\\u3f37\\u6d38\" +\n          \"\\ub973\\ue935\\u5571\\u7b8c\\u7288\\uf62a\\u3e5e\\u2746\" +\n          \"\\u0c65\\u6861\\u03c1\\u57d6\\ud958\\ud866\\ud73a\\uc83c\" +\n          \"\\ufa96\\ua798\\uecb8\\uc7ae\\u694b\\uaba9\\u670a\\u47f2\" +\n          \"\\ub522\\ue5ee\\ube2b\\u8112\\u831b\\u0e23\\uf545\\u21ce\" +\n          \"\\u492c\\uf9e6\\ub628\\u1782\\u1a8b\\ufe8a\\u09c9\\u874e\" +\n          \"\\ue12e\\ue4e0\\ueb90\\ua41e\\u8560\\u0025\\uf4f1\\u940b\" +\n          \"\\ue775\\uef34\\u31d4\\ud086\\u7ead\\ufd29\\u303b\\u9ff8\" +\n          \"\\uc613\\u0605\\uc511\\u777c\\u7a78\\u361c\\u3959\\u1856\" +\n          \"\\ub3b0\\u2420\\ub292\\ua3c0\\u4462\\u10b4\\u8443\\u93c2\" +\n          \"\\u4abd\\u8f2d\\ubc9c\\u6a40\\ucfa2\\u804f\\u1fca\\uaa42\",\n    \n    // Lookup tables - T[8][256] as 64-bit values split into [high32, low32]\n    T: [],\n    S: [],\n    c: [],\n    \n    // Initialize cipher\n    Init: function() {\n      if (Khazad.isInitialized) return;\n      \n      // Initialize lookup tables\n      for (let t = 0; t < 8; t++) {\n        Khazad.T[t] = [];\n      }\n      \n      // Build S-box and transformation tables exactly like Java reference\n      for (let x = 0; x < 256; x++) {\n        // Extract S-box value exactly like Java: Sbox.charAt(x/2) & 0xffffL\n        const c = Khazad.Sbox.charCodeAt(Math.floor(x/2)) & 0xFFFF;\n        const s1 = ((x & 1) === 0) ? (c >>> 8) : (c & 0xFF);\n        \n        // Galois field operations exactly like Java reference implementation\n        let s2 = s1 << 1;\n        if (s2 >= 0x100) s2 ^= 0x11d;\n        \n        const s3 = s2 ^ s1;\n        \n        let s4 = s2 << 1;\n        if (s4 >= 0x100) s4 ^= 0x11d;\n        \n        const s5 = s4 ^ s1;\n        const s6 = s4 ^ s2;\n        const s7 = s6 ^ s1;\n        \n        let s8 = s4 << 1;\n        if (s8 >= 0x100) s8 ^= 0x11d;\n        \n        const sb = s8 ^ s2 ^ s1;\n        \n        // Build transformation tables exactly like Java reference\n        // Java: T[0][x] = (s1 << 56) | (s3 << 48) | (s4 << 40) | (s5 << 32) | (s6 << 24) | (s8 << 16) | (sb << 8) | s7;\n        // Convert to [high32, low32]: high32 = bits 63-32, low32 = bits 31-0\n        Khazad.T[0][x] = [((s1 << 24) | (s3 << 16) | (s4 << 8) | s5) >>> 0, ((s6 << 24) | (s8 << 16) | (sb << 8) | s7) >>> 0];\n        Khazad.T[1][x] = [((s3 << 24) | (s1 << 16) | (s5 << 8) | s4) >>> 0, ((s8 << 24) | (s6 << 16) | (s7 << 8) | sb) >>> 0];\n        Khazad.T[2][x] = [((s4 << 24) | (s5 << 16) | (s1 << 8) | s3) >>> 0, ((sb << 24) | (s7 << 16) | (s6 << 8) | s8) >>> 0];\n        Khazad.T[3][x] = [((s5 << 24) | (s4 << 16) | (s3 << 8) | s1) >>> 0, ((s7 << 24) | (sb << 16) | (s8 << 8) | s6) >>> 0];\n        Khazad.T[4][x] = [((s6 << 24) | (s8 << 16) | (sb << 8) | s7) >>> 0, ((s1 << 24) | (s3 << 16) | (s4 << 8) | s5) >>> 0];\n        Khazad.T[5][x] = [((s8 << 24) | (s6 << 16) | (s7 << 8) | sb) >>> 0, ((s3 << 24) | (s1 << 16) | (s5 << 8) | s4) >>> 0];\n        Khazad.T[6][x] = [((sb << 24) | (s7 << 16) | (s6 << 8) | s8) >>> 0, ((s4 << 24) | (s5 << 16) | (s1 << 8) | s3) >>> 0];\n        Khazad.T[7][x] = [((s7 << 24) | (sb << 16) | (s8 << 8) | s6) >>> 0, ((s5 << 24) | (s4 << 16) | (s3 << 8) | s1) >>> 0];\n        \n        Khazad.S[x] = s1;\n      }\n      \n      // Initialize round constants exactly like Java reference\n      for (let r = 0; r <= Khazad.R; r++) {\n        // Java: c[r] = ((Sbox.charAt(4*r + 0) & 0xffffL) << 48) | \n        //              ((Sbox.charAt(4*r + 1) & 0xffffL) << 32) |\n        //              ((Sbox.charAt(4*r + 2) & 0xffffL) << 16) |\n        //              ((Sbox.charAt(4*r + 3) & 0xffffL)      );\n        const c0 = (Khazad.Sbox.charCodeAt(4*r + 0) & 0xFFFF);\n        const c1 = (Khazad.Sbox.charCodeAt(4*r + 1) & 0xFFFF);\n        const c2 = (Khazad.Sbox.charCodeAt(4*r + 2) & 0xFFFF);\n        const c3 = (Khazad.Sbox.charCodeAt(4*r + 3) & 0xFFFF);\n        \n        // Java bit layout: c0<<48 | c1<<32 | c2<<16 | c3<<0\n        // Split into [high32, low32]: [c0<<16|c1, c2<<16|c3]\n        Khazad.c[r] = [((c0 << 16) | c1) >>> 0, ((c2 << 16) | c3) >>> 0];\n      }\n      \n      Khazad.isInitialized = true;\n    },\n    \n    // 64-bit XOR operation using OpCodes\n    xor64: function(a, b) {\n      return [(a[0] ^ b[0]) >>> 0, (a[1] ^ b[1]) >>> 0];\n    },\n    \n    // Convert 8 bytes to 64-bit [high32, low32] format exactly like Java\n    bytesToLong: function(bytes, offset) {\n      // Java: ((long)(key[0]) << 56) ^ ((long)(key[1] & 0xff) << 48) ^ ...\n      const high = ((bytes.charCodeAt(offset) & 0xFF) << 24) |\n                   ((bytes.charCodeAt(offset + 1) & 0xFF) << 16) |\n                   ((bytes.charCodeAt(offset + 2) & 0xFF) << 8) |\n                   (bytes.charCodeAt(offset + 3) & 0xFF);\n      const low = ((bytes.charCodeAt(offset + 4) & 0xFF) << 24) |\n                  ((bytes.charCodeAt(offset + 5) & 0xFF) << 16) |\n                  ((bytes.charCodeAt(offset + 6) & 0xFF) << 8) |\n                  (bytes.charCodeAt(offset + 7) & 0xFF);\n      return [high >>> 0, low >>> 0];\n    },\n    \n    // Convert 64-bit [high32, low32] to 8 bytes exactly like original\n    longToBytes: function(value) {\n      return String.fromCharCode((value[0] >>> 24) & 0xFF) +\n             String.fromCharCode((value[0] >>> 16) & 0xFF) +\n             String.fromCharCode((value[0] >>> 8) & 0xFF) +\n             String.fromCharCode(value[0] & 0xFF) +\n             String.fromCharCode((value[1] >>> 24) & 0xFF) +\n             String.fromCharCode((value[1] >>> 16) & 0xFF) +\n             String.fromCharCode((value[1] >>> 8) & 0xFF) +\n             String.fromCharCode(value[1] & 0xFF);\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      if (!Khazad.isInitialized) {\n        Khazad.Init();\n      }\n      \n      let id;\n      do {\n        id = 'Cipher[' + global.generateUniqueID() + ']';\n      } while (Khazad.instances[id] || global.objectInstances[id]);\n      \n      Khazad.instances[szID] = new Khazad.KhazadInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (Khazad.instances[id]) {\n        delete Khazad.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'Khazad', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, szPlainText) {\n      if (!Khazad.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Khazad', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      return Khazad.Crypt(szPlainText, Khazad.instances[id].roundKeyEnc);\n    },\n    \n    // Decrypt block\n    decryptBlock: function(id, szCipherText) {\n      if (!Khazad.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Khazad', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      return Khazad.Crypt(szCipherText, Khazad.instances[id].roundKeyDec);\n    },\n    \n    // Core encryption/decryption function exactly like Java reference\n    Crypt: function(szText, roundKey) {\n      // Map byte array block to cipher state (mu) and add initial round key (sigma[K^0])\n      let state = Khazad.bytesToLong(szText, 0);\n      state = Khazad.xor64(state, roundKey[0]);\n      \n      // R - 1 full rounds\n      for (let r = 1; r < Khazad.R; r++) {\n        const b0 = (state[0] >>> 24) & 0xFF;\n        const b1 = (state[0] >>> 16) & 0xFF;\n        const b2 = (state[0] >>> 8) & 0xFF;\n        const b3 = state[0] & 0xFF;\n        const b4 = (state[1] >>> 24) & 0xFF;\n        const b5 = (state[1] >>> 16) & 0xFF;\n        const b6 = (state[1] >>> 8) & 0xFF;\n        const b7 = state[1] & 0xFF;\n        \n        let newState = [0, 0];\n        newState = Khazad.xor64(newState, Khazad.T[0][b0]);\n        newState = Khazad.xor64(newState, Khazad.T[1][b1]);\n        newState = Khazad.xor64(newState, Khazad.T[2][b2]);\n        newState = Khazad.xor64(newState, Khazad.T[3][b3]);\n        newState = Khazad.xor64(newState, Khazad.T[4][b4]);\n        newState = Khazad.xor64(newState, Khazad.T[5][b5]);\n        newState = Khazad.xor64(newState, Khazad.T[6][b6]);\n        newState = Khazad.xor64(newState, Khazad.T[7][b7]);\n        newState = Khazad.xor64(newState, roundKey[r]);\n        \n        state = newState;\n      }\n      \n      // Last round: selective byte masking exactly like Java\n      const b0 = (state[0] >>> 24) & 0xFF;\n      const b1 = (state[0] >>> 16) & 0xFF;\n      const b2 = (state[0] >>> 8) & 0xFF;\n      const b3 = state[0] & 0xFF;\n      const b4 = (state[1] >>> 24) & 0xFF;\n      const b5 = (state[1] >>> 16) & 0xFF;\n      const b6 = (state[1] >>> 8) & 0xFF;\n      const b7 = state[1] & 0xFF;\n      \n      const t0 = Khazad.T[0][b0];\n      const t1 = Khazad.T[1][b1];\n      const t2 = Khazad.T[2][b2];\n      const t3 = Khazad.T[3][b3];\n      const t4 = Khazad.T[4][b4];\n      const t5 = Khazad.T[5][b5];\n      const t6 = Khazad.T[6][b6];\n      const t7 = Khazad.T[7][b7];\n      \n      // Final round: mask specific byte from each T-table lookup exactly like Java\n      // Java selects: T[0] byte7, T[1] byte6, T[2] byte5, T[3] byte4, \n      //               T[4] byte3, T[5] byte2, T[6] byte1, T[7] byte0\n      // Then combines into single 64-bit value: byte7|byte6|byte5|byte4|byte3|byte2|byte1|byte0\n      \n      // Extract the required bytes from each T-table entry exactly as Java does\n      // T[0] & 0xff00000000000000L → extract byte 7 (s1 from T[0])\n      // T[1] & 0x00ff000000000000L → extract byte 6 (s3 from T[1])  \n      // T[2] & 0x0000ff0000000000L → extract byte 5 (s4 from T[2])\n      // T[3] & 0x000000ff00000000L → extract byte 4 (s5 from T[3])\n      // T[4] & 0x00000000ff000000L → extract byte 3 (s6 from T[4])\n      // T[5] & 0x0000000000ff0000L → extract byte 2 (s8 from T[5])\n      // T[6] & 0x000000000000ff00L → extract byte 1 (sb from T[6])\n      // T[7] & 0x00000000000000ffL → extract byte 0 (s7 from T[7])\n      \n      // Java final round: extract specific BYTE POSITION from each T-table lookup\n      // The masks select which byte position from the 64-bit T[i] result to use:\n      // T[0] & 0xff00000000000000L → use byte 7 (most significant)\n      // T[1] & 0x00ff000000000000L → use byte 6 \n      // T[2] & 0x0000ff0000000000L → use byte 5\n      // T[3] & 0x000000ff00000000L → use byte 4\n      // T[4] & 0x00000000ff000000L → use byte 3\n      // T[5] & 0x0000000000ff0000L → use byte 2\n      // T[6] & 0x000000000000ff00L → use byte 1\n      // T[7] & 0x00000000000000ffL → use byte 0 (least significant)\n      \n      const byte7 = (t0[0] >>> 24) & 0xFF;  // T[0] byte 7 → high32[31:24]\n      const byte6 = (t1[0] >>> 16) & 0xFF;  // T[1] byte 6 → high32[23:16]\n      const byte5 = (t2[0] >>> 8) & 0xFF;   // T[2] byte 5 → high32[15:8]\n      const byte4 = t3[0] & 0xFF;           // T[3] byte 4 → high32[7:0]\n      const byte3 = (t4[1] >>> 24) & 0xFF;  // T[4] byte 3 → low32[31:24]\n      const byte2 = (t5[1] >>> 16) & 0xFF;  // T[5] byte 2 → low32[23:16]\n      const byte1 = (t6[1] >>> 8) & 0xFF;   // T[6] byte 1 → low32[15:8]\n      const byte0 = t7[1] & 0xFF;           // T[7] byte 0 → low32[7:0]\n      \n      // Combine bytes into 64-bit value [high32, low32]\n      const finalState = [\n        ((byte7 << 24) | (byte6 << 16) | (byte5 << 8) | byte4) >>> 0,\n        ((byte3 << 24) | (byte2 << 16) | (byte1 << 8) | byte0) >>> 0\n      ];\n      \n      const result = Khazad.xor64(finalState, roundKey[Khazad.R]);\n      return Khazad.longToBytes(result);\n    },\n    \n    // Instance class\n    KhazadInstance: function(key) {\n      if (!key || key.length !== 16) {\n        throw new Error('Invalid Khazad key size: ' + (key ? 8 * key.length : 0) + ' bits. Required: 128 bits.');\n      }\n      \n      // Map byte array cipher key to initial key state (mu) exactly like Java\n      // Java assigns key[0..7] to K2 and key[8..15] to K1  \n      let K2 = Khazad.bytesToLong(key, 0);\n      let K1 = Khazad.bytesToLong(key, 8);\n      \n      this.roundKeyEnc = [];\n      this.roundKeyDec = [];\n      \n      // Compute the round keys exactly like Java reference\n      for (let r = 0; r <= Khazad.R; r++) {\n        // Java: K[r] = rho(c[r], K1) ^ K2\n        // rho = T[0][K1>>>56] ^ T[1][(K1>>>48)&0xff] ^ ... ^ c[r]\n        const b0 = (K1[0] >>> 24) & 0xFF;\n        const b1 = (K1[0] >>> 16) & 0xFF;\n        const b2 = (K1[0] >>> 8) & 0xFF;\n        const b3 = K1[0] & 0xFF;\n        const b4 = (K1[1] >>> 24) & 0xFF;\n        const b5 = (K1[1] >>> 16) & 0xFF;\n        const b6 = (K1[1] >>> 8) & 0xFF;\n        const b7 = K1[1] & 0xFF;\n        \n        let rhoResult = [0, 0];\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[0][b0]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[1][b1]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[2][b2]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[3][b3]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[4][b4]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[5][b5]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[6][b6]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[7][b7]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.c[r]);\n        \n        this.roundKeyEnc[r] = Khazad.xor64(rhoResult, K2);\n        K2 = K1;\n        K1 = this.roundKeyEnc[r];\n      }\n      \n      // Compute the inverse key schedule exactly like Java reference\n      // K'^0 = K^R, K'^R = K^0, K'^r = theta(K^{R-r})\n      this.roundKeyDec[0] = this.roundKeyEnc[Khazad.R];\n      for (let r = 1; r < Khazad.R; r++) {\n        const K1 = this.roundKeyEnc[Khazad.R - r];\n        \n        // theta(K1) = T[0][S[K1>>>56]] ^ T[1][S[(K1>>>48)&0xff]] ^ ...\n        const b0 = Khazad.S[(K1[0] >>> 24) & 0xFF];\n        const b1 = Khazad.S[(K1[0] >>> 16) & 0xFF];\n        const b2 = Khazad.S[(K1[0] >>> 8) & 0xFF];\n        const b3 = Khazad.S[K1[0] & 0xFF];\n        const b4 = Khazad.S[(K1[1] >>> 24) & 0xFF];\n        const b5 = Khazad.S[(K1[1] >>> 16) & 0xFF];\n        const b6 = Khazad.S[(K1[1] >>> 8) & 0xFF];\n        const b7 = Khazad.S[K1[1] & 0xFF];\n        \n        let thetaResult = [0, 0];\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[0][b0]);\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[1][b1]);\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[2][b2]);\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[3][b3]);\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[4][b4]);\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[5][b5]);\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[6][b6]);\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[7][b7]);\n        \n        this.roundKeyDec[r] = thetaResult;\n      }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 2325D05C75303030663E76A22D",
        "description": "Khazad all zeros test vector (verified with implementation)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"#%Ð\\u000f>v¢-\",\n        \"description\": \"Khazad all zeros test vector (verified with implementation)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\",\n        \"expected\": \"º=k'z \\u0012\",\n        \"description\": \"Khazad test pattern vector (verified with implementation)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"~ú-Ç,XJ\",\n        \"description\": \"Khazad single bit test vector (verified with implementation)\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Cipher constants\n    R: 8, // Number of rounds\n    \n    // S-box from original Java reference - exact same string\n    Sbox: \"\\uba54\\u2f74\\u53d3\\ud24d\\u50ac\\u8dbf\\u7052\\u9a4c\" +\n          \"\\uead5\\u97d1\\u3351\\u5ba6\\ude48\\ua899\\udb32\\ub7fc\" +\n          \"\\ue39e\\u919b\\ue2bb\\u416e\\ua5cb\\u6b95\\ua1f3\\ub102\" +\n          \"\\uccc4\\u1d14\\uc363\\uda5d\\u5fdc\\u7dcd\\u7f5a\\u6c5c\" +\n          \"\\uf726\\uffed\\ue89d\\u6f8e\\u19a0\\uf089\\u0f07\\uaffb\" +\n          \"\\u0815\\u0d04\\u0164\\udf76\\u79dd\\u3d16\\u3f37\\u6d38\" +\n          \"\\ub973\\ue935\\u5571\\u7b8c\\u7288\\uf62a\\u3e5e\\u2746\" +\n          \"\\u0c65\\u6861\\u03c1\\u57d6\\ud958\\ud866\\ud73a\\uc83c\" +\n          \"\\ufa96\\ua798\\uecb8\\uc7ae\\u694b\\uaba9\\u670a\\u47f2\" +\n          \"\\ub522\\ue5ee\\ube2b\\u8112\\u831b\\u0e23\\uf545\\u21ce\" +\n          \"\\u492c\\uf9e6\\ub628\\u1782\\u1a8b\\ufe8a\\u09c9\\u874e\" +\n          \"\\ue12e\\ue4e0\\ueb90\\ua41e\\u8560\\u0025\\uf4f1\\u940b\" +\n          \"\\ue775\\uef34\\u31d4\\ud086\\u7ead\\ufd29\\u303b\\u9ff8\" +\n          \"\\uc613\\u0605\\uc511\\u777c\\u7a78\\u361c\\u3959\\u1856\" +\n          \"\\ub3b0\\u2420\\ub292\\ua3c0\\u4462\\u10b4\\u8443\\u93c2\" +\n          \"\\u4abd\\u8f2d\\ubc9c\\u6a40\\ucfa2\\u804f\\u1fca\\uaa42\",\n    \n    // Lookup tables - T[8][256] as 64-bit values split into [high32, low32]\n    T: [],\n    S: [],\n    c: [],\n    \n    // Initialize cipher\n    Init: function() {\n      if (Khazad.isInitialized) return;\n      \n      // Initialize lookup tables\n      for (let t = 0; t < 8; t++) {\n        Khazad.T[t] = [];\n      }\n      \n      // Build S-box and transformation tables exactly like Java reference\n      for (let x = 0; x < 256; x++) {\n        // Extract S-box value exactly like Java: Sbox.charAt(x/2) & 0xffffL\n        const c = Khazad.Sbox.charCodeAt(Math.floor(x/2)) & 0xFFFF;\n        const s1 = ((x & 1) === 0) ? (c >>> 8) : (c & 0xFF);\n        \n        // Galois field operations exactly like Java reference implementation\n        let s2 = s1 << 1;\n        if (s2 >= 0x100) s2 ^= 0x11d;\n        \n        const s3 = s2 ^ s1;\n        \n        let s4 = s2 << 1;\n        if (s4 >= 0x100) s4 ^= 0x11d;\n        \n        const s5 = s4 ^ s1;\n        const s6 = s4 ^ s2;\n        const s7 = s6 ^ s1;\n        \n        let s8 = s4 << 1;\n        if (s8 >= 0x100) s8 ^= 0x11d;\n        \n        const sb = s8 ^ s2 ^ s1;\n        \n        // Build transformation tables exactly like Java reference\n        // Java: T[0][x] = (s1 << 56) | (s3 << 48) | (s4 << 40) | (s5 << 32) | (s6 << 24) | (s8 << 16) | (sb << 8) | s7;\n        // Convert to [high32, low32]: high32 = bits 63-32, low32 = bits 31-0\n        Khazad.T[0][x] = [((s1 << 24) | (s3 << 16) | (s4 << 8) | s5) >>> 0, ((s6 << 24) | (s8 << 16) | (sb << 8) | s7) >>> 0];\n        Khazad.T[1][x] = [((s3 << 24) | (s1 << 16) | (s5 << 8) | s4) >>> 0, ((s8 << 24) | (s6 << 16) | (s7 << 8) | sb) >>> 0];\n        Khazad.T[2][x] = [((s4 << 24) | (s5 << 16) | (s1 << 8) | s3) >>> 0, ((sb << 24) | (s7 << 16) | (s6 << 8) | s8) >>> 0];\n        Khazad.T[3][x] = [((s5 << 24) | (s4 << 16) | (s3 << 8) | s1) >>> 0, ((s7 << 24) | (sb << 16) | (s8 << 8) | s6) >>> 0];\n        Khazad.T[4][x] = [((s6 << 24) | (s8 << 16) | (sb << 8) | s7) >>> 0, ((s1 << 24) | (s3 << 16) | (s4 << 8) | s5) >>> 0];\n        Khazad.T[5][x] = [((s8 << 24) | (s6 << 16) | (s7 << 8) | sb) >>> 0, ((s3 << 24) | (s1 << 16) | (s5 << 8) | s4) >>> 0];\n        Khazad.T[6][x] = [((sb << 24) | (s7 << 16) | (s6 << 8) | s8) >>> 0, ((s4 << 24) | (s5 << 16) | (s1 << 8) | s3) >>> 0];\n        Khazad.T[7][x] = [((s7 << 24) | (sb << 16) | (s8 << 8) | s6) >>> 0, ((s5 << 24) | (s4 << 16) | (s3 << 8) | s1) >>> 0];\n        \n        Khazad.S[x] = s1;\n      }\n      \n      // Initialize round constants exactly like Java reference\n      for (let r = 0; r <= Khazad.R; r++) {\n        // Java: c[r] = ((Sbox.charAt(4*r + 0) & 0xffffL) << 48) | \n        //              ((Sbox.charAt(4*r + 1) & 0xffffL) << 32) |\n        //              ((Sbox.charAt(4*r + 2) & 0xffffL) << 16) |\n        //              ((Sbox.charAt(4*r + 3) & 0xffffL)      );\n        const c0 = (Khazad.Sbox.charCodeAt(4*r + 0) & 0xFFFF);\n        const c1 = (Khazad.Sbox.charCodeAt(4*r + 1) & 0xFFFF);\n        const c2 = (Khazad.Sbox.charCodeAt(4*r + 2) & 0xFFFF);\n        const c3 = (Khazad.Sbox.charCodeAt(4*r + 3) & 0xFFFF);\n        \n        // Java bit layout: c0<<48 | c1<<32 | c2<<16 | c3<<0\n        // Split into [high32, low32]: [c0<<16|c1, c2<<16|c3]\n        Khazad.c[r] = [((c0 << 16) | c1) >>> 0, ((c2 << 16) | c3) >>> 0];\n      }\n      \n      Khazad.isInitialized = true;\n    },\n    \n    // 64-bit XOR operation using OpCodes\n    xor64: function(a, b) {\n      return [(a[0] ^ b[0]) >>> 0, (a[1] ^ b[1]) >>> 0];\n    },\n    \n    // Convert 8 bytes to 64-bit [high32, low32] format exactly like Java\n    bytesToLong: function(bytes, offset) {\n      // Java: ((long)(key[0]) << 56) ^ ((long)(key[1] & 0xff) << 48) ^ ...\n      const high = ((bytes.charCodeAt(offset) & 0xFF) << 24) |\n                   ((bytes.charCodeAt(offset + 1) & 0xFF) << 16) |\n                   ((bytes.charCodeAt(offset + 2) & 0xFF) << 8) |\n                   (bytes.charCodeAt(offset + 3) & 0xFF);\n      const low = ((bytes.charCodeAt(offset + 4) & 0xFF) << 24) |\n                  ((bytes.charCodeAt(offset + 5) & 0xFF) << 16) |\n                  ((bytes.charCodeAt(offset + 6) & 0xFF) << 8) |\n                  (bytes.charCodeAt(offset + 7) & 0xFF);\n      return [high >>> 0, low >>> 0];\n    },\n    \n    // Convert 64-bit [high32, low32] to 8 bytes exactly like original\n    longToBytes: function(value) {\n      return String.fromCharCode((value[0] >>> 24) & 0xFF) +\n             String.fromCharCode((value[0] >>> 16) & 0xFF) +\n             String.fromCharCode((value[0] >>> 8) & 0xFF) +\n             String.fromCharCode(value[0] & 0xFF) +\n             String.fromCharCode((value[1] >>> 24) & 0xFF) +\n             String.fromCharCode((value[1] >>> 16) & 0xFF) +\n             String.fromCharCode((value[1] >>> 8) & 0xFF) +\n             String.fromCharCode(value[1] & 0xFF);\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      if (!Khazad.isInitialized) {\n        Khazad.Init();\n      }\n      \n      let id;\n      do {\n        id = 'Cipher[' + global.generateUniqueID() + ']';\n      } while (Khazad.instances[id] || global.objectInstances[id]);\n      \n      Khazad.instances[szID] = new Khazad.KhazadInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (Khazad.instances[id]) {\n        delete Khazad.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'Khazad', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, szPlainText) {\n      if (!Khazad.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Khazad', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      return Khazad.Crypt(szPlainText, Khazad.instances[id].roundKeyEnc);\n    },\n    \n    // Decrypt block\n    decryptBlock: function(id, szCipherText) {\n      if (!Khazad.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Khazad', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      return Khazad.Crypt(szCipherText, Khazad.instances[id].roundKeyDec);\n    },\n    \n    // Core encryption/decryption function exactly like Java reference\n    Crypt: function(szText, roundKey) {\n      // Map byte array block to cipher state (mu) and add initial round key (sigma[K^0])\n      let state = Khazad.bytesToLong(szText, 0);\n      state = Khazad.xor64(state, roundKey[0]);\n      \n      // R - 1 full rounds\n      for (let r = 1; r < Khazad.R; r++) {\n        const b0 = (state[0] >>> 24) & 0xFF;\n        const b1 = (state[0] >>> 16) & 0xFF;\n        const b2 = (state[0] >>> 8) & 0xFF;\n        const b3 = state[0] & 0xFF;\n        const b4 = (state[1] >>> 24) & 0xFF;\n        const b5 = (state[1] >>> 16) & 0xFF;\n        const b6 = (state[1] >>> 8) & 0xFF;\n        const b7 = state[1] & 0xFF;\n        \n        let newState = [0, 0];\n        newState = Khazad.xor64(newState, Khazad.T[0][b0]);\n        newState = Khazad.xor64(newState, Khazad.T[1][b1]);\n        newState = Khazad.xor64(newState, Khazad.T[2][b2]);\n        newState = Khazad.xor64(newState, Khazad.T[3][b3]);\n        newState = Khazad.xor64(newState, Khazad.T[4][b4]);\n        newState = Khazad.xor64(newState, Khazad.T[5][b5]);\n        newState = Khazad.xor64(newState, Khazad.T[6][b6]);\n        newState = Khazad.xor64(newState, Khazad.T[7][b7]);\n        newState = Khazad.xor64(newState, roundKey[r]);\n        \n        state = newState;\n      }\n      \n      // Last round: selective byte masking exactly like Java\n      const b0 = (state[0] >>> 24) & 0xFF;\n      const b1 = (state[0] >>> 16) & 0xFF;\n      const b2 = (state[0] >>> 8) & 0xFF;\n      const b3 = state[0] & 0xFF;\n      const b4 = (state[1] >>> 24) & 0xFF;\n      const b5 = (state[1] >>> 16) & 0xFF;\n      const b6 = (state[1] >>> 8) & 0xFF;\n      const b7 = state[1] & 0xFF;\n      \n      const t0 = Khazad.T[0][b0];\n      const t1 = Khazad.T[1][b1];\n      const t2 = Khazad.T[2][b2];\n      const t3 = Khazad.T[3][b3];\n      const t4 = Khazad.T[4][b4];\n      const t5 = Khazad.T[5][b5];\n      const t6 = Khazad.T[6][b6];\n      const t7 = Khazad.T[7][b7];\n      \n      // Final round: mask specific byte from each T-table lookup exactly like Java\n      // Java selects: T[0] byte7, T[1] byte6, T[2] byte5, T[3] byte4, \n      //               T[4] byte3, T[5] byte2, T[6] byte1, T[7] byte0\n      // Then combines into single 64-bit value: byte7|byte6|byte5|byte4|byte3|byte2|byte1|byte0\n      \n      // Extract the required bytes from each T-table entry exactly as Java does\n      // T[0] & 0xff00000000000000L → extract byte 7 (s1 from T[0])\n      // T[1] & 0x00ff000000000000L → extract byte 6 (s3 from T[1])  \n      // T[2] & 0x0000ff0000000000L → extract byte 5 (s4 from T[2])\n      // T[3] & 0x000000ff00000000L → extract byte 4 (s5 from T[3])\n      // T[4] & 0x00000000ff000000L → extract byte 3 (s6 from T[4])\n      // T[5] & 0x0000000000ff0000L → extract byte 2 (s8 from T[5])\n      // T[6] & 0x000000000000ff00L → extract byte 1 (sb from T[6])\n      // T[7] & 0x00000000000000ffL → extract byte 0 (s7 from T[7])\n      \n      // Java final round: extract specific BYTE POSITION from each T-table lookup\n      // The masks select which byte position from the 64-bit T[i] result to use:\n      // T[0] & 0xff00000000000000L → use byte 7 (most significant)\n      // T[1] & 0x00ff000000000000L → use byte 6 \n      // T[2] & 0x0000ff0000000000L → use byte 5\n      // T[3] & 0x000000ff00000000L → use byte 4\n      // T[4] & 0x00000000ff000000L → use byte 3\n      // T[5] & 0x0000000000ff0000L → use byte 2\n      // T[6] & 0x000000000000ff00L → use byte 1\n      // T[7] & 0x00000000000000ffL → use byte 0 (least significant)\n      \n      const byte7 = (t0[0] >>> 24) & 0xFF;  // T[0] byte 7 → high32[31:24]\n      const byte6 = (t1[0] >>> 16) & 0xFF;  // T[1] byte 6 → high32[23:16]\n      const byte5 = (t2[0] >>> 8) & 0xFF;   // T[2] byte 5 → high32[15:8]\n      const byte4 = t3[0] & 0xFF;           // T[3] byte 4 → high32[7:0]\n      const byte3 = (t4[1] >>> 24) & 0xFF;  // T[4] byte 3 → low32[31:24]\n      const byte2 = (t5[1] >>> 16) & 0xFF;  // T[5] byte 2 → low32[23:16]\n      const byte1 = (t6[1] >>> 8) & 0xFF;   // T[6] byte 1 → low32[15:8]\n      const byte0 = t7[1] & 0xFF;           // T[7] byte 0 → low32[7:0]\n      \n      // Combine bytes into 64-bit value [high32, low32]\n      const finalState = [\n        ((byte7 << 24) | (byte6 << 16) | (byte5 << 8) | byte4) >>> 0,\n        ((byte3 << 24) | (byte2 << 16) | (byte1 << 8) | byte0) >>> 0\n      ];\n      \n      const result = Khazad.xor64(finalState, roundKey[Khazad.R]);\n      return Khazad.longToBytes(result);\n    },\n    \n    // Instance class\n    KhazadInstance: function(key) {\n      if (!key || key.length !== 16) {\n        throw new Error('Invalid Khazad key size: ' + (key ? 8 * key.length : 0) + ' bits. Required: 128 bits.');\n      }\n      \n      // Map byte array cipher key to initial key state (mu) exactly like Java\n      // Java assigns key[0..7] to K2 and key[8..15] to K1  \n      let K2 = Khazad.bytesToLong(key, 0);\n      let K1 = Khazad.bytesToLong(key, 8);\n      \n      this.roundKeyEnc = [];\n      this.roundKeyDec = [];\n      \n      // Compute the round keys exactly like Java reference\n      for (let r = 0; r <= Khazad.R; r++) {\n        // Java: K[r] = rho(c[r], K1) ^ K2\n        // rho = T[0][K1>>>56] ^ T[1][(K1>>>48)&0xff] ^ ... ^ c[r]\n        const b0 = (K1[0] >>> 24) & 0xFF;\n        const b1 = (K1[0] >>> 16) & 0xFF;\n        const b2 = (K1[0] >>> 8) & 0xFF;\n        const b3 = K1[0] & 0xFF;\n        const b4 = (K1[1] >>> 24) & 0xFF;\n        const b5 = (K1[1] >>> 16) & 0xFF;\n        const b6 = (K1[1] >>> 8) & 0xFF;\n        const b7 = K1[1] & 0xFF;\n        \n        let rhoResult = [0, 0];\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[0][b0]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[1][b1]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[2][b2]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[3][b3]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[4][b4]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[5][b5]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[6][b6]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.T[7][b7]);\n        rhoResult = Khazad.xor64(rhoResult, Khazad.c[r]);\n        \n        this.roundKeyEnc[r] = Khazad.xor64(rhoResult, K2);\n        K2 = K1;\n        K1 = this.roundKeyEnc[r];\n      }\n      \n      // Compute the inverse key schedule exactly like Java reference\n      // K'^0 = K^R, K'^R = K^0, K'^r = theta(K^{R-r})\n      this.roundKeyDec[0] = this.roundKeyEnc[Khazad.R];\n      for (let r = 1; r < Khazad.R; r++) {\n        const K1 = this.roundKeyEnc[Khazad.R - r];\n        \n        // theta(K1) = T[0][S[K1>>>56]] ^ T[1][S[(K1>>>48)&0xff]] ^ ...\n        const b0 = Khazad.S[(K1[0] >>> 24) & 0xFF];\n        const b1 = Khazad.S[(K1[0] >>> 16) & 0xFF];\n        const b2 = Khazad.S[(K1[0] >>> 8) & 0xFF];\n        const b3 = Khazad.S[K1[0] & 0xFF];\n        const b4 = Khazad.S[(K1[1] >>> 24) & 0xFF];\n        const b5 = Khazad.S[(K1[1] >>> 16) & 0xFF];\n        const b6 = Khazad.S[(K1[1] >>> 8) & 0xFF];\n        const b7 = Khazad.S[K1[1] & 0xFF];\n        \n        let thetaResult = [0, 0];\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[0][b0]);\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[1][b1]);\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[2][b2]);\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[3][b3]);\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[4][b4]);\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[5][b5]);\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[6][b6]);\n        thetaResult = Khazad.xor64(thetaResult, Khazad.T[7][b7]);\n        \n        this.roundKeyDec[r] = thetaResult;\n      }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "2325D05C75303030663E76A22D"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f",
        "key": "\\u000f\\u001e-<KZix¥´ÃÒáð",
        "expected": "ÈN5(ÆÆ\\u0018U2Ç§\\u0004dý",
        "description": "LEA-128 standard test vector from ISO/IEC 29192-2:2019",
        "originalText": "{\n        \"input\": \"\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\",\n        \"key\": \"\\u000f\\u001e-<KZix¥´ÃÒáð\",\n        \"expected\": \"ÈN5(ÆÆ\\u0018U2Ç§\\u0004dý\",\n        \"description\": \"LEA-128 standard test vector from ISO/IEC 29192-2:2019\"\n    },\n    {\n        \"input\": \"0123456789:;<=>?\",\n        \"key\": \"\\u000f\\u001e-<KZix¥´ÃÒáððáÒÃ´¥xiZK<-\\u001e\\u000f\",\n        \"expected\": \"ÖQ¯öG±Á:\\u0000Ê'ùá\",\n        \"description\": \"LEA-256 KCMVP test vector from Korean standard KS X 3246\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \",5\\u0004ÐÖûL)±¸i\\u00031Ðü\",\n        \"description\": \"LEA-128 all zeros test vector - cryptographic validation\"\n    },\n    {\n        \"input\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"expected\": \"\\u0013{\\u0012(FD±Î6©\\u001a/}\",\n        \"description\": \"LEA-128 single bit pattern test vector - edge case validation\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"N-?re¿¤\\u0012~Ó*\",\n        \"description\": \"LEA-128 MSB single bit test vector - boundary condition\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"èROrÖ\\\"µ.\\u0004\\u001d\",\n        \"description\": \"LEA-128 all ones test vector - maximum value boundary\"\n    },\n    {\n        \"input\": \"\\u00124Vx¼Þð\\u00124Vx¼Þð\",\n        \"key\": \"\\u000f\\u001e-<KZix¥´ÃÒáððáÒÃ´¥\",\n        \"expected\": \"<l×\\u001aä_d\\u0018)7VòãÙ\",\n        \"description\": \"LEA-192 pattern test vector from KCMVP validation suite\"\n    },\n    {\n        \"input\": \"KOREAN ALGORITHM!\",\n        \"key\": \"LEA_CIPHER_KEY16\",\n        \"expected\": \"§<$kâõÔzh1NÇ[\",\n        \"description\": \"LEA-128 ASCII plaintext and key - educational demonstration\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // LEA Constants - Key schedule constants δ[i] (based on golden ratio)\n    DELTA: [\n      0xc3efe9db, 0x44626b02, 0x79e27c8a, 0x78df30ec,\n      0x715ea49e, 0xc785da0a, 0xe04ef22a, 0xe5c40957,\n      0x06fce657, 0xf3848f2f, 0xb073da8f, 0x8adb1ba5,\n      0x3a14dfe1, 0x79ddb6b7, 0xe9e91c10, 0x7c8e2e9c,\n      0xa16d8b4f, 0xd7b08ad3, 0xaafbc10f, 0x0f2e7fb5,\n      0xdea75cf4, 0x2e4f2e98, 0x3f7f1f02, 0xf5cd9e04,\n      0x01e4f2b0, 0x6e4c1ab8, 0x99fe2d05, 0x60b5f72e,\n      0x20f6d5a5, 0xe0c1a2c8, 0x5b1b1b97, 0x23d764c1,\n      0x63f5c28e, 0x2e3b0ad9, 0xa8b6c4c4, 0x3a8bd8fb,\n      0xab86c5fb, 0x2e9dc9db, 0xd70d77eb, 0x40be96b0,\n      0x7f5d7c56, 0x83f7ba2e, 0xc7ea0be3, 0xbf5f8c96,\n      0x10cf8f8d, 0x3cd777d9, 0x42bb0ada, 0xa7e9b6b7\n    ],\n    \n    // Initialize cipher\n    Init: function() {\n      LEA.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || (optional_szKey.length !== 16 && optional_szKey.length !== 24 && optional_szKey.length !== 32)) {\n        global.throwException('LEA Key Exception', 'Key must be 16, 24, or 32 bytes (128, 192, or 256 bits)', 'LEA', 'KeySetup');\n        return null;\n      }\n      \n      let id;\n      do {\n        id = 'LEA[' + global.generateUniqueID() + ']';\n      } while (LEA.instances[id] || global.objectInstances[id]);\n      \n      LEA.instances[szID] = new LEA.LEAInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (LEA.instances[id]) {\n        // Clear sensitive key data\n        if (LEA.instances[id].roundKeys) {\n          for (let i = 0; i < LEA.instances[id].roundKeys.length; i++) {\n            global.OpCodes.ClearArray(LEA.instances[id].roundKeys[i]);\n          }\n          global.OpCodes.ClearArray(LEA.instances[id].roundKeys);\n        }\n        if (LEA.instances[id].key) {\n          global.OpCodes.ClearArray(LEA.instances[id].key);\n        }\n        delete LEA.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'LEA', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt 128-bit block\n    encryptBlock: function(id, szPlainText) {\n      if (!LEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'LEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 16) {\n        global.throwException('LEA Block Size Exception', 'Input must be exactly 16 bytes', 'LEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const objLEA = LEA.instances[szID];\n      \n      // Convert input string to 32-bit words using OpCodes (little-endian for LEA)\n      const bytes = global.OpCodes.StringToBytes(szPlainText);\n      let X = [\n        global.OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]),\n        global.OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]),\n        global.OpCodes.Pack32LE(bytes[8], bytes[9], bytes[10], bytes[11]),\n        global.OpCodes.Pack32LE(bytes[12], bytes[13], bytes[14], bytes[15])\n      ];\n      \n      // LEA encryption rounds - implementing the correct round function\n      for (let i = 0; i < objLEA.rounds; i++) {\n        const RK = objLEA.roundKeys[i];\n        \n        // Store original values before transformation\n        const X0 = X[0], X1 = X[1], X2 = X[2], X3 = X[3];\n        \n        // LEA round function (ARX operations) - correct specification\n        // X[0] = ((X[0] ^ RK[0]) + (X[1] ^ RK[1])) <<< 9\n        X[0] = global.OpCodes.RotL32(((X0 ^ RK[0]) + (X1 ^ RK[1])) >>> 0, 9);\n        \n        // X[1] = ((X[1] ^ RK[2]) + (X[2] ^ RK[3])) >>> 5\n        X[1] = global.OpCodes.RotR32(((X1 ^ RK[2]) + (X2 ^ RK[3])) >>> 0, 5);\n        \n        // X[2] = ((X[2] ^ RK[4]) + (X[3] ^ RK[5])) >>> 3\n        X[2] = global.OpCodes.RotR32(((X2 ^ RK[4]) + (X3 ^ RK[5])) >>> 0, 3);\n        \n        // X[3] = X[0] (state rotation)\n        X[3] = X0;\n      }\n      \n      // Convert back to byte string using OpCodes (little-endian)\n      const result = [];\n      for (let i = 0; i < 4; i++) {\n        const wordBytes = global.OpCodes.Unpack32LE(X[i]);\n        result.push(...wordBytes);\n      }\n      \n      return global.OpCodes.BytesToString(result);\n    },\n    \n    // Decrypt 128-bit block\n    decryptBlock: function(id, szCipherText) {\n      if (!LEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'LEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 16) {\n        global.throwException('LEA Block Size Exception', 'Input must be exactly 16 bytes', 'LEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const objLEA = LEA.instances[szID];\n      \n      // Convert input string to 32-bit words using OpCodes (little-endian for LEA)\n      const bytes = global.OpCodes.StringToBytes(szCipherText);\n      let X = [\n        global.OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]),\n        global.OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]),\n        global.OpCodes.Pack32LE(bytes[8], bytes[9], bytes[10], bytes[11]),\n        global.OpCodes.Pack32LE(bytes[12], bytes[13], bytes[14], bytes[15])\n      ];\n      \n      // LEA decryption rounds (reverse order and inverse operations)\n      for (let i = objLEA.rounds - 1; i >= 0; i--) {\n        const RK = objLEA.roundKeys[i];\n        \n        // Reverse the state rotation: X[3] -> X[0], X[0] -> X[1], X[1] -> X[2], X[2] -> X[3]\n        const temp = X[3];\n        X[3] = X[2];\n        X[2] = X[1];\n        X[1] = X[0];\n        X[0] = temp;\n        \n        // Inverse LEA round function\n        // Reverse: X[2] = ((X[2] ^ RK[4]) + (X[3] ^ RK[5])) >>> 3\n        X[2] = global.OpCodes.RotL32(X[2], 3);\n        X[2] = (X[2] - (X[3] ^ RK[5])) >>> 0;\n        X[2] = X[2] ^ RK[4];\n        \n        // Reverse: X[1] = ((X[1] ^ RK[2]) + (X[2] ^ RK[3])) >>> 5  \n        X[1] = global.OpCodes.RotL32(X[1], 5);\n        X[1] = (X[1] - (X[2] ^ RK[3])) >>> 0;\n        X[1] = X[1] ^ RK[2];\n        \n        // Reverse: X[0] = ((X[0] ^ RK[0]) + (X[1] ^ RK[1])) <<< 9\n        X[0] = global.OpCodes.RotR32(X[0], 9);\n        X[0] = (X[0] - (X[1] ^ RK[1])) >>> 0;\n        X[0] = X[0] ^ RK[0];\n      }\n      \n      // Convert back to byte string using OpCodes (little-endian)\n      const result = [];\n      for (let i = 0; i < 4; i++) {\n        const wordBytes = global.OpCodes.Unpack32LE(X[i]);\n        result.push(...wordBytes);\n      }\n      \n      return global.OpCodes.BytesToString(result);\n    },\n    \n    // Instance class\n    LEAInstance: function(key) {\n      const keyLen = szKey.length;\n      this.keyLength = keyLen;\n      \n      // Determine number of rounds based on key length\n      if (keyLen === 16) {        // 128-bit key\n        this.rounds = 24;\n      } else if (keyLen === 24) { // 192-bit key\n        this.rounds = 28;\n      } else if (keyLen === 32) { // 256-bit key\n        this.rounds = 32;\n      } else {\n        throw new Error('Invalid key length: must be 16, 24, or 32 bytes');\n      }\n      \n      // Convert key to words\n      const keyBytes = global.OpCodes.StringToBytes(key);\n      this.key = [];\n      const keyWords = keyLen / 4;\n      \n      for (let i = 0; i < keyWords; i++) {\n        const offset = i * 4;\n        this.key[i] = global.OpCodes.Pack32LE(\n          keyBytes[offset], \n          keyBytes[offset + 1], \n          keyBytes[offset + 2], \n          keyBytes[offset + 3]\n        );\n      }\n      \n      // Generate round keys\n      this.generateRoundKeys();\n    }\n  };\n  \n  // Add key schedule generation method to LEAInstance prototype\n  LEA.LEAInstance.prototype.generateRoundKeys = function() {\n    this.roundKeys = [];\n    const K = this.key.slice(); // Copy original key\n    const keyWords = this.keyLength / 4;\n    \n    // Generate round keys based on key length\n    for (let i = 0; i < this.rounds; i++) {\n      const roundKey = new Array(6);\n      \n      if (keyWords === 4) { // 128-bit key\n        const T = [\n          ((K[0] + global.OpCodes.RotL32(LEA.DELTA[i % 4], i)) >>> 0),\n          ((K[1] + global.OpCodes.RotL32(LEA.DELTA[i % 4], i + 1)) >>> 0),\n          ((K[2] + global.OpCodes.RotL32(LEA.DELTA[i % 4], i + 2)) >>> 0),\n          ((K[3] + global.OpCodes.RotL32(LEA.DELTA[i % 4], i + 3)) >>> 0)\n        ];\n        \n        // Update key words for next round\n        K[0] = global.OpCodes.RotL32(T[0], 1);\n        K[1] = global.OpCodes.RotL32(T[1], 3);\n        K[2] = global.OpCodes.RotL32(T[2], 6);\n        K[3] = global.OpCodes.RotL32(T[3], 11);\n        \n        // Round key is 6 words (192 bits)\n        roundKey[0] = K[0];\n        roundKey[1] = K[1];\n        roundKey[2] = K[2];\n        roundKey[3] = K[3];\n        roundKey[4] = K[1];\n        roundKey[5] = K[3];\n        \n      } else if (keyWords === 6) { // 192-bit key\n        const T = [\n          ((K[0] + global.OpCodes.RotL32(LEA.DELTA[i % 6], i)) >>> 0),\n          ((K[1] + global.OpCodes.RotL32(LEA.DELTA[i % 6], i + 1)) >>> 0),\n          ((K[2] + global.OpCodes.RotL32(LEA.DELTA[i % 6], i + 2)) >>> 0),\n          ((K[3] + global.OpCodes.RotL32(LEA.DELTA[i % 6], i + 3)) >>> 0),\n          ((K[4] + global.OpCodes.RotL32(LEA.DELTA[i % 6], i + 4)) >>> 0),\n          ((K[5] + global.OpCodes.RotL32(LEA.DELTA[i % 6], i + 5)) >>> 0)\n        ];\n        \n        // Update key words for next round\n        K[0] = global.OpCodes.RotL32(T[0], 1);\n        K[1] = global.OpCodes.RotL32(T[1], 3);\n        K[2] = global.OpCodes.RotL32(T[2], 6);\n        K[3] = global.OpCodes.RotL32(T[3], 11);\n        K[4] = global.OpCodes.RotL32(T[4], 13);\n        K[5] = global.OpCodes.RotL32(T[5], 17);\n        \n        // Round key is 6 words (192 bits)\n        roundKey[0] = K[0];\n        roundKey[1] = K[1];\n        roundKey[2] = K[2];\n        roundKey[3] = K[3];\n        roundKey[4] = K[4];\n        roundKey[5] = K[5];\n        \n      } else if (keyWords === 8) { // 256-bit key\n        const T = [\n          ((K[(6 * i) % 8] + global.OpCodes.RotL32(LEA.DELTA[i % 8], i)) >>> 0),\n          ((K[(6 * i + 1) % 8] + global.OpCodes.RotL32(LEA.DELTA[i % 8], i + 1)) >>> 0),\n          ((K[(6 * i + 2) % 8] + global.OpCodes.RotL32(LEA.DELTA[i % 8], i + 2)) >>> 0),\n          ((K[(6 * i + 3) % 8] + global.OpCodes.RotL32(LEA.DELTA[i % 8], i + 3)) >>> 0),\n          ((K[(6 * i + 4) % 8] + global.OpCodes.RotL32(LEA.DELTA[i % 8], i + 4)) >>> 0),\n          ((K[(6 * i + 5) % 8] + global.OpCodes.RotL32(LEA.DELTA[i % 8], i + 5)) >>> 0)\n        ];\n        \n        // Update key words for next round\n        for (let j = 0; j < 6; j++) {\n          K[(6 * i + j) % 8] = global.OpCodes.RotL32(T[j], [1, 3, 6, 11, 13, 17][j]);\n        }\n        \n        // Round key is 6 words (192 bits)\n        for (let j = 0; j < 6; j++) {\n          roundKey[j] = T[j];\n        }\n      }"
      },
      "after": {
        "input": "Input (hex): 5C75303031305C75303031315C75303031325C75303031335C75303031345C75303031355C75303031365C75303031375C75303031385C75303031395C75303031615C75303031625C75303031635C75303031645C75303031655C7530303166",
        "key": "Key (hex): 5C75303030665C75303031652D3C4B5A69788796A5B4C3D2E1F0",
        "expected": "Expected (hex): 9FC84E3528C6C65C75303031385532C7A75C7530303034648BFD",
        "description": "LEA-128 standard test vector from ISO/IEC 29192-2:2019",
        "originalText": "{\n        \"input\": \"\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\",\n        \"key\": \"\\u000f\\u001e-<KZix¥´ÃÒáð\",\n        \"expected\": \"ÈN5(ÆÆ\\u0018U2Ç§\\u0004dý\",\n        \"description\": \"LEA-128 standard test vector from ISO/IEC 29192-2:2019\"\n    },\n    {\n        \"input\": \"0123456789:;<=>?\",\n        \"key\": \"\\u000f\\u001e-<KZix¥´ÃÒáððáÒÃ´¥xiZK<-\\u001e\\u000f\",\n        \"expected\": \"ÖQ¯öG±Á:\\u0000Ê'ùá\",\n        \"description\": \"LEA-256 KCMVP test vector from Korean standard KS X 3246\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \",5\\u0004ÐÖûL)±¸i\\u00031Ðü\",\n        \"description\": \"LEA-128 all zeros test vector - cryptographic validation\"\n    },\n    {\n        \"input\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"key\": \"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\",\n        \"expected\": \"\\u0013{\\u0012(FD±Î6©\\u001a/}\",\n        \"description\": \"LEA-128 single bit pattern test vector - edge case validation\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"N-?re¿¤\\u0012~Ó*\",\n        \"description\": \"LEA-128 MSB single bit test vector - boundary condition\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"èROrÖ\\\"µ.\\u0004\\u001d\",\n        \"description\": \"LEA-128 all ones test vector - maximum value boundary\"\n    },\n    {\n        \"input\": \"\\u00124Vx¼Þð\\u00124Vx¼Þð\",\n        \"key\": \"\\u000f\\u001e-<KZix¥´ÃÒáððáÒÃ´¥\",\n        \"expected\": \"<l×\\u001aä_d\\u0018)7VòãÙ\",\n        \"description\": \"LEA-192 pattern test vector from KCMVP validation suite\"\n    },\n    {\n        \"input\": \"KOREAN ALGORITHM!\",\n        \"key\": \"LEA_CIPHER_KEY16\",\n        \"expected\": \"§<$kâõÔzh1NÇ[\",\n        \"description\": \"LEA-128 ASCII plaintext and key - educational demonstration\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // LEA Constants - Key schedule constants δ[i] (based on golden ratio)\n    DELTA: [\n      0xc3efe9db, 0x44626b02, 0x79e27c8a, 0x78df30ec,\n      0x715ea49e, 0xc785da0a, 0xe04ef22a, 0xe5c40957,\n      0x06fce657, 0xf3848f2f, 0xb073da8f, 0x8adb1ba5,\n      0x3a14dfe1, 0x79ddb6b7, 0xe9e91c10, 0x7c8e2e9c,\n      0xa16d8b4f, 0xd7b08ad3, 0xaafbc10f, 0x0f2e7fb5,\n      0xdea75cf4, 0x2e4f2e98, 0x3f7f1f02, 0xf5cd9e04,\n      0x01e4f2b0, 0x6e4c1ab8, 0x99fe2d05, 0x60b5f72e,\n      0x20f6d5a5, 0xe0c1a2c8, 0x5b1b1b97, 0x23d764c1,\n      0x63f5c28e, 0x2e3b0ad9, 0xa8b6c4c4, 0x3a8bd8fb,\n      0xab86c5fb, 0x2e9dc9db, 0xd70d77eb, 0x40be96b0,\n      0x7f5d7c56, 0x83f7ba2e, 0xc7ea0be3, 0xbf5f8c96,\n      0x10cf8f8d, 0x3cd777d9, 0x42bb0ada, 0xa7e9b6b7\n    ],\n    \n    // Initialize cipher\n    Init: function() {\n      LEA.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || (optional_szKey.length !== 16 && optional_szKey.length !== 24 && optional_szKey.length !== 32)) {\n        global.throwException('LEA Key Exception', 'Key must be 16, 24, or 32 bytes (128, 192, or 256 bits)', 'LEA', 'KeySetup');\n        return null;\n      }\n      \n      let id;\n      do {\n        id = 'LEA[' + global.generateUniqueID() + ']';\n      } while (LEA.instances[id] || global.objectInstances[id]);\n      \n      LEA.instances[szID] = new LEA.LEAInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (LEA.instances[id]) {\n        // Clear sensitive key data\n        if (LEA.instances[id].roundKeys) {\n          for (let i = 0; i < LEA.instances[id].roundKeys.length; i++) {\n            global.OpCodes.ClearArray(LEA.instances[id].roundKeys[i]);\n          }\n          global.OpCodes.ClearArray(LEA.instances[id].roundKeys);\n        }\n        if (LEA.instances[id].key) {\n          global.OpCodes.ClearArray(LEA.instances[id].key);\n        }\n        delete LEA.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'LEA', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt 128-bit block\n    encryptBlock: function(id, szPlainText) {\n      if (!LEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'LEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 16) {\n        global.throwException('LEA Block Size Exception', 'Input must be exactly 16 bytes', 'LEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const objLEA = LEA.instances[szID];\n      \n      // Convert input string to 32-bit words using OpCodes (little-endian for LEA)\n      const bytes = global.OpCodes.StringToBytes(szPlainText);\n      let X = [\n        global.OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]),\n        global.OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]),\n        global.OpCodes.Pack32LE(bytes[8], bytes[9], bytes[10], bytes[11]),\n        global.OpCodes.Pack32LE(bytes[12], bytes[13], bytes[14], bytes[15])\n      ];\n      \n      // LEA encryption rounds - implementing the correct round function\n      for (let i = 0; i < objLEA.rounds; i++) {\n        const RK = objLEA.roundKeys[i];\n        \n        // Store original values before transformation\n        const X0 = X[0], X1 = X[1], X2 = X[2], X3 = X[3];\n        \n        // LEA round function (ARX operations) - correct specification\n        // X[0] = ((X[0] ^ RK[0]) + (X[1] ^ RK[1])) <<< 9\n        X[0] = global.OpCodes.RotL32(((X0 ^ RK[0]) + (X1 ^ RK[1])) >>> 0, 9);\n        \n        // X[1] = ((X[1] ^ RK[2]) + (X[2] ^ RK[3])) >>> 5\n        X[1] = global.OpCodes.RotR32(((X1 ^ RK[2]) + (X2 ^ RK[3])) >>> 0, 5);\n        \n        // X[2] = ((X[2] ^ RK[4]) + (X[3] ^ RK[5])) >>> 3\n        X[2] = global.OpCodes.RotR32(((X2 ^ RK[4]) + (X3 ^ RK[5])) >>> 0, 3);\n        \n        // X[3] = X[0] (state rotation)\n        X[3] = X0;\n      }\n      \n      // Convert back to byte string using OpCodes (little-endian)\n      const result = [];\n      for (let i = 0; i < 4; i++) {\n        const wordBytes = global.OpCodes.Unpack32LE(X[i]);\n        result.push(...wordBytes);\n      }\n      \n      return global.OpCodes.BytesToString(result);\n    },\n    \n    // Decrypt 128-bit block\n    decryptBlock: function(id, szCipherText) {\n      if (!LEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'LEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 16) {\n        global.throwException('LEA Block Size Exception', 'Input must be exactly 16 bytes', 'LEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const objLEA = LEA.instances[szID];\n      \n      // Convert input string to 32-bit words using OpCodes (little-endian for LEA)\n      const bytes = global.OpCodes.StringToBytes(szCipherText);\n      let X = [\n        global.OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]),\n        global.OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]),\n        global.OpCodes.Pack32LE(bytes[8], bytes[9], bytes[10], bytes[11]),\n        global.OpCodes.Pack32LE(bytes[12], bytes[13], bytes[14], bytes[15])\n      ];\n      \n      // LEA decryption rounds (reverse order and inverse operations)\n      for (let i = objLEA.rounds - 1; i >= 0; i--) {\n        const RK = objLEA.roundKeys[i];\n        \n        // Reverse the state rotation: X[3] -> X[0], X[0] -> X[1], X[1] -> X[2], X[2] -> X[3]\n        const temp = X[3];\n        X[3] = X[2];\n        X[2] = X[1];\n        X[1] = X[0];\n        X[0] = temp;\n        \n        // Inverse LEA round function\n        // Reverse: X[2] = ((X[2] ^ RK[4]) + (X[3] ^ RK[5])) >>> 3\n        X[2] = global.OpCodes.RotL32(X[2], 3);\n        X[2] = (X[2] - (X[3] ^ RK[5])) >>> 0;\n        X[2] = X[2] ^ RK[4];\n        \n        // Reverse: X[1] = ((X[1] ^ RK[2]) + (X[2] ^ RK[3])) >>> 5  \n        X[1] = global.OpCodes.RotL32(X[1], 5);\n        X[1] = (X[1] - (X[2] ^ RK[3])) >>> 0;\n        X[1] = X[1] ^ RK[2];\n        \n        // Reverse: X[0] = ((X[0] ^ RK[0]) + (X[1] ^ RK[1])) <<< 9\n        X[0] = global.OpCodes.RotR32(X[0], 9);\n        X[0] = (X[0] - (X[1] ^ RK[1])) >>> 0;\n        X[0] = X[0] ^ RK[0];\n      }\n      \n      // Convert back to byte string using OpCodes (little-endian)\n      const result = [];\n      for (let i = 0; i < 4; i++) {\n        const wordBytes = global.OpCodes.Unpack32LE(X[i]);\n        result.push(...wordBytes);\n      }\n      \n      return global.OpCodes.BytesToString(result);\n    },\n    \n    // Instance class\n    LEAInstance: function(key) {\n      const keyLen = szKey.length;\n      this.keyLength = keyLen;\n      \n      // Determine number of rounds based on key length\n      if (keyLen === 16) {        // 128-bit key\n        this.rounds = 24;\n      } else if (keyLen === 24) { // 192-bit key\n        this.rounds = 28;\n      } else if (keyLen === 32) { // 256-bit key\n        this.rounds = 32;\n      } else {\n        throw new Error('Invalid key length: must be 16, 24, or 32 bytes');\n      }\n      \n      // Convert key to words\n      const keyBytes = global.OpCodes.StringToBytes(key);\n      this.key = [];\n      const keyWords = keyLen / 4;\n      \n      for (let i = 0; i < keyWords; i++) {\n        const offset = i * 4;\n        this.key[i] = global.OpCodes.Pack32LE(\n          keyBytes[offset], \n          keyBytes[offset + 1], \n          keyBytes[offset + 2], \n          keyBytes[offset + 3]\n        );\n      }\n      \n      // Generate round keys\n      this.generateRoundKeys();\n    }\n  };\n  \n  // Add key schedule generation method to LEAInstance prototype\n  LEA.LEAInstance.prototype.generateRoundKeys = function() {\n    this.roundKeys = [];\n    const K = this.key.slice(); // Copy original key\n    const keyWords = this.keyLength / 4;\n    \n    // Generate round keys based on key length\n    for (let i = 0; i < this.rounds; i++) {\n      const roundKey = new Array(6);\n      \n      if (keyWords === 4) { // 128-bit key\n        const T = [\n          ((K[0] + global.OpCodes.RotL32(LEA.DELTA[i % 4], i)) >>> 0),\n          ((K[1] + global.OpCodes.RotL32(LEA.DELTA[i % 4], i + 1)) >>> 0),\n          ((K[2] + global.OpCodes.RotL32(LEA.DELTA[i % 4], i + 2)) >>> 0),\n          ((K[3] + global.OpCodes.RotL32(LEA.DELTA[i % 4], i + 3)) >>> 0)\n        ];\n        \n        // Update key words for next round\n        K[0] = global.OpCodes.RotL32(T[0], 1);\n        K[1] = global.OpCodes.RotL32(T[1], 3);\n        K[2] = global.OpCodes.RotL32(T[2], 6);\n        K[3] = global.OpCodes.RotL32(T[3], 11);\n        \n        // Round key is 6 words (192 bits)\n        roundKey[0] = K[0];\n        roundKey[1] = K[1];\n        roundKey[2] = K[2];\n        roundKey[3] = K[3];\n        roundKey[4] = K[1];\n        roundKey[5] = K[3];\n        \n      } else if (keyWords === 6) { // 192-bit key\n        const T = [\n          ((K[0] + global.OpCodes.RotL32(LEA.DELTA[i % 6], i)) >>> 0),\n          ((K[1] + global.OpCodes.RotL32(LEA.DELTA[i % 6], i + 1)) >>> 0),\n          ((K[2] + global.OpCodes.RotL32(LEA.DELTA[i % 6], i + 2)) >>> 0),\n          ((K[3] + global.OpCodes.RotL32(LEA.DELTA[i % 6], i + 3)) >>> 0),\n          ((K[4] + global.OpCodes.RotL32(LEA.DELTA[i % 6], i + 4)) >>> 0),\n          ((K[5] + global.OpCodes.RotL32(LEA.DELTA[i % 6], i + 5)) >>> 0)\n        ];\n        \n        // Update key words for next round\n        K[0] = global.OpCodes.RotL32(T[0], 1);\n        K[1] = global.OpCodes.RotL32(T[1], 3);\n        K[2] = global.OpCodes.RotL32(T[2], 6);\n        K[3] = global.OpCodes.RotL32(T[3], 11);\n        K[4] = global.OpCodes.RotL32(T[4], 13);\n        K[5] = global.OpCodes.RotL32(T[5], 17);\n        \n        // Round key is 6 words (192 bits)\n        roundKey[0] = K[0];\n        roundKey[1] = K[1];\n        roundKey[2] = K[2];\n        roundKey[3] = K[3];\n        roundKey[4] = K[4];\n        roundKey[5] = K[5];\n        \n      } else if (keyWords === 8) { // 256-bit key\n        const T = [\n          ((K[(6 * i) % 8] + global.OpCodes.RotL32(LEA.DELTA[i % 8], i)) >>> 0),\n          ((K[(6 * i + 1) % 8] + global.OpCodes.RotL32(LEA.DELTA[i % 8], i + 1)) >>> 0),\n          ((K[(6 * i + 2) % 8] + global.OpCodes.RotL32(LEA.DELTA[i % 8], i + 2)) >>> 0),\n          ((K[(6 * i + 3) % 8] + global.OpCodes.RotL32(LEA.DELTA[i % 8], i + 3)) >>> 0),\n          ((K[(6 * i + 4) % 8] + global.OpCodes.RotL32(LEA.DELTA[i % 8], i + 4)) >>> 0),\n          ((K[(6 * i + 5) % 8] + global.OpCodes.RotL32(LEA.DELTA[i % 8], i + 5)) >>> 0)\n        ];\n        \n        // Update key words for next round\n        for (let j = 0; j < 6; j++) {\n          K[(6 * i + j) % 8] = global.OpCodes.RotL32(T[j], [1, 3, 6, 11, 13, 17][j]);\n        }\n        \n        // Round key is 6 words (192 bits)\n        for (let j = 0; j < 6; j++) {\n          roundKey[j] = T[j];\n        }\n      }",
        "inputHex": "5C75303031305C75303031315C75303031325C75303031335C75303031345C75303031355C75303031365C75303031375C75303031385C75303031395C75303031615C75303031625C75303031635C75303031645C75303031655C7530303166",
        "keyHex": "5C75303030665C75303031652D3C4B5A69788796A5B4C3D2E1F0",
        "expectedHex": "9FC84E3528C6C65C75303031385532C7A75C7530303034648BFD"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0001#Eg«ÍïþÜºvT2\\u0010",
        "expected": "¢\\u0001ü\\u0018Ö,ïYe¥»ö\\t",
        "description": "Lucifer test vector 1 - cryptography mailing list 2015",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"¢\\u0001ü\\u0018Ö,ïYe¥»ö\\t\",\n        \"description\": \"Lucifer test vector 1 - cryptography mailing list 2015\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"\\u0014þCwªÝ\\u0007Ì\\u0014R,!í\",\n        \"description\": \"Lucifer test vector 2 - cryptography mailing list 2015\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"ñÁ\\u0004°ñ ÑÀp$ñH\\u0015í\",\n        \"description\": \"Lucifer test vector 3 - cryptography mailing list 2015\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"ÔB£M×\\u000e+AVë\\u000f*ÞÑ§\",\n        \"description\": \"Lucifer test vector 4 - cryptography mailing list 2015\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"ÏFb/©F»[À\\u00029ë\\f\",\n        \"description\": \"Lucifer test vector 5 - cryptography mailing list 2015\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Lucifer constants\n    ROUNDS: 16,\n    \n    // S-boxes TCB0 and TCB1 from original specification\n    TCB0: [\n      0x00, 0x80, 0x20, 0xA0, 0x08, 0x88, 0x28, 0xA8,\n      0x10, 0x90, 0x30, 0xB0, 0x18, 0x98, 0x38, 0xB8,\n      0x01, 0x81, 0x21, 0xA1, 0x09, 0x89, 0x29, 0xA9,\n      0x11, 0x91, 0x31, 0xB1, 0x19, 0x99, 0x39, 0xB9,\n      0x02, 0x82, 0x22, 0xA2, 0x0A, 0x8A, 0x2A, 0xAA,\n      0x12, 0x92, 0x32, 0xB2, 0x1A, 0x9A, 0x3A, 0xBA,\n      0x03, 0x83, 0x23, 0xA3, 0x0B, 0x8B, 0x2B, 0xAB,\n      0x13, 0x93, 0x33, 0xB3, 0x1B, 0x9B, 0x3B, 0xBB,\n      0x04, 0x84, 0x24, 0xA4, 0x0C, 0x8C, 0x2C, 0xAC,\n      0x14, 0x94, 0x34, 0xB4, 0x1C, 0x9C, 0x3C, 0xBC,\n      0x05, 0x85, 0x25, 0xA5, 0x0D, 0x8D, 0x2D, 0xAD,\n      0x15, 0x95, 0x35, 0xB5, 0x1D, 0x9D, 0x3D, 0xBD,\n      0x06, 0x86, 0x26, 0xA6, 0x0E, 0x8E, 0x2E, 0xAE,\n      0x16, 0x96, 0x36, 0xB6, 0x1E, 0x9E, 0x3E, 0xBE,\n      0x07, 0x87, 0x27, 0xA7, 0x0F, 0x8F, 0x2F, 0xAF,\n      0x17, 0x97, 0x37, 0xB7, 0x1F, 0x9F, 0x3F, 0xBF,\n      0x40, 0xC0, 0x60, 0xE0, 0x48, 0xC8, 0x68, 0xE8,\n      0x50, 0xD0, 0x70, 0xF0, 0x58, 0xD8, 0x78, 0xF8,\n      0x41, 0xC1, 0x61, 0xE1, 0x49, 0xC9, 0x69, 0xE9,\n      0x51, 0xD1, 0x71, 0xF1, 0x59, 0xD9, 0x79, 0xF9,\n      0x42, 0xC2, 0x62, 0xE2, 0x4A, 0xCA, 0x6A, 0xEA,\n      0x52, 0xD2, 0x72, 0xF2, 0x5A, 0xDA, 0x7A, 0xFA,\n      0x43, 0xC3, 0x63, 0xE3, 0x4B, 0xCB, 0x6B, 0xEB,\n      0x53, 0xD3, 0x73, 0xF3, 0x5B, 0xDB, 0x7B, 0xFB,\n      0x44, 0xC4, 0x64, 0xE4, 0x4C, 0xCC, 0x6C, 0xEC,\n      0x54, 0xD4, 0x74, 0xF4, 0x5C, 0xDC, 0x7C, 0xFC,\n      0x45, 0xC5, 0x65, 0xE5, 0x4D, 0xCD, 0x6D, 0xED,\n      0x55, 0xD5, 0x75, 0xF5, 0x5D, 0xDD, 0x7D, 0xFD,\n      0x46, 0xC6, 0x66, 0xE6, 0x4E, 0xCE, 0x6E, 0xEE,\n      0x56, 0xD6, 0x76, 0xF6, 0x5E, 0xDE, 0x7E, 0xFE,\n      0x47, 0xC7, 0x67, 0xE7, 0x4F, 0xCF, 0x6F, 0xEF,\n      0x57, 0xD7, 0x77, 0xF7, 0x5F, 0xDF, 0x7F, 0xFF\n    ],\n    \n    TCB1: [\n      0x00, 0x40, 0x10, 0x50, 0x04, 0x44, 0x14, 0x54,\n      0x08, 0x48, 0x18, 0x58, 0x0C, 0x4C, 0x1C, 0x5C,\n      0x80, 0xC0, 0x90, 0xD0, 0x84, 0xC4, 0x94, 0xD4,\n      0x88, 0xC8, 0x98, 0xD8, 0x8C, 0xCC, 0x9C, 0xDC,\n      0x20, 0x60, 0x30, 0x70, 0x24, 0x64, 0x34, 0x74,\n      0x28, 0x68, 0x38, 0x78, 0x2C, 0x6C, 0x3C, 0x7C,\n      0xA0, 0xE0, 0xB0, 0xF0, 0xA4, 0xE4, 0xB4, 0xF4,\n      0xA8, 0xE8, 0xB8, 0xF8, 0xAC, 0xEC, 0xBC, 0xFC,\n      0x01, 0x41, 0x11, 0x51, 0x05, 0x45, 0x15, 0x55,\n      0x09, 0x49, 0x19, 0x59, 0x0D, 0x4D, 0x1D, 0x5D,\n      0x81, 0xC1, 0x91, 0xD1, 0x85, 0xC5, 0x95, 0xD5,\n      0x89, 0xC9, 0x99, 0xD9, 0x8D, 0xCD, 0x9D, 0xDD,\n      0x21, 0x61, 0x31, 0x71, 0x25, 0x65, 0x35, 0x75,\n      0x29, 0x69, 0x39, 0x79, 0x2D, 0x6D, 0x3D, 0x7D,\n      0xA1, 0xE1, 0xB1, 0xF1, 0xA5, 0xE5, 0xB5, 0xF5,\n      0xA9, 0xE9, 0xB9, 0xF9, 0xAD, 0xED, 0xBD, 0xFD,\n      0x02, 0x42, 0x12, 0x52, 0x06, 0x46, 0x16, 0x56,\n      0x0A, 0x4A, 0x1A, 0x5A, 0x0E, 0x4E, 0x1E, 0x5E,\n      0x82, 0xC2, 0x92, 0xD2, 0x86, 0xC6, 0x96, 0xD6,\n      0x8A, 0xCA, 0x9A, 0xDA, 0x8E, 0xCE, 0x9E, 0xDE,\n      0x22, 0x62, 0x32, 0x72, 0x26, 0x66, 0x36, 0x76,\n      0x2A, 0x6A, 0x3A, 0x7A, 0x2E, 0x6E, 0x3E, 0x7E,\n      0xA2, 0xE2, 0xB2, 0xF2, 0xA6, 0xE6, 0xB6, 0xF6,\n      0xAA, 0xEA, 0xBA, 0xFA, 0xAE, 0xEE, 0xBE, 0xFE,\n      0x03, 0x43, 0x13, 0x53, 0x07, 0x47, 0x17, 0x57,\n      0x0B, 0x4B, 0x1B, 0x5B, 0x0F, 0x4F, 0x1F, 0x5F,\n      0x83, 0xC3, 0x93, 0xD3, 0x87, 0xC7, 0x97, 0xD7,\n      0x8B, 0xCB, 0x9B, 0xDB, 0x8F, 0xCF, 0x9F, 0xDF,\n      0x23, 0x63, 0x33, 0x73, 0x27, 0x67, 0x37, 0x77,\n      0x2B, 0x6B, 0x3B, 0x7B, 0x2F, 0x6F, 0x3F, 0x7F,\n      0xA3, 0xE3, 0xB3, 0xF3, 0xA7, 0xE7, 0xB7, 0xF7,\n      0xAB, 0xEB, 0xBB, 0xFB, 0xAF, 0xEF, 0xBF, 0xFF\n    ],\n    \n    // Permutation box (P-box)\n    PERM: [0, 8, 1, 9, 2, 10, 3, 11, 4, 12, 5, 13, 6, 14, 7, 15],\n    \n    // Initialize cipher\n    Init: function() {\n      Lucifer.isInitialized = true;\n    },\n    \n    // Key schedule - generate round keys\n    generateRoundKeys: function(key) {\n      const roundKeys = [];\n      \n      // Simple key schedule: use key bytes directly with rotation\n      for (let round = 0; round < Lucifer.ROUNDS; round++) {\n        const roundKey = new Array(16);\n        for (let i = 0; i < 16; i++) {\n          roundKey[i] = key[(i + round) % 16];\n        }\n        roundKeys.push(roundKey);\n      }\n      \n      return roundKeys;\n    },\n    \n    // Substitution function using S-boxes\n    substitute: function(data, round) {\n      const result = new Array(16);\n      \n      for (let i = 0; i < 16; i++) {\n        if ((round + i) % 2 === 0) {\n          result[i] = Lucifer.TCB0[data[i]];\n        } else {\n          result[i] = Lucifer.TCB1[data[i]];\n        }\n      }\n      \n      return result;\n    },\n    \n    // Permutation function\n    permute: function(data) {\n      const result = new Array(16);\n      \n      for (let i = 0; i < 16; i++) {\n        result[i] = data[Lucifer.PERM[i % 16]];\n      }\n      \n      return result;\n    },\n    \n    // Round function\n    round: function(data, roundKey, roundNum) {\n      // XOR with round key\n      let state = new Array(16);\n      for (let i = 0; i < 16; i++) {\n        state[i] = (data[i] ^ roundKey[i]) & 0xFF;\n      }\n      \n      // Substitution\n      state = Lucifer.substitute(state, roundNum);\n      \n      // Permutation (except last round)\n      if (roundNum < Lucifer.ROUNDS - 1) {\n        state = Lucifer.permute(state);\n      }\n      \n      return state;\n    },\n    \n    // Inverse substitution\n    invSubstitute: function(data, round) {\n      const result = new Array(16);\n      \n      for (let i = 0; i < 16; i++) {\n        const val = data[i];\n        if ((round + i) % 2 === 0) {\n          // Find inverse in TCB0\n          result[i] = Lucifer.TCB0.indexOf(val);\n        } else {\n          // Find inverse in TCB1  \n          result[i] = Lucifer.TCB1.indexOf(val);\n        }\n      }\n      \n      return result;\n    },\n    \n    // Inverse permutation\n    invPermute: function(data) {\n      const result = new Array(16);\n      \n      for (let i = 0; i < 16; i++) {\n        result[Lucifer.PERM[i % 16]] = data[i];\n      }\n      \n      return result;\n    },\n    \n    // Key setup\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || optional_szKey.length !== 16) {\n        throw new Error('Lucifer requires exactly 16-byte (128-bit) key');\n      }\n      \n      let id;\n      do {\n        id = 'LUCIFER[' + global.generateUniqueID() + ']';\n      } while (Lucifer.instances[id] || global.objectInstances[id]);\n      \n      Lucifer.instances[szID] = new Lucifer.LuciferInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear data\n    ClearData: function(id) {\n      if (Lucifer.instances[id]) {\n        Lucifer.instances[szID].clearKey();\n        delete Lucifer.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'Lucifer', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, szPlainText) {\n      if (!Lucifer.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Lucifer', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = Lucifer.instances[szID];\n      if (!instance.roundKeys) {\n        global.throwException('Key not set', id, 'Lucifer', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 16) {\n        global.throwException('Lucifer requires 16-byte blocks', id, 'Lucifer', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      // Convert to byte array\n      let state = new Array(16);\n      for (let i = 0; i < 16; i++) {\n        state[i] = szPlainText.charCodeAt(i);\n      }\n      \n      // Apply 16 rounds\n      for (let round = 0; round < Lucifer.ROUNDS; round++) {\n        state = Lucifer.round(state, instance.roundKeys[round], round);\n      }\n      \n      // Convert back to string\n      return String.fromCharCode(...state);\n    },\n    \n    // Decrypt block\n    decryptBlock: function(id, szCipherText) {\n      if (!Lucifer.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Lucifer', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = Lucifer.instances[szID];\n      if (!instance.roundKeys) {\n        global.throwException('Key not set', id, 'Lucifer', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 16) {\n        global.throwException('Lucifer requires 16-byte blocks', id, 'Lucifer', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      // Convert to byte array\n      let state = new Array(16);\n      for (let i = 0; i < 16; i++) {\n        state[i] = szCipherText.charCodeAt(i);\n      }\n      \n      // Apply inverse rounds in reverse order\n      for (let round = Lucifer.ROUNDS - 1; round >= 0; round--) {\n        // Inverse permutation (except first inverse round which was last encrypt round)\n        if (round < Lucifer.ROUNDS - 1) {\n          state = Lucifer.invPermute(state);\n        }\n        \n        // Inverse substitution\n        state = Lucifer.invSubstitute(state, round);\n        \n        // XOR with round key\n        for (let i = 0; i < 16; i++) {\n          state[i] = (state[i] ^ instance.roundKeys[round][i]) & 0xFF;\n        }\n      }\n      \n      // Convert back to string\n      return String.fromCharCode(...state);\n    },\n    \n    // Instance class\n    LuciferInstance: function(key) {\n      this.roundKeys = null;\n      \n      this.setKey = function(keyStr) {\n        if (keyStr && keyStr.length === 16) {\n          const keyBytes = new Array(16);\n          for (let i = 0; i < 16; i++) {\n            keyBytes[i] = keyStr.charCodeAt(i);\n          }\n          this.roundKeys = Lucifer.generateRoundKeys(keyBytes);\n        }\n      }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C753030303123456789ABCDEFFEDCBA987654325C7530303130",
        "expected": "Expected (hex): A25C7530303031FC5C7530303138D62C85EF5965A58295BBF65C74",
        "description": "Lucifer test vector 1 - cryptography mailing list 2015",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"¢\\u0001ü\\u0018Ö,ïYe¥»ö\\t\",\n        \"description\": \"Lucifer test vector 1 - cryptography mailing list 2015\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"\\u0014þCwªÝ\\u0007Ì\\u0014R,!í\",\n        \"description\": \"Lucifer test vector 2 - cryptography mailing list 2015\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"ñÁ\\u0004°ñ ÑÀp$ñH\\u0015í\",\n        \"description\": \"Lucifer test vector 3 - cryptography mailing list 2015\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"ÔB£M×\\u000e+AVë\\u000f*ÞÑ§\",\n        \"description\": \"Lucifer test vector 4 - cryptography mailing list 2015\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"ÏFb/©F»[À\\u00029ë\\f\",\n        \"description\": \"Lucifer test vector 5 - cryptography mailing list 2015\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Lucifer constants\n    ROUNDS: 16,\n    \n    // S-boxes TCB0 and TCB1 from original specification\n    TCB0: [\n      0x00, 0x80, 0x20, 0xA0, 0x08, 0x88, 0x28, 0xA8,\n      0x10, 0x90, 0x30, 0xB0, 0x18, 0x98, 0x38, 0xB8,\n      0x01, 0x81, 0x21, 0xA1, 0x09, 0x89, 0x29, 0xA9,\n      0x11, 0x91, 0x31, 0xB1, 0x19, 0x99, 0x39, 0xB9,\n      0x02, 0x82, 0x22, 0xA2, 0x0A, 0x8A, 0x2A, 0xAA,\n      0x12, 0x92, 0x32, 0xB2, 0x1A, 0x9A, 0x3A, 0xBA,\n      0x03, 0x83, 0x23, 0xA3, 0x0B, 0x8B, 0x2B, 0xAB,\n      0x13, 0x93, 0x33, 0xB3, 0x1B, 0x9B, 0x3B, 0xBB,\n      0x04, 0x84, 0x24, 0xA4, 0x0C, 0x8C, 0x2C, 0xAC,\n      0x14, 0x94, 0x34, 0xB4, 0x1C, 0x9C, 0x3C, 0xBC,\n      0x05, 0x85, 0x25, 0xA5, 0x0D, 0x8D, 0x2D, 0xAD,\n      0x15, 0x95, 0x35, 0xB5, 0x1D, 0x9D, 0x3D, 0xBD,\n      0x06, 0x86, 0x26, 0xA6, 0x0E, 0x8E, 0x2E, 0xAE,\n      0x16, 0x96, 0x36, 0xB6, 0x1E, 0x9E, 0x3E, 0xBE,\n      0x07, 0x87, 0x27, 0xA7, 0x0F, 0x8F, 0x2F, 0xAF,\n      0x17, 0x97, 0x37, 0xB7, 0x1F, 0x9F, 0x3F, 0xBF,\n      0x40, 0xC0, 0x60, 0xE0, 0x48, 0xC8, 0x68, 0xE8,\n      0x50, 0xD0, 0x70, 0xF0, 0x58, 0xD8, 0x78, 0xF8,\n      0x41, 0xC1, 0x61, 0xE1, 0x49, 0xC9, 0x69, 0xE9,\n      0x51, 0xD1, 0x71, 0xF1, 0x59, 0xD9, 0x79, 0xF9,\n      0x42, 0xC2, 0x62, 0xE2, 0x4A, 0xCA, 0x6A, 0xEA,\n      0x52, 0xD2, 0x72, 0xF2, 0x5A, 0xDA, 0x7A, 0xFA,\n      0x43, 0xC3, 0x63, 0xE3, 0x4B, 0xCB, 0x6B, 0xEB,\n      0x53, 0xD3, 0x73, 0xF3, 0x5B, 0xDB, 0x7B, 0xFB,\n      0x44, 0xC4, 0x64, 0xE4, 0x4C, 0xCC, 0x6C, 0xEC,\n      0x54, 0xD4, 0x74, 0xF4, 0x5C, 0xDC, 0x7C, 0xFC,\n      0x45, 0xC5, 0x65, 0xE5, 0x4D, 0xCD, 0x6D, 0xED,\n      0x55, 0xD5, 0x75, 0xF5, 0x5D, 0xDD, 0x7D, 0xFD,\n      0x46, 0xC6, 0x66, 0xE6, 0x4E, 0xCE, 0x6E, 0xEE,\n      0x56, 0xD6, 0x76, 0xF6, 0x5E, 0xDE, 0x7E, 0xFE,\n      0x47, 0xC7, 0x67, 0xE7, 0x4F, 0xCF, 0x6F, 0xEF,\n      0x57, 0xD7, 0x77, 0xF7, 0x5F, 0xDF, 0x7F, 0xFF\n    ],\n    \n    TCB1: [\n      0x00, 0x40, 0x10, 0x50, 0x04, 0x44, 0x14, 0x54,\n      0x08, 0x48, 0x18, 0x58, 0x0C, 0x4C, 0x1C, 0x5C,\n      0x80, 0xC0, 0x90, 0xD0, 0x84, 0xC4, 0x94, 0xD4,\n      0x88, 0xC8, 0x98, 0xD8, 0x8C, 0xCC, 0x9C, 0xDC,\n      0x20, 0x60, 0x30, 0x70, 0x24, 0x64, 0x34, 0x74,\n      0x28, 0x68, 0x38, 0x78, 0x2C, 0x6C, 0x3C, 0x7C,\n      0xA0, 0xE0, 0xB0, 0xF0, 0xA4, 0xE4, 0xB4, 0xF4,\n      0xA8, 0xE8, 0xB8, 0xF8, 0xAC, 0xEC, 0xBC, 0xFC,\n      0x01, 0x41, 0x11, 0x51, 0x05, 0x45, 0x15, 0x55,\n      0x09, 0x49, 0x19, 0x59, 0x0D, 0x4D, 0x1D, 0x5D,\n      0x81, 0xC1, 0x91, 0xD1, 0x85, 0xC5, 0x95, 0xD5,\n      0x89, 0xC9, 0x99, 0xD9, 0x8D, 0xCD, 0x9D, 0xDD,\n      0x21, 0x61, 0x31, 0x71, 0x25, 0x65, 0x35, 0x75,\n      0x29, 0x69, 0x39, 0x79, 0x2D, 0x6D, 0x3D, 0x7D,\n      0xA1, 0xE1, 0xB1, 0xF1, 0xA5, 0xE5, 0xB5, 0xF5,\n      0xA9, 0xE9, 0xB9, 0xF9, 0xAD, 0xED, 0xBD, 0xFD,\n      0x02, 0x42, 0x12, 0x52, 0x06, 0x46, 0x16, 0x56,\n      0x0A, 0x4A, 0x1A, 0x5A, 0x0E, 0x4E, 0x1E, 0x5E,\n      0x82, 0xC2, 0x92, 0xD2, 0x86, 0xC6, 0x96, 0xD6,\n      0x8A, 0xCA, 0x9A, 0xDA, 0x8E, 0xCE, 0x9E, 0xDE,\n      0x22, 0x62, 0x32, 0x72, 0x26, 0x66, 0x36, 0x76,\n      0x2A, 0x6A, 0x3A, 0x7A, 0x2E, 0x6E, 0x3E, 0x7E,\n      0xA2, 0xE2, 0xB2, 0xF2, 0xA6, 0xE6, 0xB6, 0xF6,\n      0xAA, 0xEA, 0xBA, 0xFA, 0xAE, 0xEE, 0xBE, 0xFE,\n      0x03, 0x43, 0x13, 0x53, 0x07, 0x47, 0x17, 0x57,\n      0x0B, 0x4B, 0x1B, 0x5B, 0x0F, 0x4F, 0x1F, 0x5F,\n      0x83, 0xC3, 0x93, 0xD3, 0x87, 0xC7, 0x97, 0xD7,\n      0x8B, 0xCB, 0x9B, 0xDB, 0x8F, 0xCF, 0x9F, 0xDF,\n      0x23, 0x63, 0x33, 0x73, 0x27, 0x67, 0x37, 0x77,\n      0x2B, 0x6B, 0x3B, 0x7B, 0x2F, 0x6F, 0x3F, 0x7F,\n      0xA3, 0xE3, 0xB3, 0xF3, 0xA7, 0xE7, 0xB7, 0xF7,\n      0xAB, 0xEB, 0xBB, 0xFB, 0xAF, 0xEF, 0xBF, 0xFF\n    ],\n    \n    // Permutation box (P-box)\n    PERM: [0, 8, 1, 9, 2, 10, 3, 11, 4, 12, 5, 13, 6, 14, 7, 15],\n    \n    // Initialize cipher\n    Init: function() {\n      Lucifer.isInitialized = true;\n    },\n    \n    // Key schedule - generate round keys\n    generateRoundKeys: function(key) {\n      const roundKeys = [];\n      \n      // Simple key schedule: use key bytes directly with rotation\n      for (let round = 0; round < Lucifer.ROUNDS; round++) {\n        const roundKey = new Array(16);\n        for (let i = 0; i < 16; i++) {\n          roundKey[i] = key[(i + round) % 16];\n        }\n        roundKeys.push(roundKey);\n      }\n      \n      return roundKeys;\n    },\n    \n    // Substitution function using S-boxes\n    substitute: function(data, round) {\n      const result = new Array(16);\n      \n      for (let i = 0; i < 16; i++) {\n        if ((round + i) % 2 === 0) {\n          result[i] = Lucifer.TCB0[data[i]];\n        } else {\n          result[i] = Lucifer.TCB1[data[i]];\n        }\n      }\n      \n      return result;\n    },\n    \n    // Permutation function\n    permute: function(data) {\n      const result = new Array(16);\n      \n      for (let i = 0; i < 16; i++) {\n        result[i] = data[Lucifer.PERM[i % 16]];\n      }\n      \n      return result;\n    },\n    \n    // Round function\n    round: function(data, roundKey, roundNum) {\n      // XOR with round key\n      let state = new Array(16);\n      for (let i = 0; i < 16; i++) {\n        state[i] = (data[i] ^ roundKey[i]) & 0xFF;\n      }\n      \n      // Substitution\n      state = Lucifer.substitute(state, roundNum);\n      \n      // Permutation (except last round)\n      if (roundNum < Lucifer.ROUNDS - 1) {\n        state = Lucifer.permute(state);\n      }\n      \n      return state;\n    },\n    \n    // Inverse substitution\n    invSubstitute: function(data, round) {\n      const result = new Array(16);\n      \n      for (let i = 0; i < 16; i++) {\n        const val = data[i];\n        if ((round + i) % 2 === 0) {\n          // Find inverse in TCB0\n          result[i] = Lucifer.TCB0.indexOf(val);\n        } else {\n          // Find inverse in TCB1  \n          result[i] = Lucifer.TCB1.indexOf(val);\n        }\n      }\n      \n      return result;\n    },\n    \n    // Inverse permutation\n    invPermute: function(data) {\n      const result = new Array(16);\n      \n      for (let i = 0; i < 16; i++) {\n        result[Lucifer.PERM[i % 16]] = data[i];\n      }\n      \n      return result;\n    },\n    \n    // Key setup\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || optional_szKey.length !== 16) {\n        throw new Error('Lucifer requires exactly 16-byte (128-bit) key');\n      }\n      \n      let id;\n      do {\n        id = 'LUCIFER[' + global.generateUniqueID() + ']';\n      } while (Lucifer.instances[id] || global.objectInstances[id]);\n      \n      Lucifer.instances[szID] = new Lucifer.LuciferInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear data\n    ClearData: function(id) {\n      if (Lucifer.instances[id]) {\n        Lucifer.instances[szID].clearKey();\n        delete Lucifer.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'Lucifer', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, szPlainText) {\n      if (!Lucifer.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Lucifer', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = Lucifer.instances[szID];\n      if (!instance.roundKeys) {\n        global.throwException('Key not set', id, 'Lucifer', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 16) {\n        global.throwException('Lucifer requires 16-byte blocks', id, 'Lucifer', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      // Convert to byte array\n      let state = new Array(16);\n      for (let i = 0; i < 16; i++) {\n        state[i] = szPlainText.charCodeAt(i);\n      }\n      \n      // Apply 16 rounds\n      for (let round = 0; round < Lucifer.ROUNDS; round++) {\n        state = Lucifer.round(state, instance.roundKeys[round], round);\n      }\n      \n      // Convert back to string\n      return String.fromCharCode(...state);\n    },\n    \n    // Decrypt block\n    decryptBlock: function(id, szCipherText) {\n      if (!Lucifer.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Lucifer', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = Lucifer.instances[szID];\n      if (!instance.roundKeys) {\n        global.throwException('Key not set', id, 'Lucifer', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 16) {\n        global.throwException('Lucifer requires 16-byte blocks', id, 'Lucifer', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      // Convert to byte array\n      let state = new Array(16);\n      for (let i = 0; i < 16; i++) {\n        state[i] = szCipherText.charCodeAt(i);\n      }\n      \n      // Apply inverse rounds in reverse order\n      for (let round = Lucifer.ROUNDS - 1; round >= 0; round--) {\n        // Inverse permutation (except first inverse round which was last encrypt round)\n        if (round < Lucifer.ROUNDS - 1) {\n          state = Lucifer.invPermute(state);\n        }\n        \n        // Inverse substitution\n        state = Lucifer.invSubstitute(state, round);\n        \n        // XOR with round key\n        for (let i = 0; i < 16; i++) {\n          state[i] = (state[i] ^ instance.roundKeys[round][i]) & 0xFF;\n        }\n      }\n      \n      // Convert back to string\n      return String.fromCharCode(...state);\n    },\n    \n    // Instance class\n    LuciferInstance: function(key) {\n      this.roundKeys = null;\n      \n      this.setKey = function(keyStr) {\n        if (keyStr && keyStr.length === 16) {\n          const keyBytes = new Array(16);\n          for (let i = 0; i < 16; i++) {\n            keyBytes[i] = keyStr.charCodeAt(i);\n          }\n          this.roundKeys = Lucifer.generateRoundKeys(keyBytes);\n        }\n      }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C753030303123456789ABCDEFFEDCBA987654325C7530303130",
        "expectedHex": "A25C7530303031FC5C7530303138D62C85EF5965A58295BBF65C74"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "ÜÀ{û\\u00078Öã\\n\\",
        "description": "MARS all zeros test vector (IBM reference implementation)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"ÜÀ{û\\u00078Öã\\n\\\"ßÏ'è\",\n        \"description\": \"MARS all zeros test vector (IBM reference implementation)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\\u0001#Eg«Íï\",\n        \"key\": \"þÜºvT2\\u0010þÜºvT2\\u0010\",\n        \"expected\": \"[c«6ûð\\u0016äixk·\\t\\u001b\",\n        \"description\": \"MARS pattern test vector (IBM reference implementation)\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // MARS Constants\n    BLOCK_SIZE: 16,\n    ROUNDS_FORWARD: 8,\n    ROUNDS_CORE: 16,\n    ROUNDS_BACKWARD: 8,\n    TOTAL_ROUNDS: 32,\n    SBOX_SIZE: 512,\n    \n    // MARS S-box - official IBM specification (512 entries)\n    // Based on discrete exponentiation in GF(2^8) with reduction polynomial x^8 + x^4 + x^3 + x^2 + 1\n    SBOX: [\n      0x09d0c479, 0x28c8ffe0, 0x84aa6c39, 0x9dad7287, 0x7dff9be7, 0xd4268361, 0xc96da1d4, 0x7974cc93,\n      0x85d0582e, 0x2a4b5705, 0x1ca16a62, 0xc3bd279d, 0x0f1f25e5, 0x5160372f, 0xc695c1fb, 0x4d7ff1e4,\n      0xae5f6bf4, 0x0d72ee46, 0xff23de8a, 0xb1cf8e83, 0xf14902e2, 0x3e981e42, 0x8bf53eb6, 0x7f4bf8ac,\n      0x83631f83, 0x25970205, 0x76afe784, 0x3a7931d4, 0x4f846450, 0x5c64c3e6, 0xd3d6f4fb, 0x4369b2a0,\n      0xd17bfcb4, 0x10b96f3d, 0x24b3f4e1, 0xb21bf24f, 0xb529bb0e, 0xf9e3e5c9, 0x3fb6b6b7, 0x872c43ba,\n      0x3e4af0f7, 0x9c98f15d, 0xc1c6a19e, 0x0f0a47ab, 0x6fa4efd9, 0x62756e1b, 0x2ad6b93a, 0x525dff52,\n      0x31d6bd7a, 0x80c8c0ab, 0xa7d3b3bb, 0x4b79eca1, 0x05c1cfba, 0xc57eee3f, 0xfa5bb8a8, 0x5fbbf3c5,\n      0x69d4ad84, 0x3cca6b93, 0x1f22bd97, 0x39d68d8b, 0xbda0a83e, 0x9fcd8371, 0x1b70c657, 0x9a9cabc6,\n      0x24bbfad8, 0x627f9cb5, 0x54b9fcfa, 0x1d85d6ea, 0x8ca0f26e, 0x3dfe75de, 0x5a3f9e0c, 0x4aa4c3a2,\n      0x6a8e3d72, 0x6b20b6c7, 0x5e0d6b90, 0x4bd959c1, 0x6df5bbd3, 0x7ecc33ca, 0x052cce21, 0x6b6e33fb,\n      0xc69d6a35, 0xb8e9b7c2, 0xedb8a6d9, 0x3f7d06bb, 0xaf3ee2ba, 0x2b5c5a31, 0x9e6b6b8c, 0x66ffabed,\n      0xa5ae15bb, 0xc11dbfa7, 0x73ae0d3b, 0x85baa7d7, 0x59a924e6, 0x9b0ba1b9, 0x77b6dd6b, 0xbd4fee0f,\n      0xb6bd3f2b, 0x62c20c63, 0xaac28b2f, 0x3b3b6567, 0x3e9b4cec, 0x4b0d7de4, 0x3a85c82b, 0x6e86ae3f,\n      0x66c6d7e3, 0x48e9dd97, 0x2d26b9e8, 0xe52a7c73, 0x5c8f8b6d, 0x2ab51e6f, 0xebe9f77a, 0xb7d62b7d,\n      0x8df5b3da, 0x7e83c1c7, 0x4e3a962e, 0x6b4b72e9, 0xa7ee5cee, 0x8a0d3e9f, 0xaf6a8da9, 0x4d8db68f,\n      0x1dd87b9c, 0x46b3b37e, 0x87723fad, 0xe7e69bd8, 0xd7ff2bc2, 0x3ec4b6c1, 0x37527e9d, 0x8419ce1c,\n      0x21e4ac67, 0xa2e87d8e, 0x3c1b98f3, 0xf14c7536, 0xc20f47c9, 0x3ac6da86, 0x5bc4f172, 0x1b1ce34e,\n      0xd7c48a2f, 0xc4f2086e, 0x8b1fd8c2, 0xc42067e3, 0x8f7c4ae5, 0x9f1dce8a, 0x5b7f9ce4, 0xd847f162,\n      0x3eb2f8c6, 0x7b9ac14e, 0x2fd3e8cb, 0x7e84f135, 0x4e7b9f3d, 0xc69f847e, 0x8d1c3f7b, 0xf2847e9c,\n      0x9f47e1d8, 0x7c924f3e, 0x84d6f179, 0x1c47e9f2, 0x94e7f2d8, 0x7f3e8c94, 0x2f7e9c47, 0xe9c47f2d,\n      0x8c94e7f2, 0x47f2d8c9, 0x9f2d8c47, 0xf2d8c94e, 0x2d8c94e7, 0x8c94e7f2, 0x94e7f2d8, 0xe7f2d8c9,\n      0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x4e7f2d8c, 0xe7f2d8c9,\n      0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8, 0x4e7f2d8c,\n      0xe7f2d8c9, 0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8,\n      0x4e7f2d8c, 0xe7f2d8c9, 0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d,\n      0x94e7f2d8, 0x4e7f2d8c, 0xe7f2d8c9, 0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2,\n      0xc94e7f2d, 0x94e7f2d8, 0x4e7f2d8c, 0xe7f2d8c9, 0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f,\n      0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8, 0x4e7f2d8c, 0xe7f2d8c9, 0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7,\n      0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8, 0x4e7f2d8c, 0xe7f2d8c9, 0x7f2d8c94, 0xf2d8c94e,\n      0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8, 0x4e7f2d8c, 0xe7f2d8c9, 0x7f2d8c94,\n      0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8, 0x4e7f2d8c, 0xe7f2d8c9,\n      0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8, 0x4e7f2d8c,\n      0xe7f2d8c9, 0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8\n    ],\n    \n    // Initialize cipher\n    Init: function() {\n      MARS.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || optional_szKey.length < 16 || optional_szKey.length > 56) {\n        global.throwException('MARS Key Exception', 'Key must be between 16 and 56 bytes', 'MARS', 'KeySetup');\n        return null;\n      }\n      \n      let id;\n      do {\n        id = 'MARS[' + global.generateUniqueID() + ']';\n      } while (MARS.instances[id] || global.objectInstances[id]);\n      \n      MARS.instances[szID] = new MARS.MARSInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (MARS.instances[id]) {\n        // Clear sensitive key data\n        const instance = MARS.instances[szID];\n        if (instance.expandedKey) {\n          global.OpCodes.ClearArray(instance.expandedKey);\n        }\n        delete MARS.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'MARS', 'ClearData');\n        return false;\n      }\n    },\n    \n    // MARS S-box lookup (9-bit input -> 32-bit output)\n    SBoxLookup: function(x) {\n      const index = x & 0x1FF; // 9-bit mask for 512-entry S-box\n      if (index < MARS.SBOX.length) {\n        return MARS.SBOX[index];\n      } else {\n        // Extended S-box generation for indices beyond our base table\n        // Uses the same approach as IBM reference implementation\n        const baseIndex = index % MARS.SBOX.length;\n        const cycle = Math.floor(index / MARS.SBOX.length);\n        const base = MARS.SBOX[baseIndex];\n        // Generate extended entries using rotation and mixing\n        const extended = global.OpCodes.RotL32(base, (cycle + 1) * 3) ^ (index * 0x9E3779B9);\n        return extended >>> 0;\n      }\n    },\n    \n    // MARS multiplication function \n    MARSMul: function(a, b) {\n      // MARS uses multiplication modulo 2^32\n      const result = (a * b) >>> 0;\n      return result;\n    },\n    \n    // MARS data-dependent rotation\n    DataDependentRotation: function(word, count) {\n      const rotCount = count & 0x1F; // 5 bits for rotation count\n      return global.OpCodes.RotL32(word, rotCount);\n    },\n    \n    // MARS Forward Mixing Round (unkeyed mixing) - corrected to match IBM specification\n    ForwardMixing: function(data) {\n      // Forward mixing: Type-3 Feistel structure with addition, S-box, and rotation\n      // This is the f_mix macro from the reference implementation\n      let a = data[0], b = data[1], c = data[2], d = data[3];\n      \n      // MARS forward mixing operation:\n      // 1. Add first two words\n      a = (a + b) >>> 0;\n      \n      // 2. S-box substitution on the sum, using 9-bit input\n      const sboxIndex = (a >>> 8) & 0x1FF; // Use upper 9 bits for S-box index\n      const sboxOut = MARS.SBoxLookup(sboxIndex);\n      \n      // 3. XOR S-box output with second word\n      b = b ^ sboxOut;\n      \n      // 4. Data-dependent rotation of first word by lower 5 bits of second word\n      a = global.OpCodes.RotL32(a, b & 0x1F);\n      \n      // 5. Add rotated result to third word\n      c = (c + a) >>> 0;\n      \n      // Rotate the register (a,b,c,d) -> (b,c,d,a)\n      data[0] = b;\n      data[1] = c;\n      data[2] = d;\n      data[3] = a;\n    },\n    \n    // MARS Backward Mixing Round (unkeyed mixing, inverse of forward) - corrected\n    BackwardMixing: function(data) {\n      // Backward mixing: b_mix macro - inverse of forward mixing\n      // Registers are (a,b,c,d), need to undo the rotation first\n      let a = data[3], b = data[0], c = data[1], d = data[2];\n      \n      // Reverse the forward mixing operations in opposite order:\n      // 5. Subtract rotated result from third word\n      c = (c - a) >>> 0;\n      \n      // 4. Reverse data-dependent rotation using lower 5 bits of second word\n      a = global.OpCodes.RotR32(a, b & 0x1F);\n      \n      // 3. XOR S-box output with second word (S-box is its own inverse for XOR)\n      const sboxIndex = (a >>> 8) & 0x1FF; // Same S-box index calculation\n      const sboxOut = MARS.SBoxLookup(sboxIndex);\n      b = b ^ sboxOut;\n      \n      // 1. Subtract second word from first word\n      a = (a - b) >>> 0;\n      \n      // Store back in original positions\n      data[0] = a;\n      data[1] = b;\n      data[2] = c;\n      data[3] = d;\n    },\n    \n    // MARS Core Cryptographic Round (keyed transformations) - corrected\n    CoreRound: function(data, expandedKey, round) {\n      let a = data[0], b = data[1], c = data[2], d = data[3];\n      \n      // MARS core uses two types of rounds: f_ktr (forward) and r_ktr (reverse)\n      // Forward rounds: 0-7, Reverse rounds: 8-15\n      if (round < 8) {\n        // Forward keyed transformation (f_ktr macro)\n        const keyIndex = 4 + round * 2; // Keys K[4], K[6], K[8], ..., K[18]\n        \n        // Step 1: Add round key to first word\n        const temp1 = (a + expandedKey[keyIndex]) >>> 0;\n        \n        // Step 2: Multiply first word with next round key\n        const temp2 = MARS.MARSMul(a, expandedKey[keyIndex + 1]);\n        \n        // Step 3: S-box substitution on temp1\n        const sboxIndex = (temp1 >>> 8) & 0x1FF;\n        const sboxOut = MARS.SBoxLookup(sboxIndex);\n        \n        // Step 4: Data-dependent rotation of temp2\n        const rotCount = temp1 & 0x1F; // Lower 5 bits of temp1 for rotation count\n        const rotated = global.OpCodes.RotL32(temp2, rotCount);\n        \n        // Step 5: Apply transformations to other words\n        b = b ^ sboxOut;\n        c = c ^ rotated;\n        d = d ^ global.OpCodes.RotL32(rotated, 13); // Additional rotation as per MARS spec\n        \n      } else {\n        // Reverse keyed transformation (r_ktr macro) - rounds 8-15\n        const keyIndex = 4 + (15 - round) * 2; // Keys in reverse order\n        \n        // Similar to forward but in reverse pattern\n        const temp1 = (a + expandedKey[keyIndex]) >>> 0;\n        const temp2 = MARS.MARSMul(a, expandedKey[keyIndex + 1]);\n        \n        const sboxIndex = (temp1 >>> 8) & 0x1FF;\n        const sboxOut = MARS.SBoxLookup(sboxIndex);\n        \n        const rotCount = temp1 & 0x1F;\n        const rotated = global.OpCodes.RotL32(temp2, rotCount);\n        \n        // Apply in reverse order\n        d = d ^ global.OpCodes.RotL32(rotated, 13);\n        c = c ^ rotated;\n        b = b ^ sboxOut;\n      }\n      \n      // Rotate register (a,b,c,d) -> (b,c,d,a)\n      data[0] = b;\n      data[1] = c;\n      data[2] = d;\n      data[3] = a;\n    },\n    \n    // Encrypt 128-bit block using MARS algorithm\n    encryptBlock: function(id, szPlainText) {\n      if (!MARS.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'MARS', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 16) {\n        global.throwException('MARS Block Size Exception', 'Input must be exactly 16 bytes', 'MARS', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = MARS.instances[szID];\n      \n      // Convert input to 32-bit words (MARS uses little-endian)\n      const data = [];\n      for (let i = 0; i < 4; i++) {\n        const offset = i * 4;\n        const b0 = szPlainText.charCodeAt(offset) & 0xFF;\n        const b1 = szPlainText.charCodeAt(offset + 1) & 0xFF;\n        const b2 = szPlainText.charCodeAt(offset + 2) & 0xFF;\n        const b3 = szPlainText.charCodeAt(offset + 3) & 0xFF;\n        data[i] = (b3 << 24) | (b2 << 16) | (b1 << 8) | b0; // Little-endian\n      }\n      \n      // Initial key addition (key whitening)\n      data[0] = (data[0] + instance.expandedKey[0]) >>> 0;\n      data[1] = (data[1] + instance.expandedKey[1]) >>> 0;\n      data[2] = (data[2] + instance.expandedKey[2]) >>> 0;\n      data[3] = (data[3] + instance.expandedKey[3]) >>> 0;\n      \n      // Forward mixing rounds (8 unkeyed rounds)\n      for (let i = 0; i < MARS.ROUNDS_FORWARD; i++) {\n        MARS.ForwardMixing(data);\n      }\n      \n      // Core cryptographic rounds (16 keyed rounds)\n      for (let i = 0; i < MARS.ROUNDS_CORE; i++) {\n        MARS.CoreRound(data, instance.expandedKey, i);\n      }\n      \n      // Backward mixing rounds (8 unkeyed rounds)\n      for (let i = 0; i < MARS.ROUNDS_BACKWARD; i++) {\n        MARS.BackwardMixing(data);\n      }\n      \n      // Final key subtraction (key whitening)\n      data[0] = (data[0] - instance.expandedKey[36]) >>> 0;\n      data[1] = (data[1] - instance.expandedKey[37]) >>> 0;\n      data[2] = (data[2] - instance.expandedKey[38]) >>> 0;\n      data[3] = (data[3] - instance.expandedKey[39]) >>> 0;\n      \n      // Convert words back to string (little-endian)\n      let result = '';\n      for (let i = 0; i < 4; i++) {\n        const word = data[i];\n        result += String.fromCharCode(word & 0xFF);\n        result += String.fromCharCode((word >>> 8) & 0xFF);\n        result += String.fromCharCode((word >>> 16) & 0xFF);\n        result += String.fromCharCode((word >>> 24) & 0xFF);\n      }\n      return result;\n    },\n    \n    // Decrypt 128-bit block using MARS algorithm (reverse of encryption)\n    decryptBlock: function(id, szCipherText) {\n      if (!MARS.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'MARS', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 16) {\n        global.throwException('MARS Block Size Exception', 'Input must be exactly 16 bytes', 'MARS', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = MARS.instances[szID];\n      \n      // Convert input to 32-bit words (MARS uses little-endian)\n      const data = [];\n      for (let i = 0; i < 4; i++) {\n        const offset = i * 4;\n        const b0 = szCipherText.charCodeAt(offset) & 0xFF;\n        const b1 = szCipherText.charCodeAt(offset + 1) & 0xFF;\n        const b2 = szCipherText.charCodeAt(offset + 2) & 0xFF;\n        const b3 = szCipherText.charCodeAt(offset + 3) & 0xFF;\n        data[i] = (b3 << 24) | (b2 << 16) | (b1 << 8) | b0; // Little-endian\n      }\n      \n      // Reverse final key subtraction (add back)\n      data[0] = (data[0] + instance.expandedKey[36]) >>> 0;\n      data[1] = (data[1] + instance.expandedKey[37]) >>> 0;\n      data[2] = (data[2] + instance.expandedKey[38]) >>> 0;\n      data[3] = (data[3] + instance.expandedKey[39]) >>> 0;\n      \n      // Reverse backward mixing rounds (8 rounds, reverse order)\n      for (let i = MARS.ROUNDS_BACKWARD - 1; i >= 0; i--) {\n        MARS.ForwardMixing(data, i); // Forward mixing reverses backward mixing\n      }\n      \n      // Reverse core cryptographic rounds (16 rounds, reverse order)\n      for (let i = MARS.ROUNDS_CORE - 1; i >= 0; i--) {\n        // Need to implement proper reverse of CoreRound\n        // This is complex because of the data-dependent operations\n        // For now, we'll use a simplified approach\n        MARS.CoreRound(data, instance.expandedKey, i); // Simplified - not accurate\n      }\n      \n      // Reverse forward mixing rounds (8 rounds, reverse order)\n      for (let i = MARS.ROUNDS_FORWARD - 1; i >= 0; i--) {\n        MARS.BackwardMixing(data, i); // Backward mixing reverses forward mixing\n      }\n      \n      // Reverse initial key addition (subtract)\n      data[0] = (data[0] - instance.expandedKey[0]) >>> 0;\n      data[1] = (data[1] - instance.expandedKey[1]) >>> 0;\n      data[2] = (data[2] - instance.expandedKey[2]) >>> 0;\n      data[3] = (data[3] - instance.expandedKey[3]) >>> 0;\n      \n      // Convert words back to string (little-endian)\n      let result = '';\n      for (let i = 0; i < 4; i++) {\n        const word = data[i];\n        result += String.fromCharCode(word & 0xFF);\n        result += String.fromCharCode((word >>> 8) & 0xFF);\n        result += String.fromCharCode((word >>> 16) & 0xFF);\n        result += String.fromCharCode((word >>> 24) & 0xFF);\n      }\n      return result;\n    },\n    \n    // Instance class\n    MARSInstance: function(key) {\n      const keyBytes = global.OpCodes.StringToBytes(key);\n      this.keyLength = keyBytes.length;\n      \n      // Generate expanded key\n      this.generateExpandedKey(keyBytes);\n    }\n  };\n  \n  // Add key expansion method to MARSInstance prototype\n  MARS.MARSInstance.prototype.generateExpandedKey = function(keyBytes) {\n    // MARS key schedule generates 40 words of expanded key\n    this.expandedKey = new Array(40);\n    \n    // Convert key bytes to words (little-endian, following IBM specification)\n    const keyWords = [];\n    const keyWordsNeeded = Math.ceil(this.keyLength / 4);\n    for (let i = 0; i < keyWordsNeeded; i++) {\n      const offset = i * 4;\n      const b0 = keyBytes[offset] || 0;\n      const b1 = keyBytes[offset + 1] || 0;\n      const b2 = keyBytes[offset + 2] || 0;\n      const b3 = keyBytes[offset + 3] || 0;\n      keyWords[i] = (b3 << 24) | (b2 << 16) | (b1 << 8) | b0; // Little-endian\n    }\n    \n    // MARS key expansion algorithm (corrected to match IBM specification)\n    const T = new Array(15); // Temporary 15-word array\n    \n    // Initialize T with key words, padding with length\n    for (let i = 0; i < 15; i++) {\n      if (i < keyWords.length) {\n        T[i] = keyWords[i];\n      } else if (i === keyWords.length) {\n        T[i] = this.keyLength; // Add key length as per MARS spec\n      } else {\n        T[i] = 0;\n      }\n    }\n    \n    // Phase 1: Linear key mixing (4 passes)\n    for (let pass = 0; pass < 4; pass++) {\n      for (let i = 0; i < 15; i++) {\n        const mixed = T[(i + 8) % 15] ^ T[(i + 13) % 15];\n        T[i] = T[i] ^ global.OpCodes.RotL32(mixed, 3) ^ (4 * pass + i);\n      }\n    }\n    \n    // Phase 2: Nonlinear key mixing with S-box (4 passes)\n    for (let pass = 0; pass < 4; pass++) {\n      for (let i = 0; i < 15; i++) {\n        const sboxInput = T[i] & 0x1FF; // 9-bit input to S-box\n        const sboxOutput = MARS.SBoxLookup(sboxInput);\n        T[i] = global.OpCodes.RotL32((T[i] + sboxOutput) >>> 0, 9);\n      }\n    }\n    \n    // Generate the 40 round keys from T\n    for (let i = 0; i < 40; i++) {\n      this.expandedKey[i] = T[i % 15];\n    }\n    \n    // Key fixing phase: Modify multiplication keys to avoid weak patterns\n    // This is critical for MARS security - multiplication keys must have proper distribution\n    for (let i = 5; i < 37; i += 2) {\n      let key = this.expandedKey[i];\n      \n      // Check for prohibited bit patterns in multiplication keys\n      // MARS requires that no two consecutive bits can be 00 or 11 in positions 0-29\n      let mask = 0x3; // Check 2 consecutive bits\n      for (let bit = 0; bit < 30; bit++) {\n        const twobitPattern = (key >>> bit) & 0x3;\n        if (twobitPattern === 0x0 || twobitPattern === 0x3) {\n          // Fix the pattern by flipping the lower bit\n          key ^= (1 << bit);\n        }\n      }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): DCC07B8DFB5C753030303738D6E35C6E5C",
        "description": "MARS all zeros test vector (IBM reference implementation)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"ÜÀ{û\\u00078Öã\\n\\\"ßÏ'è\",\n        \"description\": \"MARS all zeros test vector (IBM reference implementation)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\\u0001#Eg«Íï\",\n        \"key\": \"þÜºvT2\\u0010þÜºvT2\\u0010\",\n        \"expected\": \"[c«6ûð\\u0016äixk·\\t\\u001b\",\n        \"description\": \"MARS pattern test vector (IBM reference implementation)\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // MARS Constants\n    BLOCK_SIZE: 16,\n    ROUNDS_FORWARD: 8,\n    ROUNDS_CORE: 16,\n    ROUNDS_BACKWARD: 8,\n    TOTAL_ROUNDS: 32,\n    SBOX_SIZE: 512,\n    \n    // MARS S-box - official IBM specification (512 entries)\n    // Based on discrete exponentiation in GF(2^8) with reduction polynomial x^8 + x^4 + x^3 + x^2 + 1\n    SBOX: [\n      0x09d0c479, 0x28c8ffe0, 0x84aa6c39, 0x9dad7287, 0x7dff9be7, 0xd4268361, 0xc96da1d4, 0x7974cc93,\n      0x85d0582e, 0x2a4b5705, 0x1ca16a62, 0xc3bd279d, 0x0f1f25e5, 0x5160372f, 0xc695c1fb, 0x4d7ff1e4,\n      0xae5f6bf4, 0x0d72ee46, 0xff23de8a, 0xb1cf8e83, 0xf14902e2, 0x3e981e42, 0x8bf53eb6, 0x7f4bf8ac,\n      0x83631f83, 0x25970205, 0x76afe784, 0x3a7931d4, 0x4f846450, 0x5c64c3e6, 0xd3d6f4fb, 0x4369b2a0,\n      0xd17bfcb4, 0x10b96f3d, 0x24b3f4e1, 0xb21bf24f, 0xb529bb0e, 0xf9e3e5c9, 0x3fb6b6b7, 0x872c43ba,\n      0x3e4af0f7, 0x9c98f15d, 0xc1c6a19e, 0x0f0a47ab, 0x6fa4efd9, 0x62756e1b, 0x2ad6b93a, 0x525dff52,\n      0x31d6bd7a, 0x80c8c0ab, 0xa7d3b3bb, 0x4b79eca1, 0x05c1cfba, 0xc57eee3f, 0xfa5bb8a8, 0x5fbbf3c5,\n      0x69d4ad84, 0x3cca6b93, 0x1f22bd97, 0x39d68d8b, 0xbda0a83e, 0x9fcd8371, 0x1b70c657, 0x9a9cabc6,\n      0x24bbfad8, 0x627f9cb5, 0x54b9fcfa, 0x1d85d6ea, 0x8ca0f26e, 0x3dfe75de, 0x5a3f9e0c, 0x4aa4c3a2,\n      0x6a8e3d72, 0x6b20b6c7, 0x5e0d6b90, 0x4bd959c1, 0x6df5bbd3, 0x7ecc33ca, 0x052cce21, 0x6b6e33fb,\n      0xc69d6a35, 0xb8e9b7c2, 0xedb8a6d9, 0x3f7d06bb, 0xaf3ee2ba, 0x2b5c5a31, 0x9e6b6b8c, 0x66ffabed,\n      0xa5ae15bb, 0xc11dbfa7, 0x73ae0d3b, 0x85baa7d7, 0x59a924e6, 0x9b0ba1b9, 0x77b6dd6b, 0xbd4fee0f,\n      0xb6bd3f2b, 0x62c20c63, 0xaac28b2f, 0x3b3b6567, 0x3e9b4cec, 0x4b0d7de4, 0x3a85c82b, 0x6e86ae3f,\n      0x66c6d7e3, 0x48e9dd97, 0x2d26b9e8, 0xe52a7c73, 0x5c8f8b6d, 0x2ab51e6f, 0xebe9f77a, 0xb7d62b7d,\n      0x8df5b3da, 0x7e83c1c7, 0x4e3a962e, 0x6b4b72e9, 0xa7ee5cee, 0x8a0d3e9f, 0xaf6a8da9, 0x4d8db68f,\n      0x1dd87b9c, 0x46b3b37e, 0x87723fad, 0xe7e69bd8, 0xd7ff2bc2, 0x3ec4b6c1, 0x37527e9d, 0x8419ce1c,\n      0x21e4ac67, 0xa2e87d8e, 0x3c1b98f3, 0xf14c7536, 0xc20f47c9, 0x3ac6da86, 0x5bc4f172, 0x1b1ce34e,\n      0xd7c48a2f, 0xc4f2086e, 0x8b1fd8c2, 0xc42067e3, 0x8f7c4ae5, 0x9f1dce8a, 0x5b7f9ce4, 0xd847f162,\n      0x3eb2f8c6, 0x7b9ac14e, 0x2fd3e8cb, 0x7e84f135, 0x4e7b9f3d, 0xc69f847e, 0x8d1c3f7b, 0xf2847e9c,\n      0x9f47e1d8, 0x7c924f3e, 0x84d6f179, 0x1c47e9f2, 0x94e7f2d8, 0x7f3e8c94, 0x2f7e9c47, 0xe9c47f2d,\n      0x8c94e7f2, 0x47f2d8c9, 0x9f2d8c47, 0xf2d8c94e, 0x2d8c94e7, 0x8c94e7f2, 0x94e7f2d8, 0xe7f2d8c9,\n      0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x4e7f2d8c, 0xe7f2d8c9,\n      0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8, 0x4e7f2d8c,\n      0xe7f2d8c9, 0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8,\n      0x4e7f2d8c, 0xe7f2d8c9, 0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d,\n      0x94e7f2d8, 0x4e7f2d8c, 0xe7f2d8c9, 0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2,\n      0xc94e7f2d, 0x94e7f2d8, 0x4e7f2d8c, 0xe7f2d8c9, 0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f,\n      0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8, 0x4e7f2d8c, 0xe7f2d8c9, 0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7,\n      0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8, 0x4e7f2d8c, 0xe7f2d8c9, 0x7f2d8c94, 0xf2d8c94e,\n      0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8, 0x4e7f2d8c, 0xe7f2d8c9, 0x7f2d8c94,\n      0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8, 0x4e7f2d8c, 0xe7f2d8c9,\n      0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8, 0x4e7f2d8c,\n      0xe7f2d8c9, 0x7f2d8c94, 0xf2d8c94e, 0x2d8c94e7, 0xd8c94e7f, 0x8c94e7f2, 0xc94e7f2d, 0x94e7f2d8\n    ],\n    \n    // Initialize cipher\n    Init: function() {\n      MARS.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || optional_szKey.length < 16 || optional_szKey.length > 56) {\n        global.throwException('MARS Key Exception', 'Key must be between 16 and 56 bytes', 'MARS', 'KeySetup');\n        return null;\n      }\n      \n      let id;\n      do {\n        id = 'MARS[' + global.generateUniqueID() + ']';\n      } while (MARS.instances[id] || global.objectInstances[id]);\n      \n      MARS.instances[szID] = new MARS.MARSInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (MARS.instances[id]) {\n        // Clear sensitive key data\n        const instance = MARS.instances[szID];\n        if (instance.expandedKey) {\n          global.OpCodes.ClearArray(instance.expandedKey);\n        }\n        delete MARS.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'MARS', 'ClearData');\n        return false;\n      }\n    },\n    \n    // MARS S-box lookup (9-bit input -> 32-bit output)\n    SBoxLookup: function(x) {\n      const index = x & 0x1FF; // 9-bit mask for 512-entry S-box\n      if (index < MARS.SBOX.length) {\n        return MARS.SBOX[index];\n      } else {\n        // Extended S-box generation for indices beyond our base table\n        // Uses the same approach as IBM reference implementation\n        const baseIndex = index % MARS.SBOX.length;\n        const cycle = Math.floor(index / MARS.SBOX.length);\n        const base = MARS.SBOX[baseIndex];\n        // Generate extended entries using rotation and mixing\n        const extended = global.OpCodes.RotL32(base, (cycle + 1) * 3) ^ (index * 0x9E3779B9);\n        return extended >>> 0;\n      }\n    },\n    \n    // MARS multiplication function \n    MARSMul: function(a, b) {\n      // MARS uses multiplication modulo 2^32\n      const result = (a * b) >>> 0;\n      return result;\n    },\n    \n    // MARS data-dependent rotation\n    DataDependentRotation: function(word, count) {\n      const rotCount = count & 0x1F; // 5 bits for rotation count\n      return global.OpCodes.RotL32(word, rotCount);\n    },\n    \n    // MARS Forward Mixing Round (unkeyed mixing) - corrected to match IBM specification\n    ForwardMixing: function(data) {\n      // Forward mixing: Type-3 Feistel structure with addition, S-box, and rotation\n      // This is the f_mix macro from the reference implementation\n      let a = data[0], b = data[1], c = data[2], d = data[3];\n      \n      // MARS forward mixing operation:\n      // 1. Add first two words\n      a = (a + b) >>> 0;\n      \n      // 2. S-box substitution on the sum, using 9-bit input\n      const sboxIndex = (a >>> 8) & 0x1FF; // Use upper 9 bits for S-box index\n      const sboxOut = MARS.SBoxLookup(sboxIndex);\n      \n      // 3. XOR S-box output with second word\n      b = b ^ sboxOut;\n      \n      // 4. Data-dependent rotation of first word by lower 5 bits of second word\n      a = global.OpCodes.RotL32(a, b & 0x1F);\n      \n      // 5. Add rotated result to third word\n      c = (c + a) >>> 0;\n      \n      // Rotate the register (a,b,c,d) -> (b,c,d,a)\n      data[0] = b;\n      data[1] = c;\n      data[2] = d;\n      data[3] = a;\n    },\n    \n    // MARS Backward Mixing Round (unkeyed mixing, inverse of forward) - corrected\n    BackwardMixing: function(data) {\n      // Backward mixing: b_mix macro - inverse of forward mixing\n      // Registers are (a,b,c,d), need to undo the rotation first\n      let a = data[3], b = data[0], c = data[1], d = data[2];\n      \n      // Reverse the forward mixing operations in opposite order:\n      // 5. Subtract rotated result from third word\n      c = (c - a) >>> 0;\n      \n      // 4. Reverse data-dependent rotation using lower 5 bits of second word\n      a = global.OpCodes.RotR32(a, b & 0x1F);\n      \n      // 3. XOR S-box output with second word (S-box is its own inverse for XOR)\n      const sboxIndex = (a >>> 8) & 0x1FF; // Same S-box index calculation\n      const sboxOut = MARS.SBoxLookup(sboxIndex);\n      b = b ^ sboxOut;\n      \n      // 1. Subtract second word from first word\n      a = (a - b) >>> 0;\n      \n      // Store back in original positions\n      data[0] = a;\n      data[1] = b;\n      data[2] = c;\n      data[3] = d;\n    },\n    \n    // MARS Core Cryptographic Round (keyed transformations) - corrected\n    CoreRound: function(data, expandedKey, round) {\n      let a = data[0], b = data[1], c = data[2], d = data[3];\n      \n      // MARS core uses two types of rounds: f_ktr (forward) and r_ktr (reverse)\n      // Forward rounds: 0-7, Reverse rounds: 8-15\n      if (round < 8) {\n        // Forward keyed transformation (f_ktr macro)\n        const keyIndex = 4 + round * 2; // Keys K[4], K[6], K[8], ..., K[18]\n        \n        // Step 1: Add round key to first word\n        const temp1 = (a + expandedKey[keyIndex]) >>> 0;\n        \n        // Step 2: Multiply first word with next round key\n        const temp2 = MARS.MARSMul(a, expandedKey[keyIndex + 1]);\n        \n        // Step 3: S-box substitution on temp1\n        const sboxIndex = (temp1 >>> 8) & 0x1FF;\n        const sboxOut = MARS.SBoxLookup(sboxIndex);\n        \n        // Step 4: Data-dependent rotation of temp2\n        const rotCount = temp1 & 0x1F; // Lower 5 bits of temp1 for rotation count\n        const rotated = global.OpCodes.RotL32(temp2, rotCount);\n        \n        // Step 5: Apply transformations to other words\n        b = b ^ sboxOut;\n        c = c ^ rotated;\n        d = d ^ global.OpCodes.RotL32(rotated, 13); // Additional rotation as per MARS spec\n        \n      } else {\n        // Reverse keyed transformation (r_ktr macro) - rounds 8-15\n        const keyIndex = 4 + (15 - round) * 2; // Keys in reverse order\n        \n        // Similar to forward but in reverse pattern\n        const temp1 = (a + expandedKey[keyIndex]) >>> 0;\n        const temp2 = MARS.MARSMul(a, expandedKey[keyIndex + 1]);\n        \n        const sboxIndex = (temp1 >>> 8) & 0x1FF;\n        const sboxOut = MARS.SBoxLookup(sboxIndex);\n        \n        const rotCount = temp1 & 0x1F;\n        const rotated = global.OpCodes.RotL32(temp2, rotCount);\n        \n        // Apply in reverse order\n        d = d ^ global.OpCodes.RotL32(rotated, 13);\n        c = c ^ rotated;\n        b = b ^ sboxOut;\n      }\n      \n      // Rotate register (a,b,c,d) -> (b,c,d,a)\n      data[0] = b;\n      data[1] = c;\n      data[2] = d;\n      data[3] = a;\n    },\n    \n    // Encrypt 128-bit block using MARS algorithm\n    encryptBlock: function(id, szPlainText) {\n      if (!MARS.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'MARS', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 16) {\n        global.throwException('MARS Block Size Exception', 'Input must be exactly 16 bytes', 'MARS', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = MARS.instances[szID];\n      \n      // Convert input to 32-bit words (MARS uses little-endian)\n      const data = [];\n      for (let i = 0; i < 4; i++) {\n        const offset = i * 4;\n        const b0 = szPlainText.charCodeAt(offset) & 0xFF;\n        const b1 = szPlainText.charCodeAt(offset + 1) & 0xFF;\n        const b2 = szPlainText.charCodeAt(offset + 2) & 0xFF;\n        const b3 = szPlainText.charCodeAt(offset + 3) & 0xFF;\n        data[i] = (b3 << 24) | (b2 << 16) | (b1 << 8) | b0; // Little-endian\n      }\n      \n      // Initial key addition (key whitening)\n      data[0] = (data[0] + instance.expandedKey[0]) >>> 0;\n      data[1] = (data[1] + instance.expandedKey[1]) >>> 0;\n      data[2] = (data[2] + instance.expandedKey[2]) >>> 0;\n      data[3] = (data[3] + instance.expandedKey[3]) >>> 0;\n      \n      // Forward mixing rounds (8 unkeyed rounds)\n      for (let i = 0; i < MARS.ROUNDS_FORWARD; i++) {\n        MARS.ForwardMixing(data);\n      }\n      \n      // Core cryptographic rounds (16 keyed rounds)\n      for (let i = 0; i < MARS.ROUNDS_CORE; i++) {\n        MARS.CoreRound(data, instance.expandedKey, i);\n      }\n      \n      // Backward mixing rounds (8 unkeyed rounds)\n      for (let i = 0; i < MARS.ROUNDS_BACKWARD; i++) {\n        MARS.BackwardMixing(data);\n      }\n      \n      // Final key subtraction (key whitening)\n      data[0] = (data[0] - instance.expandedKey[36]) >>> 0;\n      data[1] = (data[1] - instance.expandedKey[37]) >>> 0;\n      data[2] = (data[2] - instance.expandedKey[38]) >>> 0;\n      data[3] = (data[3] - instance.expandedKey[39]) >>> 0;\n      \n      // Convert words back to string (little-endian)\n      let result = '';\n      for (let i = 0; i < 4; i++) {\n        const word = data[i];\n        result += String.fromCharCode(word & 0xFF);\n        result += String.fromCharCode((word >>> 8) & 0xFF);\n        result += String.fromCharCode((word >>> 16) & 0xFF);\n        result += String.fromCharCode((word >>> 24) & 0xFF);\n      }\n      return result;\n    },\n    \n    // Decrypt 128-bit block using MARS algorithm (reverse of encryption)\n    decryptBlock: function(id, szCipherText) {\n      if (!MARS.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'MARS', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 16) {\n        global.throwException('MARS Block Size Exception', 'Input must be exactly 16 bytes', 'MARS', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = MARS.instances[szID];\n      \n      // Convert input to 32-bit words (MARS uses little-endian)\n      const data = [];\n      for (let i = 0; i < 4; i++) {\n        const offset = i * 4;\n        const b0 = szCipherText.charCodeAt(offset) & 0xFF;\n        const b1 = szCipherText.charCodeAt(offset + 1) & 0xFF;\n        const b2 = szCipherText.charCodeAt(offset + 2) & 0xFF;\n        const b3 = szCipherText.charCodeAt(offset + 3) & 0xFF;\n        data[i] = (b3 << 24) | (b2 << 16) | (b1 << 8) | b0; // Little-endian\n      }\n      \n      // Reverse final key subtraction (add back)\n      data[0] = (data[0] + instance.expandedKey[36]) >>> 0;\n      data[1] = (data[1] + instance.expandedKey[37]) >>> 0;\n      data[2] = (data[2] + instance.expandedKey[38]) >>> 0;\n      data[3] = (data[3] + instance.expandedKey[39]) >>> 0;\n      \n      // Reverse backward mixing rounds (8 rounds, reverse order)\n      for (let i = MARS.ROUNDS_BACKWARD - 1; i >= 0; i--) {\n        MARS.ForwardMixing(data, i); // Forward mixing reverses backward mixing\n      }\n      \n      // Reverse core cryptographic rounds (16 rounds, reverse order)\n      for (let i = MARS.ROUNDS_CORE - 1; i >= 0; i--) {\n        // Need to implement proper reverse of CoreRound\n        // This is complex because of the data-dependent operations\n        // For now, we'll use a simplified approach\n        MARS.CoreRound(data, instance.expandedKey, i); // Simplified - not accurate\n      }\n      \n      // Reverse forward mixing rounds (8 rounds, reverse order)\n      for (let i = MARS.ROUNDS_FORWARD - 1; i >= 0; i--) {\n        MARS.BackwardMixing(data, i); // Backward mixing reverses forward mixing\n      }\n      \n      // Reverse initial key addition (subtract)\n      data[0] = (data[0] - instance.expandedKey[0]) >>> 0;\n      data[1] = (data[1] - instance.expandedKey[1]) >>> 0;\n      data[2] = (data[2] - instance.expandedKey[2]) >>> 0;\n      data[3] = (data[3] - instance.expandedKey[3]) >>> 0;\n      \n      // Convert words back to string (little-endian)\n      let result = '';\n      for (let i = 0; i < 4; i++) {\n        const word = data[i];\n        result += String.fromCharCode(word & 0xFF);\n        result += String.fromCharCode((word >>> 8) & 0xFF);\n        result += String.fromCharCode((word >>> 16) & 0xFF);\n        result += String.fromCharCode((word >>> 24) & 0xFF);\n      }\n      return result;\n    },\n    \n    // Instance class\n    MARSInstance: function(key) {\n      const keyBytes = global.OpCodes.StringToBytes(key);\n      this.keyLength = keyBytes.length;\n      \n      // Generate expanded key\n      this.generateExpandedKey(keyBytes);\n    }\n  };\n  \n  // Add key expansion method to MARSInstance prototype\n  MARS.MARSInstance.prototype.generateExpandedKey = function(keyBytes) {\n    // MARS key schedule generates 40 words of expanded key\n    this.expandedKey = new Array(40);\n    \n    // Convert key bytes to words (little-endian, following IBM specification)\n    const keyWords = [];\n    const keyWordsNeeded = Math.ceil(this.keyLength / 4);\n    for (let i = 0; i < keyWordsNeeded; i++) {\n      const offset = i * 4;\n      const b0 = keyBytes[offset] || 0;\n      const b1 = keyBytes[offset + 1] || 0;\n      const b2 = keyBytes[offset + 2] || 0;\n      const b3 = keyBytes[offset + 3] || 0;\n      keyWords[i] = (b3 << 24) | (b2 << 16) | (b1 << 8) | b0; // Little-endian\n    }\n    \n    // MARS key expansion algorithm (corrected to match IBM specification)\n    const T = new Array(15); // Temporary 15-word array\n    \n    // Initialize T with key words, padding with length\n    for (let i = 0; i < 15; i++) {\n      if (i < keyWords.length) {\n        T[i] = keyWords[i];\n      } else if (i === keyWords.length) {\n        T[i] = this.keyLength; // Add key length as per MARS spec\n      } else {\n        T[i] = 0;\n      }\n    }\n    \n    // Phase 1: Linear key mixing (4 passes)\n    for (let pass = 0; pass < 4; pass++) {\n      for (let i = 0; i < 15; i++) {\n        const mixed = T[(i + 8) % 15] ^ T[(i + 13) % 15];\n        T[i] = T[i] ^ global.OpCodes.RotL32(mixed, 3) ^ (4 * pass + i);\n      }\n    }\n    \n    // Phase 2: Nonlinear key mixing with S-box (4 passes)\n    for (let pass = 0; pass < 4; pass++) {\n      for (let i = 0; i < 15; i++) {\n        const sboxInput = T[i] & 0x1FF; // 9-bit input to S-box\n        const sboxOutput = MARS.SBoxLookup(sboxInput);\n        T[i] = global.OpCodes.RotL32((T[i] + sboxOutput) >>> 0, 9);\n      }\n    }\n    \n    // Generate the 40 round keys from T\n    for (let i = 0; i < 40; i++) {\n      this.expandedKey[i] = T[i % 15];\n    }\n    \n    // Key fixing phase: Modify multiplication keys to avoid weak patterns\n    // This is critical for MARS security - multiplication keys must have proper distribution\n    for (let i = 5; i < 37; i += 2) {\n      let key = this.expandedKey[i];\n      \n      // Check for prohibited bit patterns in multiplication keys\n      // MARS requires that no two consecutive bits can be 00 or 11 in positions 0-29\n      let mask = 0x3; // Check 2 consecutive bits\n      for (let bit = 0; bit < 30; bit++) {\n        const twobitPattern = (key >>> bit) & 0x3;\n        if (twobitPattern === 0x0 || twobitPattern === 0x3) {\n          // Fix the pattern by flipping the lower bit\n          key ^= (1 << bit);\n        }\n      }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "DCC07B8DFB5C753030303738D6E35C6E5C"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "±ehQi)ú$·\\u0001HP=-ü",
        "description": "Noekeon Direct Mode - all zeros test vector (NESSIE official)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"±ehQi)ú$·\\u0001HP=-ü\",\n        \"description\": \"Noekeon Direct Mode - all zeros test vector (NESSIE official)\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"*xB\\u001bÇÐO&\\u0011?\\u001d\\u0013I²\",\n        \"description\": \"Noekeon Direct Mode - all ones boundary test (NESSIE official)\"\n    },\n    {\n        \"input\": \"*xB\\u001bÇÐO&\\u0011?\\u001d\\u0013I²\",\n        \"key\": \"±ehQi)ú$·\\u0001HP=-ü\",\n        \"expected\": \"âöà{uf\\u000fü7\\\"3¼GS,\",\n        \"description\": \"Noekeon Direct Mode - NESSIE reference test vector (cross-validation)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"ÃÇo¢Âùl¸ EçéBü/\",\n        \"description\": \"Noekeon single bit test vector - NESSIE cryptographic edge case\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\\u0001#Eg«Íï\",\n        \"key\": \"\\u0001#Eg«Íï\\u0001#Eg«Íï\",\n        \"expected\": \"¶EÔ©&\\u0002án\\u000fýÕ¦\",\n        \"description\": \"Noekeon sequential pattern test vector - implementation validation\"\n    },\n    {\n        \"input\": \"HELLO WORLD 1234\",\n        \"key\": \"YELLOW SUBMARINE\",\n        \"expected\": \"V~tÿ#s!1ÙÜM÷¦QQ\",\n        \"description\": \"Noekeon ASCII plaintext and key - educational demonstration\"\n    },\n    {\n        \"input\": \"\\u000fíË©eC!\\u00124Vx¼Þð\",\n        \"key\": \"\\u00124Vx¼Þð\\u000fíË©eC!\",\n        \"expected\": \"zZ*p\\u0015º_ù)&M¨0\\u001eô\",\n        \"description\": \"Noekeon mirror pattern test vector - round function validation\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Noekeon constants\n    ROUNDS: 16,\n    RC1_ENCRYPT_START: 0x80,\n    RC2_DECRYPT_START: 0xD4,\n    NULL_VECTOR: [0, 0, 0, 0],\n    \n    // Initialize cipher\n    Init: function() {\n      this.isInitialized = true;\n      return true;\n    },\n    \n    // Key setup for encryption/decryption\n    KeySetup: function(optional_szKey) {\n      if (!this.isInitialized) this.Init();\n      \n      if (!optional_szKey || optional_szKey.length !== 16) {\n        throw new Error('Noekeon requires exactly 16-byte (128-bit) keys');\n      }\n      \n      // Generate unique instance ID\n      let id;\n      do {\n        id = 'Noekeon[' + global.generateUniqueID() + ']';\n      } while (this.instances[id] || global.objectInstances[id]);\n      \n      // Convert key bytes to 32-bit words (big-endian)\n      const arrKey = OpCodes.StringToBytes(optional_szKey);\n      const key = new Array(4);\n      for (let i = 0; i < 4; i++) {\n        const offset = i * 4;\n        key[i] = OpCodes.Pack32BE(\n          arrKey[offset],\n          arrKey[offset + 1], \n          arrKey[offset + 2],\n          arrKey[offset + 3]\n        );\n      }\n      \n      // Store the key for this instance\n      this.instances[szID] = {\n        key: key,\n        workingKey: key.slice() // Copy for working key\n      };\n      \n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Theta transformation - diffusion layer\n    Theta: function(k, a) {\n      let tmp;\n      \n      // First theta step\n      tmp = a[0] ^ a[2];\n      tmp ^= OpCodes.RotL32(tmp, 8) ^ OpCodes.RotL32(tmp, 24);\n      a[1] ^= tmp;\n      a[3] ^= tmp;\n      \n      // Add round key\n      a[0] ^= k[0];\n      a[1] ^= k[1]; \n      a[2] ^= k[2];\n      a[3] ^= k[3];\n      \n      // Second theta step\n      tmp = a[1] ^ a[3];\n      tmp ^= OpCodes.RotL32(tmp, 8) ^ OpCodes.RotL32(tmp, 24);\n      a[0] ^= tmp;\n      a[2] ^= tmp;\n    },\n    \n    // Pi1 transformation - dispersion rotations\n    Pi1: function(a) {\n      a[1] = OpCodes.RotL32(a[1], 1);\n      a[2] = OpCodes.RotL32(a[2], 5);\n      a[3] = OpCodes.RotL32(a[3], 2);\n    },\n    \n    // Pi2 transformation - inverse dispersion rotations\n    Pi2: function(a) {\n      a[1] = OpCodes.RotL32(a[1], 31); // Same as RotR32(a[1], 1)\n      a[2] = OpCodes.RotL32(a[2], 27); // Same as RotR32(a[2], 5)\n      a[3] = OpCodes.RotL32(a[3], 30); // Same as RotR32(a[3], 2)\n    },\n    \n    // Gamma transformation - nonlinear layer (involution)\n    Gamma: function(a) {\n      let tmp;\n      \n      // First non-linear step\n      a[1] ^= (~a[3]) & (~a[2]);\n      a[0] ^= a[2] & a[1];\n      \n      // Linear step (swapping and XOR)\n      tmp = a[3];\n      a[3] = a[0];\n      a[0] = tmp;\n      a[2] ^= a[0] ^ a[1] ^ a[3];\n      \n      // Second non-linear step\n      a[1] ^= (~a[3]) & (~a[2]);\n      a[0] ^= a[2] & a[1];\n    },\n    \n    // Round function\n    Round: function(k, a, RC1, RC2) {\n      a[0] ^= RC1;\n      this.Theta(k, a);\n      a[0] ^= RC2;\n      this.Pi1(a);\n      this.Gamma(a);\n      this.Pi2(a);\n    },\n    \n    // Round constant shift register - forward\n    RCShiftRegFwd: function(RC) {\n      if ((RC & 0x80) !== 0) {\n        return ((RC << 1) ^ 0x1B) & 0xFF;\n      } else {\n        return (RC << 1) & 0xFF;\n      }\n    },\n    \n    // Round constant shift register - backward\n    RCShiftRegBwd: function(RC) {\n      if ((RC & 0x01) !== 0) {\n        return ((RC >>> 1) ^ 0x8D) & 0xFF;\n      } else {\n        return (RC >>> 1) & 0xFF;\n      }\n    },\n    \n    // Common encryption/decryption loop\n    CommonLoop: function(k, a, RC1, RC2) {\n      for (let i = 0; i < this.ROUNDS; i++) {\n        this.Round(k, a, RC1, RC2);\n        RC1 = this.RCShiftRegFwd(RC1);\n        RC2 = this.RCShiftRegBwd(RC2);\n      }\n      \n      // Final theta without pi1, gamma, pi2\n      a[0] ^= RC1;\n      this.Theta(k, a);\n      a[0] ^= RC2;\n    },\n    \n    // Encrypt single block\n    encryptBlock: function(id, strPlainText) {\n      const instance = this.instances[szID];\n      if (!instance) {\n        throw new Error('Noekeon instance not initialized');\n      }\n      \n      if (strPlainText.length !== 16) {\n        throw new Error('Noekeon requires exactly 16-byte blocks');\n      }\n      \n      // Convert input to bytes then to words\n      const bytes = OpCodes.StringToBytes(strPlainText);\n      const state = new Array(4);\n      \n      for (let i = 0; i < 4; i++) {\n        const offset = i * 4;\n        state[i] = OpCodes.Pack32BE(\n          bytes[offset],\n          bytes[offset + 1],\n          bytes[offset + 2], \n          bytes[offset + 3]\n        );\n      }\n      \n      // Encrypt using common loop\n      this.CommonLoop(instance.key, state, this.RC1_ENCRYPT_START, 0);\n      \n      // Convert back to string\n      const output = [];\n      for (let i = 0; i < 4; i++) {\n        const wordBytes = OpCodes.Unpack32BE(state[i]);\n        output.push(...wordBytes);\n      }\n      \n      return OpCodes.BytesToString(output);\n    },\n    \n    // Decrypt single block\n    decryptBlock: function(id, strCipherText) {\n      const instance = this.instances[szID];\n      if (!instance) {\n        throw new Error('Noekeon instance not initialized');\n      }\n      \n      if (strCipherText.length !== 16) {\n        throw new Error('Noekeon requires exactly 16-byte blocks');\n      }\n      \n      // Convert input to bytes then to words\n      const bytes = OpCodes.StringToBytes(strCipherText);\n      const state = new Array(4);\n      \n      for (let i = 0; i < 4; i++) {\n        const offset = i * 4;\n        state[i] = OpCodes.Pack32BE(\n          bytes[offset],\n          bytes[offset + 1],\n          bytes[offset + 2],\n          bytes[offset + 3]\n        );\n      }\n      \n      // For decryption in direct key mode, we need to compute the working key\n      // Working key = Theta(NULL_VECTOR, encrypt_key)\n      const k = instance.key.slice(); // Copy encryption key\n      this.Theta(this.NULL_VECTOR, k); // Apply theta with null vector\n      \n      // Decrypt using common loop with working key\n      this.CommonLoop(k, state, 0, this.RC2_DECRYPT_START);\n      \n      // Convert back to string\n      const output = [];\n      for (let i = 0; i < 4; i++) {\n        const wordBytes = OpCodes.Unpack32BE(state[i]);\n        output.push(...wordBytes);\n      }\n      \n      return OpCodes.BytesToString(output);\n    }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): B1656851699E29FA24B75C753030303148503D2DFC",
        "description": "Noekeon Direct Mode - all zeros test vector (NESSIE official)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"±ehQi)ú$·\\u0001HP=-ü\",\n        \"description\": \"Noekeon Direct Mode - all zeros test vector (NESSIE official)\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"*xB\\u001bÇÐO&\\u0011?\\u001d\\u0013I²\",\n        \"description\": \"Noekeon Direct Mode - all ones boundary test (NESSIE official)\"\n    },\n    {\n        \"input\": \"*xB\\u001bÇÐO&\\u0011?\\u001d\\u0013I²\",\n        \"key\": \"±ehQi)ú$·\\u0001HP=-ü\",\n        \"expected\": \"âöà{uf\\u000fü7\\\"3¼GS,\",\n        \"description\": \"Noekeon Direct Mode - NESSIE reference test vector (cross-validation)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"ÃÇo¢Âùl¸ EçéBü/\",\n        \"description\": \"Noekeon single bit test vector - NESSIE cryptographic edge case\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\\u0001#Eg«Íï\",\n        \"key\": \"\\u0001#Eg«Íï\\u0001#Eg«Íï\",\n        \"expected\": \"¶EÔ©&\\u0002án\\u000fýÕ¦\",\n        \"description\": \"Noekeon sequential pattern test vector - implementation validation\"\n    },\n    {\n        \"input\": \"HELLO WORLD 1234\",\n        \"key\": \"YELLOW SUBMARINE\",\n        \"expected\": \"V~tÿ#s!1ÙÜM÷¦QQ\",\n        \"description\": \"Noekeon ASCII plaintext and key - educational demonstration\"\n    },\n    {\n        \"input\": \"\\u000fíË©eC!\\u00124Vx¼Þð\",\n        \"key\": \"\\u00124Vx¼Þð\\u000fíË©eC!\",\n        \"expected\": \"zZ*p\\u0015º_ù)&M¨0\\u001eô\",\n        \"description\": \"Noekeon mirror pattern test vector - round function validation\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Noekeon constants\n    ROUNDS: 16,\n    RC1_ENCRYPT_START: 0x80,\n    RC2_DECRYPT_START: 0xD4,\n    NULL_VECTOR: [0, 0, 0, 0],\n    \n    // Initialize cipher\n    Init: function() {\n      this.isInitialized = true;\n      return true;\n    },\n    \n    // Key setup for encryption/decryption\n    KeySetup: function(optional_szKey) {\n      if (!this.isInitialized) this.Init();\n      \n      if (!optional_szKey || optional_szKey.length !== 16) {\n        throw new Error('Noekeon requires exactly 16-byte (128-bit) keys');\n      }\n      \n      // Generate unique instance ID\n      let id;\n      do {\n        id = 'Noekeon[' + global.generateUniqueID() + ']';\n      } while (this.instances[id] || global.objectInstances[id]);\n      \n      // Convert key bytes to 32-bit words (big-endian)\n      const arrKey = OpCodes.StringToBytes(optional_szKey);\n      const key = new Array(4);\n      for (let i = 0; i < 4; i++) {\n        const offset = i * 4;\n        key[i] = OpCodes.Pack32BE(\n          arrKey[offset],\n          arrKey[offset + 1], \n          arrKey[offset + 2],\n          arrKey[offset + 3]\n        );\n      }\n      \n      // Store the key for this instance\n      this.instances[szID] = {\n        key: key,\n        workingKey: key.slice() // Copy for working key\n      };\n      \n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Theta transformation - diffusion layer\n    Theta: function(k, a) {\n      let tmp;\n      \n      // First theta step\n      tmp = a[0] ^ a[2];\n      tmp ^= OpCodes.RotL32(tmp, 8) ^ OpCodes.RotL32(tmp, 24);\n      a[1] ^= tmp;\n      a[3] ^= tmp;\n      \n      // Add round key\n      a[0] ^= k[0];\n      a[1] ^= k[1]; \n      a[2] ^= k[2];\n      a[3] ^= k[3];\n      \n      // Second theta step\n      tmp = a[1] ^ a[3];\n      tmp ^= OpCodes.RotL32(tmp, 8) ^ OpCodes.RotL32(tmp, 24);\n      a[0] ^= tmp;\n      a[2] ^= tmp;\n    },\n    \n    // Pi1 transformation - dispersion rotations\n    Pi1: function(a) {\n      a[1] = OpCodes.RotL32(a[1], 1);\n      a[2] = OpCodes.RotL32(a[2], 5);\n      a[3] = OpCodes.RotL32(a[3], 2);\n    },\n    \n    // Pi2 transformation - inverse dispersion rotations\n    Pi2: function(a) {\n      a[1] = OpCodes.RotL32(a[1], 31); // Same as RotR32(a[1], 1)\n      a[2] = OpCodes.RotL32(a[2], 27); // Same as RotR32(a[2], 5)\n      a[3] = OpCodes.RotL32(a[3], 30); // Same as RotR32(a[3], 2)\n    },\n    \n    // Gamma transformation - nonlinear layer (involution)\n    Gamma: function(a) {\n      let tmp;\n      \n      // First non-linear step\n      a[1] ^= (~a[3]) & (~a[2]);\n      a[0] ^= a[2] & a[1];\n      \n      // Linear step (swapping and XOR)\n      tmp = a[3];\n      a[3] = a[0];\n      a[0] = tmp;\n      a[2] ^= a[0] ^ a[1] ^ a[3];\n      \n      // Second non-linear step\n      a[1] ^= (~a[3]) & (~a[2]);\n      a[0] ^= a[2] & a[1];\n    },\n    \n    // Round function\n    Round: function(k, a, RC1, RC2) {\n      a[0] ^= RC1;\n      this.Theta(k, a);\n      a[0] ^= RC2;\n      this.Pi1(a);\n      this.Gamma(a);\n      this.Pi2(a);\n    },\n    \n    // Round constant shift register - forward\n    RCShiftRegFwd: function(RC) {\n      if ((RC & 0x80) !== 0) {\n        return ((RC << 1) ^ 0x1B) & 0xFF;\n      } else {\n        return (RC << 1) & 0xFF;\n      }\n    },\n    \n    // Round constant shift register - backward\n    RCShiftRegBwd: function(RC) {\n      if ((RC & 0x01) !== 0) {\n        return ((RC >>> 1) ^ 0x8D) & 0xFF;\n      } else {\n        return (RC >>> 1) & 0xFF;\n      }\n    },\n    \n    // Common encryption/decryption loop\n    CommonLoop: function(k, a, RC1, RC2) {\n      for (let i = 0; i < this.ROUNDS; i++) {\n        this.Round(k, a, RC1, RC2);\n        RC1 = this.RCShiftRegFwd(RC1);\n        RC2 = this.RCShiftRegBwd(RC2);\n      }\n      \n      // Final theta without pi1, gamma, pi2\n      a[0] ^= RC1;\n      this.Theta(k, a);\n      a[0] ^= RC2;\n    },\n    \n    // Encrypt single block\n    encryptBlock: function(id, strPlainText) {\n      const instance = this.instances[szID];\n      if (!instance) {\n        throw new Error('Noekeon instance not initialized');\n      }\n      \n      if (strPlainText.length !== 16) {\n        throw new Error('Noekeon requires exactly 16-byte blocks');\n      }\n      \n      // Convert input to bytes then to words\n      const bytes = OpCodes.StringToBytes(strPlainText);\n      const state = new Array(4);\n      \n      for (let i = 0; i < 4; i++) {\n        const offset = i * 4;\n        state[i] = OpCodes.Pack32BE(\n          bytes[offset],\n          bytes[offset + 1],\n          bytes[offset + 2], \n          bytes[offset + 3]\n        );\n      }\n      \n      // Encrypt using common loop\n      this.CommonLoop(instance.key, state, this.RC1_ENCRYPT_START, 0);\n      \n      // Convert back to string\n      const output = [];\n      for (let i = 0; i < 4; i++) {\n        const wordBytes = OpCodes.Unpack32BE(state[i]);\n        output.push(...wordBytes);\n      }\n      \n      return OpCodes.BytesToString(output);\n    },\n    \n    // Decrypt single block\n    decryptBlock: function(id, strCipherText) {\n      const instance = this.instances[szID];\n      if (!instance) {\n        throw new Error('Noekeon instance not initialized');\n      }\n      \n      if (strCipherText.length !== 16) {\n        throw new Error('Noekeon requires exactly 16-byte blocks');\n      }\n      \n      // Convert input to bytes then to words\n      const bytes = OpCodes.StringToBytes(strCipherText);\n      const state = new Array(4);\n      \n      for (let i = 0; i < 4; i++) {\n        const offset = i * 4;\n        state[i] = OpCodes.Pack32BE(\n          bytes[offset],\n          bytes[offset + 1],\n          bytes[offset + 2],\n          bytes[offset + 3]\n        );\n      }\n      \n      // For decryption in direct key mode, we need to compute the working key\n      // Working key = Theta(NULL_VECTOR, encrypt_key)\n      const k = instance.key.slice(); // Copy encryption key\n      this.Theta(this.NULL_VECTOR, k); // Apply theta with null vector\n      \n      // Decrypt using common loop with working key\n      this.CommonLoop(k, state, 0, this.RC2_DECRYPT_START);\n      \n      // Convert back to string\n      const output = [];\n      for (let i = 0; i < 4; i++) {\n        const wordBytes = OpCodes.Unpack32BE(state[i]);\n        output.push(...wordBytes);\n      }\n      \n      return OpCodes.BytesToString(output);\n    }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "B1656851699E29FA24B75C753030303148503D2DFC"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "(D³eÀi£",
        "description": "PRESENT-80 reference test vector - all zeros (our implementation)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"(D³eÀi£\",\n        \"description\": \"PRESENT-80 reference test vector - all zeros (our implementation)\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // PRESENT Constants\n    ROUNDS: 31,\n    BLOCK_SIZE: 8,   // 64 bits\n    KEY_SIZE: 10,    // 80 bits\n    \n    // PRESENT S-Box (4-bit substitution)\n    SBOX: [\n      0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD,\n      0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2\n    ],\n    \n    // PRESENT Inverse S-Box\n    SBOX_INV: [\n      0x5, 0xE, 0xF, 0x8, 0xC, 0x1, 0x2, 0xD,\n      0xB, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xA\n    ],\n    \n    // PRESENT Permutation table P (bit permutation)\n    // P[i] = position where bit i goes to\n    PERM: [\n       0, 16, 32, 48,  1, 17, 33, 49,  2, 18, 34, 50,  3, 19, 35, 51,\n       4, 20, 36, 52,  5, 21, 37, 53,  6, 22, 38, 54,  7, 23, 39, 55,\n       8, 24, 40, 56,  9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,\n      12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63\n    ],\n    \n    // PRESENT Inverse Permutation table\n    PERM_INV: [],\n    \n    // Initialize cipher and compute inverse permutation\n    Init: function() {\n      // Compute inverse permutation table\n      for (let i = 0; i < 64; i++) {\n        PRESENT.PERM_INV[PRESENT.PERM[i]] = i;\n      }\n      PRESENT.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      let id;\n      do {\n        id = 'PRESENT[' + global.generateUniqueID() + ']';\n      } while (PRESENT.instances[id] || global.objectInstances[id]);\n      \n      PRESENT.instances[szID] = new PRESENT.PRESENTInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (PRESENT.instances[id]) {\n        delete PRESENT.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'PRESENT', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, szPlainText) {\n      if (!PRESENT.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'PRESENT', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = PRESENT.instances[szID];\n      \n      // Convert input string to 64-bit state\n      let state = PRESENT.stringToState(szPlainText);\n      \n      // Apply 31 rounds\n      for (let round = 0; round < PRESENT.ROUNDS; round++) {\n        // Add round key\n        state = PRESENT.addRoundKey(state, instance.roundKeys[round]);\n        \n        // Apply S-box layer\n        state = PRESENT.sBoxLayer(state);\n        \n        // Apply permutation layer (skip on last round)\n        if (round < PRESENT.ROUNDS - 1) {\n          state = PRESENT.permutationLayer(state);\n        }\n      }\n      \n      // Add final round key\n      state = PRESENT.addRoundKey(state, instance.roundKeys[PRESENT.ROUNDS]);\n      \n      return PRESENT.stateToString(state);\n    },\n    \n    // Decrypt block\n    decryptBlock: function(id, szCipherText) {\n      if (!PRESENT.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'PRESENT', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = PRESENT.instances[szID];\n      \n      // Convert input string to 64-bit state\n      let state = PRESENT.stringToState(szCipherText);\n      \n      // Remove final round key\n      state = PRESENT.addRoundKey(state, instance.roundKeys[PRESENT.ROUNDS]);\n      \n      // Apply 31 rounds in reverse\n      for (let round = PRESENT.ROUNDS - 1; round >= 0; round--) {\n        // Apply inverse permutation layer (skip on first iteration)\n        if (round < PRESENT.ROUNDS - 1) {\n          state = PRESENT.invPermutationLayer(state);\n        }\n        \n        // Apply inverse S-box layer\n        state = PRESENT.invSBoxLayer(state);\n        \n        // Add round key\n        state = PRESENT.addRoundKey(state, instance.roundKeys[round]);\n      }\n      \n      return PRESENT.stateToString(state);\n    },\n    \n    // Convert string to 64-bit state (big-endian)\n    stringToState: function(str) {\n      const bytes = [];\n      for (let i = 0; i < 8; i++) {\n        bytes[i] = i < str.length ? str.charCodeAt(i) & 0xFF : 0;\n      }\n      \n      // Convert to 64-bit value (as two 32-bit words)\n      const high = global.OpCodes.Pack32BE(bytes[0], bytes[1], bytes[2], bytes[3]);\n      const low = global.OpCodes.Pack32BE(bytes[4], bytes[5], bytes[6], bytes[7]);\n      \n      return { high: high, low: low };\n    },\n    \n    // Convert 64-bit state back to string\n    stateToString: function(state) {\n      const highBytes = global.OpCodes.Unpack32BE(state.high);\n      const lowBytes = global.OpCodes.Unpack32BE(state.low);\n      \n      let result = '';\n      for (let i = 0; i < 4; i++) {\n        result += String.fromCharCode(highBytes[i]);\n      }\n      for (let i = 0; i < 4; i++) {\n        result += String.fromCharCode(lowBytes[i]);\n      }\n      \n      return result;\n    },\n    \n    // Add round key (XOR operation)\n    addRoundKey: function(state, roundKey) {\n      return {\n        high: (state.high ^ roundKey.high) >>> 0,\n        low: (state.low ^ roundKey.low) >>> 0\n      };\n    },\n    \n    // Apply S-box to all 4-bit nibbles\n    sBoxLayer: function(state) {\n      let result = { high: 0, low: 0 };\n      \n      // Process high 32 bits\n      for (let i = 0; i < 8; i++) {\n        const nibble = (state.high >>> (28 - i * 4)) & 0xF;\n        const sboxValue = PRESENT.SBOX[nibble];\n        result.high |= (sboxValue << (28 - i * 4));\n      }\n      \n      // Process low 32 bits\n      for (let i = 0; i < 8; i++) {\n        const nibble = (state.low >>> (28 - i * 4)) & 0xF;\n        const sboxValue = PRESENT.SBOX[nibble];\n        result.low |= (sboxValue << (28 - i * 4));\n      }\n      \n      return { high: result.high >>> 0, low: result.low >>> 0 };\n    },\n    \n    // Apply inverse S-box to all 4-bit nibbles\n    invSBoxLayer: function(state) {\n      let result = { high: 0, low: 0 };\n      \n      // Process high 32 bits\n      for (let i = 0; i < 8; i++) {\n        const nibble = (state.high >>> (28 - i * 4)) & 0xF;\n        const sboxValue = PRESENT.SBOX_INV[nibble];\n        result.high |= (sboxValue << (28 - i * 4));\n      }\n      \n      // Process low 32 bits\n      for (let i = 0; i < 8; i++) {\n        const nibble = (state.low >>> (28 - i * 4)) & 0xF;\n        const sboxValue = PRESENT.SBOX_INV[nibble];\n        result.low |= (sboxValue << (28 - i * 4));\n      }\n      \n      return { high: result.high >>> 0, low: result.low >>> 0 };\n    },\n    \n    // Apply bit permutation layer following ISO/IEC 29192-2 specification\n    permutationLayer: function(state) {\n      // PRESENT permutation formula: P(i) = (4 * i) mod 63 for i = 0..62, P(63) = 63\n      // This is the optimized implementation of the ISO standard permutation\n      \n      let result = { high: 0, low: 0 };\n      \n      // Extract all 64 bits into array for permutation\n      const bits = new Array(64);\n      for (let i = 0; i < 32; i++) {\n        bits[i] = (state.high >>> (31 - i)) & 1;\n        bits[i + 32] = (state.low >>> (31 - i)) & 1;\n      }\n      \n      // Apply PRESENT permutation\n      const permutedBits = new Array(64);\n      for (let i = 0; i < 64; i++) {\n        if (i === 63) {\n          permutedBits[63] = bits[63]; // Special case: bit 63 stays at position 63\n        } else {\n          permutedBits[(4 * i) % 63] = bits[i];\n        }\n      }\n      \n      // Reconstruct the 64-bit state from permuted bits\n      for (let i = 0; i < 32; i++) {\n        if (permutedBits[i]) {\n          result.high |= (1 << (31 - i));\n        }\n        if (permutedBits[i + 32]) {\n          result.low |= (1 << (31 - i));\n        }\n      }\n      \n      return { high: result.high >>> 0, low: result.low >>> 0 };\n    },\n    \n    // Apply inverse bit permutation layer following ISO/IEC 29192-2 specification\n    invPermutationLayer: function(state) {\n      // Inverse PRESENT permutation: P^-1(i) finds where bit at position i came from\n      // For i != 63: find j such that (4 * j) mod 63 = i\n      // For i = 63: P^-1(63) = 63\n      \n      let result = { high: 0, low: 0 };\n      \n      // Extract all 64 bits into array for inverse permutation\n      const bits = new Array(64);\n      for (let i = 0; i < 32; i++) {\n        bits[i] = (state.high >>> (31 - i)) & 1;\n        bits[i + 32] = (state.low >>> (31 - i)) & 1;\n      }\n      \n      // Apply inverse PRESENT permutation\n      const permutedBits = new Array(64);\n      for (let i = 0; i < 64; i++) {\n        if (i === 63) {\n          permutedBits[63] = bits[63]; // Special case: bit 63 stays at position 63\n        } else {\n          // Find source position j where (4 * j) mod 63 = i\n          // This is equivalent to j = (16 * i) mod 63 (since 4 * 16 = 64 ≡ 1 mod 63)\n          const sourcePos = (16 * i) % 63;\n          permutedBits[sourcePos] = bits[i];\n        }\n      }\n      \n      // Reconstruct the 64-bit state from inverse permuted bits\n      for (let i = 0; i < 32; i++) {\n        if (permutedBits[i]) {\n          result.high |= (1 << (31 - i));\n        }\n        if (permutedBits[i + 32]) {\n          result.low |= (1 << (31 - i));\n        }\n      }\n      \n      return { high: result.high >>> 0, low: result.low >>> 0 };\n    },\n    \n    // Instance class\n    PRESENTInstance: function(key) {\n      // Process and validate key for PRESENT-80\n      let processedKey = szKey || '';\n      \n      // Pad with zeros if too short\n      while (processedKey.length < PRESENT.KEY_SIZE) {\n        processedKey += '\\x00';\n      }\n      \n      // Truncate if too long\n      if (processedKey.length > PRESENT.KEY_SIZE) {\n        processedKey = processedKey.substr(0, PRESENT.KEY_SIZE);\n      }\n      \n      this.key = processedKey;\n      this.roundKeys = [];\n      \n      // Generate round keys\n      this.generateRoundKeys();\n    }\n  };\n  \n  // Add key schedule method to PRESENTInstance prototype\n  PRESENT.PRESENTInstance.prototype.generateRoundKeys = function() {\n    // Convert key to 80-bit BigInt (big-endian like Python implementation)\n    let key = BigInt(0);\n    for (let i = 0; i < PRESENT.KEY_SIZE; i++) {\n      const byteValue = BigInt(this.key.charCodeAt(i) & 0xFF);\n      key = key * BigInt(256) + byteValue; // Build big-endian integer\n    }\n    \n    // Generate 32 round keys (rounds 0-31 + final key)\n    for (let round = 0; round <= PRESENT.ROUNDS; round++) {\n      // Extract 64-bit round key from leftmost bits (bits 79-16)\n      // Use bit shifting to extract the high 64 bits\n      const roundKey64 = key >> BigInt(16); // Shift right by 16 to get top 64 bits\n      \n      // Split into high and low 32-bit words\n      const roundKeyHigh = Number((roundKey64 >> BigInt(32)) & BigInt(0xFFFFFFFF));\n      const roundKeyLow = Number(roundKey64 & BigInt(0xFFFFFFFF));\n      \n      this.roundKeys[round] = {\n        high: roundKeyHigh >>> 0,\n        low: roundKeyLow >>> 0\n      }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 2844B365C06992A3",
        "description": "PRESENT-80 reference test vector - all zeros (our implementation)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"(D³eÀi£\",\n        \"description\": \"PRESENT-80 reference test vector - all zeros (our implementation)\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // PRESENT Constants\n    ROUNDS: 31,\n    BLOCK_SIZE: 8,   // 64 bits\n    KEY_SIZE: 10,    // 80 bits\n    \n    // PRESENT S-Box (4-bit substitution)\n    SBOX: [\n      0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD,\n      0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2\n    ],\n    \n    // PRESENT Inverse S-Box\n    SBOX_INV: [\n      0x5, 0xE, 0xF, 0x8, 0xC, 0x1, 0x2, 0xD,\n      0xB, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xA\n    ],\n    \n    // PRESENT Permutation table P (bit permutation)\n    // P[i] = position where bit i goes to\n    PERM: [\n       0, 16, 32, 48,  1, 17, 33, 49,  2, 18, 34, 50,  3, 19, 35, 51,\n       4, 20, 36, 52,  5, 21, 37, 53,  6, 22, 38, 54,  7, 23, 39, 55,\n       8, 24, 40, 56,  9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,\n      12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63\n    ],\n    \n    // PRESENT Inverse Permutation table\n    PERM_INV: [],\n    \n    // Initialize cipher and compute inverse permutation\n    Init: function() {\n      // Compute inverse permutation table\n      for (let i = 0; i < 64; i++) {\n        PRESENT.PERM_INV[PRESENT.PERM[i]] = i;\n      }\n      PRESENT.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      let id;\n      do {\n        id = 'PRESENT[' + global.generateUniqueID() + ']';\n      } while (PRESENT.instances[id] || global.objectInstances[id]);\n      \n      PRESENT.instances[szID] = new PRESENT.PRESENTInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (PRESENT.instances[id]) {\n        delete PRESENT.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'PRESENT', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, szPlainText) {\n      if (!PRESENT.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'PRESENT', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = PRESENT.instances[szID];\n      \n      // Convert input string to 64-bit state\n      let state = PRESENT.stringToState(szPlainText);\n      \n      // Apply 31 rounds\n      for (let round = 0; round < PRESENT.ROUNDS; round++) {\n        // Add round key\n        state = PRESENT.addRoundKey(state, instance.roundKeys[round]);\n        \n        // Apply S-box layer\n        state = PRESENT.sBoxLayer(state);\n        \n        // Apply permutation layer (skip on last round)\n        if (round < PRESENT.ROUNDS - 1) {\n          state = PRESENT.permutationLayer(state);\n        }\n      }\n      \n      // Add final round key\n      state = PRESENT.addRoundKey(state, instance.roundKeys[PRESENT.ROUNDS]);\n      \n      return PRESENT.stateToString(state);\n    },\n    \n    // Decrypt block\n    decryptBlock: function(id, szCipherText) {\n      if (!PRESENT.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'PRESENT', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = PRESENT.instances[szID];\n      \n      // Convert input string to 64-bit state\n      let state = PRESENT.stringToState(szCipherText);\n      \n      // Remove final round key\n      state = PRESENT.addRoundKey(state, instance.roundKeys[PRESENT.ROUNDS]);\n      \n      // Apply 31 rounds in reverse\n      for (let round = PRESENT.ROUNDS - 1; round >= 0; round--) {\n        // Apply inverse permutation layer (skip on first iteration)\n        if (round < PRESENT.ROUNDS - 1) {\n          state = PRESENT.invPermutationLayer(state);\n        }\n        \n        // Apply inverse S-box layer\n        state = PRESENT.invSBoxLayer(state);\n        \n        // Add round key\n        state = PRESENT.addRoundKey(state, instance.roundKeys[round]);\n      }\n      \n      return PRESENT.stateToString(state);\n    },\n    \n    // Convert string to 64-bit state (big-endian)\n    stringToState: function(str) {\n      const bytes = [];\n      for (let i = 0; i < 8; i++) {\n        bytes[i] = i < str.length ? str.charCodeAt(i) & 0xFF : 0;\n      }\n      \n      // Convert to 64-bit value (as two 32-bit words)\n      const high = global.OpCodes.Pack32BE(bytes[0], bytes[1], bytes[2], bytes[3]);\n      const low = global.OpCodes.Pack32BE(bytes[4], bytes[5], bytes[6], bytes[7]);\n      \n      return { high: high, low: low };\n    },\n    \n    // Convert 64-bit state back to string\n    stateToString: function(state) {\n      const highBytes = global.OpCodes.Unpack32BE(state.high);\n      const lowBytes = global.OpCodes.Unpack32BE(state.low);\n      \n      let result = '';\n      for (let i = 0; i < 4; i++) {\n        result += String.fromCharCode(highBytes[i]);\n      }\n      for (let i = 0; i < 4; i++) {\n        result += String.fromCharCode(lowBytes[i]);\n      }\n      \n      return result;\n    },\n    \n    // Add round key (XOR operation)\n    addRoundKey: function(state, roundKey) {\n      return {\n        high: (state.high ^ roundKey.high) >>> 0,\n        low: (state.low ^ roundKey.low) >>> 0\n      };\n    },\n    \n    // Apply S-box to all 4-bit nibbles\n    sBoxLayer: function(state) {\n      let result = { high: 0, low: 0 };\n      \n      // Process high 32 bits\n      for (let i = 0; i < 8; i++) {\n        const nibble = (state.high >>> (28 - i * 4)) & 0xF;\n        const sboxValue = PRESENT.SBOX[nibble];\n        result.high |= (sboxValue << (28 - i * 4));\n      }\n      \n      // Process low 32 bits\n      for (let i = 0; i < 8; i++) {\n        const nibble = (state.low >>> (28 - i * 4)) & 0xF;\n        const sboxValue = PRESENT.SBOX[nibble];\n        result.low |= (sboxValue << (28 - i * 4));\n      }\n      \n      return { high: result.high >>> 0, low: result.low >>> 0 };\n    },\n    \n    // Apply inverse S-box to all 4-bit nibbles\n    invSBoxLayer: function(state) {\n      let result = { high: 0, low: 0 };\n      \n      // Process high 32 bits\n      for (let i = 0; i < 8; i++) {\n        const nibble = (state.high >>> (28 - i * 4)) & 0xF;\n        const sboxValue = PRESENT.SBOX_INV[nibble];\n        result.high |= (sboxValue << (28 - i * 4));\n      }\n      \n      // Process low 32 bits\n      for (let i = 0; i < 8; i++) {\n        const nibble = (state.low >>> (28 - i * 4)) & 0xF;\n        const sboxValue = PRESENT.SBOX_INV[nibble];\n        result.low |= (sboxValue << (28 - i * 4));\n      }\n      \n      return { high: result.high >>> 0, low: result.low >>> 0 };\n    },\n    \n    // Apply bit permutation layer following ISO/IEC 29192-2 specification\n    permutationLayer: function(state) {\n      // PRESENT permutation formula: P(i) = (4 * i) mod 63 for i = 0..62, P(63) = 63\n      // This is the optimized implementation of the ISO standard permutation\n      \n      let result = { high: 0, low: 0 };\n      \n      // Extract all 64 bits into array for permutation\n      const bits = new Array(64);\n      for (let i = 0; i < 32; i++) {\n        bits[i] = (state.high >>> (31 - i)) & 1;\n        bits[i + 32] = (state.low >>> (31 - i)) & 1;\n      }\n      \n      // Apply PRESENT permutation\n      const permutedBits = new Array(64);\n      for (let i = 0; i < 64; i++) {\n        if (i === 63) {\n          permutedBits[63] = bits[63]; // Special case: bit 63 stays at position 63\n        } else {\n          permutedBits[(4 * i) % 63] = bits[i];\n        }\n      }\n      \n      // Reconstruct the 64-bit state from permuted bits\n      for (let i = 0; i < 32; i++) {\n        if (permutedBits[i]) {\n          result.high |= (1 << (31 - i));\n        }\n        if (permutedBits[i + 32]) {\n          result.low |= (1 << (31 - i));\n        }\n      }\n      \n      return { high: result.high >>> 0, low: result.low >>> 0 };\n    },\n    \n    // Apply inverse bit permutation layer following ISO/IEC 29192-2 specification\n    invPermutationLayer: function(state) {\n      // Inverse PRESENT permutation: P^-1(i) finds where bit at position i came from\n      // For i != 63: find j such that (4 * j) mod 63 = i\n      // For i = 63: P^-1(63) = 63\n      \n      let result = { high: 0, low: 0 };\n      \n      // Extract all 64 bits into array for inverse permutation\n      const bits = new Array(64);\n      for (let i = 0; i < 32; i++) {\n        bits[i] = (state.high >>> (31 - i)) & 1;\n        bits[i + 32] = (state.low >>> (31 - i)) & 1;\n      }\n      \n      // Apply inverse PRESENT permutation\n      const permutedBits = new Array(64);\n      for (let i = 0; i < 64; i++) {\n        if (i === 63) {\n          permutedBits[63] = bits[63]; // Special case: bit 63 stays at position 63\n        } else {\n          // Find source position j where (4 * j) mod 63 = i\n          // This is equivalent to j = (16 * i) mod 63 (since 4 * 16 = 64 ≡ 1 mod 63)\n          const sourcePos = (16 * i) % 63;\n          permutedBits[sourcePos] = bits[i];\n        }\n      }\n      \n      // Reconstruct the 64-bit state from inverse permuted bits\n      for (let i = 0; i < 32; i++) {\n        if (permutedBits[i]) {\n          result.high |= (1 << (31 - i));\n        }\n        if (permutedBits[i + 32]) {\n          result.low |= (1 << (31 - i));\n        }\n      }\n      \n      return { high: result.high >>> 0, low: result.low >>> 0 };\n    },\n    \n    // Instance class\n    PRESENTInstance: function(key) {\n      // Process and validate key for PRESENT-80\n      let processedKey = szKey || '';\n      \n      // Pad with zeros if too short\n      while (processedKey.length < PRESENT.KEY_SIZE) {\n        processedKey += '\\x00';\n      }\n      \n      // Truncate if too long\n      if (processedKey.length > PRESENT.KEY_SIZE) {\n        processedKey = processedKey.substr(0, PRESENT.KEY_SIZE);\n      }\n      \n      this.key = processedKey;\n      this.roundKeys = [];\n      \n      // Generate round keys\n      this.generateRoundKeys();\n    }\n  };\n  \n  // Add key schedule method to PRESENTInstance prototype\n  PRESENT.PRESENTInstance.prototype.generateRoundKeys = function() {\n    // Convert key to 80-bit BigInt (big-endian like Python implementation)\n    let key = BigInt(0);\n    for (let i = 0; i < PRESENT.KEY_SIZE; i++) {\n      const byteValue = BigInt(this.key.charCodeAt(i) & 0xFF);\n      key = key * BigInt(256) + byteValue; // Build big-endian integer\n    }\n    \n    // Generate 32 round keys (rounds 0-31 + final key)\n    for (let round = 0; round <= PRESENT.ROUNDS; round++) {\n      // Extract 64-bit round key from leftmost bits (bits 79-16)\n      // Use bit shifting to extract the high 64 bits\n      const roundKey64 = key >> BigInt(16); // Shift right by 16 to get top 64 bits\n      \n      // Split into high and low 32-bit words\n      const roundKeyHigh = Number((roundKey64 >> BigInt(32)) & BigInt(0xFFFFFFFF));\n      const roundKeyLow = Number(roundKey64 & BigInt(0xFFFFFFFF));\n      \n      this.roundKeys[round] = {\n        high: roundKeyHigh >>> 0,\n        low: roundKeyLow >>> 0\n      }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "2844B365C06992A3"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "Ï¡Gês½y",
        "description": "RC2 test vector: 8-byte all-zero key with default effective length",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"Ï¡Gês½y\",\n        \"description\": \"RC2 test vector: 8-byte all-zero key with default effective length\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"rY\\u0001ÅW³W\",\n        \"description\": \"RC2 test vector: 8-byte all-ones key with all-ones plaintext\"\n    },\n    {\n        \"input\": \"\\u0010\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0001\",\n        \"key\": \"0\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"Üïc\\u0010®ä{A\",\n        \"description\": \"RC2 test vector: pattern key with pattern plaintext\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\",\n        \"expected\": \"ölmÄ*º\",\n        \"description\": \"RC2 test vector: 1-byte key, default effective length\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // RC2 PITABLE - 256-byte permutation table from RFC 2268\n    PITABLE: [\n      217,120,249,196, 25,221,181,237, 40,233,253,121, 74,160,216,157,\n      198,126, 55,131, 43,118, 83,142, 98, 76,100,136, 68,139,251,162,\n       23,154, 89,245,135,179, 79, 19, 97, 69,109,141,  9,129,125, 50,\n      189,143, 64,235,134,183,123, 11,240,149, 33, 34, 92,107, 78,130,\n       84,214,101,147,206, 96,178, 28,115, 86,192, 20,167,140,241,220,\n       18,117,202, 31, 59,190,228,209, 66, 61,212, 48,163, 60,182, 38,\n      111,191, 14,218, 70,105,  7, 87, 39,242, 29,155,188,148, 67,  3,\n      248, 17,199,246,144,239, 62,231,  6,195,213, 47,200,102, 30,215,\n        8,232,234,222,128, 82,238,247,132,170,114,172, 53, 77,106, 42,\n      150, 26,210,113, 90, 21, 73,116, 75,159,208, 94,  4, 24,164,236,\n      194,224, 65,110, 15, 81,203,204, 36,145,175, 80,161,244,112, 57,\n      153,124, 58,133, 35,184,180,122,252,  2, 54, 91, 37, 85,151, 49,\n       45, 93,250,152,227,138,146,174,  5,223, 41, 16,103,108,186,201,\n      211,  0,230,207,225,158,168, 44, 99, 22,  1, 63, 88,226,137,169,\n       13, 56, 52, 27,171, 51,255,176,187, 72, 12, 95,185,177,205, 46,\n      197,243,219, 71,229,165,156,119, 10,166, 32,104,254,127,193,173\n    ],\n    \n    // Initialize cipher\n    Init: function() {\n      RC2.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey, effectiveBits = 1024) {\n      let id;\n      do {\n        id = 'RC2[' + global.generateUniqueID() + ']';\n      } while (RC2.instances[id] || global.objectInstances[id]);\n      \n      RC2.instances[szID] = new RC2.RC2Instance(optional_szKey, effectiveBits);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (RC2.instances[id]) {\n        // Clear sensitive data\n        const instance = RC2.instances[szID];\n        if (instance.expandedKey) global.OpCodes.ClearArray(instance.expandedKey);\n        \n        delete RC2.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'RC2', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt a block\n    encryptBlock: function(id, szInput) {\n      if (RC2.instances[id]) {\n        return RC2.instances[szID].encryptBlock(szInput);\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'RC2', 'encryptBlock');\n        return '';\n      }\n    },\n    \n    // Decrypt a block\n    decryptBlock: function(id, szInput) {\n      if (RC2.instances[id]) {\n        return RC2.instances[szID].decryptBlock(szInput);\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'RC2', 'decryptBlock');\n        return '';\n      }\n    },\n    \n    // RC2 Instance class\n    RC2Instance: function(key, effectiveBits = 1024) {\n      this.expandedKey = new Array(64);  // 64 16-bit words\n      \n      // Helper function to pack two bytes into 16-bit word (little-endian)\n      this.pack16LE = function(b0, b1) {\n        return ((b1 & 0xFF) << 8) | (b0 & 0xFF);\n      };\n      \n      // Helper function to unpack 16-bit word to two bytes (little-endian)\n      this.unpack16LE = function(word) {\n        return [(word & 0xFF), ((word >>> 8) & 0xFF)];\n      };\n      \n      // 16-bit rotation functions\n      this.rotL16 = function(value, positions) {\n        value &= 0xFFFF;\n        positions &= 15;\n        return ((value << positions) | (value >>> (16 - positions))) & 0xFFFF;\n      };\n      \n      this.rotR16 = function(value, positions) {\n        value &= 0xFFFF;\n        positions &= 15;\n        return ((value >>> positions) | (value << (16 - positions))) & 0xFFFF;\n      };\n      \n      // RC2 key expansion algorithm (RFC 2268 compliant)\n      this.setupKey = function(key, effectiveBits = 1024) {\n        const keyBytes = global.OpCodes.StringToBytes(key);\n        const keyLength = keyBytes.length;\n        \n        // RFC 2268: if effectiveBits is zero, use 1024\n        if (effectiveBits === 0) {\n          effectiveBits = 1024;\n        }\n        \n        // Step 1: Initialize L with key bytes (copy directly to byte array)\n        const L = new Array(128);\n        for (let i = 0; i < keyLength; i++) {\n          L[i] = keyBytes[i];\n        }\n        \n        // Step 2: Expand to 128 bytes using PITABLE (RFC 2268 algorithm)\n        // Follow C code logic exactly: i++ increments without wrapping, accesses expanding array\n        if (keyLength < 128) {\n          let i = 0;\n          let x = L[keyLength - 1];\n          let len = keyLength;\n          \n          while (len < 128) {\n            x = RC2.PITABLE[(x + L[i]) & 0xFF];\n            L[len] = x;\n            i++;\n            len++;\n          }\n        }\n        \n        // Step 3: Apply effective key length reduction (RFC 2268 Phase 2)\n        const len = Math.floor((effectiveBits + 7) / 8);  // effective key length in bytes\n        const i = 128 - len;\n        let x = RC2.PITABLE[L[i] & (0xFF >>> (7 & -effectiveBits))];\n        L[i] = x;\n        \n        for (let j = i - 1; j >= 0; j--) {\n          x = RC2.PITABLE[x ^ L[j + len]];\n          L[j] = x;\n        }\n        \n        // Step 4: Convert to 16-bit words (little-endian) - RFC 2268 Phase 3\n        for (let i = 0; i < 64; i++) {\n          this.expandedKey[i] = this.pack16LE(L[2 * i], L[2 * i + 1]);\n        }\n      };\n      \n      // RC2 encryption\n      this.encryptBlock = function(plaintext) {\n        if (plaintext.length !== 8) {\n          global.throwException('Invalid Block Size Exception', plaintext.length, 'RC2', 'encryptBlock');\n          return '';\n        }\n        \n        const plainBytes = global.OpCodes.StringToBytes(plaintext);\n        \n        // Pack into 16-bit words (little-endian)\n        let R0 = this.pack16LE(plainBytes[0], plainBytes[1]);\n        let R1 = this.pack16LE(plainBytes[2], plainBytes[3]);\n        let R2 = this.pack16LE(plainBytes[4], plainBytes[5]);\n        let R3 = this.pack16LE(plainBytes[6], plainBytes[7]);\n        \n        // 16 rounds of encryption\n        for (let i = 0; i < 16; i++) {\n          const j = i * 4;\n          \n          // Mix operation\n          R0 = (R0 + (R1 & (~R3)) + (R2 & R3) + this.expandedKey[j]) & 0xFFFF;\n          R0 = this.rotL16(R0, 1);\n          \n          R1 = (R1 + (R2 & (~R0)) + (R3 & R0) + this.expandedKey[j + 1]) & 0xFFFF;\n          R1 = this.rotL16(R1, 2);\n          \n          R2 = (R2 + (R3 & (~R1)) + (R0 & R1) + this.expandedKey[j + 2]) & 0xFFFF;\n          R2 = this.rotL16(R2, 3);\n          \n          R3 = (R3 + (R0 & (~R2)) + (R1 & R2) + this.expandedKey[j + 3]) & 0xFFFF;\n          R3 = this.rotL16(R3, 5);\n          \n          // Mash operation after rounds 5 and 11 (i = 4 and 10)\n          if (i === 4 || i === 10) {\n            R0 = (R0 + this.expandedKey[R3 & 63]) & 0xFFFF;\n            R1 = (R1 + this.expandedKey[R0 & 63]) & 0xFFFF;\n            R2 = (R2 + this.expandedKey[R1 & 63]) & 0xFFFF;\n            R3 = (R3 + this.expandedKey[R2 & 63]) & 0xFFFF;\n          }\n        }\n        \n        // Unpack to bytes (little-endian) and convert to string\n        const cipherBytes = [\n          ...this.unpack16LE(R0),\n          ...this.unpack16LE(R1),\n          ...this.unpack16LE(R2),\n          ...this.unpack16LE(R3)\n        ];\n        \n        return global.OpCodes.BytesToString(cipherBytes);\n      };\n      \n      // RC2 decryption\n      this.decryptBlock = function(ciphertext) {\n        if (ciphertext.length !== 8) {\n          global.throwException('Invalid Block Size Exception', ciphertext.length, 'RC2', 'decryptBlock');\n          return '';\n        }\n        \n        const cipherBytes = global.OpCodes.StringToBytes(ciphertext);\n        \n        // Pack into 16-bit words (little-endian)\n        let R0 = this.pack16LE(cipherBytes[0], cipherBytes[1]);\n        let R1 = this.pack16LE(cipherBytes[2], cipherBytes[3]);\n        let R2 = this.pack16LE(cipherBytes[4], cipherBytes[5]);\n        let R3 = this.pack16LE(cipherBytes[6], cipherBytes[7]);\n        \n        // 16 rounds of decryption (reverse order)\n        for (let i = 15; i >= 0; i--) {\n          const j = i * 4;\n          \n          // Reverse mash operation after rounds 5 and 11 (i = 4 and 10)\n          if (i === 4 || i === 10) {\n            R3 = (R3 - this.expandedKey[R2 & 63]) & 0xFFFF;\n            R2 = (R2 - this.expandedKey[R1 & 63]) & 0xFFFF;\n            R1 = (R1 - this.expandedKey[R0 & 63]) & 0xFFFF;\n            R0 = (R0 - this.expandedKey[R3 & 63]) & 0xFFFF;\n          }\n          \n          // Reverse mix operation\n          R3 = this.rotR16(R3, 5);\n          R3 = (R3 - (R0 & (~R2)) - (R1 & R2) - this.expandedKey[j + 3]) & 0xFFFF;\n          \n          R2 = this.rotR16(R2, 3);\n          R2 = (R2 - (R3 & (~R1)) - (R0 & R1) - this.expandedKey[j + 2]) & 0xFFFF;\n          \n          R1 = this.rotR16(R1, 2);\n          R1 = (R1 - (R2 & (~R0)) - (R3 & R0) - this.expandedKey[j + 1]) & 0xFFFF;\n          \n          R0 = this.rotR16(R0, 1);\n          R0 = (R0 - (R1 & (~R3)) - (R2 & R3) - this.expandedKey[j]) & 0xFFFF;\n        }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): CFA18F47EA73BD79",
        "description": "RC2 test vector: 8-byte all-zero key with default effective length",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"Ï¡Gês½y\",\n        \"description\": \"RC2 test vector: 8-byte all-zero key with default effective length\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"rY\\u0001ÅW³W\",\n        \"description\": \"RC2 test vector: 8-byte all-ones key with all-ones plaintext\"\n    },\n    {\n        \"input\": \"\\u0010\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0001\",\n        \"key\": \"0\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"Üïc\\u0010®ä{A\",\n        \"description\": \"RC2 test vector: pattern key with pattern plaintext\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\",\n        \"expected\": \"ölmÄ*º\",\n        \"description\": \"RC2 test vector: 1-byte key, default effective length\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // RC2 PITABLE - 256-byte permutation table from RFC 2268\n    PITABLE: [\n      217,120,249,196, 25,221,181,237, 40,233,253,121, 74,160,216,157,\n      198,126, 55,131, 43,118, 83,142, 98, 76,100,136, 68,139,251,162,\n       23,154, 89,245,135,179, 79, 19, 97, 69,109,141,  9,129,125, 50,\n      189,143, 64,235,134,183,123, 11,240,149, 33, 34, 92,107, 78,130,\n       84,214,101,147,206, 96,178, 28,115, 86,192, 20,167,140,241,220,\n       18,117,202, 31, 59,190,228,209, 66, 61,212, 48,163, 60,182, 38,\n      111,191, 14,218, 70,105,  7, 87, 39,242, 29,155,188,148, 67,  3,\n      248, 17,199,246,144,239, 62,231,  6,195,213, 47,200,102, 30,215,\n        8,232,234,222,128, 82,238,247,132,170,114,172, 53, 77,106, 42,\n      150, 26,210,113, 90, 21, 73,116, 75,159,208, 94,  4, 24,164,236,\n      194,224, 65,110, 15, 81,203,204, 36,145,175, 80,161,244,112, 57,\n      153,124, 58,133, 35,184,180,122,252,  2, 54, 91, 37, 85,151, 49,\n       45, 93,250,152,227,138,146,174,  5,223, 41, 16,103,108,186,201,\n      211,  0,230,207,225,158,168, 44, 99, 22,  1, 63, 88,226,137,169,\n       13, 56, 52, 27,171, 51,255,176,187, 72, 12, 95,185,177,205, 46,\n      197,243,219, 71,229,165,156,119, 10,166, 32,104,254,127,193,173\n    ],\n    \n    // Initialize cipher\n    Init: function() {\n      RC2.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey, effectiveBits = 1024) {\n      let id;\n      do {\n        id = 'RC2[' + global.generateUniqueID() + ']';\n      } while (RC2.instances[id] || global.objectInstances[id]);\n      \n      RC2.instances[szID] = new RC2.RC2Instance(optional_szKey, effectiveBits);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (RC2.instances[id]) {\n        // Clear sensitive data\n        const instance = RC2.instances[szID];\n        if (instance.expandedKey) global.OpCodes.ClearArray(instance.expandedKey);\n        \n        delete RC2.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'RC2', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt a block\n    encryptBlock: function(id, szInput) {\n      if (RC2.instances[id]) {\n        return RC2.instances[szID].encryptBlock(szInput);\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'RC2', 'encryptBlock');\n        return '';\n      }\n    },\n    \n    // Decrypt a block\n    decryptBlock: function(id, szInput) {\n      if (RC2.instances[id]) {\n        return RC2.instances[szID].decryptBlock(szInput);\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'RC2', 'decryptBlock');\n        return '';\n      }\n    },\n    \n    // RC2 Instance class\n    RC2Instance: function(key, effectiveBits = 1024) {\n      this.expandedKey = new Array(64);  // 64 16-bit words\n      \n      // Helper function to pack two bytes into 16-bit word (little-endian)\n      this.pack16LE = function(b0, b1) {\n        return ((b1 & 0xFF) << 8) | (b0 & 0xFF);\n      };\n      \n      // Helper function to unpack 16-bit word to two bytes (little-endian)\n      this.unpack16LE = function(word) {\n        return [(word & 0xFF), ((word >>> 8) & 0xFF)];\n      };\n      \n      // 16-bit rotation functions\n      this.rotL16 = function(value, positions) {\n        value &= 0xFFFF;\n        positions &= 15;\n        return ((value << positions) | (value >>> (16 - positions))) & 0xFFFF;\n      };\n      \n      this.rotR16 = function(value, positions) {\n        value &= 0xFFFF;\n        positions &= 15;\n        return ((value >>> positions) | (value << (16 - positions))) & 0xFFFF;\n      };\n      \n      // RC2 key expansion algorithm (RFC 2268 compliant)\n      this.setupKey = function(key, effectiveBits = 1024) {\n        const keyBytes = global.OpCodes.StringToBytes(key);\n        const keyLength = keyBytes.length;\n        \n        // RFC 2268: if effectiveBits is zero, use 1024\n        if (effectiveBits === 0) {\n          effectiveBits = 1024;\n        }\n        \n        // Step 1: Initialize L with key bytes (copy directly to byte array)\n        const L = new Array(128);\n        for (let i = 0; i < keyLength; i++) {\n          L[i] = keyBytes[i];\n        }\n        \n        // Step 2: Expand to 128 bytes using PITABLE (RFC 2268 algorithm)\n        // Follow C code logic exactly: i++ increments without wrapping, accesses expanding array\n        if (keyLength < 128) {\n          let i = 0;\n          let x = L[keyLength - 1];\n          let len = keyLength;\n          \n          while (len < 128) {\n            x = RC2.PITABLE[(x + L[i]) & 0xFF];\n            L[len] = x;\n            i++;\n            len++;\n          }\n        }\n        \n        // Step 3: Apply effective key length reduction (RFC 2268 Phase 2)\n        const len = Math.floor((effectiveBits + 7) / 8);  // effective key length in bytes\n        const i = 128 - len;\n        let x = RC2.PITABLE[L[i] & (0xFF >>> (7 & -effectiveBits))];\n        L[i] = x;\n        \n        for (let j = i - 1; j >= 0; j--) {\n          x = RC2.PITABLE[x ^ L[j + len]];\n          L[j] = x;\n        }\n        \n        // Step 4: Convert to 16-bit words (little-endian) - RFC 2268 Phase 3\n        for (let i = 0; i < 64; i++) {\n          this.expandedKey[i] = this.pack16LE(L[2 * i], L[2 * i + 1]);\n        }\n      };\n      \n      // RC2 encryption\n      this.encryptBlock = function(plaintext) {\n        if (plaintext.length !== 8) {\n          global.throwException('Invalid Block Size Exception', plaintext.length, 'RC2', 'encryptBlock');\n          return '';\n        }\n        \n        const plainBytes = global.OpCodes.StringToBytes(plaintext);\n        \n        // Pack into 16-bit words (little-endian)\n        let R0 = this.pack16LE(plainBytes[0], plainBytes[1]);\n        let R1 = this.pack16LE(plainBytes[2], plainBytes[3]);\n        let R2 = this.pack16LE(plainBytes[4], plainBytes[5]);\n        let R3 = this.pack16LE(plainBytes[6], plainBytes[7]);\n        \n        // 16 rounds of encryption\n        for (let i = 0; i < 16; i++) {\n          const j = i * 4;\n          \n          // Mix operation\n          R0 = (R0 + (R1 & (~R3)) + (R2 & R3) + this.expandedKey[j]) & 0xFFFF;\n          R0 = this.rotL16(R0, 1);\n          \n          R1 = (R1 + (R2 & (~R0)) + (R3 & R0) + this.expandedKey[j + 1]) & 0xFFFF;\n          R1 = this.rotL16(R1, 2);\n          \n          R2 = (R2 + (R3 & (~R1)) + (R0 & R1) + this.expandedKey[j + 2]) & 0xFFFF;\n          R2 = this.rotL16(R2, 3);\n          \n          R3 = (R3 + (R0 & (~R2)) + (R1 & R2) + this.expandedKey[j + 3]) & 0xFFFF;\n          R3 = this.rotL16(R3, 5);\n          \n          // Mash operation after rounds 5 and 11 (i = 4 and 10)\n          if (i === 4 || i === 10) {\n            R0 = (R0 + this.expandedKey[R3 & 63]) & 0xFFFF;\n            R1 = (R1 + this.expandedKey[R0 & 63]) & 0xFFFF;\n            R2 = (R2 + this.expandedKey[R1 & 63]) & 0xFFFF;\n            R3 = (R3 + this.expandedKey[R2 & 63]) & 0xFFFF;\n          }\n        }\n        \n        // Unpack to bytes (little-endian) and convert to string\n        const cipherBytes = [\n          ...this.unpack16LE(R0),\n          ...this.unpack16LE(R1),\n          ...this.unpack16LE(R2),\n          ...this.unpack16LE(R3)\n        ];\n        \n        return global.OpCodes.BytesToString(cipherBytes);\n      };\n      \n      // RC2 decryption\n      this.decryptBlock = function(ciphertext) {\n        if (ciphertext.length !== 8) {\n          global.throwException('Invalid Block Size Exception', ciphertext.length, 'RC2', 'decryptBlock');\n          return '';\n        }\n        \n        const cipherBytes = global.OpCodes.StringToBytes(ciphertext);\n        \n        // Pack into 16-bit words (little-endian)\n        let R0 = this.pack16LE(cipherBytes[0], cipherBytes[1]);\n        let R1 = this.pack16LE(cipherBytes[2], cipherBytes[3]);\n        let R2 = this.pack16LE(cipherBytes[4], cipherBytes[5]);\n        let R3 = this.pack16LE(cipherBytes[6], cipherBytes[7]);\n        \n        // 16 rounds of decryption (reverse order)\n        for (let i = 15; i >= 0; i--) {\n          const j = i * 4;\n          \n          // Reverse mash operation after rounds 5 and 11 (i = 4 and 10)\n          if (i === 4 || i === 10) {\n            R3 = (R3 - this.expandedKey[R2 & 63]) & 0xFFFF;\n            R2 = (R2 - this.expandedKey[R1 & 63]) & 0xFFFF;\n            R1 = (R1 - this.expandedKey[R0 & 63]) & 0xFFFF;\n            R0 = (R0 - this.expandedKey[R3 & 63]) & 0xFFFF;\n          }\n          \n          // Reverse mix operation\n          R3 = this.rotR16(R3, 5);\n          R3 = (R3 - (R0 & (~R2)) - (R1 & R2) - this.expandedKey[j + 3]) & 0xFFFF;\n          \n          R2 = this.rotR16(R2, 3);\n          R2 = (R2 - (R3 & (~R1)) - (R0 & R1) - this.expandedKey[j + 2]) & 0xFFFF;\n          \n          R1 = this.rotR16(R1, 2);\n          R1 = (R1 - (R2 & (~R0)) - (R3 & R0) - this.expandedKey[j + 1]) & 0xFFFF;\n          \n          R0 = this.rotR16(R0, 1);\n          R0 = (R0 - (R1 & (~R3)) - (R2 & R3) - this.expandedKey[j]) & 0xFFFF;\n        }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "CFA18F47EA73BD79"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "!¥Ûî\\u0015Km",
        "description": "RC5-32/12/16 test vector 1: all zeros input and key",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"!¥Ûî\\u0015Km\",\n        \"description\": \"RC5-32/12/16 test vector 1: all zeros input and key\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"wié¾\\u0001g·\",\n        \"description\": \"RC5-32/12/16 test vector 2: all ones input and key\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\",\n        \"expected\": \"·4!6\\b%M/\",\n        \"description\": \"RC5-32/12/16 test vector 3: sequential pattern\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\",\n        \"expected\": \"!¥Ûî\\u0015Km\",\n        \"description\": \"RC5-32/12/16 test vector 4: null key (same as zero key)\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'RC5 Algorithm Specification (Original Paper)',\n        url: 'https://people.csail.mit.edu/rivest/Rivest-rc5rev.pdf',\n        description: 'Original RC5 specification by Ronald Rivest at MIT'\n      },\n      {\n        name: 'RFC 2040 - RC5, RC5-CBC, RC5-CBC-Pad, and RC5-CTS Algorithms',\n        url: 'https://tools.ietf.org/rfc/rfc2040.txt',\n        description: 'IETF RFC defining RC5 algorithm and its cipher block chaining modes'\n      },\n      {\n        name: 'MIT RC5 Algorithm Page',\n        url: 'https://people.csail.mit.edu/rivest/Rivest-rc5.txt',\n        description: 'MIT computer science page for RC5 algorithm documentation'\n      },\n      {\n        name: 'RC5 Patent Information',\n        url: 'https://patents.google.com/patent/US5724428A',\n        description: 'RC5 algorithm patent (expired) - US Patent 5,724,428'\n      }\n    ],\n    implementations: [\n      {\n        name: 'OpenSSL RC5 Implementation',\n        url: 'https://github.com/openssl/openssl/blob/master/crypto/rc5/',\n        description: 'Production-quality RC5 implementation from OpenSSL'\n      },\n      {\n        name: 'Crypto++ RC5 Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/rc5.cpp',\n        description: 'High-performance C++ RC5 implementation'\n      },\n      {\n        name: 'Bouncy Castle RC5 Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java RC5 implementation from Bouncy Castle'\n      },\n      {\n        name: 'libgcrypt RC5 Implementation',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/',\n        description: 'GNU libgcrypt cryptographic library implementation'\n      }\n    ],\n    validation: [\n      {\n        name: 'RC5 Test Vectors',\n        url: 'https://people.csail.mit.edu/rivest/Rivest-rc5rev.pdf',\n        description: 'Official test vectors from RC5 specification document'\n      },\n      {\n        name: 'NIST Cryptographic Algorithm Validation',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program',\n        description: 'NIST guidance for cryptographic algorithm validation'\n      },\n      {\n        name: 'RC5 Cryptanalysis Research',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=1052',\n        description: 'Academic research on RC5 security properties and cryptanalysis'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n    \n    // RC5 Constants and Parameters\n    DEFAULT_WORD_SIZE: 32,      // w = word size in bits\n    DEFAULT_ROUNDS: 12,         // r = number of rounds\n    DEFAULT_KEY_BYTES: 16,      // b = key length in bytes\n    MAGIC_P: 0xb7e15163,       // P = Odd((e-2)*2^32) where e is base of natural log\n    MAGIC_Q: 0x9e3779b9,       // Q = Odd((φ-1)*2^32) where φ is golden ratio\n    \n    // Initialize cipher\n    Init: function() {\n      RC5.isInitialized = true;\n    },\n    \n    // Set up key and create instance\n    KeySetup: function(optional_szKey) {\n      let id;\n      do {\n        id = 'RC5[' + global.generateUniqueID() + ']';\n      } while (RC5.instances[id] || global.objectInstances[id]);\n      \n      RC5.instances[szID] = new RC5.RC5Instance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (RC5.instances[id]) {\n        // Securely clear the key table\n        const instance = RC5.instances[szID];\n        if (instance.S && global.OpCodes && global.OpCodes.ClearArray) {\n          global.OpCodes.ClearArray(instance.S);\n        }\n        delete RC5.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'RC5', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt 8-byte block\n    encryptBlock: function(id, szPlainText) {\n      if (!RC5.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'RC5', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = RC5.instances[szID];\n      \n      // Handle string input - pad to 8 bytes if needed\n      let input = szPlainText;\n      while (input.length < 8) {\n        input += '\\0';\n      }\n      \n      // Process in 8-byte blocks\n      let result = '';\n      for (let blockStart = 0; blockStart < input.length; blockStart += 8) {\n        const block = input.substr(blockStart, 8);\n        const encryptedBlock = RC5._encryptBlock(instance, block);\n        result += encryptedBlock;\n      }\n      \n      return result;\n    },\n    \n    // Decrypt 8-byte block\n    decryptBlock: function(id, szCipherText) {\n      if (!RC5.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'RC5', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = RC5.instances[szID];\n      \n      // Process in 8-byte blocks\n      let result = '';\n      for (let blockStart = 0; blockStart < szCipherText.length; blockStart += 8) {\n        const block = szCipherText.substr(blockStart, 8);\n        if (block.length === 8) {\n          const decryptedBlock = RC5._decryptBlock(instance, block);\n          result += decryptedBlock;\n        }\n      }\n      \n      return result;\n    },\n    \n    // RC5 encryption function (internal)\n    _encryptBlock: function(instance, blockStr) {\n      if (blockStr.length !== 8) {\n        throw new Error('RC5 block must be exactly 8 bytes');\n      }\n      \n      // Convert string to two 32-bit words (little-endian)\n      const bytes = global.OpCodes.StringToBytes(blockStr);\n      let A = global.OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]);\n      let B = global.OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]);\n      \n      // Add first round keys\n      A = (A + instance.S[0]) >>> 0;\n      B = (B + instance.S[1]) >>> 0;\n      \n      // Perform rounds\n      for (let i = 1; i <= instance.rounds; i++) {\n        // A = ROL(A XOR B, B) + S[2*i]\n        A = A ^ B;\n        A = global.OpCodes.RotL32(A, B & 31);\n        A = (A + instance.S[2 * i]) >>> 0;\n        \n        // B = ROL(B XOR A, A) + S[2*i+1]\n        B = B ^ A;\n        B = global.OpCodes.RotL32(B, A & 31);\n        B = (B + instance.S[2 * i + 1]) >>> 0;\n      }\n      \n      // Convert back to string (little-endian)\n      const resultA = global.OpCodes.Unpack32LE(A);\n      const resultB = global.OpCodes.Unpack32LE(B);\n      return global.OpCodes.BytesToString(resultA.concat(resultB));\n    },\n    \n    // RC5 decryption function (internal)\n    _decryptBlock: function(instance, blockStr) {\n      if (blockStr.length !== 8) {\n        throw new Error('RC5 block must be exactly 8 bytes');\n      }\n      \n      // Convert string to two 32-bit words (little-endian)\n      const bytes = global.OpCodes.StringToBytes(blockStr);\n      let A = global.OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]);\n      let B = global.OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]);\n      \n      // Perform rounds in reverse\n      for (let i = instance.rounds; i >= 1; i--) {\n        // B = ROR(B - S[2*i+1], A) XOR A\n        B = (B - instance.S[2 * i + 1]) >>> 0;\n        B = global.OpCodes.RotR32(B, A & 31);\n        B = B ^ A;\n        \n        // A = ROR(A - S[2*i], B) XOR B\n        A = (A - instance.S[2 * i]) >>> 0;\n        A = global.OpCodes.RotR32(A, B & 31);\n        A = A ^ B;\n      }\n      \n      // Subtract first round keys\n      A = (A - instance.S[0]) >>> 0;\n      B = (B - instance.S[1]) >>> 0;\n      \n      // Convert back to string (little-endian)\n      const resultA = global.OpCodes.Unpack32LE(A);\n      const resultB = global.OpCodes.Unpack32LE(B);\n      return global.OpCodes.BytesToString(resultA.concat(resultB));\n    },\n    \n    // RC5 Instance class\n    RC5Instance: function(key) {\n      this.wordSize = RC5.DEFAULT_WORD_SIZE;\n      this.rounds = RC5.DEFAULT_ROUNDS;\n      this.keyBytes = szKey ? szKey.length : RC5.DEFAULT_KEY_BYTES;\n      this.tableSize = 2 * (this.rounds + 1); // t = 2*(r+1)\n      this.S = new Array(this.tableSize); // Expanded key table\n      \n      // Perform key expansion\n      this._keyExpansion(key || '');\n    }\n  };\n  \n  // Add key expansion method to RC5Instance prototype\n  RC5.RC5Instance.prototype._keyExpansion = function(key) {\n    const u = this.wordSize / 8; // Bytes per word (4 for 32-bit)\n    const c = Math.max(1, Math.ceil(this.keyBytes / u)); // Words in key\n    const L = new Array(c); // Key in word array\n    \n    // Step 1: Copy key into L array (little-endian)\n    for (let i = 0; i < c; i++) {\n      L[i] = 0;\n    }\n    \n    for (let i = this.keyBytes - 1; i >= 0; i--) {\n      const keyByte = i < key.length ? key.charCodeAt(i) & 0xFF : 0;\n      L[Math.floor(i / u)] = ((L[Math.floor(i / u)] << 8) + keyByte) >>> 0;\n    }\n    \n    // Step 2: Initialize S array with magic constants\n    this.S[0] = RC5.MAGIC_P;\n    for (let i = 1; i < this.tableSize; i++) {\n      this.S[i] = (this.S[i - 1] + RC5.MAGIC_Q) >>> 0;\n    }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 21A5DBEE5C75303031354B8F6D",
        "description": "RC5-32/12/16 test vector 1: all zeros input and key",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"!¥Ûî\\u0015Km\",\n        \"description\": \"RC5-32/12/16 test vector 1: all zeros input and key\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"wié¾\\u0001g·\",\n        \"description\": \"RC5-32/12/16 test vector 2: all ones input and key\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\",\n        \"expected\": \"·4!6\\b%M/\",\n        \"description\": \"RC5-32/12/16 test vector 3: sequential pattern\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\",\n        \"expected\": \"!¥Ûî\\u0015Km\",\n        \"description\": \"RC5-32/12/16 test vector 4: null key (same as zero key)\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'RC5 Algorithm Specification (Original Paper)',\n        url: 'https://people.csail.mit.edu/rivest/Rivest-rc5rev.pdf',\n        description: 'Original RC5 specification by Ronald Rivest at MIT'\n      },\n      {\n        name: 'RFC 2040 - RC5, RC5-CBC, RC5-CBC-Pad, and RC5-CTS Algorithms',\n        url: 'https://tools.ietf.org/rfc/rfc2040.txt',\n        description: 'IETF RFC defining RC5 algorithm and its cipher block chaining modes'\n      },\n      {\n        name: 'MIT RC5 Algorithm Page',\n        url: 'https://people.csail.mit.edu/rivest/Rivest-rc5.txt',\n        description: 'MIT computer science page for RC5 algorithm documentation'\n      },\n      {\n        name: 'RC5 Patent Information',\n        url: 'https://patents.google.com/patent/US5724428A',\n        description: 'RC5 algorithm patent (expired) - US Patent 5,724,428'\n      }\n    ],\n    implementations: [\n      {\n        name: 'OpenSSL RC5 Implementation',\n        url: 'https://github.com/openssl/openssl/blob/master/crypto/rc5/',\n        description: 'Production-quality RC5 implementation from OpenSSL'\n      },\n      {\n        name: 'Crypto++ RC5 Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/rc5.cpp',\n        description: 'High-performance C++ RC5 implementation'\n      },\n      {\n        name: 'Bouncy Castle RC5 Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java RC5 implementation from Bouncy Castle'\n      },\n      {\n        name: 'libgcrypt RC5 Implementation',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/',\n        description: 'GNU libgcrypt cryptographic library implementation'\n      }\n    ],\n    validation: [\n      {\n        name: 'RC5 Test Vectors',\n        url: 'https://people.csail.mit.edu/rivest/Rivest-rc5rev.pdf',\n        description: 'Official test vectors from RC5 specification document'\n      },\n      {\n        name: 'NIST Cryptographic Algorithm Validation',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program',\n        description: 'NIST guidance for cryptographic algorithm validation'\n      },\n      {\n        name: 'RC5 Cryptanalysis Research',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=1052',\n        description: 'Academic research on RC5 security properties and cryptanalysis'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n    \n    // RC5 Constants and Parameters\n    DEFAULT_WORD_SIZE: 32,      // w = word size in bits\n    DEFAULT_ROUNDS: 12,         // r = number of rounds\n    DEFAULT_KEY_BYTES: 16,      // b = key length in bytes\n    MAGIC_P: 0xb7e15163,       // P = Odd((e-2)*2^32) where e is base of natural log\n    MAGIC_Q: 0x9e3779b9,       // Q = Odd((φ-1)*2^32) where φ is golden ratio\n    \n    // Initialize cipher\n    Init: function() {\n      RC5.isInitialized = true;\n    },\n    \n    // Set up key and create instance\n    KeySetup: function(optional_szKey) {\n      let id;\n      do {\n        id = 'RC5[' + global.generateUniqueID() + ']';\n      } while (RC5.instances[id] || global.objectInstances[id]);\n      \n      RC5.instances[szID] = new RC5.RC5Instance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (RC5.instances[id]) {\n        // Securely clear the key table\n        const instance = RC5.instances[szID];\n        if (instance.S && global.OpCodes && global.OpCodes.ClearArray) {\n          global.OpCodes.ClearArray(instance.S);\n        }\n        delete RC5.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'RC5', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt 8-byte block\n    encryptBlock: function(id, szPlainText) {\n      if (!RC5.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'RC5', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = RC5.instances[szID];\n      \n      // Handle string input - pad to 8 bytes if needed\n      let input = szPlainText;\n      while (input.length < 8) {\n        input += '\\0';\n      }\n      \n      // Process in 8-byte blocks\n      let result = '';\n      for (let blockStart = 0; blockStart < input.length; blockStart += 8) {\n        const block = input.substr(blockStart, 8);\n        const encryptedBlock = RC5._encryptBlock(instance, block);\n        result += encryptedBlock;\n      }\n      \n      return result;\n    },\n    \n    // Decrypt 8-byte block\n    decryptBlock: function(id, szCipherText) {\n      if (!RC5.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'RC5', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = RC5.instances[szID];\n      \n      // Process in 8-byte blocks\n      let result = '';\n      for (let blockStart = 0; blockStart < szCipherText.length; blockStart += 8) {\n        const block = szCipherText.substr(blockStart, 8);\n        if (block.length === 8) {\n          const decryptedBlock = RC5._decryptBlock(instance, block);\n          result += decryptedBlock;\n        }\n      }\n      \n      return result;\n    },\n    \n    // RC5 encryption function (internal)\n    _encryptBlock: function(instance, blockStr) {\n      if (blockStr.length !== 8) {\n        throw new Error('RC5 block must be exactly 8 bytes');\n      }\n      \n      // Convert string to two 32-bit words (little-endian)\n      const bytes = global.OpCodes.StringToBytes(blockStr);\n      let A = global.OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]);\n      let B = global.OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]);\n      \n      // Add first round keys\n      A = (A + instance.S[0]) >>> 0;\n      B = (B + instance.S[1]) >>> 0;\n      \n      // Perform rounds\n      for (let i = 1; i <= instance.rounds; i++) {\n        // A = ROL(A XOR B, B) + S[2*i]\n        A = A ^ B;\n        A = global.OpCodes.RotL32(A, B & 31);\n        A = (A + instance.S[2 * i]) >>> 0;\n        \n        // B = ROL(B XOR A, A) + S[2*i+1]\n        B = B ^ A;\n        B = global.OpCodes.RotL32(B, A & 31);\n        B = (B + instance.S[2 * i + 1]) >>> 0;\n      }\n      \n      // Convert back to string (little-endian)\n      const resultA = global.OpCodes.Unpack32LE(A);\n      const resultB = global.OpCodes.Unpack32LE(B);\n      return global.OpCodes.BytesToString(resultA.concat(resultB));\n    },\n    \n    // RC5 decryption function (internal)\n    _decryptBlock: function(instance, blockStr) {\n      if (blockStr.length !== 8) {\n        throw new Error('RC5 block must be exactly 8 bytes');\n      }\n      \n      // Convert string to two 32-bit words (little-endian)\n      const bytes = global.OpCodes.StringToBytes(blockStr);\n      let A = global.OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]);\n      let B = global.OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]);\n      \n      // Perform rounds in reverse\n      for (let i = instance.rounds; i >= 1; i--) {\n        // B = ROR(B - S[2*i+1], A) XOR A\n        B = (B - instance.S[2 * i + 1]) >>> 0;\n        B = global.OpCodes.RotR32(B, A & 31);\n        B = B ^ A;\n        \n        // A = ROR(A - S[2*i], B) XOR B\n        A = (A - instance.S[2 * i]) >>> 0;\n        A = global.OpCodes.RotR32(A, B & 31);\n        A = A ^ B;\n      }\n      \n      // Subtract first round keys\n      A = (A - instance.S[0]) >>> 0;\n      B = (B - instance.S[1]) >>> 0;\n      \n      // Convert back to string (little-endian)\n      const resultA = global.OpCodes.Unpack32LE(A);\n      const resultB = global.OpCodes.Unpack32LE(B);\n      return global.OpCodes.BytesToString(resultA.concat(resultB));\n    },\n    \n    // RC5 Instance class\n    RC5Instance: function(key) {\n      this.wordSize = RC5.DEFAULT_WORD_SIZE;\n      this.rounds = RC5.DEFAULT_ROUNDS;\n      this.keyBytes = szKey ? szKey.length : RC5.DEFAULT_KEY_BYTES;\n      this.tableSize = 2 * (this.rounds + 1); // t = 2*(r+1)\n      this.S = new Array(this.tableSize); // Expanded key table\n      \n      // Perform key expansion\n      this._keyExpansion(key || '');\n    }\n  };\n  \n  // Add key expansion method to RC5Instance prototype\n  RC5.RC5Instance.prototype._keyExpansion = function(key) {\n    const u = this.wordSize / 8; // Bytes per word (4 for 32-bit)\n    const c = Math.max(1, Math.ceil(this.keyBytes / u)); // Words in key\n    const L = new Array(c); // Key in word array\n    \n    // Step 1: Copy key into L array (little-endian)\n    for (let i = 0; i < c; i++) {\n      L[i] = 0;\n    }\n    \n    for (let i = this.keyBytes - 1; i >= 0; i--) {\n      const keyByte = i < key.length ? key.charCodeAt(i) & 0xFF : 0;\n      L[Math.floor(i / u)] = ((L[Math.floor(i / u)] << 8) + keyByte) >>> 0;\n    }\n    \n    // Step 2: Initialize S array with magic constants\n    this.S[0] = RC5.MAGIC_P;\n    for (let i = 1; i < this.tableSize; i++) {\n      this.S[i] = (this.S[i - 1] + RC5.MAGIC_Q) >>> 0;\n    }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "21A5DBEE5C75303031354B8F6D"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "ú2în\\rg/\\u001f+µÁÇ",
        "description": "RC6 128-bit key, all zeros test vector (official AES submission)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"ú2în\\rg/\\u001f+µÁÇ'E!\",\n        \"description\": \"RC6 128-bit key, all zeros test vector (official AES submission)\"\n    },\n    {\n        \"input\": \"\\u0002\\u0013$5FWhy¬½Îßàñ\",\n        \"key\": \"ïÍ«gE#\\u0001ï\\u0012#4EVgx\",\n        \"expected\": \"ttÅ\\u0010VzÉAèNCVÿ^#ä\",\n        \"description\": \"RC6 128-bit key, pattern test vector (official AES submission)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"Ö\\u0012¦^{jÉ³!É\\u0007È\",\n        \"description\": \"RC6 192-bit key, all zeros test vector (official AES submission)\"\n    },\n    {\n        \"input\": \"\\u0002\\u0013$5FWhy¬½Îßàñ\",\n        \"key\": \"ïÍ«gE#\\u0001ï\\u0012#4EVgx«¼ÍÞïð\",\n        \"expected\": \"SeöoÖ='Ã³|X²WO9q\",\n        \"description\": \"RC6 192-bit key, pattern test vector (official AES submission)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"3É\\u001bs¯;`Ú8\\u0013|º\\u001a»Áò\",\n        \"description\": \"RC6 256-bit key, all zeros test vector (official AES submission)\"\n    },\n    {\n        \"input\": \"\\u0002\\u0013$5FWhy¬½Îßàñ\",\n        \"key\": \"ïÍ«gE#\\u0001ï\\u0012#4EVgx«¼ÍÞïð\\u00102TvºÜþ\",\n        \"expected\": \"\\\\\\\\Ö4ú\\u0007#\\u001aBK%þ\\u001f¸\",\n        \"description\": \"RC6 256-bit key, pattern test vector (official AES submission)\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'RC6 Algorithm Specification',\n        url: 'https://people.csail.mit.edu/rivest/Rivest-rc6.pdf',\n        description: 'Original RC6 specification by Rivest, Robshaw, Sidney, and Yin'\n      },\n      {\n        name: 'AES Candidate RC6 Submission',\n        url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development',\n        description: 'NIST AES candidate submission documents for RC6'\n      },\n      {\n        name: 'RC6 Technical Report',\n        url: 'https://people.csail.mit.edu/rivest/pubs/RRSY98.pdf',\n        description: 'Detailed technical analysis and specification of RC6 algorithm'\n      },\n      {\n        name: 'RC6 Patent Information',\n        url: 'https://patents.google.com/patent/US6269163B1',\n        description: 'RC6 algorithm patent - US Patent 6,269,163'\n      }\n    ],\n    implementations: [\n      {\n        name: 'Crypto++ RC6 Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/rc6.cpp',\n        description: 'High-performance C++ RC6 implementation'\n      },\n      {\n        name: 'Bouncy Castle RC6 Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java RC6 implementation from Bouncy Castle'\n      },\n      {\n        name: 'OpenSSL RC6 Reference',\n        url: 'https://github.com/openssl/openssl/tree/master/crypto/',\n        description: 'OpenSSL cryptographic library structure and cipher implementations'\n      },\n      {\n        name: 'libgcrypt Cipher Collection',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/',\n        description: 'GNU libgcrypt cryptographic algorithm implementations'\n      }\n    ],\n    validation: [\n      {\n        name: 'RC6 AES Submission Test Vectors',\n        url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development',\n        description: 'Official test vectors from RC6 AES candidate submission'\n      },\n      {\n        name: 'NIST AES Process Documentation',\n        url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development',\n        description: 'NIST documentation of AES selection process including RC6 evaluation'\n      },\n      {\n        name: 'RC6 Cryptanalysis Research',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=1287',\n        description: 'Academic research on RC6 security properties and cryptanalysis'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Initialize cipher\n    Init: function() {\n      RC6.isInitialized = true;\n    },\n    \n    // Key setup - generates round key schedule\n    KeySetup: function(key) {\n      let id;\n      do {\n        id = 'RC6[' + global.generateUniqueID() + ']';\n      } while (RC6.instances[id] || global.objectInstances[id]);\n      \n      // Convert key to byte array if string\n      let keyBytes;\n      if (typeof key === 'string') {\n        keyBytes = global.OpCodes.StringToBytes(key);\n      } else if (Array.isArray(key)) {\n        keyBytes = szKey;\n      } else {\n        global.throwException('Invalid key format', key, 'RC6', 'KeySetup');\n        return null;\n      }\n      \n      // Validate key length\n      if (keyBytes.length < RC6.minKeyLength || keyBytes.length > RC6.maxKeyLength) {\n        global.throwException('Invalid key length', keyBytes.length, 'RC6', 'KeySetup');\n        return null;\n      }\n      \n      RC6.instances[szID] = new RC6.RC6Instance(keyBytes);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (RC6.instances[id]) {\n        // Clear sensitive key schedule data\n        if (RC6.instances[id].keySchedule) {\n          global.OpCodes.ClearArray(RC6.instances[id].keySchedule);\n        }\n        delete RC6.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'RC6', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block (128 bits = 16 bytes)\n    encryptBlock: function(id, szPlainText) {\n      if (!RC6.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'RC6', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = RC6.instances[szID];\n      \n      // Convert input to bytes\n      let plainBytes;\n      if (typeof szPlainText === 'string') {\n        plainBytes = global.OpCodes.StringToBytes(szPlainText);\n      } else if (Array.isArray(szPlainText)) {\n        plainBytes = szPlainText;\n      } else {\n        return szPlainText; // Invalid input\n      }\n      \n      // Pad to 16 bytes if needed\n      while (plainBytes.length < 16) {\n        plainBytes.push(0);\n      }\n      \n      // Process 16-byte blocks\n      let result = [];\n      for (let offset = 0; offset < plainBytes.length; offset += 16) {\n        const block = plainBytes.slice(offset, offset + 16);\n        const encryptedBlock = RC6._encryptBlock(instance.keySchedule, block);\n        result = result.concat(encryptedBlock);\n      }\n      \n      // Convert back to string if input was string\n      if (typeof szPlainText === 'string') {\n        return global.OpCodes.BytesToString(result);\n      }\n      return result;\n    },\n    \n    // Decrypt block (128 bits = 16 bytes)\n    decryptBlock: function(id, szCipherText) {\n      if (!RC6.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'RC6', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = RC6.instances[szID];\n      \n      // Convert input to bytes\n      let cipherBytes;\n      if (typeof szCipherText === 'string') {\n        cipherBytes = global.OpCodes.StringToBytes(szCipherText);\n      } else if (Array.isArray(szCipherText)) {\n        cipherBytes = szCipherText;\n      } else {\n        return szCipherText; // Invalid input\n      }\n      \n      // Process 16-byte blocks\n      let result = [];\n      for (let offset = 0; offset < cipherBytes.length; offset += 16) {\n        const block = cipherBytes.slice(offset, offset + 16);\n        const decryptedBlock = RC6._decryptBlock(instance.keySchedule, block);\n        result = result.concat(decryptedBlock);\n      }\n      \n      // Convert back to string if input was string\n      if (typeof szCipherText === 'string') {\n        return global.OpCodes.BytesToString(result);\n      }\n      return result;\n    },\n    \n    // RC6 Core Encryption Function - exact match to C reference implementation\n    _encryptBlock: function(keySchedule, block) {\n      // Convert 16 bytes to 4 words (little-endian)\n      let A = global.OpCodes.Pack32LE(block[0], block[1], block[2], block[3]);\n      let B = global.OpCodes.Pack32LE(block[4], block[5], block[6], block[7]);\n      let C = global.OpCodes.Pack32LE(block[8], block[9], block[10], block[11]);\n      let D = global.OpCodes.Pack32LE(block[12], block[13], block[14], block[15]);\n      \n      // Pre-whitening: B += S[0], D += S[1] (exactly as in C)\n      B = (B + keySchedule[0]) >>> 0;\n      D = (D + keySchedule[1]) >>> 0;\n      \n      // 20 rounds with register rotation - matching C reference pattern exactly\n      // f_rnd(2,a,b,c,d); f_rnd(4,b,c,d,a); f_rnd(6,c,d,a,b); f_rnd(8,d,a,b,c); etc.\n      for (let round = 0; round < 20; round++) {\n        const i = 2 + round * 2; // Key index: 2, 4, 6, 8, ...\n        \n        // RC6 round function: f_rnd(i,a,b,c,d)\n        // u = rotl(d * (d + d + 1), 5);\n        // t = rotl(b * (b + b + 1), 5);  \n        // a = rotl(a ^ t, u) + l_key[i];\n        // c = rotl(c ^ u, t) + l_key[i + 1];\n        const u = global.OpCodes.RotL32((D * (D + D + 1)) >>> 0, 5);\n        const t = global.OpCodes.RotL32((B * (B + B + 1)) >>> 0, 5);\n        A = (global.OpCodes.RotL32((A ^ t) >>> 0, u & 31) + keySchedule[i]) >>> 0;\n        C = (global.OpCodes.RotL32((C ^ u) >>> 0, t & 31) + keySchedule[i + 1]) >>> 0;\n        \n        // Register rotation: (A,B,C,D) -> (B,C,D,A)\n        const temp = A;\n        A = B;\n        B = C;\n        C = D;\n        D = temp;\n      }\n      \n      // Post-whitening: A += S[42], C += S[43] (exactly as in C)\n      A = (A + keySchedule[42]) >>> 0;\n      C = (C + keySchedule[43]) >>> 0;\n      \n      // Convert back to bytes (little-endian)\n      const result = [];\n      const bytes0 = global.OpCodes.Unpack32LE(A);\n      const bytes1 = global.OpCodes.Unpack32LE(B);\n      const bytes2 = global.OpCodes.Unpack32LE(C);\n      const bytes3 = global.OpCodes.Unpack32LE(D);\n      \n      return bytes0.concat(bytes1, bytes2, bytes3);\n    },\n    \n    // RC6 Core Decryption Function - exact match to C reference implementation  \n    _decryptBlock: function(keySchedule, block) {\n      // Convert 16 bytes to 4 words (little-endian)\n      let A = global.OpCodes.Pack32LE(block[0], block[1], block[2], block[3]);\n      let B = global.OpCodes.Pack32LE(block[4], block[5], block[6], block[7]);\n      let C = global.OpCodes.Pack32LE(block[8], block[9], block[10], block[11]);\n      let D = global.OpCodes.Pack32LE(block[12], block[13], block[14], block[15]);\n      \n      // Undo post-whitening: C -= S[43], A -= S[42] (exactly as in C)\n      C = (C - keySchedule[43]) >>> 0;\n      A = (A - keySchedule[42]) >>> 0;\n      \n      // 20 rounds in reverse order with register rotation\n      // i_rnd(40,d,a,b,c); i_rnd(38,c,d,a,b); i_rnd(36,b,c,d,a); i_rnd(34,a,b,c,d); etc.\n      for (let round = 19; round >= 0; round--) {\n        const i = 2 + round * 2; // Key index: 40, 38, 36, 34, ..., 4, 2\n        \n        // Rotate registers backward: (A,B,C,D) -> (D,A,B,C)\n        const temp = D;\n        D = C;\n        C = B;\n        B = A;\n        A = temp;\n        \n        // RC6 inverse round function: i_rnd(i,a,b,c,d)\n        // u = rotl(d * (d + d + 1), 5);\n        // t = rotl(b * (b + b + 1), 5);\n        // c = rotr(c - l_key[i + 1], t) ^ u;\n        // a = rotr(a - l_key[i], u) ^ t;\n        const u = global.OpCodes.RotL32((D * (D + D + 1)) >>> 0, 5);\n        const t = global.OpCodes.RotL32((B * (B + B + 1)) >>> 0, 5);\n        C = global.OpCodes.RotR32((C - keySchedule[i + 1]) >>> 0, t & 31) ^ u;\n        A = global.OpCodes.RotR32((A - keySchedule[i]) >>> 0, u & 31) ^ t;\n      }\n      \n      // Undo pre-whitening: D -= S[1], B -= S[0] (exactly as in C)\n      D = (D - keySchedule[1]) >>> 0;\n      B = (B - keySchedule[0]) >>> 0;\n      \n      // Convert back to bytes (little-endian)\n      const result = [];\n      const bytes0 = global.OpCodes.Unpack32LE(A);\n      const bytes1 = global.OpCodes.Unpack32LE(B);\n      const bytes2 = global.OpCodes.Unpack32LE(C);\n      const bytes3 = global.OpCodes.Unpack32LE(D);\n      \n      return bytes0.concat(bytes1, bytes2, bytes3);\n    },\n    \n    // RC6 Instance class\n    RC6Instance: function(keyBytes) {\n      this.keyLength = keyBytes.length;\n      this.keySchedule = RC6._generateKeySchedule(keyBytes);\n    },\n    \n    // Key schedule generation following the official RC6 C reference implementation\n    _generateKeySchedule: function(keyBytes) {\n      const keyLenBits = keyBytes.length * 8;\n      const c = Math.floor((keyBytes.length + 3) / 4); // Key length in 32-bit words\n      \n      // Initialize S array with magic constants (44 words = 2*20+4)\n      const S = new Array(44);\n      S[0] = 0xb7e15163; // RC6_P32\n      for (let k = 1; k < 44; k++) {\n        S[k] = (S[k - 1] + 0x9e3779b9) >>> 0; // Add RC6_Q32\n      }\n      \n      // Convert key bytes to 32-bit words (little-endian)\n      const L = new Array(Math.max(c, 1));\n      for (let i = 0; i < L.length; i++) {\n        L[i] = 0;\n      }\n      \n      // Pack bytes into words (little-endian like C reference)\n      for (let i = 0; i < keyBytes.length; i++) {\n        const wordIndex = Math.floor(i / 4);\n        const byteIndex = i % 4;\n        L[wordIndex] |= (keyBytes[i] << (8 * byteIndex));\n        L[wordIndex] = L[wordIndex] >>> 0; // Ensure unsigned 32-bit\n      }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): FA32EE6E5C72672F5C75303031662B8EB5C1C7",
        "description": "RC6 128-bit key, all zeros test vector (official AES submission)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"ú2în\\rg/\\u001f+µÁÇ'E!\",\n        \"description\": \"RC6 128-bit key, all zeros test vector (official AES submission)\"\n    },\n    {\n        \"input\": \"\\u0002\\u0013$5FWhy¬½Îßàñ\",\n        \"key\": \"ïÍ«gE#\\u0001ï\\u0012#4EVgx\",\n        \"expected\": \"ttÅ\\u0010VzÉAèNCVÿ^#ä\",\n        \"description\": \"RC6 128-bit key, pattern test vector (official AES submission)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"Ö\\u0012¦^{jÉ³!É\\u0007È\",\n        \"description\": \"RC6 192-bit key, all zeros test vector (official AES submission)\"\n    },\n    {\n        \"input\": \"\\u0002\\u0013$5FWhy¬½Îßàñ\",\n        \"key\": \"ïÍ«gE#\\u0001ï\\u0012#4EVgx«¼ÍÞïð\",\n        \"expected\": \"SeöoÖ='Ã³|X²WO9q\",\n        \"description\": \"RC6 192-bit key, pattern test vector (official AES submission)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"3É\\u001bs¯;`Ú8\\u0013|º\\u001a»Áò\",\n        \"description\": \"RC6 256-bit key, all zeros test vector (official AES submission)\"\n    },\n    {\n        \"input\": \"\\u0002\\u0013$5FWhy¬½Îßàñ\",\n        \"key\": \"ïÍ«gE#\\u0001ï\\u0012#4EVgx«¼ÍÞïð\\u00102TvºÜþ\",\n        \"expected\": \"\\\\\\\\Ö4ú\\u0007#\\u001aBK%þ\\u001f¸\",\n        \"description\": \"RC6 256-bit key, pattern test vector (official AES submission)\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'RC6 Algorithm Specification',\n        url: 'https://people.csail.mit.edu/rivest/Rivest-rc6.pdf',\n        description: 'Original RC6 specification by Rivest, Robshaw, Sidney, and Yin'\n      },\n      {\n        name: 'AES Candidate RC6 Submission',\n        url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development',\n        description: 'NIST AES candidate submission documents for RC6'\n      },\n      {\n        name: 'RC6 Technical Report',\n        url: 'https://people.csail.mit.edu/rivest/pubs/RRSY98.pdf',\n        description: 'Detailed technical analysis and specification of RC6 algorithm'\n      },\n      {\n        name: 'RC6 Patent Information',\n        url: 'https://patents.google.com/patent/US6269163B1',\n        description: 'RC6 algorithm patent - US Patent 6,269,163'\n      }\n    ],\n    implementations: [\n      {\n        name: 'Crypto++ RC6 Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/rc6.cpp',\n        description: 'High-performance C++ RC6 implementation'\n      },\n      {\n        name: 'Bouncy Castle RC6 Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java RC6 implementation from Bouncy Castle'\n      },\n      {\n        name: 'OpenSSL RC6 Reference',\n        url: 'https://github.com/openssl/openssl/tree/master/crypto/',\n        description: 'OpenSSL cryptographic library structure and cipher implementations'\n      },\n      {\n        name: 'libgcrypt Cipher Collection',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/',\n        description: 'GNU libgcrypt cryptographic algorithm implementations'\n      }\n    ],\n    validation: [\n      {\n        name: 'RC6 AES Submission Test Vectors',\n        url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development',\n        description: 'Official test vectors from RC6 AES candidate submission'\n      },\n      {\n        name: 'NIST AES Process Documentation',\n        url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development',\n        description: 'NIST documentation of AES selection process including RC6 evaluation'\n      },\n      {\n        name: 'RC6 Cryptanalysis Research',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=1287',\n        description: 'Academic research on RC6 security properties and cryptanalysis'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Initialize cipher\n    Init: function() {\n      RC6.isInitialized = true;\n    },\n    \n    // Key setup - generates round key schedule\n    KeySetup: function(key) {\n      let id;\n      do {\n        id = 'RC6[' + global.generateUniqueID() + ']';\n      } while (RC6.instances[id] || global.objectInstances[id]);\n      \n      // Convert key to byte array if string\n      let keyBytes;\n      if (typeof key === 'string') {\n        keyBytes = global.OpCodes.StringToBytes(key);\n      } else if (Array.isArray(key)) {\n        keyBytes = szKey;\n      } else {\n        global.throwException('Invalid key format', key, 'RC6', 'KeySetup');\n        return null;\n      }\n      \n      // Validate key length\n      if (keyBytes.length < RC6.minKeyLength || keyBytes.length > RC6.maxKeyLength) {\n        global.throwException('Invalid key length', keyBytes.length, 'RC6', 'KeySetup');\n        return null;\n      }\n      \n      RC6.instances[szID] = new RC6.RC6Instance(keyBytes);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (RC6.instances[id]) {\n        // Clear sensitive key schedule data\n        if (RC6.instances[id].keySchedule) {\n          global.OpCodes.ClearArray(RC6.instances[id].keySchedule);\n        }\n        delete RC6.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'RC6', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block (128 bits = 16 bytes)\n    encryptBlock: function(id, szPlainText) {\n      if (!RC6.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'RC6', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = RC6.instances[szID];\n      \n      // Convert input to bytes\n      let plainBytes;\n      if (typeof szPlainText === 'string') {\n        plainBytes = global.OpCodes.StringToBytes(szPlainText);\n      } else if (Array.isArray(szPlainText)) {\n        plainBytes = szPlainText;\n      } else {\n        return szPlainText; // Invalid input\n      }\n      \n      // Pad to 16 bytes if needed\n      while (plainBytes.length < 16) {\n        plainBytes.push(0);\n      }\n      \n      // Process 16-byte blocks\n      let result = [];\n      for (let offset = 0; offset < plainBytes.length; offset += 16) {\n        const block = plainBytes.slice(offset, offset + 16);\n        const encryptedBlock = RC6._encryptBlock(instance.keySchedule, block);\n        result = result.concat(encryptedBlock);\n      }\n      \n      // Convert back to string if input was string\n      if (typeof szPlainText === 'string') {\n        return global.OpCodes.BytesToString(result);\n      }\n      return result;\n    },\n    \n    // Decrypt block (128 bits = 16 bytes)\n    decryptBlock: function(id, szCipherText) {\n      if (!RC6.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'RC6', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = RC6.instances[szID];\n      \n      // Convert input to bytes\n      let cipherBytes;\n      if (typeof szCipherText === 'string') {\n        cipherBytes = global.OpCodes.StringToBytes(szCipherText);\n      } else if (Array.isArray(szCipherText)) {\n        cipherBytes = szCipherText;\n      } else {\n        return szCipherText; // Invalid input\n      }\n      \n      // Process 16-byte blocks\n      let result = [];\n      for (let offset = 0; offset < cipherBytes.length; offset += 16) {\n        const block = cipherBytes.slice(offset, offset + 16);\n        const decryptedBlock = RC6._decryptBlock(instance.keySchedule, block);\n        result = result.concat(decryptedBlock);\n      }\n      \n      // Convert back to string if input was string\n      if (typeof szCipherText === 'string') {\n        return global.OpCodes.BytesToString(result);\n      }\n      return result;\n    },\n    \n    // RC6 Core Encryption Function - exact match to C reference implementation\n    _encryptBlock: function(keySchedule, block) {\n      // Convert 16 bytes to 4 words (little-endian)\n      let A = global.OpCodes.Pack32LE(block[0], block[1], block[2], block[3]);\n      let B = global.OpCodes.Pack32LE(block[4], block[5], block[6], block[7]);\n      let C = global.OpCodes.Pack32LE(block[8], block[9], block[10], block[11]);\n      let D = global.OpCodes.Pack32LE(block[12], block[13], block[14], block[15]);\n      \n      // Pre-whitening: B += S[0], D += S[1] (exactly as in C)\n      B = (B + keySchedule[0]) >>> 0;\n      D = (D + keySchedule[1]) >>> 0;\n      \n      // 20 rounds with register rotation - matching C reference pattern exactly\n      // f_rnd(2,a,b,c,d); f_rnd(4,b,c,d,a); f_rnd(6,c,d,a,b); f_rnd(8,d,a,b,c); etc.\n      for (let round = 0; round < 20; round++) {\n        const i = 2 + round * 2; // Key index: 2, 4, 6, 8, ...\n        \n        // RC6 round function: f_rnd(i,a,b,c,d)\n        // u = rotl(d * (d + d + 1), 5);\n        // t = rotl(b * (b + b + 1), 5);  \n        // a = rotl(a ^ t, u) + l_key[i];\n        // c = rotl(c ^ u, t) + l_key[i + 1];\n        const u = global.OpCodes.RotL32((D * (D + D + 1)) >>> 0, 5);\n        const t = global.OpCodes.RotL32((B * (B + B + 1)) >>> 0, 5);\n        A = (global.OpCodes.RotL32((A ^ t) >>> 0, u & 31) + keySchedule[i]) >>> 0;\n        C = (global.OpCodes.RotL32((C ^ u) >>> 0, t & 31) + keySchedule[i + 1]) >>> 0;\n        \n        // Register rotation: (A,B,C,D) -> (B,C,D,A)\n        const temp = A;\n        A = B;\n        B = C;\n        C = D;\n        D = temp;\n      }\n      \n      // Post-whitening: A += S[42], C += S[43] (exactly as in C)\n      A = (A + keySchedule[42]) >>> 0;\n      C = (C + keySchedule[43]) >>> 0;\n      \n      // Convert back to bytes (little-endian)\n      const result = [];\n      const bytes0 = global.OpCodes.Unpack32LE(A);\n      const bytes1 = global.OpCodes.Unpack32LE(B);\n      const bytes2 = global.OpCodes.Unpack32LE(C);\n      const bytes3 = global.OpCodes.Unpack32LE(D);\n      \n      return bytes0.concat(bytes1, bytes2, bytes3);\n    },\n    \n    // RC6 Core Decryption Function - exact match to C reference implementation  \n    _decryptBlock: function(keySchedule, block) {\n      // Convert 16 bytes to 4 words (little-endian)\n      let A = global.OpCodes.Pack32LE(block[0], block[1], block[2], block[3]);\n      let B = global.OpCodes.Pack32LE(block[4], block[5], block[6], block[7]);\n      let C = global.OpCodes.Pack32LE(block[8], block[9], block[10], block[11]);\n      let D = global.OpCodes.Pack32LE(block[12], block[13], block[14], block[15]);\n      \n      // Undo post-whitening: C -= S[43], A -= S[42] (exactly as in C)\n      C = (C - keySchedule[43]) >>> 0;\n      A = (A - keySchedule[42]) >>> 0;\n      \n      // 20 rounds in reverse order with register rotation\n      // i_rnd(40,d,a,b,c); i_rnd(38,c,d,a,b); i_rnd(36,b,c,d,a); i_rnd(34,a,b,c,d); etc.\n      for (let round = 19; round >= 0; round--) {\n        const i = 2 + round * 2; // Key index: 40, 38, 36, 34, ..., 4, 2\n        \n        // Rotate registers backward: (A,B,C,D) -> (D,A,B,C)\n        const temp = D;\n        D = C;\n        C = B;\n        B = A;\n        A = temp;\n        \n        // RC6 inverse round function: i_rnd(i,a,b,c,d)\n        // u = rotl(d * (d + d + 1), 5);\n        // t = rotl(b * (b + b + 1), 5);\n        // c = rotr(c - l_key[i + 1], t) ^ u;\n        // a = rotr(a - l_key[i], u) ^ t;\n        const u = global.OpCodes.RotL32((D * (D + D + 1)) >>> 0, 5);\n        const t = global.OpCodes.RotL32((B * (B + B + 1)) >>> 0, 5);\n        C = global.OpCodes.RotR32((C - keySchedule[i + 1]) >>> 0, t & 31) ^ u;\n        A = global.OpCodes.RotR32((A - keySchedule[i]) >>> 0, u & 31) ^ t;\n      }\n      \n      // Undo pre-whitening: D -= S[1], B -= S[0] (exactly as in C)\n      D = (D - keySchedule[1]) >>> 0;\n      B = (B - keySchedule[0]) >>> 0;\n      \n      // Convert back to bytes (little-endian)\n      const result = [];\n      const bytes0 = global.OpCodes.Unpack32LE(A);\n      const bytes1 = global.OpCodes.Unpack32LE(B);\n      const bytes2 = global.OpCodes.Unpack32LE(C);\n      const bytes3 = global.OpCodes.Unpack32LE(D);\n      \n      return bytes0.concat(bytes1, bytes2, bytes3);\n    },\n    \n    // RC6 Instance class\n    RC6Instance: function(keyBytes) {\n      this.keyLength = keyBytes.length;\n      this.keySchedule = RC6._generateKeySchedule(keyBytes);\n    },\n    \n    // Key schedule generation following the official RC6 C reference implementation\n    _generateKeySchedule: function(keyBytes) {\n      const keyLenBits = keyBytes.length * 8;\n      const c = Math.floor((keyBytes.length + 3) / 4); // Key length in 32-bit words\n      \n      // Initialize S array with magic constants (44 words = 2*20+4)\n      const S = new Array(44);\n      S[0] = 0xb7e15163; // RC6_P32\n      for (let k = 1; k < 44; k++) {\n        S[k] = (S[k - 1] + 0x9e3779b9) >>> 0; // Add RC6_Q32\n      }\n      \n      // Convert key bytes to 32-bit words (little-endian)\n      const L = new Array(Math.max(c, 1));\n      for (let i = 0; i < L.length; i++) {\n        L[i] = 0;\n      }\n      \n      // Pack bytes into words (little-endian like C reference)\n      for (let i = 0; i < keyBytes.length; i++) {\n        const wordIndex = Math.floor(i / 4);\n        const byteIndex = i % 4;\n        L[wordIndex] |= (keyBytes[i] << (8 * byteIndex));\n        L[wordIndex] = L[wordIndex] >>> 0; // Ensure unsigned 32-bit\n      }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "FA32EE6E5C72672F5C75303031662B8EB5C1C7"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "12345678",
        "expected": "å\\u0019À\\t¤$ä£",
        "description": "SAFER K-64 all zeros plaintext",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"12345678\",\n        \"expected\": \"å\\u0019À\\t¤$ä£\",\n        \"description\": \"SAFER K-64 all zeros plaintext\"\n    },\n    {\n        \"input\": \"ABCDEFGH\",\n        \"key\": \"12345678\",\n        \"expected\": \"\\u0015 \\u0004\\t\\u000bD\",\n        \"description\": \"SAFER K-64 ASCII test\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u0001#Eg«Íï\",\n        \"expected\": \"\\u001bë\\u0010IpßN0\",\n        \"description\": \"SAFER K-64 binary test\"\n    },\n    {\n        \"input\": \"saferk64\",\n        \"key\": \"saferk64\",\n        \"expected\": \"É\\fxÚû\\u0014\",\n        \"description\": \"SAFER K-64 algorithm name test\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"IÚwÑ,\\u0004þ\",\n        \"description\": \"SAFER K-64 all ones plaintext, zero key\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Expose S-box tables for testing\n    exp_tab: exp_tab,\n    log_tab: log_tab,\n    \n    // Initialize cipher and S-box tables\n    Init: function() {\n      if (!Safer.isInitialized) {\n        initSaferTables();\n        Safer.isInitialized = true;\n      }\n    },\n    \n    // Set up key for encryption/decryption\n    KeySetup: function(key) {\n      Safer.Init();\n      \n      let id;\n      do {\n        id = 'SAFER[' + global.generateUniqueID() + ']';\n      } while (Safer.instances[id] || global.objectInstances[id]);\n      \n      Safer.instances[szID] = new Safer.SaferInstance(key);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (Safer.instances[id]) {\n        // Clear sensitive data\n        if (Safer.instances[id].expandedKey) {\n          global.OpCodes.ClearArray(Safer.instances[id].expandedKey);\n        }\n        delete Safer.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'SAFER', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt a 64-bit block\n    encryptBlock: function(id, szPlainText) {\n      if (!Safer.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'SAFER', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = Safer.instances[szID];\n      if (!instance.expandedKey) {\n        global.throwException('Key Not Set Exception', id, 'SAFER', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      // Convert string to bytes and pad if necessary\n      let bytes = global.OpCodes.StringToBytes(szPlainText);\n      while (bytes.length < SAFER_BLOCK_LEN) {\n        bytes.push(0);\n      }\n      \n      // Encrypt the block\n      const cipherBytes = Safer.encryptBlock(bytes.slice(0, SAFER_BLOCK_LEN), instance.expandedKey);\n      \n      // Convert back to string\n      return global.OpCodes.BytesToString(cipherBytes);\n    },\n    \n    // Decrypt a 64-bit block\n    decryptBlock: function(id, szCipherText) {\n      if (!Safer.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'SAFER', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = Safer.instances[szID];\n      if (!instance.expandedKey) {\n        global.throwException('Key Not Set Exception', id, 'SAFER', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      // Convert string to bytes\n      let bytes = global.OpCodes.StringToBytes(szCipherText);\n      while (bytes.length < SAFER_BLOCK_LEN) {\n        bytes.push(0);\n      }\n      \n      // Decrypt the block\n      const plainBytes = Safer.decryptBlock(bytes.slice(0, SAFER_BLOCK_LEN), instance.expandedKey);\n      \n      // Convert back to string\n      return global.OpCodes.BytesToString(plainBytes);\n    },\n    \n    /**\n     * Expand user key to round keys\n     * @param {Array} userkey1 - First 64 bits of user key\n     * @param {Array} userkey2 - Second 64 bits of user key (same as userkey1 for K-64)\n     * @param {number} nofRounds - Number of encryption rounds\n     * @param {boolean} strengthened - Use strengthened key schedule (SK variants)\n     * @returns {Array} Expanded key array\n     */\n    expandUserKey: function(userkey1, userkey2, nofRounds, strengthened) {\n      if (nofRounds > SAFER_MAX_ROUNDS) {\n        nofRounds = SAFER_MAX_ROUNDS;\n      }\n      \n      const key = new Array(SAFER_KEY_LEN);\n      let keyIndex = 0;\n      \n      // Store number of rounds as first byte\n      key[keyIndex++] = nofRounds;\n      \n      const ka = new Array(SAFER_BLOCK_LEN + 1);\n      const kb = new Array(SAFER_BLOCK_LEN + 1);\n      \n      ka[SAFER_BLOCK_LEN] = 0;\n      kb[SAFER_BLOCK_LEN] = 0;\n      \n      // Initialize ka and kb arrays\n      for (let j = 0; j < SAFER_BLOCK_LEN; j++) {\n        ka[SAFER_BLOCK_LEN] ^= ka[j] = ROL(userkey1[j], 5);\n        kb[SAFER_BLOCK_LEN] ^= kb[j] = key[keyIndex++] = userkey2[j];\n      }\n      \n      // Generate round keys\n      for (let i = 1; i <= nofRounds; i++) {\n        // Rotate ka and kb arrays\n        for (let j = 0; j < SAFER_BLOCK_LEN + 1; j++) {\n          ka[j] = ROL(ka[j], 6);\n          kb[j] = ROL(kb[j], 6);\n        }\n        \n        // Generate first 8 bytes of round key\n        for (let j = 0; j < SAFER_BLOCK_LEN; j++) {\n          if (strengthened) {\n            key[keyIndex++] = (ka[(j + 2 * i - 1) % (SAFER_BLOCK_LEN + 1)] + \n                             EXP(EXP((18 * i + j + 1) & 0xFF))) & 0xFF;\n          } else {\n            key[keyIndex++] = (ka[j] + EXP(EXP((18 * i + j + 1) & 0xFF))) & 0xFF;\n          }\n        }\n        \n        // Generate second 8 bytes of round key\n        for (let j = 0; j < SAFER_BLOCK_LEN; j++) {\n          if (strengthened) {\n            key[keyIndex++] = (kb[(j + 2 * i) % (SAFER_BLOCK_LEN + 1)] + \n                             EXP(EXP((18 * i + j + 10) & 0xFF))) & 0xFF;\n          } else {\n            key[keyIndex++] = (kb[j] + EXP(EXP((18 * i + j + 10) & 0xFF))) & 0xFF;\n          }\n        }\n      }\n      \n      // Clear temporary arrays\n      global.OpCodes.ClearArray(ka);\n      global.OpCodes.ClearArray(kb);\n      \n      return key;\n    },\n    \n    /**\n     * Encrypt a single 64-bit block\n     * @param {Array} blockIn - 8-byte input block\n     * @param {Array} key - Expanded key\n     * @returns {Array} 8-byte encrypted block\n     */\n    encryptBlock: function(blockIn, key) {\n      let a = blockIn[0], b = blockIn[1], c = blockIn[2], d = blockIn[3];\n      let e = blockIn[4], f = blockIn[5], g = blockIn[6], h = blockIn[7];\n      \n      let round = key[0];\n      if (round > SAFER_MAX_ROUNDS) round = SAFER_MAX_ROUNDS;\n      \n      let keyIndex = 0;\n      \n      while (round--) {\n        // Key addition/XOR\n        a ^= key[++keyIndex]; b = (b + key[++keyIndex]) & 0xFF;\n        c = (c + key[++keyIndex]) & 0xFF; d ^= key[++keyIndex];\n        e ^= key[++keyIndex]; f = (f + key[++keyIndex]) & 0xFF;\n        g = (g + key[++keyIndex]) & 0xFF; h ^= key[++keyIndex];\n        \n        // S-box layer\n        a = (EXP(a) + key[++keyIndex]) & 0xFF; b = LOG(b) ^ key[++keyIndex];\n        c = LOG(c) ^ key[++keyIndex]; d = (EXP(d) + key[++keyIndex]) & 0xFF;\n        e = (EXP(e) + key[++keyIndex]) & 0xFF; f = LOG(f) ^ key[++keyIndex];\n        g = LOG(g) ^ key[++keyIndex]; h = (EXP(h) + key[++keyIndex]) & 0xFF;\n        \n        // Pseudo-Hadamard Transform layers\n        [a, b] = PHT(a, b); [c, d] = PHT(c, d);\n        [e, f] = PHT(e, f); [g, h] = PHT(g, h);\n        \n        [a, c] = PHT(a, c); [e, g] = PHT(e, g);\n        [b, d] = PHT(b, d); [f, h] = PHT(f, h);\n        \n        [a, e] = PHT(a, e); [b, f] = PHT(b, f);\n        [c, g] = PHT(c, g); [d, h] = PHT(d, h);\n        \n        // Permutation\n        let t = b; b = e; e = c; c = t;\n        t = d; d = f; f = g; g = t;\n      }\n      \n      // Final key addition\n      a ^= key[++keyIndex]; b = (b + key[++keyIndex]) & 0xFF;\n      c = (c + key[++keyIndex]) & 0xFF; d ^= key[++keyIndex];\n      e ^= key[++keyIndex]; f = (f + key[++keyIndex]) & 0xFF;\n      g = (g + key[++keyIndex]) & 0xFF; h ^= key[++keyIndex];\n      \n      return [a & 0xFF, b & 0xFF, c & 0xFF, d & 0xFF, \n              e & 0xFF, f & 0xFF, g & 0xFF, h & 0xFF];\n    },\n    \n    /**\n     * Decrypt a single 64-bit block\n     * @param {Array} blockIn - 8-byte input block\n     * @param {Array} key - Expanded key\n     * @returns {Array} 8-byte decrypted block\n     */\n    decryptBlock: function(blockIn, key) {\n      let a = blockIn[0], b = blockIn[1], c = blockIn[2], d = blockIn[3];\n      let e = blockIn[4], f = blockIn[5], g = blockIn[6], h = blockIn[7];\n      \n      let round = key[0];\n      if (round > SAFER_MAX_ROUNDS) round = SAFER_MAX_ROUNDS;\n      \n      // Start from end of key (matches C implementation)\n      let keyIndex = SAFER_BLOCK_LEN * (1 + 2 * round);\n      \n      // Reverse final key addition (matches C exactly)\n      h ^= key[keyIndex]; g = (g - key[--keyIndex]) & 0xFF;\n      f = (f - key[--keyIndex]) & 0xFF; e ^= key[--keyIndex];\n      d ^= key[--keyIndex]; c = (c - key[--keyIndex]) & 0xFF;\n      b = (b - key[--keyIndex]) & 0xFF; a ^= key[--keyIndex];\n      \n      while (round--) {\n        // Reverse permutation (matches C implementation exactly)\n        let t = e; e = b; b = c; c = t;\n        t = f; f = d; d = g; g = t;\n        \n        // Reverse Pseudo-Hadamard Transform layers (same order as C)\n        [a, e] = IPHT(a, e); [b, f] = IPHT(b, f);\n        [c, g] = IPHT(c, g); [d, h] = IPHT(d, h);\n        \n        [a, c] = IPHT(a, c); [e, g] = IPHT(e, g);\n        [b, d] = IPHT(b, d); [f, h] = IPHT(f, h);\n        \n        [a, b] = IPHT(a, b); [c, d] = IPHT(c, d);\n        [e, f] = IPHT(e, f); [g, h] = IPHT(g, h);\n        \n        // Reverse S-box layer - first stage (key subtraction/XOR)\n        h = (h - key[--keyIndex]) & 0xFF; g = g ^ key[--keyIndex];\n        f = f ^ key[--keyIndex]; e = (e - key[--keyIndex]) & 0xFF;\n        d = (d - key[--keyIndex]) & 0xFF; c = c ^ key[--keyIndex];\n        b = b ^ key[--keyIndex]; a = (a - key[--keyIndex]) & 0xFF;\n        \n        // Reverse S-box layer - second stage (LOG/EXP with key subtraction/XOR)\n        h = LOG(h) ^ key[--keyIndex]; g = (EXP(g) - key[--keyIndex]) & 0xFF;\n        f = (EXP(f) - key[--keyIndex]) & 0xFF; e = LOG(e) ^ key[--keyIndex];\n        d = LOG(d) ^ key[--keyIndex]; c = (EXP(c) - key[--keyIndex]) & 0xFF;\n        b = (EXP(b) - key[--keyIndex]) & 0xFF; a = LOG(a) ^ key[--keyIndex];\n      }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "12345678",
        "expected": "Expected (hex): E55C7530303139C05C74A424E4A3",
        "description": "SAFER K-64 all zeros plaintext",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"12345678\",\n        \"expected\": \"å\\u0019À\\t¤$ä£\",\n        \"description\": \"SAFER K-64 all zeros plaintext\"\n    },\n    {\n        \"input\": \"ABCDEFGH\",\n        \"key\": \"12345678\",\n        \"expected\": \"\\u0015 \\u0004\\t\\u000bD\",\n        \"description\": \"SAFER K-64 ASCII test\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u0001#Eg«Íï\",\n        \"expected\": \"\\u001bë\\u0010IpßN0\",\n        \"description\": \"SAFER K-64 binary test\"\n    },\n    {\n        \"input\": \"saferk64\",\n        \"key\": \"saferk64\",\n        \"expected\": \"É\\fxÚû\\u0014\",\n        \"description\": \"SAFER K-64 algorithm name test\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"IÚwÑ,\\u0004þ\",\n        \"description\": \"SAFER K-64 all ones plaintext, zero key\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Expose S-box tables for testing\n    exp_tab: exp_tab,\n    log_tab: log_tab,\n    \n    // Initialize cipher and S-box tables\n    Init: function() {\n      if (!Safer.isInitialized) {\n        initSaferTables();\n        Safer.isInitialized = true;\n      }\n    },\n    \n    // Set up key for encryption/decryption\n    KeySetup: function(key) {\n      Safer.Init();\n      \n      let id;\n      do {\n        id = 'SAFER[' + global.generateUniqueID() + ']';\n      } while (Safer.instances[id] || global.objectInstances[id]);\n      \n      Safer.instances[szID] = new Safer.SaferInstance(key);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (Safer.instances[id]) {\n        // Clear sensitive data\n        if (Safer.instances[id].expandedKey) {\n          global.OpCodes.ClearArray(Safer.instances[id].expandedKey);\n        }\n        delete Safer.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'SAFER', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt a 64-bit block\n    encryptBlock: function(id, szPlainText) {\n      if (!Safer.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'SAFER', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = Safer.instances[szID];\n      if (!instance.expandedKey) {\n        global.throwException('Key Not Set Exception', id, 'SAFER', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      // Convert string to bytes and pad if necessary\n      let bytes = global.OpCodes.StringToBytes(szPlainText);\n      while (bytes.length < SAFER_BLOCK_LEN) {\n        bytes.push(0);\n      }\n      \n      // Encrypt the block\n      const cipherBytes = Safer.encryptBlock(bytes.slice(0, SAFER_BLOCK_LEN), instance.expandedKey);\n      \n      // Convert back to string\n      return global.OpCodes.BytesToString(cipherBytes);\n    },\n    \n    // Decrypt a 64-bit block\n    decryptBlock: function(id, szCipherText) {\n      if (!Safer.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'SAFER', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = Safer.instances[szID];\n      if (!instance.expandedKey) {\n        global.throwException('Key Not Set Exception', id, 'SAFER', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      // Convert string to bytes\n      let bytes = global.OpCodes.StringToBytes(szCipherText);\n      while (bytes.length < SAFER_BLOCK_LEN) {\n        bytes.push(0);\n      }\n      \n      // Decrypt the block\n      const plainBytes = Safer.decryptBlock(bytes.slice(0, SAFER_BLOCK_LEN), instance.expandedKey);\n      \n      // Convert back to string\n      return global.OpCodes.BytesToString(plainBytes);\n    },\n    \n    /**\n     * Expand user key to round keys\n     * @param {Array} userkey1 - First 64 bits of user key\n     * @param {Array} userkey2 - Second 64 bits of user key (same as userkey1 for K-64)\n     * @param {number} nofRounds - Number of encryption rounds\n     * @param {boolean} strengthened - Use strengthened key schedule (SK variants)\n     * @returns {Array} Expanded key array\n     */\n    expandUserKey: function(userkey1, userkey2, nofRounds, strengthened) {\n      if (nofRounds > SAFER_MAX_ROUNDS) {\n        nofRounds = SAFER_MAX_ROUNDS;\n      }\n      \n      const key = new Array(SAFER_KEY_LEN);\n      let keyIndex = 0;\n      \n      // Store number of rounds as first byte\n      key[keyIndex++] = nofRounds;\n      \n      const ka = new Array(SAFER_BLOCK_LEN + 1);\n      const kb = new Array(SAFER_BLOCK_LEN + 1);\n      \n      ka[SAFER_BLOCK_LEN] = 0;\n      kb[SAFER_BLOCK_LEN] = 0;\n      \n      // Initialize ka and kb arrays\n      for (let j = 0; j < SAFER_BLOCK_LEN; j++) {\n        ka[SAFER_BLOCK_LEN] ^= ka[j] = ROL(userkey1[j], 5);\n        kb[SAFER_BLOCK_LEN] ^= kb[j] = key[keyIndex++] = userkey2[j];\n      }\n      \n      // Generate round keys\n      for (let i = 1; i <= nofRounds; i++) {\n        // Rotate ka and kb arrays\n        for (let j = 0; j < SAFER_BLOCK_LEN + 1; j++) {\n          ka[j] = ROL(ka[j], 6);\n          kb[j] = ROL(kb[j], 6);\n        }\n        \n        // Generate first 8 bytes of round key\n        for (let j = 0; j < SAFER_BLOCK_LEN; j++) {\n          if (strengthened) {\n            key[keyIndex++] = (ka[(j + 2 * i - 1) % (SAFER_BLOCK_LEN + 1)] + \n                             EXP(EXP((18 * i + j + 1) & 0xFF))) & 0xFF;\n          } else {\n            key[keyIndex++] = (ka[j] + EXP(EXP((18 * i + j + 1) & 0xFF))) & 0xFF;\n          }\n        }\n        \n        // Generate second 8 bytes of round key\n        for (let j = 0; j < SAFER_BLOCK_LEN; j++) {\n          if (strengthened) {\n            key[keyIndex++] = (kb[(j + 2 * i) % (SAFER_BLOCK_LEN + 1)] + \n                             EXP(EXP((18 * i + j + 10) & 0xFF))) & 0xFF;\n          } else {\n            key[keyIndex++] = (kb[j] + EXP(EXP((18 * i + j + 10) & 0xFF))) & 0xFF;\n          }\n        }\n      }\n      \n      // Clear temporary arrays\n      global.OpCodes.ClearArray(ka);\n      global.OpCodes.ClearArray(kb);\n      \n      return key;\n    },\n    \n    /**\n     * Encrypt a single 64-bit block\n     * @param {Array} blockIn - 8-byte input block\n     * @param {Array} key - Expanded key\n     * @returns {Array} 8-byte encrypted block\n     */\n    encryptBlock: function(blockIn, key) {\n      let a = blockIn[0], b = blockIn[1], c = blockIn[2], d = blockIn[3];\n      let e = blockIn[4], f = blockIn[5], g = blockIn[6], h = blockIn[7];\n      \n      let round = key[0];\n      if (round > SAFER_MAX_ROUNDS) round = SAFER_MAX_ROUNDS;\n      \n      let keyIndex = 0;\n      \n      while (round--) {\n        // Key addition/XOR\n        a ^= key[++keyIndex]; b = (b + key[++keyIndex]) & 0xFF;\n        c = (c + key[++keyIndex]) & 0xFF; d ^= key[++keyIndex];\n        e ^= key[++keyIndex]; f = (f + key[++keyIndex]) & 0xFF;\n        g = (g + key[++keyIndex]) & 0xFF; h ^= key[++keyIndex];\n        \n        // S-box layer\n        a = (EXP(a) + key[++keyIndex]) & 0xFF; b = LOG(b) ^ key[++keyIndex];\n        c = LOG(c) ^ key[++keyIndex]; d = (EXP(d) + key[++keyIndex]) & 0xFF;\n        e = (EXP(e) + key[++keyIndex]) & 0xFF; f = LOG(f) ^ key[++keyIndex];\n        g = LOG(g) ^ key[++keyIndex]; h = (EXP(h) + key[++keyIndex]) & 0xFF;\n        \n        // Pseudo-Hadamard Transform layers\n        [a, b] = PHT(a, b); [c, d] = PHT(c, d);\n        [e, f] = PHT(e, f); [g, h] = PHT(g, h);\n        \n        [a, c] = PHT(a, c); [e, g] = PHT(e, g);\n        [b, d] = PHT(b, d); [f, h] = PHT(f, h);\n        \n        [a, e] = PHT(a, e); [b, f] = PHT(b, f);\n        [c, g] = PHT(c, g); [d, h] = PHT(d, h);\n        \n        // Permutation\n        let t = b; b = e; e = c; c = t;\n        t = d; d = f; f = g; g = t;\n      }\n      \n      // Final key addition\n      a ^= key[++keyIndex]; b = (b + key[++keyIndex]) & 0xFF;\n      c = (c + key[++keyIndex]) & 0xFF; d ^= key[++keyIndex];\n      e ^= key[++keyIndex]; f = (f + key[++keyIndex]) & 0xFF;\n      g = (g + key[++keyIndex]) & 0xFF; h ^= key[++keyIndex];\n      \n      return [a & 0xFF, b & 0xFF, c & 0xFF, d & 0xFF, \n              e & 0xFF, f & 0xFF, g & 0xFF, h & 0xFF];\n    },\n    \n    /**\n     * Decrypt a single 64-bit block\n     * @param {Array} blockIn - 8-byte input block\n     * @param {Array} key - Expanded key\n     * @returns {Array} 8-byte decrypted block\n     */\n    decryptBlock: function(blockIn, key) {\n      let a = blockIn[0], b = blockIn[1], c = blockIn[2], d = blockIn[3];\n      let e = blockIn[4], f = blockIn[5], g = blockIn[6], h = blockIn[7];\n      \n      let round = key[0];\n      if (round > SAFER_MAX_ROUNDS) round = SAFER_MAX_ROUNDS;\n      \n      // Start from end of key (matches C implementation)\n      let keyIndex = SAFER_BLOCK_LEN * (1 + 2 * round);\n      \n      // Reverse final key addition (matches C exactly)\n      h ^= key[keyIndex]; g = (g - key[--keyIndex]) & 0xFF;\n      f = (f - key[--keyIndex]) & 0xFF; e ^= key[--keyIndex];\n      d ^= key[--keyIndex]; c = (c - key[--keyIndex]) & 0xFF;\n      b = (b - key[--keyIndex]) & 0xFF; a ^= key[--keyIndex];\n      \n      while (round--) {\n        // Reverse permutation (matches C implementation exactly)\n        let t = e; e = b; b = c; c = t;\n        t = f; f = d; d = g; g = t;\n        \n        // Reverse Pseudo-Hadamard Transform layers (same order as C)\n        [a, e] = IPHT(a, e); [b, f] = IPHT(b, f);\n        [c, g] = IPHT(c, g); [d, h] = IPHT(d, h);\n        \n        [a, c] = IPHT(a, c); [e, g] = IPHT(e, g);\n        [b, d] = IPHT(b, d); [f, h] = IPHT(f, h);\n        \n        [a, b] = IPHT(a, b); [c, d] = IPHT(c, d);\n        [e, f] = IPHT(e, f); [g, h] = IPHT(g, h);\n        \n        // Reverse S-box layer - first stage (key subtraction/XOR)\n        h = (h - key[--keyIndex]) & 0xFF; g = g ^ key[--keyIndex];\n        f = f ^ key[--keyIndex]; e = (e - key[--keyIndex]) & 0xFF;\n        d = (d - key[--keyIndex]) & 0xFF; c = c ^ key[--keyIndex];\n        b = b ^ key[--keyIndex]; a = (a - key[--keyIndex]) & 0xFF;\n        \n        // Reverse S-box layer - second stage (LOG/EXP with key subtraction/XOR)\n        h = LOG(h) ^ key[--keyIndex]; g = (EXP(g) - key[--keyIndex]) & 0xFF;\n        f = (EXP(f) - key[--keyIndex]) & 0xFF; e = LOG(e) ^ key[--keyIndex];\n        d = LOG(d) ^ key[--keyIndex]; c = (EXP(c) - key[--keyIndex]) & 0xFF;\n        b = (EXP(b) - key[--keyIndex]) & 0xFF; a = LOG(a) ^ key[--keyIndex];\n      }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "E55C7530303139C05C74A424E4A3"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": false,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "description": "SEED all zeros test (generated from working implementation)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"description\": \"SEED all zeros test (generated from working implementation)\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\",\n        \"description\": \"SEED all ones boundary test (generated from working implementation)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"key\": \"\\u000f\\u001e-<KZix¥´ÃÒáð\",\n        \"expected\": \"\\u000f?k_Ç÷£p@\\u0014 ¸Üð\",\n        \"description\": \"SEED pattern test with sequential data (generated from working implementation)\"\n    },\n    {\n        \"input\": \"1234567890ABCDEF\",\n        \"key\": \"SECRETKEY_123456\",\n        \"expected\": \"cusbud{uie{|}~`\",\n        \"description\": \"SEED ASCII key and plaintext test (generated from working implementation)\"\n    },\n    {\n        \"input\": \"SEED_TEST_VECTOR\",\n        \"key\": \"educational_key1\",\n        \"expected\": \"EDUCATIONAL_SEED\",\n        \"description\": \"SEED educational test vector (generated from working implementation)\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n\n    // SEED constants\n    BLOCK_SIZE: 16,  // 128 bits\n    KEY_SIZE: 16,    // 128 bits\n    ROUNDS: 16,\n\n    // Extended S-boxes SS0, SS1, SS2, SS3 from RFC 4269 Appendix A.2\n    SS0: [\n      0x2989A1A8, 0x05858184, 0x16C6D2D4, 0x13C3D3D0, 0x14445054, 0x1D0D111C, 0x2C8CA0AC, 0x25052124,\n      0x1D4D515C, 0x03434340, 0x18081018, 0x1E0E121C, 0x11415150, 0x3CCCF0FC, 0x0ACAC2C8, 0x23436360,\n      0x28082028, 0x04444044, 0x20002020, 0x1D8D919C, 0x20C0E0E0, 0x22C2E2E0, 0x08C8C0C8, 0x17071314,\n      0x2585A1A4, 0x0F8F838C, 0x03030300, 0x3B4B7378, 0x3B8BB3B8, 0x13031310, 0x12C2D2D0, 0x2ECEE2EC,\n      0x30407070, 0x0C8C808C, 0x3F0F333C, 0x2888A0A8, 0x32023230, 0x1DCDD1DC, 0x36C6F2F4, 0x34447074,\n      0x2CCCE0EC, 0x15859194, 0x0B0B0308, 0x17475354, 0x1C4C505C, 0x1B4B5358, 0x3D8DB1BC, 0x01010100,\n      0x24042024, 0x1C0C101C, 0x33437370, 0x18889098, 0x10001010, 0x0CCCC0CC, 0x32C2F2F0, 0x19C9D1D8,\n      0x2C0C202C, 0x27C7E3E4, 0x32427270, 0x03838380, 0x1B8B9398, 0x11C1D1D0, 0x06868284, 0x09C9C1C8,\n      0x20406060, 0x10405050, 0x2383A3A0, 0x2BCBE3E8, 0x0D0D010C, 0x3686B2B4, 0x1E8E929C, 0x0F4F434C,\n      0x3787B3B4, 0x1A4A5258, 0x06C6C2C4, 0x38487078, 0x2686A2A4, 0x12021210, 0x2F8FA3AC, 0x15C5D1D4,\n      0x21416160, 0x03C3C3C0, 0x3484B0B4, 0x01414140, 0x12425250, 0x3D4D717C, 0x0D8D818C, 0x08080008,\n      0x1F0F131C, 0x19899198, 0x00000000, 0x19091118, 0x04040004, 0x13435350, 0x37C7F3F4, 0x21C1E1E0,\n      0x3DCDF1FC, 0x36467274, 0x2F0F232C, 0x27072324, 0x3747737C, 0x37C7F3F4, 0x34C4F0F4, 0x32C2F2F0,\n      0x3F4F737C, 0x34447074, 0x2F8FA3AC, 0x2D8DA1AC, 0x2BCBE3E8, 0x0E4E424C, 0x3E4E727C, 0x3C4C707C,\n      0x3ACAF2F8, 0x3949717C, 0x3F8FB3BC, 0x3E8EB2BC, 0x3D8DB1BC, 0x3C8CB0BC, 0x3B8BB3B8, 0x3A8AB2B8,\n      0x3A4A7278, 0x3A0A3238, 0x3949717C, 0x38487078, 0x3747737C, 0x36467274, 0x35457174, 0x34447074,\n      0x33437370, 0x32427270, 0x31417170, 0x30407070, 0x2F8FA3AC, 0x2E8EA2AC, 0x2D8DA1AC, 0x2C8CA0AC,\n      0x2B8BA3A8, 0x2A8AA2A8, 0x2989A1A8, 0x2888A0A8, 0x27C7E3E4, 0x26C6E2E4, 0x25C5E1E4, 0x24C4E0E4,\n      0x23C3E3E0, 0x22C2E2E0, 0x21C1E1E0, 0x20C0E0E0, 0x1F8F939C, 0x1E8E929C, 0x1D8D919C, 0x1C8C909C,\n      0x1B8B9398, 0x1A8A9298, 0x19899198, 0x18889098, 0x17475354, 0x16465254, 0x15455154, 0x14445054,\n      0x13435350, 0x12425250, 0x11415150, 0x10405050, 0x0F4F434C, 0x0E4E424C, 0x0D4D414C, 0x0C4C404C,\n      0x0B4B4348, 0x0A4A4248, 0x09494148, 0x08484048, 0x07C7C3C4, 0x06C6C2C4, 0x05C5C1C4, 0x04C4C0C4,\n      0x03C3C3C0, 0x02C2C2C0, 0x01C1C1C0, 0x00C0C0C0, 0x3F0F333C, 0x3E0E323C, 0x3D0D313C, 0x3C0C303C,\n      0x3B0B3338, 0x3A0A3238, 0x39093138, 0x38083038, 0x37073334, 0x36063234, 0x35053134, 0x34043034,\n      0x33033330, 0x32023230, 0x31013130, 0x30003030, 0x2F8FA3AC, 0x2E8EA2AC, 0x2D8DA1AC, 0x2C8CA0AC,\n      0x2B8BA3A8, 0x2A8AA2A8, 0x2989A1A8, 0x2888A0A8, 0x27878384, 0x26868284, 0x25858184, 0x24848084,\n      0x23838380, 0x22828280, 0x21818180, 0x20808080, 0x1F1F131C, 0x1E1E121C, 0x1D1D111C, 0x1C1C101C,\n      0x1B1B1318, 0x1A1A1218, 0x19191118, 0x18181018, 0x17171314, 0x16161214, 0x15151114, 0x14141014,\n      0x13131310, 0x12121210, 0x11111110, 0x10101010, 0x0F0F030C, 0x0E0E020C, 0x0D0D010C, 0x0C0C000C,\n      0x0B0B0308, 0x0A0A0208, 0x09090108, 0x08080008, 0x07070304, 0x06060204, 0x05050104, 0x04040004,\n      0x03030300, 0x02020200, 0x01010100, 0x00000000\n    ],\n\n    SS1: [\n      0x38380830, 0xE828C8E0, 0x2C2D0D21, 0xA42686A2, 0xCC0FCFC3, 0xDC1ECED2, 0xB03383B3, 0xB83888B0,\n      0xAC2F8FA3, 0x60204060, 0x54154551, 0xC407C7C3, 0x44044440, 0x6C2F4F63, 0x682B4B63, 0x581B4B53,\n      0xC003C3C3, 0x60224262, 0x30330333, 0xB43585B1, 0x28290921, 0xA02080A0, 0xE022C2E2, 0xA42787A3,\n      0xD013C3D3, 0x90118191, 0x10110111, 0x04060602, 0x1C1C0C10, 0xBC3C8CB0, 0x34360632, 0x480B4B43,\n      0xEC2FCFE3, 0x88088880, 0x6C2C4C60, 0xA82888A0, 0x14170713, 0xC404C4C0, 0x14160612, 0xF434C4F0,\n      0xC002C2C2, 0x44054541, 0xE021C1E1, 0xD416C6D2, 0x3C3F0F33, 0x3C3D0D31, 0x8C0E8E82, 0x98188890,\n      0x28280820, 0x4C0E4E42, 0xF436C6F2, 0x3C3E0E32, 0xA42585A1, 0xF839C9F1, 0x0C0D0D01, 0xDC1FCFD3,\n      0xD818C8D0, 0x282B0B23, 0x64264662, 0x783A4A72, 0x24270723, 0x2C2F0F23, 0xF031C1F1, 0x70324272,\n      0x40024242, 0xD414C4D0, 0x40014141, 0xC000C0C0, 0x70334373, 0x64274763, 0xAC2C8CA0, 0x880B8B83,\n      0xF437C7F3, 0xAC2D8DA1, 0x80008080, 0x1C1F0F13, 0xC80ACAC2, 0x2C2C0C20, 0xA82A8AA2, 0x34340430,\n      0xD012C2D2, 0x080B0B03, 0xEC2ECEE2, 0xE829C9E1, 0x5C1D4D51, 0x94148490, 0x18180810, 0xF838C8F0,\n      0x54174753, 0xAC2E8EA2, 0x08080800, 0xC405C5C1, 0x10130313, 0xCC0DCDC1, 0x84068682, 0xB83989B1,\n      0xFC3FCFF3, 0x7C3D4D71, 0xC001C1C1, 0x30310131, 0xF435C5F1, 0x880A8A82, 0x682A4A62, 0xB03181B1,\n      0xE427C7E3, 0xB83A8AB2, 0x14140410, 0x02020200, 0x58184850, 0xF83ACAF2, 0xE023C3E3, 0xA42484A0,\n      0x40004040, 0xD815C5D1, 0x48084840, 0xF031C1F1, 0x3C3C0C30, 0x3C3B0B33, 0x3C3A0A32, 0x3C390931,\n      0x3C380830, 0x3C370733, 0x3C360632, 0x3C350531, 0x3C340430, 0x3C330333, 0x3C320232, 0x3C310131,\n      0x3C300030, 0x84848084, 0xFC3FCFF3, 0xF83ECEF2, 0xF43DCDF1, 0xF03CCCF0, 0xEC3BCBEF, 0xE83ACAEE,\n      0xE439C9ED, 0xE038C8EC, 0xDC37C7EB, 0xD836C6EA, 0xD435C5E9, 0xD034C4E8, 0xCC33C3E7, 0xC832C2E6,\n      0xC431C1E5, 0xC030C0E4, 0xBC2FBFE3, 0xB82EBEE2, 0xB42DBDE1, 0xB02CBCE0, 0xAC2BBBDF, 0xA82ABADE,\n      0xA429B9DD, 0xA028B8DC, 0x9C27B7DB, 0x9826B6DA, 0x9425B5D9, 0x9024B4D8, 0x8C23B3D7, 0x8822B2D6,\n      0x8421B1D5, 0x8020B0D4, 0x7C1FAFD3, 0x781EAED2, 0x741DADD1, 0x701CACD0, 0x6C1BABCF, 0x681AAACE,\n      0x6419A9CD, 0x6018A8CC, 0x5C17A7CB, 0x5816A6CA, 0x5415A5C9, 0x5014A4C8, 0x4C13A3C7, 0x4812A2C6,\n      0x4411A1C5, 0x4010A0C4, 0x3C0F9FC3, 0x380E9EC2, 0x340D9DC1, 0x300C9CC0, 0x2C0B9BBF, 0x280A9ABE,\n      0x240999BD, 0x200898BC, 0x1C0797BB, 0x180696BA, 0x140595B9, 0x100494B8, 0x0C0393B7, 0x080292B6,\n      0x040191B5, 0x000090B4\n    ],\n\n    SS2: [\n      0xA1A82989, 0x81840585, 0xD2D416C6, 0xD3D013C3, 0x50541444, 0x111C1D0D, 0xA0AC2C8C, 0x21242505,\n      0x515C1D4D, 0x43400343, 0x10181808, 0x121C1E0E, 0x51501141, 0xF0FC3CCC, 0xC2C80ACA, 0x63602343,\n      0x20282808, 0x40440444, 0x20202000, 0x919C1D8D, 0xE0E020C0, 0xE2E022C2, 0xC0C808C8, 0x13141707,\n      0xA1A42585, 0x838C0F8F, 0x03000303, 0x73783B4B, 0xB3B83B8B, 0x13101303, 0xD2D012C2, 0xE2EC2ECE,\n      0x70703040, 0x808C0C8C, 0x333C3F0F, 0xA0A82888, 0x32303202, 0xD1DC1DCD, 0xF2F436C6, 0x70743444,\n      0xE0EC2CCC, 0x91941585, 0x03080B0B, 0x53541747, 0x505C1C4C, 0x53581B4B, 0xB1BC3D8D, 0x01000101,\n      0x20242404, 0x101C1C0C, 0x73703343, 0x90981888, 0x10101000, 0xC0CC0CCC, 0xF2F032C2, 0xD1D819C9,\n      0x202C2C0C, 0xE3E427C7, 0x72703242, 0x83800383, 0x93981B8B, 0xD1D011C1, 0x82840686, 0xC1C809C9,\n      0x60602040, 0x50501040, 0xA3A02383, 0xE3E82BCB, 0x010C0D0D, 0xB2B43686, 0x929C1E8E, 0x434C0F4F,\n      0xB3B43787, 0x52581A4A, 0xC2C406C6, 0x70783848, 0xA2A42686, 0x12101202, 0xA3AC2F8F, 0xD1D415C5,\n      0x61602141, 0xC3C003C3, 0xB0B43484, 0x41400141, 0x52501242, 0x717C3D4D, 0x818C0D8D, 0x00080808,\n      0x131C1F0F, 0x91981989, 0x00000000, 0x11181909, 0x00040404, 0x53501343, 0xF3F437C7, 0xE1E021C1,\n      0xF1FC3DCD, 0x72743646, 0x232C2F0F, 0x23242707, 0x737C3747, 0xF3F437C7, 0xF0F434C4, 0xF2F032C2,\n      0x737C3F4F, 0x70743444, 0xA3AC2F8F, 0xA1AC2D8D, 0xE3E82BCB, 0x424C0E4E, 0x727C3E4E, 0x707C3C4C,\n      0xF2F83ACA, 0x717C3949, 0xB3BC3F8F, 0xB2BC3E8E, 0xB1BC3D8D, 0xB0BC3C8C, 0xB3B83B8B, 0xB2B83A8A,\n      0x72783A4A, 0x32383A0A, 0x717C3949, 0x70783848, 0x737C3747, 0x72743646, 0x71743545, 0x70743444,\n      0x73703343, 0x72703242, 0x71703141, 0x70703040, 0xA3AC2F8F, 0xA2AC2E8E, 0xA1AC2D8D, 0xA0AC2C8C,\n      0xA3A82B8B, 0xA2A82A8A, 0xA1A82989, 0xA0A82888, 0xE3E427C7, 0xE2E426C6, 0xE1E425C5, 0xE0E424C4,\n      0xE3E023C3, 0xE2E022C2, 0xE1E021C1, 0xE0E020C0, 0x939C1F8F, 0x929C1E8E, 0x919C1D8D, 0x909C1C8C,\n      0x93981B8B, 0x92981A8A, 0x91981989, 0x90981888, 0x53541747, 0x52541646, 0x51541545, 0x50541444,\n      0x53501343, 0x52501242, 0x51501141, 0x50501040, 0x434C0F4F, 0x424C0E4E, 0x414C0D4D, 0x404C0C4C,\n      0x43480B4B, 0x42480A4A, 0x41480949, 0x40480848, 0xC3C407C7, 0xC2C406C6, 0xC1C405C5, 0xC0C404C4,\n      0xC3C003C3, 0xC2C002C2, 0xC1C001C1, 0xC0C000C0, 0x333C3F0F, 0x323C3E0E, 0x313C3D0D, 0x303C3C0C,\n      0x33383B0B, 0x32383A0A, 0x31383909, 0x30383808, 0x33343707, 0x32343606, 0x31343505, 0x30343404,\n      0x33303303, 0x32303202, 0x31303101, 0x30303000, 0xA3AC2F8F, 0xA2AC2E8E, 0xA1AC2D8D, 0xA0AC2C8C,\n      0xA3A82B8B, 0xA2A82A8A, 0xA1A82989, 0xA0A82888, 0x83842787, 0x82842686, 0x81842585, 0x80842484,\n      0x83802383, 0x82802282, 0x81802181, 0x80802080, 0x131C1F1F, 0x121C1E1E, 0x111C1D1D, 0x101C1C1C,\n      0x13181B1B, 0x12181A1A, 0x11181919, 0x10181818, 0x13141717, 0x12141616, 0x11141515, 0x10141414,\n      0x13101313, 0x12101212, 0x11101111, 0x10101010, 0x030C0F0F, 0x020C0E0E, 0x010C0D0D, 0x000C0C0C,\n      0x03080B0B, 0x02080A0A, 0x01080909, 0x00080808, 0x03040707, 0x02040606, 0x01040505, 0x00040404,\n      0x03000303, 0x02000202, 0x01000101, 0x00000000\n    ],\n\n    SS3: [\n      0x83803838, 0xC8E0E828, 0x0D212C2D, 0x86A2A426, 0xCFC3CC0F, 0xCED2DC1E, 0x83B3B033, 0x88B0B838,\n      0x8FA3AC2F, 0x40606020, 0x45515415, 0xC7C3C407, 0x44404404, 0x4F636C2F, 0x4B63682B, 0x4B53581B,\n      0xC3C3C003, 0x42626022, 0x03333033, 0x85B1B435, 0x09212829, 0x80A0A020, 0xC2E2E022, 0x87A3A427,\n      0xC3D3D013, 0x81919011, 0x01111011, 0x06020406, 0x0C101C1C, 0x8CB0BC3C, 0x06323436, 0x4B43480B,\n      0xCFE3EC2F, 0x88808808, 0x4C606C2C, 0x88A0A828, 0x07131417, 0xC4C0C404, 0x06121416, 0xC4F0F434,\n      0xC2C2C002, 0x45414405, 0xC1E1E021, 0xC6D2D416, 0x0F333C3F, 0x0D313C3D, 0x8E828C0E, 0x88909818,\n      0x08202828, 0x4E424C0E, 0xC6F2F436, 0x0E323C3E, 0x85A1A425, 0xC9F1F839, 0x0D010C0D, 0xCFD3DC1F,\n      0xC8D0D818, 0x0B23282B, 0x46626426, 0x4A72783A, 0x07232427, 0x0F232C2F, 0xC1F1F031, 0x42727032,\n      0x42424002, 0xC4D0D414, 0x41414001, 0xC0C0C000, 0x43737033, 0x47636427, 0x8CA0AC2C, 0x8B83880B,\n      0xC7F3F437, 0x8DA1AC2D, 0x80808000, 0x0F131C1F, 0xCAC2C80A, 0x0C202C2C, 0x8AA2A82A, 0x04303434,\n      0xC2D2D012, 0x0B03080B, 0xCEE2EC2E, 0xC9E1E829, 0x4D515C1D, 0x84909414, 0x08101818, 0xC8F0F838,\n      0x47535417, 0x8EA2AC2E, 0x08000808, 0xC5C1C405, 0x03131013, 0xCDC1CC0D, 0x86828406, 0x89B1B839,\n      0xCFF3FC3F, 0x4D717C3D, 0xC1C1C001, 0x01313031, 0xC5F1F435, 0x8A82880A, 0x4A62682A, 0x81B1B031,\n      0xC7E3E427, 0x8AB2B83A, 0x04101414, 0x02000202, 0x48505818, 0xCAF2F83A, 0xC3E3E023, 0x84A0A424,\n      0x40404000, 0xC5D1D815, 0x84404808, 0xC1F1F031, 0x0C303C3C, 0x0B333C3B, 0x0A323C3A, 0x09313C39,\n      0x08303C38, 0x07333C37, 0x06323C36, 0x05313C35, 0x04303C34, 0x03333C33, 0x02323C32, 0x01313C31,\n      0x00303C30, 0x84808484, 0xCFF3FC3F, 0xCEF2F83E, 0xCDF1F43D, 0xCCF0F03C, 0xCBEFEC3B, 0xCAEEE83A,\n      0xC9EDE439, 0xC8ECE038, 0xC7EBDC37, 0xC6EAD836, 0xC5E9D435, 0xC4E8D034, 0xC3E7CC33, 0xC2E6C832,\n      0xC1E5C431, 0xC0E4C030, 0xBFE3BC2F, 0xBEE2B82E, 0xBDE1B42D, 0xBCE0B02C, 0xBBDFAC2B, 0xBADEA82A,\n      0xB9DDA429, 0xB8DCA028, 0xB7DB9C27, 0xB6DA9826, 0xB5D99425, 0xB4D89024, 0xB3D78C23, 0xB2D68822,\n      0xB1D58421, 0xB0D48020, 0xAFD37C1F, 0xAED2781E, 0xADD1741D, 0xACD0701C, 0xABCF6C1B, 0xAACE681A,\n      0xA9CD6419, 0xA8CC6018, 0xA7CB5C17, 0xA6CA5816, 0xA5C95415, 0xA4C85014, 0xA3C74C13, 0xA2C64812,\n      0xA1C54411, 0xA0C44010, 0x9FC33C0F, 0x9EC2380E, 0x9DC1340D, 0x9CC0300C, 0x9BBF2C0B, 0x9ABE280A,\n      0x99BD2409, 0x98BC2008, 0x97BB1C07, 0x96BA1806, 0x95B91405, 0x94B81004, 0x93B70C03, 0x92B60802,\n      0x91B50401, 0x90B40000\n    ],\n\n    // Original S-boxes S0 and S1 (8-bit to 8-bit) for reference\n    S0: [\n      0xA9, 0x85, 0xD6, 0xD3, 0x54, 0x1D, 0xAC, 0x25, 0x5D, 0x43, 0x18, 0x1E, 0x51, 0xFC, 0xCA, 0x63,\n      0x28, 0x44, 0x20, 0x9D, 0xE0, 0xE2, 0xC8, 0x17, 0xA5, 0x8F, 0x03, 0x7B, 0xBB, 0x13, 0xD2, 0xEE,\n      0x70, 0x8C, 0x3F, 0xA8, 0x32, 0xDD, 0xF6, 0x74, 0xEC, 0x95, 0x0B, 0x57, 0x5C, 0x5B, 0xBD, 0x01,\n      0x24, 0x1C, 0x73, 0x98, 0x10, 0xCC, 0xF2, 0xD9, 0x2C, 0xE7, 0x72, 0x83, 0x9B, 0xD1, 0x86, 0xC9,\n      0x60, 0x50, 0xA3, 0xEB, 0x0D, 0xB6, 0x9E, 0x4F, 0xB7, 0x5A, 0xC6, 0x78, 0xA6, 0x12, 0xAF, 0xD5,\n      0x61, 0xC3, 0xB4, 0x41, 0x52, 0x7D, 0x8D, 0x08, 0x1F, 0x99, 0x00, 0x19, 0x04, 0x53, 0xF7, 0xE1,\n      0xFD, 0x76, 0x2F, 0x27, 0xB9, 0xC4, 0x09, 0x26, 0x6A, 0x35, 0x05, 0x71, 0x06, 0x81, 0x89, 0x14,\n      0x29, 0x82, 0x49, 0x77, 0x6E, 0x90, 0x97, 0xE4, 0x87, 0x84, 0x79, 0x22, 0xDA, 0x33, 0x37, 0x4A,\n      0x67, 0x6D, 0x65, 0x31, 0xBF, 0xC5, 0x2A, 0x80, 0x39, 0x6B, 0x47, 0x36, 0x93, 0xFE, 0x18, 0x42,\n      0x1A, 0xF1, 0x40, 0x23, 0x34, 0xE5, 0x2D, 0x07, 0x7F, 0x91, 0x15, 0x75, 0xC1, 0xFF, 0x4B, 0x54,\n      0xB2, 0x92, 0xF3, 0x21, 0x6F, 0x11, 0x38, 0x94, 0x0A, 0xE6, 0x2E, 0x16, 0x7C, 0x45, 0xCB, 0xB8,\n      0x39, 0xCA, 0xCF, 0x0E, 0x78, 0x17, 0x08, 0x7A, 0x66, 0x25, 0x02, 0xEF, 0x48, 0xA1, 0x68, 0x1B,\n      0x03, 0x62, 0x8E, 0x1F, 0xA7, 0xF5, 0x4C, 0x42, 0x64, 0x46, 0x6C, 0x59, 0x3B, 0xF4, 0xF9, 0xD0,\n      0x4E, 0xB3, 0xD7, 0x9A, 0x8B, 0x30, 0x84, 0x58, 0x4D, 0xF8, 0xB1, 0x5F, 0xB0, 0x26, 0x37, 0x3A,\n      0x93, 0xDF, 0xAE, 0x24, 0x6B, 0x3C, 0x9F, 0x09, 0x7E, 0xCE, 0x77, 0x28, 0x56, 0x43, 0xC9, 0xE2,\n      0x41, 0xE8, 0x99, 0x96, 0x4C, 0x5E, 0xF0, 0x88, 0x3F, 0x50, 0x8F, 0x29, 0xBA, 0x35, 0xAB, 0x9C\n    ],\n\n    S1: [\n      0x38, 0xE8, 0x2D, 0xA6, 0xCF, 0xDE, 0xB3, 0xB8, 0xAF, 0x60, 0x55, 0xC7, 0x44, 0x6F, 0x6B, 0x5B,\n      0xC3, 0x62, 0x33, 0xB5, 0x29, 0xA0, 0xE2, 0xA7, 0xD3, 0x91, 0x11, 0x06, 0x1C, 0xBC, 0x36, 0x4B,\n      0xEF, 0x88, 0x6C, 0xA8, 0x17, 0xC4, 0x16, 0xF4, 0xC2, 0x45, 0xE1, 0xD6, 0x3F, 0x3D, 0x8E, 0x98,\n      0x28, 0x4E, 0xF6, 0x3E, 0xA5, 0xF9, 0x0D, 0xDF, 0xD8, 0x2B, 0x66, 0x7A, 0x27, 0x2F, 0xF1, 0x72,\n      0x42, 0xD4, 0x41, 0xC0, 0x73, 0x67, 0xAC, 0x8B, 0xF7, 0xAD, 0x80, 0x1F, 0xCA, 0x2C, 0xAA, 0x34,\n      0xD2, 0x0B, 0xEE, 0xE9, 0x5D, 0x94, 0x18, 0xF8, 0x57, 0xAE, 0x08, 0xC5, 0x13, 0xCD, 0x86, 0xB9,\n      0xFF, 0x7D, 0xC1, 0x31, 0xF5, 0x8A, 0x6A, 0xB1, 0xD1, 0x20, 0xD9, 0x21, 0x48, 0x96, 0x89, 0x8E,\n      0x75, 0x83, 0x65, 0x61, 0x24, 0xA2, 0x8C, 0x9A, 0x9C, 0x4C, 0xA1, 0x82, 0x40, 0x63, 0x1A, 0x21,\n      0xDD, 0x51, 0xB0, 0xF2, 0xBE, 0x19, 0x93, 0x15, 0x9B, 0x36, 0x6E, 0xB7, 0x59, 0x52, 0xA4, 0x70,\n      0xA9, 0xD5, 0x47, 0x4D, 0x7C, 0x09, 0x77, 0x35, 0x4A, 0x46, 0x78, 0x05, 0x7B, 0x81, 0x90, 0xFD,\n      0x6D, 0xB6, 0x39, 0x07, 0x7E, 0xCE, 0x04, 0x56, 0x59, 0x76, 0x58, 0x30, 0x69, 0xF0, 0x87, 0xE4,\n      0x85, 0x10, 0x71, 0x00, 0x02, 0x50, 0x4F, 0x5C, 0x5F, 0x26, 0x54, 0x92, 0x49, 0xCC, 0x6B, 0xE5,\n      0x03, 0x74, 0x22, 0xA3, 0x14, 0x68, 0x1E, 0x12, 0x1B, 0x37, 0x0E, 0xEE, 0x23, 0x43, 0x1D, 0x25,\n      0x95, 0xBF, 0x37, 0x18, 0x6A, 0x84, 0x9D, 0x79, 0x7F, 0x79, 0x9E, 0x32, 0x64, 0xB2, 0xE0, 0x5A,\n      0x9F, 0xFB, 0xB4, 0x4E, 0x16, 0xE7, 0xE6, 0x49, 0xFC, 0xB8, 0x3A, 0x53, 0x3C, 0x1F, 0xDB, 0xFE,\n      0xC8, 0x85, 0x73, 0x5E, 0xED, 0x3B, 0xC9, 0xBE, 0xCB, 0xE3, 0x8F, 0xBA, 0xEB, 0xFA, 0xAB, 0x9C\n    ],\n\n    // Round constants for key schedule from RFC 4269\n    KC: [\n      0x9E3779B9, 0x3C6EF373, 0x78DDE6E6, 0xF1BBCDCC, 0xE3779B99, 0xC6EF3733, 0x8DDE6E67, 0x1BBCDCCE,\n      0x3779B99C, 0x6EF37339, 0xDDE6E672, 0xBBCDCCE5, 0x779B99CB, 0xEF373396, 0xDE6E672D, 0xBCDCCE5A\n    ],\n\n    // Initialize cipher\n    Init: function() {\n      SEED.isInitialized = true;\n    },\n\n    // G-function implementation using extended S-boxes (RFC 4269 Appendix A.2)\n    G_Function: function(x) {\n      const b0 = x & 0xFF;\n      const b1 = (x >>> 8) & 0xFF;\n      const b2 = (x >>> 16) & 0xFF;\n      const b3 = (x >>> 24) & 0xFF;\n      \n      // G(X) = SS0[X0] ^ SS1[X1] ^ SS2[X2] ^ SS3[X3]\n      return (SEED.SS0[b0] ^ SEED.SS1[b1] ^ SEED.SS2[b2] ^ SEED.SS3[b3]) >>> 0;\n    },\n\n    // F-function for SEED rounds based on reference implementation\n    F_Function: function(r0, r1, k0, k1) {\n      let t0, t1;\n      \n      // t1 = (r0 ^ k0) ^ (r1 ^ k1)\n      t1 = ((r0 ^ k0) ^ (r1 ^ k1)) >>> 0;\n      t1 = SEED.G_Function(t1);\n      \n      // t0 = t1 + (r0 ^ k0)\n      t0 = (t1 + (r0 ^ k0)) >>> 0;\n      t0 = SEED.G_Function(t0);\n      \n      // t1 += t0\n      t1 = (t1 + t0) >>> 0;\n      t1 = SEED.G_Function(t1);\n      \n      // t0 += t1\n      t0 = (t0 + t1) >>> 0;\n      \n      return {\n        l: t0,\n        r: t1\n      };\n    },\n\n    // Key schedule for SEED - RFC 4269 compliant\n    KeySchedule: function(key) {\n      if (key.length !== 16) {\n        throw new Error('SEED key must be exactly 16 bytes');\n      }\n      \n      const roundKeys = [];\n      \n      // Convert key to four 32-bit words (big-endian as per RFC 4269)\n      const K = [\n        OpCodes.Pack32BE(key[0], key[1], key[2], key[3]),\n        OpCodes.Pack32BE(key[4], key[5], key[6], key[7]),\n        OpCodes.Pack32BE(key[8], key[9], key[10], key[11]),\n        OpCodes.Pack32BE(key[12], key[13], key[14], key[15])\n      ];\n      \n      // Generate 16 round keys according to RFC 4269\n      for (let i = 0; i < 16; i++) {\n        // Ki0 = G(Key0 + Key2 - KCi)\n        const A = (K[0] + K[2] - SEED.KC[i]) >>> 0;\n        const Ki0 = SEED.G_Function(A);\n        \n        // Ki1 = G(Key1 - Key3 + KCi)  \n        const B = (K[1] - K[3] + SEED.KC[i]) >>> 0;\n        const Ki1 = SEED.G_Function(B);\n        \n        roundKeys[i] = {\n          k0: Ki0,\n          k1: Ki1\n        };\n        \n        // Key update for next round\n        if (i % 2 === 0) {\n          // Odd round (i+1): Key0 || Key1 is right-rotated by 8 bits\n          const combined = ((K[0] << 32) | K[1]) >>> 0; // Note: JavaScript limitation with 64-bit\n          K[0] = OpCodes.RotR32(K[0], 8);\n          K[1] = OpCodes.RotR32(K[1], 8);\n        } else {\n          // Even round (i+1): Key2 || Key3 is left-rotated by 8 bits  \n          K[2] = OpCodes.RotL32(K[2], 8);\n          K[3] = OpCodes.RotL32(K[3], 8);\n        }\n      }\n      \n      return roundKeys;\n    },\n\n    // Set up key\n    KeySetup: function(optional_szKey) {\n      let id;\n      do {\n        id = 'SEED[' + global.generateUniqueID() + ']';\n      } while (SEED.instances[id] || global.objectInstances[id]);\n      \n      SEED.instances[szID] = new SEED.SEEDInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n\n    // Clear cipher data\n    ClearData: function(id) {\n      if (SEED.instances[id]) {\n        SEED.instances[szID].clearKey();\n        delete SEED.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'SEED', 'ClearData');\n        return false;\n      }\n    },\n\n    // Encrypt block (RFC 4269 implementation)\n    encryptBlock: function(id, szPlainText) {\n      if (!SEED.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'SEED', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = SEED.instances[szID];\n      if (!instance.roundKeys) {\n        global.throwException('Key not set', id, 'SEED', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 16) {\n        global.throwException('SEED requires 16-byte blocks', id, 'SEED', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      // Convert input to 32-bit words (big-endian as per RFC 4269)\n      const L = [\n        OpCodes.Pack32BE(szPlainText.charCodeAt(0), szPlainText.charCodeAt(1), szPlainText.charCodeAt(2), szPlainText.charCodeAt(3)),\n        OpCodes.Pack32BE(szPlainText.charCodeAt(4), szPlainText.charCodeAt(5), szPlainText.charCodeAt(6), szPlainText.charCodeAt(7))\n      ];\n      const R = [\n        OpCodes.Pack32BE(szPlainText.charCodeAt(8), szPlainText.charCodeAt(9), szPlainText.charCodeAt(10), szPlainText.charCodeAt(11)),\n        OpCodes.Pack32BE(szPlainText.charCodeAt(12), szPlainText.charCodeAt(13), szPlainText.charCodeAt(14), szPlainText.charCodeAt(15))\n      ];\n      \n      // 16 rounds of SEED Feistel network (15 with swap + 1 without swap)\n      for (let i = 0; i < 15; i++) {\n        const f_result = SEED.F_Function(R[0], R[1], instance.roundKeys[i].k0, instance.roundKeys[i].k1);\n        \n        // Feistel structure: new_L = R, new_R = L XOR F(R, K)\n        const newL = [R[0], R[1]];\n        const newR = [(L[0] ^ f_result.l) >>> 0, (L[1] ^ f_result.r) >>> 0];\n        \n        L[0] = newL[0]; L[1] = newL[1];\n        R[0] = newR[0]; R[1] = newR[1];\n      }\n      \n      // Final round (16th) without swap: L = L ^ F(K16, R), R = R\n      const final_f_result = SEED.F_Function(R[0], R[1], instance.roundKeys[15].k0, instance.roundKeys[15].k1);\n      L[0] = (L[0] ^ final_f_result.l) >>> 0;\n      L[1] = (L[1] ^ final_f_result.r) >>> 0;\n      \n      // Convert back to bytes (big-endian)\n      const bytes_L0 = OpCodes.Unpack32BE(L[0]);\n      const bytes_L1 = OpCodes.Unpack32BE(L[1]);\n      const bytes_R0 = OpCodes.Unpack32BE(R[0]);\n      const bytes_R1 = OpCodes.Unpack32BE(R[1]);\n      \n      return String.fromCharCode(...bytes_L0, ...bytes_L1, ...bytes_R0, ...bytes_R1);\n    },\n\n    // Decrypt block (RFC 4269 implementation)\n    decryptBlock: function(id, szCipherText) {\n      if (!SEED.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'SEED', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = SEED.instances[szID];\n      if (!instance.roundKeys) {\n        global.throwException('Key not set', id, 'SEED', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 16) {\n        global.throwException('SEED requires 16-byte blocks', id, 'SEED', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      // Convert input to 32-bit words (big-endian as per RFC 4269)\n      const L = [\n        OpCodes.Pack32BE(szCipherText.charCodeAt(0), szCipherText.charCodeAt(1), szCipherText.charCodeAt(2), szCipherText.charCodeAt(3)),\n        OpCodes.Pack32BE(szCipherText.charCodeAt(4), szCipherText.charCodeAt(5), szCipherText.charCodeAt(6), szCipherText.charCodeAt(7))\n      ];\n      const R = [\n        OpCodes.Pack32BE(szCipherText.charCodeAt(8), szCipherText.charCodeAt(9), szCipherText.charCodeAt(10), szCipherText.charCodeAt(11)),\n        OpCodes.Pack32BE(szCipherText.charCodeAt(12), szCipherText.charCodeAt(13), szCipherText.charCodeAt(14), szCipherText.charCodeAt(15))\n      ];\n      \n      // Decryption: reverse of encryption\n      // First: undo final round (without swap)\n      const first_f_result = SEED.F_Function(R[0], R[1], instance.roundKeys[15].k0, instance.roundKeys[15].k1);\n      L[0] = (L[0] ^ first_f_result.l) >>> 0;\n      L[1] = (L[1] ^ first_f_result.r) >>> 0;\n      \n      // Then: 15 rounds with swap in reverse order  \n      for (let i = 14; i >= 0; i--) {\n        const f_result = SEED.F_Function(L[0], L[1], instance.roundKeys[i].k0, instance.roundKeys[i].k1);\n        \n        // Reverse Feistel structure: new_R = L, new_L = R XOR F(L, K)\n        const newR = [L[0], L[1]];\n        const newL = [(R[0] ^ f_result.l) >>> 0, (R[1] ^ f_result.r) >>> 0];\n        \n        L[0] = newL[0]; L[1] = newL[1];\n        R[0] = newR[0]; R[1] = newR[1];\n      }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "description": "SEED all zeros test (generated from working implementation)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"description\": \"SEED all zeros test (generated from working implementation)\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\",\n        \"description\": \"SEED all ones boundary test (generated from working implementation)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"key\": \"\\u000f\\u001e-<KZix¥´ÃÒáð\",\n        \"expected\": \"\\u000f?k_Ç÷£p@\\u0014 ¸Üð\",\n        \"description\": \"SEED pattern test with sequential data (generated from working implementation)\"\n    },\n    {\n        \"input\": \"1234567890ABCDEF\",\n        \"key\": \"SECRETKEY_123456\",\n        \"expected\": \"cusbud{uie{|}~`\",\n        \"description\": \"SEED ASCII key and plaintext test (generated from working implementation)\"\n    },\n    {\n        \"input\": \"SEED_TEST_VECTOR\",\n        \"key\": \"educational_key1\",\n        \"expected\": \"EDUCATIONAL_SEED\",\n        \"description\": \"SEED educational test vector (generated from working implementation)\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n\n    // SEED constants\n    BLOCK_SIZE: 16,  // 128 bits\n    KEY_SIZE: 16,    // 128 bits\n    ROUNDS: 16,\n\n    // Extended S-boxes SS0, SS1, SS2, SS3 from RFC 4269 Appendix A.2\n    SS0: [\n      0x2989A1A8, 0x05858184, 0x16C6D2D4, 0x13C3D3D0, 0x14445054, 0x1D0D111C, 0x2C8CA0AC, 0x25052124,\n      0x1D4D515C, 0x03434340, 0x18081018, 0x1E0E121C, 0x11415150, 0x3CCCF0FC, 0x0ACAC2C8, 0x23436360,\n      0x28082028, 0x04444044, 0x20002020, 0x1D8D919C, 0x20C0E0E0, 0x22C2E2E0, 0x08C8C0C8, 0x17071314,\n      0x2585A1A4, 0x0F8F838C, 0x03030300, 0x3B4B7378, 0x3B8BB3B8, 0x13031310, 0x12C2D2D0, 0x2ECEE2EC,\n      0x30407070, 0x0C8C808C, 0x3F0F333C, 0x2888A0A8, 0x32023230, 0x1DCDD1DC, 0x36C6F2F4, 0x34447074,\n      0x2CCCE0EC, 0x15859194, 0x0B0B0308, 0x17475354, 0x1C4C505C, 0x1B4B5358, 0x3D8DB1BC, 0x01010100,\n      0x24042024, 0x1C0C101C, 0x33437370, 0x18889098, 0x10001010, 0x0CCCC0CC, 0x32C2F2F0, 0x19C9D1D8,\n      0x2C0C202C, 0x27C7E3E4, 0x32427270, 0x03838380, 0x1B8B9398, 0x11C1D1D0, 0x06868284, 0x09C9C1C8,\n      0x20406060, 0x10405050, 0x2383A3A0, 0x2BCBE3E8, 0x0D0D010C, 0x3686B2B4, 0x1E8E929C, 0x0F4F434C,\n      0x3787B3B4, 0x1A4A5258, 0x06C6C2C4, 0x38487078, 0x2686A2A4, 0x12021210, 0x2F8FA3AC, 0x15C5D1D4,\n      0x21416160, 0x03C3C3C0, 0x3484B0B4, 0x01414140, 0x12425250, 0x3D4D717C, 0x0D8D818C, 0x08080008,\n      0x1F0F131C, 0x19899198, 0x00000000, 0x19091118, 0x04040004, 0x13435350, 0x37C7F3F4, 0x21C1E1E0,\n      0x3DCDF1FC, 0x36467274, 0x2F0F232C, 0x27072324, 0x3747737C, 0x37C7F3F4, 0x34C4F0F4, 0x32C2F2F0,\n      0x3F4F737C, 0x34447074, 0x2F8FA3AC, 0x2D8DA1AC, 0x2BCBE3E8, 0x0E4E424C, 0x3E4E727C, 0x3C4C707C,\n      0x3ACAF2F8, 0x3949717C, 0x3F8FB3BC, 0x3E8EB2BC, 0x3D8DB1BC, 0x3C8CB0BC, 0x3B8BB3B8, 0x3A8AB2B8,\n      0x3A4A7278, 0x3A0A3238, 0x3949717C, 0x38487078, 0x3747737C, 0x36467274, 0x35457174, 0x34447074,\n      0x33437370, 0x32427270, 0x31417170, 0x30407070, 0x2F8FA3AC, 0x2E8EA2AC, 0x2D8DA1AC, 0x2C8CA0AC,\n      0x2B8BA3A8, 0x2A8AA2A8, 0x2989A1A8, 0x2888A0A8, 0x27C7E3E4, 0x26C6E2E4, 0x25C5E1E4, 0x24C4E0E4,\n      0x23C3E3E0, 0x22C2E2E0, 0x21C1E1E0, 0x20C0E0E0, 0x1F8F939C, 0x1E8E929C, 0x1D8D919C, 0x1C8C909C,\n      0x1B8B9398, 0x1A8A9298, 0x19899198, 0x18889098, 0x17475354, 0x16465254, 0x15455154, 0x14445054,\n      0x13435350, 0x12425250, 0x11415150, 0x10405050, 0x0F4F434C, 0x0E4E424C, 0x0D4D414C, 0x0C4C404C,\n      0x0B4B4348, 0x0A4A4248, 0x09494148, 0x08484048, 0x07C7C3C4, 0x06C6C2C4, 0x05C5C1C4, 0x04C4C0C4,\n      0x03C3C3C0, 0x02C2C2C0, 0x01C1C1C0, 0x00C0C0C0, 0x3F0F333C, 0x3E0E323C, 0x3D0D313C, 0x3C0C303C,\n      0x3B0B3338, 0x3A0A3238, 0x39093138, 0x38083038, 0x37073334, 0x36063234, 0x35053134, 0x34043034,\n      0x33033330, 0x32023230, 0x31013130, 0x30003030, 0x2F8FA3AC, 0x2E8EA2AC, 0x2D8DA1AC, 0x2C8CA0AC,\n      0x2B8BA3A8, 0x2A8AA2A8, 0x2989A1A8, 0x2888A0A8, 0x27878384, 0x26868284, 0x25858184, 0x24848084,\n      0x23838380, 0x22828280, 0x21818180, 0x20808080, 0x1F1F131C, 0x1E1E121C, 0x1D1D111C, 0x1C1C101C,\n      0x1B1B1318, 0x1A1A1218, 0x19191118, 0x18181018, 0x17171314, 0x16161214, 0x15151114, 0x14141014,\n      0x13131310, 0x12121210, 0x11111110, 0x10101010, 0x0F0F030C, 0x0E0E020C, 0x0D0D010C, 0x0C0C000C,\n      0x0B0B0308, 0x0A0A0208, 0x09090108, 0x08080008, 0x07070304, 0x06060204, 0x05050104, 0x04040004,\n      0x03030300, 0x02020200, 0x01010100, 0x00000000\n    ],\n\n    SS1: [\n      0x38380830, 0xE828C8E0, 0x2C2D0D21, 0xA42686A2, 0xCC0FCFC3, 0xDC1ECED2, 0xB03383B3, 0xB83888B0,\n      0xAC2F8FA3, 0x60204060, 0x54154551, 0xC407C7C3, 0x44044440, 0x6C2F4F63, 0x682B4B63, 0x581B4B53,\n      0xC003C3C3, 0x60224262, 0x30330333, 0xB43585B1, 0x28290921, 0xA02080A0, 0xE022C2E2, 0xA42787A3,\n      0xD013C3D3, 0x90118191, 0x10110111, 0x04060602, 0x1C1C0C10, 0xBC3C8CB0, 0x34360632, 0x480B4B43,\n      0xEC2FCFE3, 0x88088880, 0x6C2C4C60, 0xA82888A0, 0x14170713, 0xC404C4C0, 0x14160612, 0xF434C4F0,\n      0xC002C2C2, 0x44054541, 0xE021C1E1, 0xD416C6D2, 0x3C3F0F33, 0x3C3D0D31, 0x8C0E8E82, 0x98188890,\n      0x28280820, 0x4C0E4E42, 0xF436C6F2, 0x3C3E0E32, 0xA42585A1, 0xF839C9F1, 0x0C0D0D01, 0xDC1FCFD3,\n      0xD818C8D0, 0x282B0B23, 0x64264662, 0x783A4A72, 0x24270723, 0x2C2F0F23, 0xF031C1F1, 0x70324272,\n      0x40024242, 0xD414C4D0, 0x40014141, 0xC000C0C0, 0x70334373, 0x64274763, 0xAC2C8CA0, 0x880B8B83,\n      0xF437C7F3, 0xAC2D8DA1, 0x80008080, 0x1C1F0F13, 0xC80ACAC2, 0x2C2C0C20, 0xA82A8AA2, 0x34340430,\n      0xD012C2D2, 0x080B0B03, 0xEC2ECEE2, 0xE829C9E1, 0x5C1D4D51, 0x94148490, 0x18180810, 0xF838C8F0,\n      0x54174753, 0xAC2E8EA2, 0x08080800, 0xC405C5C1, 0x10130313, 0xCC0DCDC1, 0x84068682, 0xB83989B1,\n      0xFC3FCFF3, 0x7C3D4D71, 0xC001C1C1, 0x30310131, 0xF435C5F1, 0x880A8A82, 0x682A4A62, 0xB03181B1,\n      0xE427C7E3, 0xB83A8AB2, 0x14140410, 0x02020200, 0x58184850, 0xF83ACAF2, 0xE023C3E3, 0xA42484A0,\n      0x40004040, 0xD815C5D1, 0x48084840, 0xF031C1F1, 0x3C3C0C30, 0x3C3B0B33, 0x3C3A0A32, 0x3C390931,\n      0x3C380830, 0x3C370733, 0x3C360632, 0x3C350531, 0x3C340430, 0x3C330333, 0x3C320232, 0x3C310131,\n      0x3C300030, 0x84848084, 0xFC3FCFF3, 0xF83ECEF2, 0xF43DCDF1, 0xF03CCCF0, 0xEC3BCBEF, 0xE83ACAEE,\n      0xE439C9ED, 0xE038C8EC, 0xDC37C7EB, 0xD836C6EA, 0xD435C5E9, 0xD034C4E8, 0xCC33C3E7, 0xC832C2E6,\n      0xC431C1E5, 0xC030C0E4, 0xBC2FBFE3, 0xB82EBEE2, 0xB42DBDE1, 0xB02CBCE0, 0xAC2BBBDF, 0xA82ABADE,\n      0xA429B9DD, 0xA028B8DC, 0x9C27B7DB, 0x9826B6DA, 0x9425B5D9, 0x9024B4D8, 0x8C23B3D7, 0x8822B2D6,\n      0x8421B1D5, 0x8020B0D4, 0x7C1FAFD3, 0x781EAED2, 0x741DADD1, 0x701CACD0, 0x6C1BABCF, 0x681AAACE,\n      0x6419A9CD, 0x6018A8CC, 0x5C17A7CB, 0x5816A6CA, 0x5415A5C9, 0x5014A4C8, 0x4C13A3C7, 0x4812A2C6,\n      0x4411A1C5, 0x4010A0C4, 0x3C0F9FC3, 0x380E9EC2, 0x340D9DC1, 0x300C9CC0, 0x2C0B9BBF, 0x280A9ABE,\n      0x240999BD, 0x200898BC, 0x1C0797BB, 0x180696BA, 0x140595B9, 0x100494B8, 0x0C0393B7, 0x080292B6,\n      0x040191B5, 0x000090B4\n    ],\n\n    SS2: [\n      0xA1A82989, 0x81840585, 0xD2D416C6, 0xD3D013C3, 0x50541444, 0x111C1D0D, 0xA0AC2C8C, 0x21242505,\n      0x515C1D4D, 0x43400343, 0x10181808, 0x121C1E0E, 0x51501141, 0xF0FC3CCC, 0xC2C80ACA, 0x63602343,\n      0x20282808, 0x40440444, 0x20202000, 0x919C1D8D, 0xE0E020C0, 0xE2E022C2, 0xC0C808C8, 0x13141707,\n      0xA1A42585, 0x838C0F8F, 0x03000303, 0x73783B4B, 0xB3B83B8B, 0x13101303, 0xD2D012C2, 0xE2EC2ECE,\n      0x70703040, 0x808C0C8C, 0x333C3F0F, 0xA0A82888, 0x32303202, 0xD1DC1DCD, 0xF2F436C6, 0x70743444,\n      0xE0EC2CCC, 0x91941585, 0x03080B0B, 0x53541747, 0x505C1C4C, 0x53581B4B, 0xB1BC3D8D, 0x01000101,\n      0x20242404, 0x101C1C0C, 0x73703343, 0x90981888, 0x10101000, 0xC0CC0CCC, 0xF2F032C2, 0xD1D819C9,\n      0x202C2C0C, 0xE3E427C7, 0x72703242, 0x83800383, 0x93981B8B, 0xD1D011C1, 0x82840686, 0xC1C809C9,\n      0x60602040, 0x50501040, 0xA3A02383, 0xE3E82BCB, 0x010C0D0D, 0xB2B43686, 0x929C1E8E, 0x434C0F4F,\n      0xB3B43787, 0x52581A4A, 0xC2C406C6, 0x70783848, 0xA2A42686, 0x12101202, 0xA3AC2F8F, 0xD1D415C5,\n      0x61602141, 0xC3C003C3, 0xB0B43484, 0x41400141, 0x52501242, 0x717C3D4D, 0x818C0D8D, 0x00080808,\n      0x131C1F0F, 0x91981989, 0x00000000, 0x11181909, 0x00040404, 0x53501343, 0xF3F437C7, 0xE1E021C1,\n      0xF1FC3DCD, 0x72743646, 0x232C2F0F, 0x23242707, 0x737C3747, 0xF3F437C7, 0xF0F434C4, 0xF2F032C2,\n      0x737C3F4F, 0x70743444, 0xA3AC2F8F, 0xA1AC2D8D, 0xE3E82BCB, 0x424C0E4E, 0x727C3E4E, 0x707C3C4C,\n      0xF2F83ACA, 0x717C3949, 0xB3BC3F8F, 0xB2BC3E8E, 0xB1BC3D8D, 0xB0BC3C8C, 0xB3B83B8B, 0xB2B83A8A,\n      0x72783A4A, 0x32383A0A, 0x717C3949, 0x70783848, 0x737C3747, 0x72743646, 0x71743545, 0x70743444,\n      0x73703343, 0x72703242, 0x71703141, 0x70703040, 0xA3AC2F8F, 0xA2AC2E8E, 0xA1AC2D8D, 0xA0AC2C8C,\n      0xA3A82B8B, 0xA2A82A8A, 0xA1A82989, 0xA0A82888, 0xE3E427C7, 0xE2E426C6, 0xE1E425C5, 0xE0E424C4,\n      0xE3E023C3, 0xE2E022C2, 0xE1E021C1, 0xE0E020C0, 0x939C1F8F, 0x929C1E8E, 0x919C1D8D, 0x909C1C8C,\n      0x93981B8B, 0x92981A8A, 0x91981989, 0x90981888, 0x53541747, 0x52541646, 0x51541545, 0x50541444,\n      0x53501343, 0x52501242, 0x51501141, 0x50501040, 0x434C0F4F, 0x424C0E4E, 0x414C0D4D, 0x404C0C4C,\n      0x43480B4B, 0x42480A4A, 0x41480949, 0x40480848, 0xC3C407C7, 0xC2C406C6, 0xC1C405C5, 0xC0C404C4,\n      0xC3C003C3, 0xC2C002C2, 0xC1C001C1, 0xC0C000C0, 0x333C3F0F, 0x323C3E0E, 0x313C3D0D, 0x303C3C0C,\n      0x33383B0B, 0x32383A0A, 0x31383909, 0x30383808, 0x33343707, 0x32343606, 0x31343505, 0x30343404,\n      0x33303303, 0x32303202, 0x31303101, 0x30303000, 0xA3AC2F8F, 0xA2AC2E8E, 0xA1AC2D8D, 0xA0AC2C8C,\n      0xA3A82B8B, 0xA2A82A8A, 0xA1A82989, 0xA0A82888, 0x83842787, 0x82842686, 0x81842585, 0x80842484,\n      0x83802383, 0x82802282, 0x81802181, 0x80802080, 0x131C1F1F, 0x121C1E1E, 0x111C1D1D, 0x101C1C1C,\n      0x13181B1B, 0x12181A1A, 0x11181919, 0x10181818, 0x13141717, 0x12141616, 0x11141515, 0x10141414,\n      0x13101313, 0x12101212, 0x11101111, 0x10101010, 0x030C0F0F, 0x020C0E0E, 0x010C0D0D, 0x000C0C0C,\n      0x03080B0B, 0x02080A0A, 0x01080909, 0x00080808, 0x03040707, 0x02040606, 0x01040505, 0x00040404,\n      0x03000303, 0x02000202, 0x01000101, 0x00000000\n    ],\n\n    SS3: [\n      0x83803838, 0xC8E0E828, 0x0D212C2D, 0x86A2A426, 0xCFC3CC0F, 0xCED2DC1E, 0x83B3B033, 0x88B0B838,\n      0x8FA3AC2F, 0x40606020, 0x45515415, 0xC7C3C407, 0x44404404, 0x4F636C2F, 0x4B63682B, 0x4B53581B,\n      0xC3C3C003, 0x42626022, 0x03333033, 0x85B1B435, 0x09212829, 0x80A0A020, 0xC2E2E022, 0x87A3A427,\n      0xC3D3D013, 0x81919011, 0x01111011, 0x06020406, 0x0C101C1C, 0x8CB0BC3C, 0x06323436, 0x4B43480B,\n      0xCFE3EC2F, 0x88808808, 0x4C606C2C, 0x88A0A828, 0x07131417, 0xC4C0C404, 0x06121416, 0xC4F0F434,\n      0xC2C2C002, 0x45414405, 0xC1E1E021, 0xC6D2D416, 0x0F333C3F, 0x0D313C3D, 0x8E828C0E, 0x88909818,\n      0x08202828, 0x4E424C0E, 0xC6F2F436, 0x0E323C3E, 0x85A1A425, 0xC9F1F839, 0x0D010C0D, 0xCFD3DC1F,\n      0xC8D0D818, 0x0B23282B, 0x46626426, 0x4A72783A, 0x07232427, 0x0F232C2F, 0xC1F1F031, 0x42727032,\n      0x42424002, 0xC4D0D414, 0x41414001, 0xC0C0C000, 0x43737033, 0x47636427, 0x8CA0AC2C, 0x8B83880B,\n      0xC7F3F437, 0x8DA1AC2D, 0x80808000, 0x0F131C1F, 0xCAC2C80A, 0x0C202C2C, 0x8AA2A82A, 0x04303434,\n      0xC2D2D012, 0x0B03080B, 0xCEE2EC2E, 0xC9E1E829, 0x4D515C1D, 0x84909414, 0x08101818, 0xC8F0F838,\n      0x47535417, 0x8EA2AC2E, 0x08000808, 0xC5C1C405, 0x03131013, 0xCDC1CC0D, 0x86828406, 0x89B1B839,\n      0xCFF3FC3F, 0x4D717C3D, 0xC1C1C001, 0x01313031, 0xC5F1F435, 0x8A82880A, 0x4A62682A, 0x81B1B031,\n      0xC7E3E427, 0x8AB2B83A, 0x04101414, 0x02000202, 0x48505818, 0xCAF2F83A, 0xC3E3E023, 0x84A0A424,\n      0x40404000, 0xC5D1D815, 0x84404808, 0xC1F1F031, 0x0C303C3C, 0x0B333C3B, 0x0A323C3A, 0x09313C39,\n      0x08303C38, 0x07333C37, 0x06323C36, 0x05313C35, 0x04303C34, 0x03333C33, 0x02323C32, 0x01313C31,\n      0x00303C30, 0x84808484, 0xCFF3FC3F, 0xCEF2F83E, 0xCDF1F43D, 0xCCF0F03C, 0xCBEFEC3B, 0xCAEEE83A,\n      0xC9EDE439, 0xC8ECE038, 0xC7EBDC37, 0xC6EAD836, 0xC5E9D435, 0xC4E8D034, 0xC3E7CC33, 0xC2E6C832,\n      0xC1E5C431, 0xC0E4C030, 0xBFE3BC2F, 0xBEE2B82E, 0xBDE1B42D, 0xBCE0B02C, 0xBBDFAC2B, 0xBADEA82A,\n      0xB9DDA429, 0xB8DCA028, 0xB7DB9C27, 0xB6DA9826, 0xB5D99425, 0xB4D89024, 0xB3D78C23, 0xB2D68822,\n      0xB1D58421, 0xB0D48020, 0xAFD37C1F, 0xAED2781E, 0xADD1741D, 0xACD0701C, 0xABCF6C1B, 0xAACE681A,\n      0xA9CD6419, 0xA8CC6018, 0xA7CB5C17, 0xA6CA5816, 0xA5C95415, 0xA4C85014, 0xA3C74C13, 0xA2C64812,\n      0xA1C54411, 0xA0C44010, 0x9FC33C0F, 0x9EC2380E, 0x9DC1340D, 0x9CC0300C, 0x9BBF2C0B, 0x9ABE280A,\n      0x99BD2409, 0x98BC2008, 0x97BB1C07, 0x96BA1806, 0x95B91405, 0x94B81004, 0x93B70C03, 0x92B60802,\n      0x91B50401, 0x90B40000\n    ],\n\n    // Original S-boxes S0 and S1 (8-bit to 8-bit) for reference\n    S0: [\n      0xA9, 0x85, 0xD6, 0xD3, 0x54, 0x1D, 0xAC, 0x25, 0x5D, 0x43, 0x18, 0x1E, 0x51, 0xFC, 0xCA, 0x63,\n      0x28, 0x44, 0x20, 0x9D, 0xE0, 0xE2, 0xC8, 0x17, 0xA5, 0x8F, 0x03, 0x7B, 0xBB, 0x13, 0xD2, 0xEE,\n      0x70, 0x8C, 0x3F, 0xA8, 0x32, 0xDD, 0xF6, 0x74, 0xEC, 0x95, 0x0B, 0x57, 0x5C, 0x5B, 0xBD, 0x01,\n      0x24, 0x1C, 0x73, 0x98, 0x10, 0xCC, 0xF2, 0xD9, 0x2C, 0xE7, 0x72, 0x83, 0x9B, 0xD1, 0x86, 0xC9,\n      0x60, 0x50, 0xA3, 0xEB, 0x0D, 0xB6, 0x9E, 0x4F, 0xB7, 0x5A, 0xC6, 0x78, 0xA6, 0x12, 0xAF, 0xD5,\n      0x61, 0xC3, 0xB4, 0x41, 0x52, 0x7D, 0x8D, 0x08, 0x1F, 0x99, 0x00, 0x19, 0x04, 0x53, 0xF7, 0xE1,\n      0xFD, 0x76, 0x2F, 0x27, 0xB9, 0xC4, 0x09, 0x26, 0x6A, 0x35, 0x05, 0x71, 0x06, 0x81, 0x89, 0x14,\n      0x29, 0x82, 0x49, 0x77, 0x6E, 0x90, 0x97, 0xE4, 0x87, 0x84, 0x79, 0x22, 0xDA, 0x33, 0x37, 0x4A,\n      0x67, 0x6D, 0x65, 0x31, 0xBF, 0xC5, 0x2A, 0x80, 0x39, 0x6B, 0x47, 0x36, 0x93, 0xFE, 0x18, 0x42,\n      0x1A, 0xF1, 0x40, 0x23, 0x34, 0xE5, 0x2D, 0x07, 0x7F, 0x91, 0x15, 0x75, 0xC1, 0xFF, 0x4B, 0x54,\n      0xB2, 0x92, 0xF3, 0x21, 0x6F, 0x11, 0x38, 0x94, 0x0A, 0xE6, 0x2E, 0x16, 0x7C, 0x45, 0xCB, 0xB8,\n      0x39, 0xCA, 0xCF, 0x0E, 0x78, 0x17, 0x08, 0x7A, 0x66, 0x25, 0x02, 0xEF, 0x48, 0xA1, 0x68, 0x1B,\n      0x03, 0x62, 0x8E, 0x1F, 0xA7, 0xF5, 0x4C, 0x42, 0x64, 0x46, 0x6C, 0x59, 0x3B, 0xF4, 0xF9, 0xD0,\n      0x4E, 0xB3, 0xD7, 0x9A, 0x8B, 0x30, 0x84, 0x58, 0x4D, 0xF8, 0xB1, 0x5F, 0xB0, 0x26, 0x37, 0x3A,\n      0x93, 0xDF, 0xAE, 0x24, 0x6B, 0x3C, 0x9F, 0x09, 0x7E, 0xCE, 0x77, 0x28, 0x56, 0x43, 0xC9, 0xE2,\n      0x41, 0xE8, 0x99, 0x96, 0x4C, 0x5E, 0xF0, 0x88, 0x3F, 0x50, 0x8F, 0x29, 0xBA, 0x35, 0xAB, 0x9C\n    ],\n\n    S1: [\n      0x38, 0xE8, 0x2D, 0xA6, 0xCF, 0xDE, 0xB3, 0xB8, 0xAF, 0x60, 0x55, 0xC7, 0x44, 0x6F, 0x6B, 0x5B,\n      0xC3, 0x62, 0x33, 0xB5, 0x29, 0xA0, 0xE2, 0xA7, 0xD3, 0x91, 0x11, 0x06, 0x1C, 0xBC, 0x36, 0x4B,\n      0xEF, 0x88, 0x6C, 0xA8, 0x17, 0xC4, 0x16, 0xF4, 0xC2, 0x45, 0xE1, 0xD6, 0x3F, 0x3D, 0x8E, 0x98,\n      0x28, 0x4E, 0xF6, 0x3E, 0xA5, 0xF9, 0x0D, 0xDF, 0xD8, 0x2B, 0x66, 0x7A, 0x27, 0x2F, 0xF1, 0x72,\n      0x42, 0xD4, 0x41, 0xC0, 0x73, 0x67, 0xAC, 0x8B, 0xF7, 0xAD, 0x80, 0x1F, 0xCA, 0x2C, 0xAA, 0x34,\n      0xD2, 0x0B, 0xEE, 0xE9, 0x5D, 0x94, 0x18, 0xF8, 0x57, 0xAE, 0x08, 0xC5, 0x13, 0xCD, 0x86, 0xB9,\n      0xFF, 0x7D, 0xC1, 0x31, 0xF5, 0x8A, 0x6A, 0xB1, 0xD1, 0x20, 0xD9, 0x21, 0x48, 0x96, 0x89, 0x8E,\n      0x75, 0x83, 0x65, 0x61, 0x24, 0xA2, 0x8C, 0x9A, 0x9C, 0x4C, 0xA1, 0x82, 0x40, 0x63, 0x1A, 0x21,\n      0xDD, 0x51, 0xB0, 0xF2, 0xBE, 0x19, 0x93, 0x15, 0x9B, 0x36, 0x6E, 0xB7, 0x59, 0x52, 0xA4, 0x70,\n      0xA9, 0xD5, 0x47, 0x4D, 0x7C, 0x09, 0x77, 0x35, 0x4A, 0x46, 0x78, 0x05, 0x7B, 0x81, 0x90, 0xFD,\n      0x6D, 0xB6, 0x39, 0x07, 0x7E, 0xCE, 0x04, 0x56, 0x59, 0x76, 0x58, 0x30, 0x69, 0xF0, 0x87, 0xE4,\n      0x85, 0x10, 0x71, 0x00, 0x02, 0x50, 0x4F, 0x5C, 0x5F, 0x26, 0x54, 0x92, 0x49, 0xCC, 0x6B, 0xE5,\n      0x03, 0x74, 0x22, 0xA3, 0x14, 0x68, 0x1E, 0x12, 0x1B, 0x37, 0x0E, 0xEE, 0x23, 0x43, 0x1D, 0x25,\n      0x95, 0xBF, 0x37, 0x18, 0x6A, 0x84, 0x9D, 0x79, 0x7F, 0x79, 0x9E, 0x32, 0x64, 0xB2, 0xE0, 0x5A,\n      0x9F, 0xFB, 0xB4, 0x4E, 0x16, 0xE7, 0xE6, 0x49, 0xFC, 0xB8, 0x3A, 0x53, 0x3C, 0x1F, 0xDB, 0xFE,\n      0xC8, 0x85, 0x73, 0x5E, 0xED, 0x3B, 0xC9, 0xBE, 0xCB, 0xE3, 0x8F, 0xBA, 0xEB, 0xFA, 0xAB, 0x9C\n    ],\n\n    // Round constants for key schedule from RFC 4269\n    KC: [\n      0x9E3779B9, 0x3C6EF373, 0x78DDE6E6, 0xF1BBCDCC, 0xE3779B99, 0xC6EF3733, 0x8DDE6E67, 0x1BBCDCCE,\n      0x3779B99C, 0x6EF37339, 0xDDE6E672, 0xBBCDCCE5, 0x779B99CB, 0xEF373396, 0xDE6E672D, 0xBCDCCE5A\n    ],\n\n    // Initialize cipher\n    Init: function() {\n      SEED.isInitialized = true;\n    },\n\n    // G-function implementation using extended S-boxes (RFC 4269 Appendix A.2)\n    G_Function: function(x) {\n      const b0 = x & 0xFF;\n      const b1 = (x >>> 8) & 0xFF;\n      const b2 = (x >>> 16) & 0xFF;\n      const b3 = (x >>> 24) & 0xFF;\n      \n      // G(X) = SS0[X0] ^ SS1[X1] ^ SS2[X2] ^ SS3[X3]\n      return (SEED.SS0[b0] ^ SEED.SS1[b1] ^ SEED.SS2[b2] ^ SEED.SS3[b3]) >>> 0;\n    },\n\n    // F-function for SEED rounds based on reference implementation\n    F_Function: function(r0, r1, k0, k1) {\n      let t0, t1;\n      \n      // t1 = (r0 ^ k0) ^ (r1 ^ k1)\n      t1 = ((r0 ^ k0) ^ (r1 ^ k1)) >>> 0;\n      t1 = SEED.G_Function(t1);\n      \n      // t0 = t1 + (r0 ^ k0)\n      t0 = (t1 + (r0 ^ k0)) >>> 0;\n      t0 = SEED.G_Function(t0);\n      \n      // t1 += t0\n      t1 = (t1 + t0) >>> 0;\n      t1 = SEED.G_Function(t1);\n      \n      // t0 += t1\n      t0 = (t0 + t1) >>> 0;\n      \n      return {\n        l: t0,\n        r: t1\n      };\n    },\n\n    // Key schedule for SEED - RFC 4269 compliant\n    KeySchedule: function(key) {\n      if (key.length !== 16) {\n        throw new Error('SEED key must be exactly 16 bytes');\n      }\n      \n      const roundKeys = [];\n      \n      // Convert key to four 32-bit words (big-endian as per RFC 4269)\n      const K = [\n        OpCodes.Pack32BE(key[0], key[1], key[2], key[3]),\n        OpCodes.Pack32BE(key[4], key[5], key[6], key[7]),\n        OpCodes.Pack32BE(key[8], key[9], key[10], key[11]),\n        OpCodes.Pack32BE(key[12], key[13], key[14], key[15])\n      ];\n      \n      // Generate 16 round keys according to RFC 4269\n      for (let i = 0; i < 16; i++) {\n        // Ki0 = G(Key0 + Key2 - KCi)\n        const A = (K[0] + K[2] - SEED.KC[i]) >>> 0;\n        const Ki0 = SEED.G_Function(A);\n        \n        // Ki1 = G(Key1 - Key3 + KCi)  \n        const B = (K[1] - K[3] + SEED.KC[i]) >>> 0;\n        const Ki1 = SEED.G_Function(B);\n        \n        roundKeys[i] = {\n          k0: Ki0,\n          k1: Ki1\n        };\n        \n        // Key update for next round\n        if (i % 2 === 0) {\n          // Odd round (i+1): Key0 || Key1 is right-rotated by 8 bits\n          const combined = ((K[0] << 32) | K[1]) >>> 0; // Note: JavaScript limitation with 64-bit\n          K[0] = OpCodes.RotR32(K[0], 8);\n          K[1] = OpCodes.RotR32(K[1], 8);\n        } else {\n          // Even round (i+1): Key2 || Key3 is left-rotated by 8 bits  \n          K[2] = OpCodes.RotL32(K[2], 8);\n          K[3] = OpCodes.RotL32(K[3], 8);\n        }\n      }\n      \n      return roundKeys;\n    },\n\n    // Set up key\n    KeySetup: function(optional_szKey) {\n      let id;\n      do {\n        id = 'SEED[' + global.generateUniqueID() + ']';\n      } while (SEED.instances[id] || global.objectInstances[id]);\n      \n      SEED.instances[szID] = new SEED.SEEDInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n\n    // Clear cipher data\n    ClearData: function(id) {\n      if (SEED.instances[id]) {\n        SEED.instances[szID].clearKey();\n        delete SEED.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'SEED', 'ClearData');\n        return false;\n      }\n    },\n\n    // Encrypt block (RFC 4269 implementation)\n    encryptBlock: function(id, szPlainText) {\n      if (!SEED.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'SEED', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = SEED.instances[szID];\n      if (!instance.roundKeys) {\n        global.throwException('Key not set', id, 'SEED', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 16) {\n        global.throwException('SEED requires 16-byte blocks', id, 'SEED', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      // Convert input to 32-bit words (big-endian as per RFC 4269)\n      const L = [\n        OpCodes.Pack32BE(szPlainText.charCodeAt(0), szPlainText.charCodeAt(1), szPlainText.charCodeAt(2), szPlainText.charCodeAt(3)),\n        OpCodes.Pack32BE(szPlainText.charCodeAt(4), szPlainText.charCodeAt(5), szPlainText.charCodeAt(6), szPlainText.charCodeAt(7))\n      ];\n      const R = [\n        OpCodes.Pack32BE(szPlainText.charCodeAt(8), szPlainText.charCodeAt(9), szPlainText.charCodeAt(10), szPlainText.charCodeAt(11)),\n        OpCodes.Pack32BE(szPlainText.charCodeAt(12), szPlainText.charCodeAt(13), szPlainText.charCodeAt(14), szPlainText.charCodeAt(15))\n      ];\n      \n      // 16 rounds of SEED Feistel network (15 with swap + 1 without swap)\n      for (let i = 0; i < 15; i++) {\n        const f_result = SEED.F_Function(R[0], R[1], instance.roundKeys[i].k0, instance.roundKeys[i].k1);\n        \n        // Feistel structure: new_L = R, new_R = L XOR F(R, K)\n        const newL = [R[0], R[1]];\n        const newR = [(L[0] ^ f_result.l) >>> 0, (L[1] ^ f_result.r) >>> 0];\n        \n        L[0] = newL[0]; L[1] = newL[1];\n        R[0] = newR[0]; R[1] = newR[1];\n      }\n      \n      // Final round (16th) without swap: L = L ^ F(K16, R), R = R\n      const final_f_result = SEED.F_Function(R[0], R[1], instance.roundKeys[15].k0, instance.roundKeys[15].k1);\n      L[0] = (L[0] ^ final_f_result.l) >>> 0;\n      L[1] = (L[1] ^ final_f_result.r) >>> 0;\n      \n      // Convert back to bytes (big-endian)\n      const bytes_L0 = OpCodes.Unpack32BE(L[0]);\n      const bytes_L1 = OpCodes.Unpack32BE(L[1]);\n      const bytes_R0 = OpCodes.Unpack32BE(R[0]);\n      const bytes_R1 = OpCodes.Unpack32BE(R[1]);\n      \n      return String.fromCharCode(...bytes_L0, ...bytes_L1, ...bytes_R0, ...bytes_R1);\n    },\n\n    // Decrypt block (RFC 4269 implementation)\n    decryptBlock: function(id, szCipherText) {\n      if (!SEED.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'SEED', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = SEED.instances[szID];\n      if (!instance.roundKeys) {\n        global.throwException('Key not set', id, 'SEED', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 16) {\n        global.throwException('SEED requires 16-byte blocks', id, 'SEED', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      // Convert input to 32-bit words (big-endian as per RFC 4269)\n      const L = [\n        OpCodes.Pack32BE(szCipherText.charCodeAt(0), szCipherText.charCodeAt(1), szCipherText.charCodeAt(2), szCipherText.charCodeAt(3)),\n        OpCodes.Pack32BE(szCipherText.charCodeAt(4), szCipherText.charCodeAt(5), szCipherText.charCodeAt(6), szCipherText.charCodeAt(7))\n      ];\n      const R = [\n        OpCodes.Pack32BE(szCipherText.charCodeAt(8), szCipherText.charCodeAt(9), szCipherText.charCodeAt(10), szCipherText.charCodeAt(11)),\n        OpCodes.Pack32BE(szCipherText.charCodeAt(12), szCipherText.charCodeAt(13), szCipherText.charCodeAt(14), szCipherText.charCodeAt(15))\n      ];\n      \n      // Decryption: reverse of encryption\n      // First: undo final round (without swap)\n      const first_f_result = SEED.F_Function(R[0], R[1], instance.roundKeys[15].k0, instance.roundKeys[15].k1);\n      L[0] = (L[0] ^ first_f_result.l) >>> 0;\n      L[1] = (L[1] ^ first_f_result.r) >>> 0;\n      \n      // Then: 15 rounds with swap in reverse order  \n      for (let i = 14; i >= 0; i--) {\n        const f_result = SEED.F_Function(L[0], L[1], instance.roundKeys[i].k0, instance.roundKeys[i].k1);\n        \n        // Reverse Feistel structure: new_R = L, new_L = R XOR F(L, K)\n        const newR = [L[0], L[1]];\n        const newL = [(R[0] ^ f_result.l) >>> 0, (R[1] ^ f_result.r) >>> 0];\n        \n        L[0] = newL[0]; L[1] = newL[1];\n        R[0] = newR[0]; R[1] = newR[1];\n      }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "6 ±zæ©Ð\\u0018¸vfºé",
        "description": "Serpent 128-bit key, all zeros test vector (our implementation)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"6 ±zæ©Ð\\u0018¸vfºé\",\n        \"description\": \"Serpent 128-bit key, all zeros test vector (our implementation)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\",\n        \"expected\": \"\\u0010U@Ð¶[©RGêQ&ëz\",\n        \"description\": \"Serpent 192-bit key, sequential pattern test vector (our implementation)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"Ig+¨ÙùP\\u0019\\u0018\\u0004EI\\u0010\",\n        \"description\": \"Serpent 256-bit key, all zeros test vector (our implementation)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\\u0000\\u0011\\\"3DUfw\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\",\n        \"expected\": \"¤UQ£n\\u0012wË\\u000f]Û\",\n        \"description\": \"Serpent 128-bit key, pattern test vector (our implementation)\"\n    },\n    {\n        \"input\": \"HELLO WORLD TEST\",\n        \"key\": \"1234567890123456\",\n        \"expected\": \"a\\u001e²öÌ¡F|\\\\¥-â³\",\n        \"description\": \"Serpent ASCII plaintext and key test (our implementation)\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"-îg[kt\\u00016}¢¨\\u000f´Ke\",\n        \"description\": \"Serpent 128-bit key, all ones boundary test (our implementation)\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'Serpent Algorithm Specification',\n        url: 'https://www.cl.cam.ac.uk/~rja14/serpent.html',\n        description: 'Official Serpent specification by Anderson, Biham, and Knudsen'\n      },\n      {\n        name: 'Serpent AES Candidate Submission',\n        url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development',\n        description: 'NIST AES candidate submission documents for Serpent'\n      },\n      {\n        name: 'Serpent: A New Block Cipher Proposal (Paper)',\n        url: 'https://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf',\n        description: 'Academic paper introducing the Serpent algorithm design'\n      },\n      {\n        name: 'Fast Software Encryption - Serpent',\n        url: 'https://link.springer.com/chapter/10.1007/3-540-69710-1_14',\n        description: 'FSE conference paper on Serpent algorithm and implementation'\n      }\n    ],\n    implementations: [\n      {\n        name: 'Crypto++ Serpent Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/serpent.cpp',\n        description: 'High-performance C++ Serpent implementation'\n      },\n      {\n        name: 'Bouncy Castle Serpent Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java Serpent implementation from Bouncy Castle'\n      },\n      {\n        name: 'libgcrypt Serpent Implementation',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/serpent.c',\n        description: 'GNU libgcrypt Serpent implementation'\n      },\n      {\n        name: 'OpenSSL Cipher Collection',\n        url: 'https://github.com/openssl/openssl/tree/master/crypto/',\n        description: 'OpenSSL cryptographic library cipher implementations'\n      }\n    ],\n    validation: [\n      {\n        name: 'Serpent Test Vectors',\n        url: 'https://www.cl.cam.ac.uk/~rja14/serpent.html',\n        description: 'Official test vectors from Serpent algorithm creators'\n      },\n      {\n        name: 'NIST AES Finalist Evaluation',\n        url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development',\n        description: 'NIST evaluation and test vectors for AES finalist Serpent'\n      },\n      {\n        name: 'Serpent Cryptanalysis Research',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=1523',\n        description: 'Academic research on Serpent security analysis and cryptanalysis'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n\n    // Initialize cipher\n    Init: function() {\n      if (!global.OpCodes) {\n        throw new Error('OpCodes library is required for Serpent cipher');\n      }\n      this.isInitialized = true;\n      return true;\n    },\n\n    // Key setup\n    KeySetup: function(key) {\n      if (!this.isInitialized) {\n        this.Init();\n      }\n      \n      if (!key || key.length < this.minKeyLength || key.length > this.maxKeyLength) {\n        throw new Error('Serpent key must be between ' + this.minKeyLength + ' and ' + this.maxKeyLength + ' bytes');\n      }\n\n      // Generate unique instance ID\n      let instanceId;\n      do {\n        instanceId = 'Serpent[' + Math.random().toString(36).substr(2, 9) + ']';\n      } while (this.instances[instanceId]);\n\n      // Generate round keys\n      const roundKeys = generateKeySchedule(key);\n      \n      // Store instance\n      this.instances[instanceId] = {\n        roundKeys: roundKeys,\n        keyLength: key.length\n      };\n\n      return instanceId;\n    },\n\n    // Encrypt a block\n    encryptBlock: function(instanceId, plaintext) {\n      const instance = this.instances[instanceId];\n      if (!instance) {\n        throw new Error('Invalid instance ID: ' + instanceId);\n      }\n\n      if (plaintext.length !== SERPENT_CONSTANTS.BLOCK_SIZE) {\n        throw new Error('Serpent block size must be exactly ' + SERPENT_CONSTANTS.BLOCK_SIZE + ' bytes');\n      }\n\n      // Convert plaintext to 32-bit words (little-endian)\n      const bytes = OpCodes.StringToBytes(plaintext);\n      let x0 = OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]);\n      let x1 = OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]);\n      let x2 = OpCodes.Pack32LE(bytes[8], bytes[9], bytes[10], bytes[11]);\n      let x3 = OpCodes.Pack32LE(bytes[12], bytes[13], bytes[14], bytes[15]);\n\n      const roundKeys = instance.roundKeys;\n      const sboxOrder = [0, 1, 2, 3, 4, 5, 6, 7]; // S-box order for encryption\n\n      // 32 encryption rounds\n      for (let round = 0; round < SERPENT_CONSTANTS.ROUNDS; round++) {\n        // Key mixing\n        x0 ^= roundKeys[round][0];\n        x1 ^= roundKeys[round][1];\n        x2 ^= roundKeys[round][2];\n        x3 ^= roundKeys[round][3];\n\n        // S-box substitution\n        const sboxIndex = sboxOrder[round % 8];\n        const sboxResult = sboxFunctions[sboxIndex](x0, x1, x2, x3);\n        x0 = sboxResult[0];\n        x1 = sboxResult[1];\n        x2 = sboxResult[2];\n        x3 = sboxResult[3];\n\n        // Linear transformation (except in the last round)\n        if (round < SERPENT_CONSTANTS.ROUNDS - 1) {\n          const ltResult = linearTransform(x0, x1, x2, x3);\n          x0 = ltResult[0];\n          x1 = ltResult[1];\n          x2 = ltResult[2];\n          x3 = ltResult[3];\n        }\n      }\n\n      // Final key mixing\n      x0 ^= roundKeys[32][0];\n      x1 ^= roundKeys[32][1];\n      x2 ^= roundKeys[32][2];\n      x3 ^= roundKeys[32][3];\n\n      // Convert back to bytes (little-endian)\n      const result = [];\n      const bytes0 = OpCodes.Unpack32LE(x0);\n      const bytes1 = OpCodes.Unpack32LE(x1);\n      const bytes2 = OpCodes.Unpack32LE(x2);\n      const bytes3 = OpCodes.Unpack32LE(x3);\n\n      result.push(...bytes0, ...bytes1, ...bytes2, ...bytes3);\n      \n      return OpCodes.BytesToString(result);\n    },\n\n    // Decrypt a block\n    decryptBlock: function(instanceId, ciphertext) {\n      const instance = this.instances[instanceId];\n      if (!instance) {\n        throw new Error('Invalid instance ID: ' + instanceId);\n      }\n\n      if (ciphertext.length !== SERPENT_CONSTANTS.BLOCK_SIZE) {\n        throw new Error('Serpent block size must be exactly ' + SERPENT_CONSTANTS.BLOCK_SIZE + ' bytes');\n      }\n\n      // Convert ciphertext to 32-bit words (little-endian)\n      const bytes = OpCodes.StringToBytes(ciphertext);\n      let x0 = OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]);\n      let x1 = OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]);\n      let x2 = OpCodes.Pack32LE(bytes[8], bytes[9], bytes[10], bytes[11]);\n      let x3 = OpCodes.Pack32LE(bytes[12], bytes[13], bytes[14], bytes[15]);\n\n      const roundKeys = instance.roundKeys;\n      const sboxOrder = [7, 6, 5, 4, 3, 2, 1, 0]; // Reverse S-box order for decryption\n\n      // Initial key mixing (undo final key mixing)\n      x0 ^= roundKeys[32][0];\n      x1 ^= roundKeys[32][1];\n      x2 ^= roundKeys[32][2];\n      x3 ^= roundKeys[32][3];\n\n      // 32 decryption rounds (in reverse order)\n      for (let round = SERPENT_CONSTANTS.ROUNDS - 1; round >= 0; round--) {\n        // Inverse linear transformation first (except for the last round, which is round 31)\n        if (round < SERPENT_CONSTANTS.ROUNDS - 1) {\n          const ltResult = linearTransformInv(x0, x1, x2, x3);\n          x0 = ltResult[0];\n          x1 = ltResult[1];\n          x2 = ltResult[2];\n          x3 = ltResult[3];\n        }\n\n        // Inverse S-box substitution\n        const sboxIndex = sboxOrder[round % 8];\n        const sboxResult = sboxInvFunctions[sboxIndex](x0, x1, x2, x3);\n        x0 = sboxResult[0];\n        x1 = sboxResult[1];\n        x2 = sboxResult[2];\n        x3 = sboxResult[3];\n\n        // Key mixing\n        x0 ^= roundKeys[round][0];\n        x1 ^= roundKeys[round][1];\n        x2 ^= roundKeys[round][2];\n        x3 ^= roundKeys[round][3];\n      }\n\n      // Convert back to bytes (little-endian)\n      const result = [];\n      const bytes0 = OpCodes.Unpack32LE(x0);\n      const bytes1 = OpCodes.Unpack32LE(x1);\n      const bytes2 = OpCodes.Unpack32LE(x2);\n      const bytes3 = OpCodes.Unpack32LE(x3);\n\n      result.push(...bytes0, ...bytes1, ...bytes2, ...bytes3);\n      \n      return OpCodes.BytesToString(result);\n    },\n\n    // Clear instance data\n    ClearData: function(instanceId) {\n      if (this.instances[instanceId]) {\n        // Clear sensitive data\n        const instance = this.instances[instanceId];\n        if (instance.roundKeys) {\n          for (let i = 0; i < instance.roundKeys.length; i++) {\n            OpCodes.ClearArray(instance.roundKeys[i]);\n          }\n        }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 3620B17AE6A993D0965C7530303138B8768266BAE9",
        "description": "Serpent 128-bit key, all zeros test vector (our implementation)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"6 ±zæ©Ð\\u0018¸vfºé\",\n        \"description\": \"Serpent 128-bit key, all zeros test vector (our implementation)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\",\n        \"expected\": \"\\u0010U@Ð¶[©RGêQ&ëz\",\n        \"description\": \"Serpent 192-bit key, sequential pattern test vector (our implementation)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"Ig+¨ÙùP\\u0019\\u0018\\u0004EI\\u0010\",\n        \"description\": \"Serpent 256-bit key, all zeros test vector (our implementation)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\\u0000\\u0011\\\"3DUfw\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\",\n        \"expected\": \"¤UQ£n\\u0012wË\\u000f]Û\",\n        \"description\": \"Serpent 128-bit key, pattern test vector (our implementation)\"\n    },\n    {\n        \"input\": \"HELLO WORLD TEST\",\n        \"key\": \"1234567890123456\",\n        \"expected\": \"a\\u001e²öÌ¡F|\\\\¥-â³\",\n        \"description\": \"Serpent ASCII plaintext and key test (our implementation)\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"-îg[kt\\u00016}¢¨\\u000f´Ke\",\n        \"description\": \"Serpent 128-bit key, all ones boundary test (our implementation)\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'Serpent Algorithm Specification',\n        url: 'https://www.cl.cam.ac.uk/~rja14/serpent.html',\n        description: 'Official Serpent specification by Anderson, Biham, and Knudsen'\n      },\n      {\n        name: 'Serpent AES Candidate Submission',\n        url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development',\n        description: 'NIST AES candidate submission documents for Serpent'\n      },\n      {\n        name: 'Serpent: A New Block Cipher Proposal (Paper)',\n        url: 'https://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf',\n        description: 'Academic paper introducing the Serpent algorithm design'\n      },\n      {\n        name: 'Fast Software Encryption - Serpent',\n        url: 'https://link.springer.com/chapter/10.1007/3-540-69710-1_14',\n        description: 'FSE conference paper on Serpent algorithm and implementation'\n      }\n    ],\n    implementations: [\n      {\n        name: 'Crypto++ Serpent Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/serpent.cpp',\n        description: 'High-performance C++ Serpent implementation'\n      },\n      {\n        name: 'Bouncy Castle Serpent Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java Serpent implementation from Bouncy Castle'\n      },\n      {\n        name: 'libgcrypt Serpent Implementation',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/serpent.c',\n        description: 'GNU libgcrypt Serpent implementation'\n      },\n      {\n        name: 'OpenSSL Cipher Collection',\n        url: 'https://github.com/openssl/openssl/tree/master/crypto/',\n        description: 'OpenSSL cryptographic library cipher implementations'\n      }\n    ],\n    validation: [\n      {\n        name: 'Serpent Test Vectors',\n        url: 'https://www.cl.cam.ac.uk/~rja14/serpent.html',\n        description: 'Official test vectors from Serpent algorithm creators'\n      },\n      {\n        name: 'NIST AES Finalist Evaluation',\n        url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development',\n        description: 'NIST evaluation and test vectors for AES finalist Serpent'\n      },\n      {\n        name: 'Serpent Cryptanalysis Research',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=1523',\n        description: 'Academic research on Serpent security analysis and cryptanalysis'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n\n    // Initialize cipher\n    Init: function() {\n      if (!global.OpCodes) {\n        throw new Error('OpCodes library is required for Serpent cipher');\n      }\n      this.isInitialized = true;\n      return true;\n    },\n\n    // Key setup\n    KeySetup: function(key) {\n      if (!this.isInitialized) {\n        this.Init();\n      }\n      \n      if (!key || key.length < this.minKeyLength || key.length > this.maxKeyLength) {\n        throw new Error('Serpent key must be between ' + this.minKeyLength + ' and ' + this.maxKeyLength + ' bytes');\n      }\n\n      // Generate unique instance ID\n      let instanceId;\n      do {\n        instanceId = 'Serpent[' + Math.random().toString(36).substr(2, 9) + ']';\n      } while (this.instances[instanceId]);\n\n      // Generate round keys\n      const roundKeys = generateKeySchedule(key);\n      \n      // Store instance\n      this.instances[instanceId] = {\n        roundKeys: roundKeys,\n        keyLength: key.length\n      };\n\n      return instanceId;\n    },\n\n    // Encrypt a block\n    encryptBlock: function(instanceId, plaintext) {\n      const instance = this.instances[instanceId];\n      if (!instance) {\n        throw new Error('Invalid instance ID: ' + instanceId);\n      }\n\n      if (plaintext.length !== SERPENT_CONSTANTS.BLOCK_SIZE) {\n        throw new Error('Serpent block size must be exactly ' + SERPENT_CONSTANTS.BLOCK_SIZE + ' bytes');\n      }\n\n      // Convert plaintext to 32-bit words (little-endian)\n      const bytes = OpCodes.StringToBytes(plaintext);\n      let x0 = OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]);\n      let x1 = OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]);\n      let x2 = OpCodes.Pack32LE(bytes[8], bytes[9], bytes[10], bytes[11]);\n      let x3 = OpCodes.Pack32LE(bytes[12], bytes[13], bytes[14], bytes[15]);\n\n      const roundKeys = instance.roundKeys;\n      const sboxOrder = [0, 1, 2, 3, 4, 5, 6, 7]; // S-box order for encryption\n\n      // 32 encryption rounds\n      for (let round = 0; round < SERPENT_CONSTANTS.ROUNDS; round++) {\n        // Key mixing\n        x0 ^= roundKeys[round][0];\n        x1 ^= roundKeys[round][1];\n        x2 ^= roundKeys[round][2];\n        x3 ^= roundKeys[round][3];\n\n        // S-box substitution\n        const sboxIndex = sboxOrder[round % 8];\n        const sboxResult = sboxFunctions[sboxIndex](x0, x1, x2, x3);\n        x0 = sboxResult[0];\n        x1 = sboxResult[1];\n        x2 = sboxResult[2];\n        x3 = sboxResult[3];\n\n        // Linear transformation (except in the last round)\n        if (round < SERPENT_CONSTANTS.ROUNDS - 1) {\n          const ltResult = linearTransform(x0, x1, x2, x3);\n          x0 = ltResult[0];\n          x1 = ltResult[1];\n          x2 = ltResult[2];\n          x3 = ltResult[3];\n        }\n      }\n\n      // Final key mixing\n      x0 ^= roundKeys[32][0];\n      x1 ^= roundKeys[32][1];\n      x2 ^= roundKeys[32][2];\n      x3 ^= roundKeys[32][3];\n\n      // Convert back to bytes (little-endian)\n      const result = [];\n      const bytes0 = OpCodes.Unpack32LE(x0);\n      const bytes1 = OpCodes.Unpack32LE(x1);\n      const bytes2 = OpCodes.Unpack32LE(x2);\n      const bytes3 = OpCodes.Unpack32LE(x3);\n\n      result.push(...bytes0, ...bytes1, ...bytes2, ...bytes3);\n      \n      return OpCodes.BytesToString(result);\n    },\n\n    // Decrypt a block\n    decryptBlock: function(instanceId, ciphertext) {\n      const instance = this.instances[instanceId];\n      if (!instance) {\n        throw new Error('Invalid instance ID: ' + instanceId);\n      }\n\n      if (ciphertext.length !== SERPENT_CONSTANTS.BLOCK_SIZE) {\n        throw new Error('Serpent block size must be exactly ' + SERPENT_CONSTANTS.BLOCK_SIZE + ' bytes');\n      }\n\n      // Convert ciphertext to 32-bit words (little-endian)\n      const bytes = OpCodes.StringToBytes(ciphertext);\n      let x0 = OpCodes.Pack32LE(bytes[0], bytes[1], bytes[2], bytes[3]);\n      let x1 = OpCodes.Pack32LE(bytes[4], bytes[5], bytes[6], bytes[7]);\n      let x2 = OpCodes.Pack32LE(bytes[8], bytes[9], bytes[10], bytes[11]);\n      let x3 = OpCodes.Pack32LE(bytes[12], bytes[13], bytes[14], bytes[15]);\n\n      const roundKeys = instance.roundKeys;\n      const sboxOrder = [7, 6, 5, 4, 3, 2, 1, 0]; // Reverse S-box order for decryption\n\n      // Initial key mixing (undo final key mixing)\n      x0 ^= roundKeys[32][0];\n      x1 ^= roundKeys[32][1];\n      x2 ^= roundKeys[32][2];\n      x3 ^= roundKeys[32][3];\n\n      // 32 decryption rounds (in reverse order)\n      for (let round = SERPENT_CONSTANTS.ROUNDS - 1; round >= 0; round--) {\n        // Inverse linear transformation first (except for the last round, which is round 31)\n        if (round < SERPENT_CONSTANTS.ROUNDS - 1) {\n          const ltResult = linearTransformInv(x0, x1, x2, x3);\n          x0 = ltResult[0];\n          x1 = ltResult[1];\n          x2 = ltResult[2];\n          x3 = ltResult[3];\n        }\n\n        // Inverse S-box substitution\n        const sboxIndex = sboxOrder[round % 8];\n        const sboxResult = sboxInvFunctions[sboxIndex](x0, x1, x2, x3);\n        x0 = sboxResult[0];\n        x1 = sboxResult[1];\n        x2 = sboxResult[2];\n        x3 = sboxResult[3];\n\n        // Key mixing\n        x0 ^= roundKeys[round][0];\n        x1 ^= roundKeys[round][1];\n        x2 ^= roundKeys[round][2];\n        x3 ^= roundKeys[round][3];\n      }\n\n      // Convert back to bytes (little-endian)\n      const result = [];\n      const bytes0 = OpCodes.Unpack32LE(x0);\n      const bytes1 = OpCodes.Unpack32LE(x1);\n      const bytes2 = OpCodes.Unpack32LE(x2);\n      const bytes3 = OpCodes.Unpack32LE(x3);\n\n      result.push(...bytes0, ...bytes1, ...bytes2, ...bytes3);\n      \n      return OpCodes.BytesToString(result);\n    },\n\n    // Clear instance data\n    ClearData: function(instanceId) {\n      if (this.instances[instanceId]) {\n        // Clear sensitive data\n        const instance = this.instances[instanceId];\n        if (instance.roundKeys) {\n          for (let i = 0; i < instance.roundKeys.length; i++) {\n            OpCodes.ClearArray(instance.roundKeys[i]);\n          }\n        }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "3620B17AE6A993D0965C7530303138B8768266BAE9"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "ª®Þgd\\u0014=",
        "description": "SkipJack all zeros test vector - verified implementation",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"ª®Þgd\\u0014=\",\n        \"description\": \"SkipJack all zeros test vector - verified implementation\"\n    },\n    {\n        \"input\": \"3\\\"\\u0011\\u0000ÝÌ»ª\",\n        \"key\": \"\\u0000wfUD3\\\"\\u0011\",\n        \"expected\": \"%Êâz\\u0012Ó\\u0000\",\n        \"description\": \"SkipJack reference test vector - matches GitHub cryptospecs implementation\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"è\\u0013!óJ 9\",\n        \"description\": \"SkipJack all ones test vector - boundary condition\"\n    },\n    {\n        \"input\": \"TESTDATA\",\n        \"key\": \"1234567890\",\n        \"expected\": \"ËÚ½!Í \",\n        \"description\": \"SkipJack ASCII plaintext and key test\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u00124Vx¼Þð\\u00124\",\n        \"expected\": \"ÊSº%×\\u0015\",\n        \"description\": \"SkipJack sequential pattern test vector\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // SkipJack F-table (S-box) - Official from NSA specification\n    FTABLE: [\n      0xa3,0xd7,0x09,0x83,0xf8,0x48,0xf6,0xf4,0xb3,0x21,0x15,0x78,0x99,0xb1,0xaf,0xf9,\n      0xe7,0x2d,0x4d,0x8a,0xce,0x4c,0xca,0x2e,0x52,0x95,0xd9,0x1e,0x4e,0x38,0x44,0x28,\n      0x0a,0xdf,0x02,0xa0,0x17,0xf1,0x60,0x68,0x12,0xb7,0x7a,0xc3,0xe9,0xfa,0x3d,0x53,\n      0x96,0x84,0x6b,0xba,0xf2,0x63,0x9a,0x19,0x7c,0xae,0xe5,0xf5,0xf7,0x16,0x6a,0xa2,\n      0x39,0xb6,0x7b,0x0f,0xc1,0x93,0x81,0x1b,0xee,0xb4,0x1a,0xea,0xd0,0x91,0x2f,0xb8,\n      0x55,0xb9,0xda,0x85,0x3f,0x41,0xbf,0xe0,0x5a,0x58,0x80,0x5f,0x66,0x0b,0xd8,0x90,\n      0x35,0xd5,0xc0,0xa7,0x33,0x06,0x65,0x69,0x45,0x00,0x94,0x56,0x6d,0x98,0x9b,0x76,\n      0x97,0xfc,0xb2,0xc2,0xb0,0xfe,0xdb,0x20,0xe1,0xeb,0xd6,0xe4,0xdd,0x47,0x4a,0x1d,\n      0x42,0xed,0x9e,0x6e,0x49,0x3c,0xcd,0x43,0x27,0xd2,0x07,0xd4,0xde,0xc7,0x67,0x18,\n      0x89,0xcb,0x30,0x1f,0x8d,0xc6,0x8f,0xaa,0xc8,0x74,0xdc,0xc9,0x5d,0x5c,0x31,0xa4,\n      0x70,0x88,0x61,0x2c,0x9f,0x0d,0x2b,0x87,0x50,0x82,0x54,0x64,0x26,0x7d,0x03,0x40,\n      0x34,0x4b,0x1c,0x73,0xd1,0xc4,0xfd,0x3b,0xcc,0xfb,0x7f,0xab,0xe6,0x3e,0x5b,0xa5,\n      0xad,0x04,0x23,0x9c,0x14,0x51,0x22,0xf0,0x29,0x79,0x71,0x7e,0xff,0x8c,0x0e,0xe2,\n      0x0c,0xef,0xbc,0x72,0x75,0x6f,0x37,0xa1,0xec,0xd3,0x8e,0x62,0x8b,0x86,0x10,0xe8,\n      0x08,0x77,0x11,0xbe,0x92,0x4f,0x24,0xc5,0x32,0x36,0x9d,0xcf,0xf3,0xa6,0xbb,0xac,\n      0x5e,0x6c,0xa9,0x13,0x57,0x25,0xb5,0xe3,0xbd,0xa8,0x3a,0x01,0x05,0x59,0x2a,0x46\n    ],\n    \n    // Initialize cipher\n    Init: function() {\n      SkipJack.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || optional_szKey.length !== 10) {\n        global.throwException('Key Length Exception', optional_szKey ? optional_szKey.length : 0, 'SkipJack', 'KeySetup');\n        return false;\n      }\n      \n      let id;\n      do {\n        id = 'SkipJack[' + global.generateUniqueID() + ']';\n      } while (SkipJack.instances[id] || global.objectInstances[id]);\n      \n      SkipJack.instances[szID] = new SkipJack.SkipJackInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (SkipJack.instances[id]) {\n        const instance = SkipJack.instances[szID];\n        if (instance.key) global.OpCodes.ClearArray(instance.key);\n        \n        delete SkipJack.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'SkipJack', 'ClearData');\n        return false;\n      }\n    },\n    \n    // G-function definitions (matching C reference implementation)\n    g0: function(input, key) {\n      const g1 = (input >>> 8) & 0xFF;\n      const g2 = input & 0xFF;\n      const g3 = SkipJack.FTABLE[g2 ^ key[0]] ^ g1;\n      const g4 = SkipJack.FTABLE[g3 ^ key[1]] ^ g2;\n      const g5 = SkipJack.FTABLE[g4 ^ key[2]] ^ g3;\n      const g6 = SkipJack.FTABLE[g5 ^ key[3]] ^ g4;\n      return (g5 << 8) | g6;\n    },\n    \n    g4: function(input, key) {\n      const g1 = (input >>> 8) & 0xFF;\n      const g2 = input & 0xFF;\n      const g3 = SkipJack.FTABLE[g2 ^ key[4]] ^ g1;\n      const g4 = SkipJack.FTABLE[g3 ^ key[5]] ^ g2;\n      const g5 = SkipJack.FTABLE[g4 ^ key[6]] ^ g3;\n      const g6 = SkipJack.FTABLE[g5 ^ key[7]] ^ g4;\n      return (g5 << 8) | g6;\n    },\n    \n    g8: function(input, key) {\n      const g1 = (input >>> 8) & 0xFF;\n      const g2 = input & 0xFF;\n      const g3 = SkipJack.FTABLE[g2 ^ key[8]] ^ g1;\n      const g4 = SkipJack.FTABLE[g3 ^ key[9]] ^ g2;\n      const g5 = SkipJack.FTABLE[g4 ^ key[0]] ^ g3;\n      const g6 = SkipJack.FTABLE[g5 ^ key[1]] ^ g4;\n      return (g5 << 8) | g6;\n    },\n    \n    g2: function(input, key) {\n      const g1 = (input >>> 8) & 0xFF;\n      const g2 = input & 0xFF;\n      const g3 = SkipJack.FTABLE[g2 ^ key[2]] ^ g1;\n      const g4 = SkipJack.FTABLE[g3 ^ key[3]] ^ g2;\n      const g5 = SkipJack.FTABLE[g4 ^ key[4]] ^ g3;\n      const g6 = SkipJack.FTABLE[g5 ^ key[5]] ^ g4;\n      return (g5 << 8) | g6;\n    },\n    \n    g6: function(input, key) {\n      const g1 = (input >>> 8) & 0xFF;\n      const g2 = input & 0xFF;\n      const g3 = SkipJack.FTABLE[g2 ^ key[6]] ^ g1;\n      const g4 = SkipJack.FTABLE[g3 ^ key[7]] ^ g2;\n      const g5 = SkipJack.FTABLE[g4 ^ key[8]] ^ g3;\n      const g6 = SkipJack.FTABLE[g5 ^ key[9]] ^ g4;\n      return (g5 << 8) | g6;\n    },\n    \n    // Inverse G-functions for decryption\n    g0_inv: function(input, key) {\n      const g6 = input & 0xFF;\n      const g5 = (input >>> 8) & 0xFF;\n      const g4 = SkipJack.FTABLE[g5 ^ key[3]] ^ g6;\n      const g3 = SkipJack.FTABLE[g4 ^ key[2]] ^ g5;\n      const g2 = SkipJack.FTABLE[g3 ^ key[1]] ^ g4;\n      const g1 = SkipJack.FTABLE[g2 ^ key[0]] ^ g3;\n      return (g1 << 8) | g2;\n    },\n    \n    g4_inv: function(input, key) {\n      const g6 = input & 0xFF;\n      const g5 = (input >>> 8) & 0xFF;\n      const g4 = SkipJack.FTABLE[g5 ^ key[7]] ^ g6;\n      const g3 = SkipJack.FTABLE[g4 ^ key[6]] ^ g5;\n      const g2 = SkipJack.FTABLE[g3 ^ key[5]] ^ g4;\n      const g1 = SkipJack.FTABLE[g2 ^ key[4]] ^ g3;\n      return (g1 << 8) | g2;\n    },\n    \n    g8_inv: function(input, key) {\n      const g6 = input & 0xFF;\n      const g5 = (input >>> 8) & 0xFF;\n      const g4 = SkipJack.FTABLE[g5 ^ key[1]] ^ g6;\n      const g3 = SkipJack.FTABLE[g4 ^ key[0]] ^ g5;\n      const g2 = SkipJack.FTABLE[g3 ^ key[9]] ^ g4;\n      const g1 = SkipJack.FTABLE[g2 ^ key[8]] ^ g3;\n      return (g1 << 8) | g2;\n    },\n    \n    g2_inv: function(input, key) {\n      const g6 = input & 0xFF;\n      const g5 = (input >>> 8) & 0xFF;\n      const g4 = SkipJack.FTABLE[g5 ^ key[5]] ^ g6;\n      const g3 = SkipJack.FTABLE[g4 ^ key[4]] ^ g5;\n      const g2 = SkipJack.FTABLE[g3 ^ key[3]] ^ g4;\n      const g1 = SkipJack.FTABLE[g2 ^ key[2]] ^ g3;\n      return (g1 << 8) | g2;\n    },\n    \n    g6_inv: function(input, key) {\n      const g6 = input & 0xFF;\n      const g5 = (input >>> 8) & 0xFF;\n      const g4 = SkipJack.FTABLE[g5 ^ key[9]] ^ g6;\n      const g3 = SkipJack.FTABLE[g4 ^ key[8]] ^ g5;\n      const g2 = SkipJack.FTABLE[g3 ^ key[7]] ^ g4;\n      const g1 = SkipJack.FTABLE[g2 ^ key[6]] ^ g3;\n      return (g1 << 8) | g2;\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, szPlainText) {\n      if (!SkipJack.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'SkipJack', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 8) {\n        global.throwException('Block Size Exception', szPlainText.length, 'SkipJack', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = SkipJack.instances[szID];\n      const key = instance.key;\n      \n      // Convert plaintext to 4 16-bit words using OpCodes\n      const bytes = global.OpCodes.StringToBytes(szPlainText);\n      let w1 = global.OpCodes.Pack32BE(bytes[0], bytes[1], 0, 0) >>> 16;\n      let w2 = global.OpCodes.Pack32BE(bytes[2], bytes[3], 0, 0) >>> 16;\n      let w3 = global.OpCodes.Pack32BE(bytes[4], bytes[5], 0, 0) >>> 16;\n      let w4 = global.OpCodes.Pack32BE(bytes[6], bytes[7], 0, 0) >>> 16;\n      \n      // First 8 rounds (Rule A) - exactly matching C reference\n      w1 = SkipJack.g0(w1, key); w4 ^= w1 ^ 1;\n      w4 = SkipJack.g4(w4, key); w3 ^= w4 ^ 2;\n      w3 = SkipJack.g8(w3, key); w2 ^= w3 ^ 3;\n      w2 = SkipJack.g2(w2, key); w1 ^= w2 ^ 4;\n      w1 = SkipJack.g6(w1, key); w4 ^= w1 ^ 5;\n      w4 = SkipJack.g0(w4, key); w3 ^= w4 ^ 6;\n      w3 = SkipJack.g4(w3, key); w2 ^= w3 ^ 7;\n      w2 = SkipJack.g8(w2, key); w1 ^= w2 ^ 8;\n      \n      // Second 8 rounds (Rule B) - exactly matching C reference\n      w2 ^= w1 ^ 9;  w1 = SkipJack.g2(w1, key);\n      w1 ^= w4 ^ 10; w4 = SkipJack.g6(w4, key);\n      w4 ^= w3 ^ 11; w3 = SkipJack.g0(w3, key);\n      w3 ^= w2 ^ 12; w2 = SkipJack.g4(w2, key);\n      w2 ^= w1 ^ 13; w1 = SkipJack.g8(w1, key);\n      w1 ^= w4 ^ 14; w4 = SkipJack.g2(w4, key);\n      w4 ^= w3 ^ 15; w3 = SkipJack.g6(w3, key);\n      w3 ^= w2 ^ 16; w2 = SkipJack.g0(w2, key);\n      \n      // Third 8 rounds (Rule A) - exactly matching C reference\n      w1 = SkipJack.g4(w1, key); w4 ^= w1 ^ 17;\n      w4 = SkipJack.g8(w4, key); w3 ^= w4 ^ 18;\n      w3 = SkipJack.g2(w3, key); w2 ^= w3 ^ 19;\n      w2 = SkipJack.g6(w2, key); w1 ^= w2 ^ 20;\n      w1 = SkipJack.g0(w1, key); w4 ^= w1 ^ 21;\n      w4 = SkipJack.g4(w4, key); w3 ^= w4 ^ 22;\n      w3 = SkipJack.g8(w3, key); w2 ^= w3 ^ 23;\n      w2 = SkipJack.g2(w2, key); w1 ^= w2 ^ 24;\n      \n      // Last 8 rounds (Rule B) - exactly matching C reference\n      w2 ^= w1 ^ 25; w1 = SkipJack.g6(w1, key);\n      w1 ^= w4 ^ 26; w4 = SkipJack.g0(w4, key);\n      w4 ^= w3 ^ 27; w3 = SkipJack.g4(w3, key);\n      w3 ^= w2 ^ 28; w2 = SkipJack.g8(w2, key);\n      w2 ^= w1 ^ 29; w1 = SkipJack.g2(w1, key);\n      w1 ^= w4 ^ 30; w4 = SkipJack.g6(w4, key);\n      w4 ^= w3 ^ 31; w3 = SkipJack.g0(w3, key);\n      w3 ^= w2 ^ 32; w2 = SkipJack.g4(w2, key);\n      \n      // Pack back to bytes using OpCodes\n      const cipherBytes = [\n        (w1 >>> 8) & 0xFF, w1 & 0xFF,\n        (w2 >>> 8) & 0xFF, w2 & 0xFF,\n        (w3 >>> 8) & 0xFF, w3 & 0xFF,\n        (w4 >>> 8) & 0xFF, w4 & 0xFF\n      ];\n      \n      return global.OpCodes.BytesToString(cipherBytes);\n    },\n    \n    // Decrypt block  \n    decryptBlock: function(id, szCipherText) {\n      if (!SkipJack.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'SkipJack', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 8) {\n        global.throwException('Block Size Exception', szCipherText.length, 'SkipJack', 'decryptBlock');\n        return szCipherText;\n      }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): AAAE8EDE67645C75303031343D",
        "description": "SkipJack all zeros test vector - verified implementation",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"ª®Þgd\\u0014=\",\n        \"description\": \"SkipJack all zeros test vector - verified implementation\"\n    },\n    {\n        \"input\": \"3\\\"\\u0011\\u0000ÝÌ»ª\",\n        \"key\": \"\\u0000wfUD3\\\"\\u0011\",\n        \"expected\": \"%Êâz\\u0012Ó\\u0000\",\n        \"description\": \"SkipJack reference test vector - matches GitHub cryptospecs implementation\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"è\\u0013!óJ 9\",\n        \"description\": \"SkipJack all ones test vector - boundary condition\"\n    },\n    {\n        \"input\": \"TESTDATA\",\n        \"key\": \"1234567890\",\n        \"expected\": \"ËÚ½!Í \",\n        \"description\": \"SkipJack ASCII plaintext and key test\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u00124Vx¼Þð\\u00124\",\n        \"expected\": \"ÊSº%×\\u0015\",\n        \"description\": \"SkipJack sequential pattern test vector\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // SkipJack F-table (S-box) - Official from NSA specification\n    FTABLE: [\n      0xa3,0xd7,0x09,0x83,0xf8,0x48,0xf6,0xf4,0xb3,0x21,0x15,0x78,0x99,0xb1,0xaf,0xf9,\n      0xe7,0x2d,0x4d,0x8a,0xce,0x4c,0xca,0x2e,0x52,0x95,0xd9,0x1e,0x4e,0x38,0x44,0x28,\n      0x0a,0xdf,0x02,0xa0,0x17,0xf1,0x60,0x68,0x12,0xb7,0x7a,0xc3,0xe9,0xfa,0x3d,0x53,\n      0x96,0x84,0x6b,0xba,0xf2,0x63,0x9a,0x19,0x7c,0xae,0xe5,0xf5,0xf7,0x16,0x6a,0xa2,\n      0x39,0xb6,0x7b,0x0f,0xc1,0x93,0x81,0x1b,0xee,0xb4,0x1a,0xea,0xd0,0x91,0x2f,0xb8,\n      0x55,0xb9,0xda,0x85,0x3f,0x41,0xbf,0xe0,0x5a,0x58,0x80,0x5f,0x66,0x0b,0xd8,0x90,\n      0x35,0xd5,0xc0,0xa7,0x33,0x06,0x65,0x69,0x45,0x00,0x94,0x56,0x6d,0x98,0x9b,0x76,\n      0x97,0xfc,0xb2,0xc2,0xb0,0xfe,0xdb,0x20,0xe1,0xeb,0xd6,0xe4,0xdd,0x47,0x4a,0x1d,\n      0x42,0xed,0x9e,0x6e,0x49,0x3c,0xcd,0x43,0x27,0xd2,0x07,0xd4,0xde,0xc7,0x67,0x18,\n      0x89,0xcb,0x30,0x1f,0x8d,0xc6,0x8f,0xaa,0xc8,0x74,0xdc,0xc9,0x5d,0x5c,0x31,0xa4,\n      0x70,0x88,0x61,0x2c,0x9f,0x0d,0x2b,0x87,0x50,0x82,0x54,0x64,0x26,0x7d,0x03,0x40,\n      0x34,0x4b,0x1c,0x73,0xd1,0xc4,0xfd,0x3b,0xcc,0xfb,0x7f,0xab,0xe6,0x3e,0x5b,0xa5,\n      0xad,0x04,0x23,0x9c,0x14,0x51,0x22,0xf0,0x29,0x79,0x71,0x7e,0xff,0x8c,0x0e,0xe2,\n      0x0c,0xef,0xbc,0x72,0x75,0x6f,0x37,0xa1,0xec,0xd3,0x8e,0x62,0x8b,0x86,0x10,0xe8,\n      0x08,0x77,0x11,0xbe,0x92,0x4f,0x24,0xc5,0x32,0x36,0x9d,0xcf,0xf3,0xa6,0xbb,0xac,\n      0x5e,0x6c,0xa9,0x13,0x57,0x25,0xb5,0xe3,0xbd,0xa8,0x3a,0x01,0x05,0x59,0x2a,0x46\n    ],\n    \n    // Initialize cipher\n    Init: function() {\n      SkipJack.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || optional_szKey.length !== 10) {\n        global.throwException('Key Length Exception', optional_szKey ? optional_szKey.length : 0, 'SkipJack', 'KeySetup');\n        return false;\n      }\n      \n      let id;\n      do {\n        id = 'SkipJack[' + global.generateUniqueID() + ']';\n      } while (SkipJack.instances[id] || global.objectInstances[id]);\n      \n      SkipJack.instances[szID] = new SkipJack.SkipJackInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (SkipJack.instances[id]) {\n        const instance = SkipJack.instances[szID];\n        if (instance.key) global.OpCodes.ClearArray(instance.key);\n        \n        delete SkipJack.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'SkipJack', 'ClearData');\n        return false;\n      }\n    },\n    \n    // G-function definitions (matching C reference implementation)\n    g0: function(input, key) {\n      const g1 = (input >>> 8) & 0xFF;\n      const g2 = input & 0xFF;\n      const g3 = SkipJack.FTABLE[g2 ^ key[0]] ^ g1;\n      const g4 = SkipJack.FTABLE[g3 ^ key[1]] ^ g2;\n      const g5 = SkipJack.FTABLE[g4 ^ key[2]] ^ g3;\n      const g6 = SkipJack.FTABLE[g5 ^ key[3]] ^ g4;\n      return (g5 << 8) | g6;\n    },\n    \n    g4: function(input, key) {\n      const g1 = (input >>> 8) & 0xFF;\n      const g2 = input & 0xFF;\n      const g3 = SkipJack.FTABLE[g2 ^ key[4]] ^ g1;\n      const g4 = SkipJack.FTABLE[g3 ^ key[5]] ^ g2;\n      const g5 = SkipJack.FTABLE[g4 ^ key[6]] ^ g3;\n      const g6 = SkipJack.FTABLE[g5 ^ key[7]] ^ g4;\n      return (g5 << 8) | g6;\n    },\n    \n    g8: function(input, key) {\n      const g1 = (input >>> 8) & 0xFF;\n      const g2 = input & 0xFF;\n      const g3 = SkipJack.FTABLE[g2 ^ key[8]] ^ g1;\n      const g4 = SkipJack.FTABLE[g3 ^ key[9]] ^ g2;\n      const g5 = SkipJack.FTABLE[g4 ^ key[0]] ^ g3;\n      const g6 = SkipJack.FTABLE[g5 ^ key[1]] ^ g4;\n      return (g5 << 8) | g6;\n    },\n    \n    g2: function(input, key) {\n      const g1 = (input >>> 8) & 0xFF;\n      const g2 = input & 0xFF;\n      const g3 = SkipJack.FTABLE[g2 ^ key[2]] ^ g1;\n      const g4 = SkipJack.FTABLE[g3 ^ key[3]] ^ g2;\n      const g5 = SkipJack.FTABLE[g4 ^ key[4]] ^ g3;\n      const g6 = SkipJack.FTABLE[g5 ^ key[5]] ^ g4;\n      return (g5 << 8) | g6;\n    },\n    \n    g6: function(input, key) {\n      const g1 = (input >>> 8) & 0xFF;\n      const g2 = input & 0xFF;\n      const g3 = SkipJack.FTABLE[g2 ^ key[6]] ^ g1;\n      const g4 = SkipJack.FTABLE[g3 ^ key[7]] ^ g2;\n      const g5 = SkipJack.FTABLE[g4 ^ key[8]] ^ g3;\n      const g6 = SkipJack.FTABLE[g5 ^ key[9]] ^ g4;\n      return (g5 << 8) | g6;\n    },\n    \n    // Inverse G-functions for decryption\n    g0_inv: function(input, key) {\n      const g6 = input & 0xFF;\n      const g5 = (input >>> 8) & 0xFF;\n      const g4 = SkipJack.FTABLE[g5 ^ key[3]] ^ g6;\n      const g3 = SkipJack.FTABLE[g4 ^ key[2]] ^ g5;\n      const g2 = SkipJack.FTABLE[g3 ^ key[1]] ^ g4;\n      const g1 = SkipJack.FTABLE[g2 ^ key[0]] ^ g3;\n      return (g1 << 8) | g2;\n    },\n    \n    g4_inv: function(input, key) {\n      const g6 = input & 0xFF;\n      const g5 = (input >>> 8) & 0xFF;\n      const g4 = SkipJack.FTABLE[g5 ^ key[7]] ^ g6;\n      const g3 = SkipJack.FTABLE[g4 ^ key[6]] ^ g5;\n      const g2 = SkipJack.FTABLE[g3 ^ key[5]] ^ g4;\n      const g1 = SkipJack.FTABLE[g2 ^ key[4]] ^ g3;\n      return (g1 << 8) | g2;\n    },\n    \n    g8_inv: function(input, key) {\n      const g6 = input & 0xFF;\n      const g5 = (input >>> 8) & 0xFF;\n      const g4 = SkipJack.FTABLE[g5 ^ key[1]] ^ g6;\n      const g3 = SkipJack.FTABLE[g4 ^ key[0]] ^ g5;\n      const g2 = SkipJack.FTABLE[g3 ^ key[9]] ^ g4;\n      const g1 = SkipJack.FTABLE[g2 ^ key[8]] ^ g3;\n      return (g1 << 8) | g2;\n    },\n    \n    g2_inv: function(input, key) {\n      const g6 = input & 0xFF;\n      const g5 = (input >>> 8) & 0xFF;\n      const g4 = SkipJack.FTABLE[g5 ^ key[5]] ^ g6;\n      const g3 = SkipJack.FTABLE[g4 ^ key[4]] ^ g5;\n      const g2 = SkipJack.FTABLE[g3 ^ key[3]] ^ g4;\n      const g1 = SkipJack.FTABLE[g2 ^ key[2]] ^ g3;\n      return (g1 << 8) | g2;\n    },\n    \n    g6_inv: function(input, key) {\n      const g6 = input & 0xFF;\n      const g5 = (input >>> 8) & 0xFF;\n      const g4 = SkipJack.FTABLE[g5 ^ key[9]] ^ g6;\n      const g3 = SkipJack.FTABLE[g4 ^ key[8]] ^ g5;\n      const g2 = SkipJack.FTABLE[g3 ^ key[7]] ^ g4;\n      const g1 = SkipJack.FTABLE[g2 ^ key[6]] ^ g3;\n      return (g1 << 8) | g2;\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, szPlainText) {\n      if (!SkipJack.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'SkipJack', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 8) {\n        global.throwException('Block Size Exception', szPlainText.length, 'SkipJack', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = SkipJack.instances[szID];\n      const key = instance.key;\n      \n      // Convert plaintext to 4 16-bit words using OpCodes\n      const bytes = global.OpCodes.StringToBytes(szPlainText);\n      let w1 = global.OpCodes.Pack32BE(bytes[0], bytes[1], 0, 0) >>> 16;\n      let w2 = global.OpCodes.Pack32BE(bytes[2], bytes[3], 0, 0) >>> 16;\n      let w3 = global.OpCodes.Pack32BE(bytes[4], bytes[5], 0, 0) >>> 16;\n      let w4 = global.OpCodes.Pack32BE(bytes[6], bytes[7], 0, 0) >>> 16;\n      \n      // First 8 rounds (Rule A) - exactly matching C reference\n      w1 = SkipJack.g0(w1, key); w4 ^= w1 ^ 1;\n      w4 = SkipJack.g4(w4, key); w3 ^= w4 ^ 2;\n      w3 = SkipJack.g8(w3, key); w2 ^= w3 ^ 3;\n      w2 = SkipJack.g2(w2, key); w1 ^= w2 ^ 4;\n      w1 = SkipJack.g6(w1, key); w4 ^= w1 ^ 5;\n      w4 = SkipJack.g0(w4, key); w3 ^= w4 ^ 6;\n      w3 = SkipJack.g4(w3, key); w2 ^= w3 ^ 7;\n      w2 = SkipJack.g8(w2, key); w1 ^= w2 ^ 8;\n      \n      // Second 8 rounds (Rule B) - exactly matching C reference\n      w2 ^= w1 ^ 9;  w1 = SkipJack.g2(w1, key);\n      w1 ^= w4 ^ 10; w4 = SkipJack.g6(w4, key);\n      w4 ^= w3 ^ 11; w3 = SkipJack.g0(w3, key);\n      w3 ^= w2 ^ 12; w2 = SkipJack.g4(w2, key);\n      w2 ^= w1 ^ 13; w1 = SkipJack.g8(w1, key);\n      w1 ^= w4 ^ 14; w4 = SkipJack.g2(w4, key);\n      w4 ^= w3 ^ 15; w3 = SkipJack.g6(w3, key);\n      w3 ^= w2 ^ 16; w2 = SkipJack.g0(w2, key);\n      \n      // Third 8 rounds (Rule A) - exactly matching C reference\n      w1 = SkipJack.g4(w1, key); w4 ^= w1 ^ 17;\n      w4 = SkipJack.g8(w4, key); w3 ^= w4 ^ 18;\n      w3 = SkipJack.g2(w3, key); w2 ^= w3 ^ 19;\n      w2 = SkipJack.g6(w2, key); w1 ^= w2 ^ 20;\n      w1 = SkipJack.g0(w1, key); w4 ^= w1 ^ 21;\n      w4 = SkipJack.g4(w4, key); w3 ^= w4 ^ 22;\n      w3 = SkipJack.g8(w3, key); w2 ^= w3 ^ 23;\n      w2 = SkipJack.g2(w2, key); w1 ^= w2 ^ 24;\n      \n      // Last 8 rounds (Rule B) - exactly matching C reference\n      w2 ^= w1 ^ 25; w1 = SkipJack.g6(w1, key);\n      w1 ^= w4 ^ 26; w4 = SkipJack.g0(w4, key);\n      w4 ^= w3 ^ 27; w3 = SkipJack.g4(w3, key);\n      w3 ^= w2 ^ 28; w2 = SkipJack.g8(w2, key);\n      w2 ^= w1 ^ 29; w1 = SkipJack.g2(w1, key);\n      w1 ^= w4 ^ 30; w4 = SkipJack.g6(w4, key);\n      w4 ^= w3 ^ 31; w3 = SkipJack.g0(w3, key);\n      w3 ^= w2 ^ 32; w2 = SkipJack.g4(w2, key);\n      \n      // Pack back to bytes using OpCodes\n      const cipherBytes = [\n        (w1 >>> 8) & 0xFF, w1 & 0xFF,\n        (w2 >>> 8) & 0xFF, w2 & 0xFF,\n        (w3 >>> 8) & 0xFF, w3 & 0xFF,\n        (w4 >>> 8) & 0xFF, w4 & 0xFF\n      ];\n      \n      return global.OpCodes.BytesToString(cipherBytes);\n    },\n    \n    // Decrypt block  \n    decryptBlock: function(id, szCipherText) {\n      if (!SkipJack.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'SkipJack', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 8) {\n        global.throwException('Block Size Exception', szCipherText.length, 'SkipJack', 'decryptBlock');\n        return szCipherText;\n      }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "AAAE8EDE67645C75303031343D"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "\\u000fîÚo/TX\\\\F¿ò8âÈ",
        "description": "Square all zeros test vector - our implementation baseline",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"\\u000fîÚo/TX\\\\F¿ò8âÈ\",\n        \"description\": \"Square all zeros test vector - our implementation baseline\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"½KïMi\\u0005Çô^ßH·a:\",\n        \"description\": \"Square all ones test vector - boundary condition\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\\u0000\\u0011\\\"3DUfw\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\",\n        \"expected\": \"\\u000f\\u0001Z³Íq°ýið^ÿ\\u0017\\u0001\",\n        \"description\": \"Square sequential pattern test vector\"\n    },\n    {\n        \"input\": \"HELLO WORLD TEST\",\n        \"key\": \"1234567890123456\",\n        \"expected\": \"+8\\u0018[ICÑë\\u0011q\\u0005Í\",\n        \"description\": \"Square ASCII plaintext test vector\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Square cipher constants\n    BLOCK_LENGTH: 16,     // 128 bits\n    KEY_LENGTH: 16,       // 128 bits  \n    ROUNDS: 8,            // Number of rounds\n    ROOT: 0x1f5,          // GF(2^8) generator polynomial\n    \n    // S-Box for encryption (from Square1.java computed)\n    SBOX_E: [\n      0xb1, 0xce, 0xc3, 0x95, 0x5a, 0xad, 0xe7, 0x02, 0x4d, 0x44, 0xfb, 0x91, 0x0c, 0x87, 0xa1, 0x50,\n      0xcb, 0x67, 0x54, 0xdd, 0x46, 0x8f, 0xe1, 0x4e, 0xf0, 0xfd, 0xfc, 0xeb, 0xf9, 0xc4, 0x1a, 0x6e,\n      0x5e, 0xf5, 0xcc, 0x8d, 0x1c, 0x56, 0x43, 0xfe, 0x07, 0x61, 0xf8, 0x75, 0x59, 0xff, 0x03, 0x22,\n      0x8a, 0xd1, 0x13, 0xee, 0x88, 0x00, 0x0e, 0x34, 0x15, 0x80, 0x94, 0xe3, 0xed, 0xb5, 0x53, 0x23,\n      0x4b, 0x47, 0x17, 0xa7, 0x90, 0x35, 0xab, 0xd8, 0xb8, 0xdf, 0x4f, 0x57, 0x9a, 0x92, 0xdb, 0x1b,\n      0x3c, 0xc8, 0x99, 0x04, 0x8e, 0xe0, 0xd7, 0x7d, 0x85, 0xbb, 0x40, 0x2c, 0x3a, 0x45, 0xf1, 0x42,\n      0x65, 0x20, 0x41, 0x18, 0x72, 0x25, 0x93, 0x70, 0x36, 0x05, 0xf2, 0x0b, 0xa3, 0x79, 0xec, 0x08,\n      0x27, 0x31, 0x32, 0xb6, 0x7c, 0xb0, 0x0a, 0x73, 0x5b, 0x7b, 0xb7, 0x81, 0xd2, 0x0d, 0x6a, 0x26,\n      0x9e, 0x58, 0x9c, 0x83, 0x74, 0xb3, 0xac, 0x30, 0x7a, 0x69, 0x77, 0x0f, 0xae, 0x21, 0xde, 0xd0,\n      0x2e, 0x97, 0x10, 0xa4, 0x98, 0xa8, 0xd4, 0x68, 0x2d, 0x62, 0x29, 0x6d, 0x16, 0x49, 0x76, 0xc7,\n      0xe8, 0xc1, 0x96, 0x37, 0xe5, 0xca, 0xf4, 0xe9, 0x63, 0x12, 0xc2, 0xa6, 0x14, 0xbc, 0xd3, 0x28,\n      0xaf, 0x2f, 0xe6, 0x24, 0x52, 0xc6, 0xa0, 0x09, 0xbd, 0x8c, 0xcf, 0x5d, 0x11, 0x5f, 0x01, 0xc5,\n      0x9f, 0x3d, 0xa2, 0x9b, 0xc9, 0x3b, 0xbe, 0x51, 0x19, 0x1f, 0x3f, 0x5c, 0xb2, 0xef, 0x4a, 0xcd,\n      0xbf, 0xba, 0x6f, 0x64, 0xd9, 0xf3, 0x3e, 0xb4, 0xaa, 0xdc, 0xd5, 0x06, 0xc0, 0x7e, 0xf6, 0x66,\n      0x6c, 0x84, 0x71, 0x38, 0xb9, 0x1d, 0x7f, 0x9d, 0x48, 0x8b, 0x2a, 0xda, 0xa5, 0x33, 0x82, 0x39,\n      0xd6, 0x78, 0x86, 0xfa, 0xe4, 0x2b, 0xa9, 0x1e, 0x89, 0x60, 0x6b, 0xea, 0x55, 0x4c, 0xf7, 0xe2\n    ],\n    \n    // S-Box for decryption (inverse of SBOX_E)\n    SBOX_D: [\n      0x35, 0xbe, 0x07, 0x2e, 0x53, 0x69, 0xdb, 0x28, 0x6f, 0xb7, 0x76, 0x6b, 0x0c, 0x7d, 0x36, 0x8b,\n      0x92, 0xbc, 0xa9, 0x32, 0xac, 0x38, 0x9c, 0x42, 0x67, 0xc8, 0x1e, 0x4f, 0x24, 0xe5, 0xf7, 0xc9,\n      0x61, 0x8d, 0x2f, 0x3f, 0xb3, 0x65, 0x7f, 0x70, 0xaf, 0x9a, 0xea, 0xf5, 0x5b, 0x98, 0x90, 0xb1,\n      0x87, 0x71, 0x72, 0xe9, 0x37, 0x45, 0x68, 0xa3, 0xe7, 0xf9, 0x5c, 0xc5, 0x50, 0xc1, 0xd6, 0xca,\n      0x5a, 0x62, 0x5f, 0x26, 0x11, 0x5d, 0x14, 0x41, 0xe8, 0x9d, 0xde, 0x40, 0xf9, 0x08, 0x17, 0x4a,\n      0x0f, 0xc7, 0xb4, 0x3e, 0x12, 0xf0, 0x25, 0x4b, 0x81, 0x2c, 0x04, 0x78, 0xcb, 0xbb, 0x20, 0xbd,\n      0xf1, 0x29, 0x99, 0xa8, 0xd3, 0x60, 0xdf, 0x11, 0x97, 0x89, 0x7e, 0xf6, 0xe0, 0x9b, 0x1f, 0xd2,\n      0x67, 0xe2, 0x64, 0x77, 0x84, 0x2b, 0x9e, 0x8a, 0xf1, 0x6d, 0x88, 0x79, 0x74, 0x57, 0xdd, 0xe6,\n      0x39, 0x7b, 0xee, 0x83, 0xe1, 0x58, 0xf2, 0x0d, 0x34, 0xf8, 0x30, 0xe8, 0xb9, 0x23, 0x54, 0x15,\n      0x44, 0x0b, 0x9f, 0x66, 0x3a, 0x03, 0xa2, 0x91, 0x94, 0x52, 0x9c, 0xc3, 0x82, 0xe7, 0x80, 0xc0,\n      0xb6, 0x0e, 0xc2, 0x6c, 0x93, 0xec, 0xab, 0x43, 0x95, 0xf6, 0xd0, 0x46, 0x86, 0x01, 0x8c, 0xb0,\n      0x75, 0x00, 0xcc, 0x85, 0xd7, 0x3d, 0x73, 0x7a, 0x48, 0xe4, 0xd1, 0x59, 0xad, 0xb8, 0xc6, 0xd8,\n      0xe0, 0xa1, 0xaa, 0x02, 0x1b, 0xbf, 0xb5, 0x9f, 0x51, 0xc4, 0xa5, 0x10, 0x22, 0xde, 0x01, 0xba,\n      0x8f, 0x31, 0x7c, 0xae, 0x96, 0xda, 0xf0, 0x56, 0x47, 0xd4, 0xeb, 0x4c, 0xd9, 0x13, 0x8e, 0x49,\n      0x55, 0x16, 0xff, 0x3b, 0xf4, 0xa4, 0xb2, 0x02, 0xa0, 0xa7, 0xfb, 0x27, 0x6e, 0x3c, 0x33, 0xdc,\n      0x18, 0x5e, 0x6a, 0xd5, 0xa6, 0x21, 0xde, 0xf6, 0x2a, 0x1c, 0xf3, 0x0a, 0x1a, 0x19, 0x07, 0x2d\n    ],\n    \n    // Diffusion polynomial coefficients c(x) = 3x³ + 1x² + 1x + 2  \n    DIFFUSION_C: [0x2, 0x1, 0x1, 0x3],\n    \n    // Inverse diffusion polynomial coefficients d(x) = Bx³ + Dx² + 9x + E\n    DIFFUSION_D: [0xE, 0x9, 0xD, 0xB],\n    \n    // Round offsets for key schedule\n    ROUND_OFFSETS: [0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80],\n    \n    // Initialize cipher\n    Init: function() {\n      Square.isInitialized = true;\n    },\n    \n    // Set up key and create cipher instance\n    KeySetup: function(optional_szKey) {\n      let id;\n      do {\n        id = 'Square[' + global.generateUniqueID() + ']';\n      } while (Square.instances[id] || global.objectInstances[id]);\n      \n      Square.instances[szID] = new Square.SquareInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (Square.instances[id]) {\n        // Clear sensitive key material\n        const instance = Square.instances[szID];\n        if (instance.roundKeysE) {\n          for (let i = 0; i < instance.roundKeysE.length; i++) {\n            OpCodes.ClearArray(instance.roundKeysE[i]);\n          }\n        }\n        if (instance.roundKeysD) {\n          for (let i = 0; i < instance.roundKeysD.length; i++) {\n            OpCodes.ClearArray(instance.roundKeysD[i]);\n          }\n        }\n        \n        delete Square.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'Square', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, szPlainText) {\n      if (!Square.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Square', 'encryptBlock');\n        return '';\n      }\n      \n      const instance = Square.instances[szID];\n      return instance.encryptBlock(szPlainText);\n    },\n    \n    // Decrypt block  \n    decryptBlock: function(id, szCipherText) {\n      if (!Square.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Square', 'decryptBlock');\n        return '';\n      }\n      \n      const instance = Square.instances[szID];\n      return instance.decryptBlock(szCipherText);\n    },\n    \n    // Galois Field multiplication in GF(2^8)\n    gfMul: function(a, b) {\n      if (a === 0 || b === 0) return 0;\n      \n      a &= 0xFF;\n      b &= 0xFF;\n      let p = 0;\n      \n      while (b !== 0) {\n        if (b & 0x01) {\n          p ^= a;\n        }\n        a <<= 1;\n        if (a > 0xFF) {\n          a ^= Square.ROOT;  // Reduce modulo ROOT polynomial\n        }\n        b >>>= 1;\n      }\n      return p & 0xFF;\n    },\n    \n    // Apply theta transformation (diffusion layer)\n    thetaTransform: function(input, coeff) {\n      const result = [0, 0, 0, 0];\n      \n      for (let i = 0; i < 4; i++) {\n        let word = input[i];\n        let mixed = 0;\n        \n        for (let j = 0; j < 4; j++) {\n          const byte = (word >>> (24 - j * 8)) & 0xFF;\n          const product = Square.gfMul(byte, coeff[j]);\n          mixed ^= (product << (24 - j * 8));\n        }\n        result[i] = mixed >>> 0;  // Ensure unsigned 32-bit\n      }\n      return result;\n    },\n    \n    // Square cipher instance class\n    SquareInstance: function(key) {\n      this.roundKeysE = [];  // Encryption round keys\n      this.roundKeysD = [];  // Decryption round keys\n      \n      // Process key\n      let keyBytes;\n      if (typeof key === 'string') {\n        keyBytes = [];\n        for (let i = 0; i < key.length; i++) {\n          keyBytes.push(key.charCodeAt(i) & 0xFF);\n        }\n      } else if (Array.isArray(key)) {\n        keyBytes = key.slice();\n      } else {\n        // Generate random key if none provided\n        keyBytes = [];\n        for (let i = 0; i < Square.KEY_LENGTH; i++) {\n          keyBytes[i] = Math.floor(Math.random() * 256);\n        }\n      }\n      \n      // Ensure key is correct length\n      if (keyBytes.length !== Square.KEY_LENGTH) {\n        keyBytes = keyBytes.slice(0, Square.KEY_LENGTH);\n        while (keyBytes.length < Square.KEY_LENGTH) {\n          keyBytes.push(0);\n        }\n      }\n      \n      // Set up the instance methods\n      this.setupKeys = Square.setupKeys;\n      this.encryptBlock = Square.encryptBlock;\n      this.decryptBlock = Square.decryptBlock;\n      this.roundFunction = Square.roundFunction;\n      this.finalRound = Square.finalRound;\n      \n      this.setupKeys(keyBytes);\n    },\n    \n    setupKeys: function(keyBytes) {\n      // Convert key to 32-bit words (big-endian)\n      const keyWords = [];\n      for (let i = 0; i < 4; i++) {\n        keyWords[i] = OpCodes.Pack32BE(\n          keyBytes[i * 4],\n          keyBytes[i * 4 + 1], \n          keyBytes[i * 4 + 2],\n          keyBytes[i * 4 + 3]\n        );\n      }\n      \n      // Initialize round keys\n      this.roundKeysE = [];\n      this.roundKeysD = [];\n      \n      // First round key is the user key\n      this.roundKeysE[0] = keyWords.slice();\n      \n      // Generate round keys using Square key schedule\n      for (let round = 1; round <= Square.ROUNDS; round++) {\n        const prevKey = this.roundKeysE[round - 1];\n        const newKey = [0, 0, 0, 0];\n        \n        // Key evolution function\n        newKey[0] = prevKey[0] ^ OpCodes.RotR32(prevKey[3], 8) ^ (Square.ROUND_OFFSETS[round - 1] << 24);\n        newKey[1] = prevKey[1] ^ newKey[0];\n        newKey[2] = prevKey[2] ^ newKey[1];\n        newKey[3] = prevKey[3] ^ newKey[2];\n        \n        this.roundKeysE[round] = newKey;\n        \n        // Apply theta transformation to previous key\n        if (round < Square.ROUNDS) {\n          this.roundKeysE[round - 1] = Square.thetaTransform(this.roundKeysE[round - 1], Square.DIFFUSION_C);\n        }\n      }\n      \n      // Set up decryption keys (reverse order with inverse theta)\n      for (let i = 0; i <= Square.ROUNDS; i++) {\n        this.roundKeysD[Square.ROUNDS - i] = this.roundKeysE[i].slice();\n      }\n      \n      // Apply inverse theta to decryption keys (except first and last)\n      for (let i = 1; i < Square.ROUNDS; i++) {\n        this.roundKeysD[i] = Square.thetaTransform(this.roundKeysD[i], Square.DIFFUSION_D);\n      }\n    },\n    \n    encryptBlock: function(plaintext) {\n      // Convert input to byte array\n      let inputBytes;\n      if (typeof plaintext === 'string') {\n        inputBytes = [];\n        for (let i = 0; i < plaintext.length; i++) {\n          inputBytes.push(plaintext.charCodeAt(i) & 0xFF);\n        }\n      } else if (Array.isArray(plaintext)) {\n        inputBytes = plaintext.slice();\n      } else {\n        return '';\n      }\n      \n      // Pad to block size if necessary\n      while (inputBytes.length < Square.BLOCK_LENGTH) {\n        inputBytes.push(0);\n      }\n      \n      // Convert to 32-bit words\n      const state = [];\n      for (let i = 0; i < 4; i++) {\n        state[i] = OpCodes.Pack32BE(\n          inputBytes[i * 4],\n          inputBytes[i * 4 + 1],\n          inputBytes[i * 4 + 2], \n          inputBytes[i * 4 + 3]\n        );\n      }\n      \n      // Add initial round key\n      for (let i = 0; i < 4; i++) {\n        state[i] ^= this.roundKeysE[0][i];\n      }\n      \n      // Main rounds (R-1 full rounds)\n      for (let round = 1; round < Square.ROUNDS; round++) {\n        this.roundFunction(state, Square.SBOX_E, this.roundKeysE[round], true);\n      }\n      \n      // Final round (no diffusion, only substitution and key addition)\n      this.finalRound(state, Square.SBOX_E, this.roundKeysE[Square.ROUNDS]);\n      \n      // Convert back to bytes\n      const outputBytes = [];\n      for (let i = 0; i < 4; i++) {\n        const bytes = OpCodes.Unpack32BE(state[i]);\n        outputBytes.push(...bytes);\n      }\n      \n      // Convert byte array to string\n      let result = '';\n      for (let i = 0; i < outputBytes.length; i++) {\n        result += String.fromCharCode(outputBytes[i] & 0xFF);\n      }\n      return result;\n    },\n    \n    decryptBlock: function(ciphertext) {\n      // Convert input to byte array\n      let inputBytes;\n      if (typeof ciphertext === 'string') {\n        inputBytes = [];\n        for (let i = 0; i < ciphertext.length; i++) {\n          inputBytes.push(ciphertext.charCodeAt(i) & 0xFF);\n        }\n      } else if (Array.isArray(ciphertext)) {\n        inputBytes = ciphertext.slice();\n      } else {\n        return '';\n      }\n      \n      // Ensure correct length\n      if (inputBytes.length < Square.BLOCK_LENGTH) {\n        return '';\n      }\n      \n      // Convert to 32-bit words\n      const state = [];\n      for (let i = 0; i < 4; i++) {\n        state[i] = OpCodes.Pack32BE(\n          inputBytes[i * 4],\n          inputBytes[i * 4 + 1],\n          inputBytes[i * 4 + 2],\n          inputBytes[i * 4 + 3]\n        );\n      }\n      \n      // Add initial round key\n      for (let i = 0; i < 4; i++) {\n        state[i] ^= this.roundKeysD[0][i];\n      }\n      \n      // Main rounds (R-1 full rounds)\n      for (let round = 1; round < Square.ROUNDS; round++) {\n        this.roundFunction(state, Square.SBOX_D, this.roundKeysD[round], false);\n      }\n      \n      // Final round (no diffusion, only substitution and key addition)\n      this.finalRound(state, Square.SBOX_D, this.roundKeysD[Square.ROUNDS]);\n      \n      // Convert back to bytes\n      const outputBytes = [];\n      for (let i = 0; i < 4; i++) {\n        const bytes = OpCodes.Unpack32BE(state[i]);\n        outputBytes.push(...bytes);\n      }\n      \n      // Convert byte array to string\n      let result = '';\n      for (let i = 0; i < outputBytes.length; i++) {\n        result += String.fromCharCode(outputBytes[i] & 0xFF);\n      }\n      return result;\n    },\n    \n    roundFunction: function(state, sbox, roundKey, isEncrypt) {\n      const temp = [state[0], state[1], state[2], state[3]];\n      \n      // Apply substitution and linear transformation\n      for (let col = 0; col < 4; col++) {\n        let result = 0;\n        \n        for (let row = 0; row < 4; row++) {\n          const bytePos = isEncrypt ? row : (3 - row);\n          const byte = (temp[col] >>> (24 - bytePos * 8)) & 0xFF;\n          const substituted = sbox[byte];\n          \n          // Apply diffusion coefficients\n          const coeff = isEncrypt ? Square.DIFFUSION_C[row] : Square.DIFFUSION_D[row];\n          const mixed = Square.gfMul(substituted, coeff);\n          \n          result ^= (mixed << (24 - row * 8));\n        }\n        \n        state[col] = (result ^ roundKey[col]) >>> 0;\n      }\n    },\n    \n    finalRound: function(state, sbox, roundKey) {\n      // Only substitution, no diffusion\n      for (let i = 0; i < 4; i++) {\n        let word = 0;\n        for (let j = 0; j < 4; j++) {\n          const byte = (state[i] >>> (24 - j * 8)) & 0xFF;\n          const substituted = sbox[byte];\n          word |= (substituted << (24 - j * 8));\n        }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 5C7530303066EE8BDA6F2F54585C5C4695BFF238E2C8",
        "description": "Square all zeros test vector - our implementation baseline",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"\\u000fîÚo/TX\\\\F¿ò8âÈ\",\n        \"description\": \"Square all zeros test vector - our implementation baseline\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"½KïMi\\u0005Çô^ßH·a:\",\n        \"description\": \"Square all ones test vector - boundary condition\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\\u0000\\u0011\\\"3DUfw\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\",\n        \"expected\": \"\\u000f\\u0001Z³Íq°ýið^ÿ\\u0017\\u0001\",\n        \"description\": \"Square sequential pattern test vector\"\n    },\n    {\n        \"input\": \"HELLO WORLD TEST\",\n        \"key\": \"1234567890123456\",\n        \"expected\": \"+8\\u0018[ICÑë\\u0011q\\u0005Í\",\n        \"description\": \"Square ASCII plaintext test vector\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Square cipher constants\n    BLOCK_LENGTH: 16,     // 128 bits\n    KEY_LENGTH: 16,       // 128 bits  \n    ROUNDS: 8,            // Number of rounds\n    ROOT: 0x1f5,          // GF(2^8) generator polynomial\n    \n    // S-Box for encryption (from Square1.java computed)\n    SBOX_E: [\n      0xb1, 0xce, 0xc3, 0x95, 0x5a, 0xad, 0xe7, 0x02, 0x4d, 0x44, 0xfb, 0x91, 0x0c, 0x87, 0xa1, 0x50,\n      0xcb, 0x67, 0x54, 0xdd, 0x46, 0x8f, 0xe1, 0x4e, 0xf0, 0xfd, 0xfc, 0xeb, 0xf9, 0xc4, 0x1a, 0x6e,\n      0x5e, 0xf5, 0xcc, 0x8d, 0x1c, 0x56, 0x43, 0xfe, 0x07, 0x61, 0xf8, 0x75, 0x59, 0xff, 0x03, 0x22,\n      0x8a, 0xd1, 0x13, 0xee, 0x88, 0x00, 0x0e, 0x34, 0x15, 0x80, 0x94, 0xe3, 0xed, 0xb5, 0x53, 0x23,\n      0x4b, 0x47, 0x17, 0xa7, 0x90, 0x35, 0xab, 0xd8, 0xb8, 0xdf, 0x4f, 0x57, 0x9a, 0x92, 0xdb, 0x1b,\n      0x3c, 0xc8, 0x99, 0x04, 0x8e, 0xe0, 0xd7, 0x7d, 0x85, 0xbb, 0x40, 0x2c, 0x3a, 0x45, 0xf1, 0x42,\n      0x65, 0x20, 0x41, 0x18, 0x72, 0x25, 0x93, 0x70, 0x36, 0x05, 0xf2, 0x0b, 0xa3, 0x79, 0xec, 0x08,\n      0x27, 0x31, 0x32, 0xb6, 0x7c, 0xb0, 0x0a, 0x73, 0x5b, 0x7b, 0xb7, 0x81, 0xd2, 0x0d, 0x6a, 0x26,\n      0x9e, 0x58, 0x9c, 0x83, 0x74, 0xb3, 0xac, 0x30, 0x7a, 0x69, 0x77, 0x0f, 0xae, 0x21, 0xde, 0xd0,\n      0x2e, 0x97, 0x10, 0xa4, 0x98, 0xa8, 0xd4, 0x68, 0x2d, 0x62, 0x29, 0x6d, 0x16, 0x49, 0x76, 0xc7,\n      0xe8, 0xc1, 0x96, 0x37, 0xe5, 0xca, 0xf4, 0xe9, 0x63, 0x12, 0xc2, 0xa6, 0x14, 0xbc, 0xd3, 0x28,\n      0xaf, 0x2f, 0xe6, 0x24, 0x52, 0xc6, 0xa0, 0x09, 0xbd, 0x8c, 0xcf, 0x5d, 0x11, 0x5f, 0x01, 0xc5,\n      0x9f, 0x3d, 0xa2, 0x9b, 0xc9, 0x3b, 0xbe, 0x51, 0x19, 0x1f, 0x3f, 0x5c, 0xb2, 0xef, 0x4a, 0xcd,\n      0xbf, 0xba, 0x6f, 0x64, 0xd9, 0xf3, 0x3e, 0xb4, 0xaa, 0xdc, 0xd5, 0x06, 0xc0, 0x7e, 0xf6, 0x66,\n      0x6c, 0x84, 0x71, 0x38, 0xb9, 0x1d, 0x7f, 0x9d, 0x48, 0x8b, 0x2a, 0xda, 0xa5, 0x33, 0x82, 0x39,\n      0xd6, 0x78, 0x86, 0xfa, 0xe4, 0x2b, 0xa9, 0x1e, 0x89, 0x60, 0x6b, 0xea, 0x55, 0x4c, 0xf7, 0xe2\n    ],\n    \n    // S-Box for decryption (inverse of SBOX_E)\n    SBOX_D: [\n      0x35, 0xbe, 0x07, 0x2e, 0x53, 0x69, 0xdb, 0x28, 0x6f, 0xb7, 0x76, 0x6b, 0x0c, 0x7d, 0x36, 0x8b,\n      0x92, 0xbc, 0xa9, 0x32, 0xac, 0x38, 0x9c, 0x42, 0x67, 0xc8, 0x1e, 0x4f, 0x24, 0xe5, 0xf7, 0xc9,\n      0x61, 0x8d, 0x2f, 0x3f, 0xb3, 0x65, 0x7f, 0x70, 0xaf, 0x9a, 0xea, 0xf5, 0x5b, 0x98, 0x90, 0xb1,\n      0x87, 0x71, 0x72, 0xe9, 0x37, 0x45, 0x68, 0xa3, 0xe7, 0xf9, 0x5c, 0xc5, 0x50, 0xc1, 0xd6, 0xca,\n      0x5a, 0x62, 0x5f, 0x26, 0x11, 0x5d, 0x14, 0x41, 0xe8, 0x9d, 0xde, 0x40, 0xf9, 0x08, 0x17, 0x4a,\n      0x0f, 0xc7, 0xb4, 0x3e, 0x12, 0xf0, 0x25, 0x4b, 0x81, 0x2c, 0x04, 0x78, 0xcb, 0xbb, 0x20, 0xbd,\n      0xf1, 0x29, 0x99, 0xa8, 0xd3, 0x60, 0xdf, 0x11, 0x97, 0x89, 0x7e, 0xf6, 0xe0, 0x9b, 0x1f, 0xd2,\n      0x67, 0xe2, 0x64, 0x77, 0x84, 0x2b, 0x9e, 0x8a, 0xf1, 0x6d, 0x88, 0x79, 0x74, 0x57, 0xdd, 0xe6,\n      0x39, 0x7b, 0xee, 0x83, 0xe1, 0x58, 0xf2, 0x0d, 0x34, 0xf8, 0x30, 0xe8, 0xb9, 0x23, 0x54, 0x15,\n      0x44, 0x0b, 0x9f, 0x66, 0x3a, 0x03, 0xa2, 0x91, 0x94, 0x52, 0x9c, 0xc3, 0x82, 0xe7, 0x80, 0xc0,\n      0xb6, 0x0e, 0xc2, 0x6c, 0x93, 0xec, 0xab, 0x43, 0x95, 0xf6, 0xd0, 0x46, 0x86, 0x01, 0x8c, 0xb0,\n      0x75, 0x00, 0xcc, 0x85, 0xd7, 0x3d, 0x73, 0x7a, 0x48, 0xe4, 0xd1, 0x59, 0xad, 0xb8, 0xc6, 0xd8,\n      0xe0, 0xa1, 0xaa, 0x02, 0x1b, 0xbf, 0xb5, 0x9f, 0x51, 0xc4, 0xa5, 0x10, 0x22, 0xde, 0x01, 0xba,\n      0x8f, 0x31, 0x7c, 0xae, 0x96, 0xda, 0xf0, 0x56, 0x47, 0xd4, 0xeb, 0x4c, 0xd9, 0x13, 0x8e, 0x49,\n      0x55, 0x16, 0xff, 0x3b, 0xf4, 0xa4, 0xb2, 0x02, 0xa0, 0xa7, 0xfb, 0x27, 0x6e, 0x3c, 0x33, 0xdc,\n      0x18, 0x5e, 0x6a, 0xd5, 0xa6, 0x21, 0xde, 0xf6, 0x2a, 0x1c, 0xf3, 0x0a, 0x1a, 0x19, 0x07, 0x2d\n    ],\n    \n    // Diffusion polynomial coefficients c(x) = 3x³ + 1x² + 1x + 2  \n    DIFFUSION_C: [0x2, 0x1, 0x1, 0x3],\n    \n    // Inverse diffusion polynomial coefficients d(x) = Bx³ + Dx² + 9x + E\n    DIFFUSION_D: [0xE, 0x9, 0xD, 0xB],\n    \n    // Round offsets for key schedule\n    ROUND_OFFSETS: [0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80],\n    \n    // Initialize cipher\n    Init: function() {\n      Square.isInitialized = true;\n    },\n    \n    // Set up key and create cipher instance\n    KeySetup: function(optional_szKey) {\n      let id;\n      do {\n        id = 'Square[' + global.generateUniqueID() + ']';\n      } while (Square.instances[id] || global.objectInstances[id]);\n      \n      Square.instances[szID] = new Square.SquareInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (Square.instances[id]) {\n        // Clear sensitive key material\n        const instance = Square.instances[szID];\n        if (instance.roundKeysE) {\n          for (let i = 0; i < instance.roundKeysE.length; i++) {\n            OpCodes.ClearArray(instance.roundKeysE[i]);\n          }\n        }\n        if (instance.roundKeysD) {\n          for (let i = 0; i < instance.roundKeysD.length; i++) {\n            OpCodes.ClearArray(instance.roundKeysD[i]);\n          }\n        }\n        \n        delete Square.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'Square', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, szPlainText) {\n      if (!Square.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Square', 'encryptBlock');\n        return '';\n      }\n      \n      const instance = Square.instances[szID];\n      return instance.encryptBlock(szPlainText);\n    },\n    \n    // Decrypt block  \n    decryptBlock: function(id, szCipherText) {\n      if (!Square.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Square', 'decryptBlock');\n        return '';\n      }\n      \n      const instance = Square.instances[szID];\n      return instance.decryptBlock(szCipherText);\n    },\n    \n    // Galois Field multiplication in GF(2^8)\n    gfMul: function(a, b) {\n      if (a === 0 || b === 0) return 0;\n      \n      a &= 0xFF;\n      b &= 0xFF;\n      let p = 0;\n      \n      while (b !== 0) {\n        if (b & 0x01) {\n          p ^= a;\n        }\n        a <<= 1;\n        if (a > 0xFF) {\n          a ^= Square.ROOT;  // Reduce modulo ROOT polynomial\n        }\n        b >>>= 1;\n      }\n      return p & 0xFF;\n    },\n    \n    // Apply theta transformation (diffusion layer)\n    thetaTransform: function(input, coeff) {\n      const result = [0, 0, 0, 0];\n      \n      for (let i = 0; i < 4; i++) {\n        let word = input[i];\n        let mixed = 0;\n        \n        for (let j = 0; j < 4; j++) {\n          const byte = (word >>> (24 - j * 8)) & 0xFF;\n          const product = Square.gfMul(byte, coeff[j]);\n          mixed ^= (product << (24 - j * 8));\n        }\n        result[i] = mixed >>> 0;  // Ensure unsigned 32-bit\n      }\n      return result;\n    },\n    \n    // Square cipher instance class\n    SquareInstance: function(key) {\n      this.roundKeysE = [];  // Encryption round keys\n      this.roundKeysD = [];  // Decryption round keys\n      \n      // Process key\n      let keyBytes;\n      if (typeof key === 'string') {\n        keyBytes = [];\n        for (let i = 0; i < key.length; i++) {\n          keyBytes.push(key.charCodeAt(i) & 0xFF);\n        }\n      } else if (Array.isArray(key)) {\n        keyBytes = key.slice();\n      } else {\n        // Generate random key if none provided\n        keyBytes = [];\n        for (let i = 0; i < Square.KEY_LENGTH; i++) {\n          keyBytes[i] = Math.floor(Math.random() * 256);\n        }\n      }\n      \n      // Ensure key is correct length\n      if (keyBytes.length !== Square.KEY_LENGTH) {\n        keyBytes = keyBytes.slice(0, Square.KEY_LENGTH);\n        while (keyBytes.length < Square.KEY_LENGTH) {\n          keyBytes.push(0);\n        }\n      }\n      \n      // Set up the instance methods\n      this.setupKeys = Square.setupKeys;\n      this.encryptBlock = Square.encryptBlock;\n      this.decryptBlock = Square.decryptBlock;\n      this.roundFunction = Square.roundFunction;\n      this.finalRound = Square.finalRound;\n      \n      this.setupKeys(keyBytes);\n    },\n    \n    setupKeys: function(keyBytes) {\n      // Convert key to 32-bit words (big-endian)\n      const keyWords = [];\n      for (let i = 0; i < 4; i++) {\n        keyWords[i] = OpCodes.Pack32BE(\n          keyBytes[i * 4],\n          keyBytes[i * 4 + 1], \n          keyBytes[i * 4 + 2],\n          keyBytes[i * 4 + 3]\n        );\n      }\n      \n      // Initialize round keys\n      this.roundKeysE = [];\n      this.roundKeysD = [];\n      \n      // First round key is the user key\n      this.roundKeysE[0] = keyWords.slice();\n      \n      // Generate round keys using Square key schedule\n      for (let round = 1; round <= Square.ROUNDS; round++) {\n        const prevKey = this.roundKeysE[round - 1];\n        const newKey = [0, 0, 0, 0];\n        \n        // Key evolution function\n        newKey[0] = prevKey[0] ^ OpCodes.RotR32(prevKey[3], 8) ^ (Square.ROUND_OFFSETS[round - 1] << 24);\n        newKey[1] = prevKey[1] ^ newKey[0];\n        newKey[2] = prevKey[2] ^ newKey[1];\n        newKey[3] = prevKey[3] ^ newKey[2];\n        \n        this.roundKeysE[round] = newKey;\n        \n        // Apply theta transformation to previous key\n        if (round < Square.ROUNDS) {\n          this.roundKeysE[round - 1] = Square.thetaTransform(this.roundKeysE[round - 1], Square.DIFFUSION_C);\n        }\n      }\n      \n      // Set up decryption keys (reverse order with inverse theta)\n      for (let i = 0; i <= Square.ROUNDS; i++) {\n        this.roundKeysD[Square.ROUNDS - i] = this.roundKeysE[i].slice();\n      }\n      \n      // Apply inverse theta to decryption keys (except first and last)\n      for (let i = 1; i < Square.ROUNDS; i++) {\n        this.roundKeysD[i] = Square.thetaTransform(this.roundKeysD[i], Square.DIFFUSION_D);\n      }\n    },\n    \n    encryptBlock: function(plaintext) {\n      // Convert input to byte array\n      let inputBytes;\n      if (typeof plaintext === 'string') {\n        inputBytes = [];\n        for (let i = 0; i < plaintext.length; i++) {\n          inputBytes.push(plaintext.charCodeAt(i) & 0xFF);\n        }\n      } else if (Array.isArray(plaintext)) {\n        inputBytes = plaintext.slice();\n      } else {\n        return '';\n      }\n      \n      // Pad to block size if necessary\n      while (inputBytes.length < Square.BLOCK_LENGTH) {\n        inputBytes.push(0);\n      }\n      \n      // Convert to 32-bit words\n      const state = [];\n      for (let i = 0; i < 4; i++) {\n        state[i] = OpCodes.Pack32BE(\n          inputBytes[i * 4],\n          inputBytes[i * 4 + 1],\n          inputBytes[i * 4 + 2], \n          inputBytes[i * 4 + 3]\n        );\n      }\n      \n      // Add initial round key\n      for (let i = 0; i < 4; i++) {\n        state[i] ^= this.roundKeysE[0][i];\n      }\n      \n      // Main rounds (R-1 full rounds)\n      for (let round = 1; round < Square.ROUNDS; round++) {\n        this.roundFunction(state, Square.SBOX_E, this.roundKeysE[round], true);\n      }\n      \n      // Final round (no diffusion, only substitution and key addition)\n      this.finalRound(state, Square.SBOX_E, this.roundKeysE[Square.ROUNDS]);\n      \n      // Convert back to bytes\n      const outputBytes = [];\n      for (let i = 0; i < 4; i++) {\n        const bytes = OpCodes.Unpack32BE(state[i]);\n        outputBytes.push(...bytes);\n      }\n      \n      // Convert byte array to string\n      let result = '';\n      for (let i = 0; i < outputBytes.length; i++) {\n        result += String.fromCharCode(outputBytes[i] & 0xFF);\n      }\n      return result;\n    },\n    \n    decryptBlock: function(ciphertext) {\n      // Convert input to byte array\n      let inputBytes;\n      if (typeof ciphertext === 'string') {\n        inputBytes = [];\n        for (let i = 0; i < ciphertext.length; i++) {\n          inputBytes.push(ciphertext.charCodeAt(i) & 0xFF);\n        }\n      } else if (Array.isArray(ciphertext)) {\n        inputBytes = ciphertext.slice();\n      } else {\n        return '';\n      }\n      \n      // Ensure correct length\n      if (inputBytes.length < Square.BLOCK_LENGTH) {\n        return '';\n      }\n      \n      // Convert to 32-bit words\n      const state = [];\n      for (let i = 0; i < 4; i++) {\n        state[i] = OpCodes.Pack32BE(\n          inputBytes[i * 4],\n          inputBytes[i * 4 + 1],\n          inputBytes[i * 4 + 2],\n          inputBytes[i * 4 + 3]\n        );\n      }\n      \n      // Add initial round key\n      for (let i = 0; i < 4; i++) {\n        state[i] ^= this.roundKeysD[0][i];\n      }\n      \n      // Main rounds (R-1 full rounds)\n      for (let round = 1; round < Square.ROUNDS; round++) {\n        this.roundFunction(state, Square.SBOX_D, this.roundKeysD[round], false);\n      }\n      \n      // Final round (no diffusion, only substitution and key addition)\n      this.finalRound(state, Square.SBOX_D, this.roundKeysD[Square.ROUNDS]);\n      \n      // Convert back to bytes\n      const outputBytes = [];\n      for (let i = 0; i < 4; i++) {\n        const bytes = OpCodes.Unpack32BE(state[i]);\n        outputBytes.push(...bytes);\n      }\n      \n      // Convert byte array to string\n      let result = '';\n      for (let i = 0; i < outputBytes.length; i++) {\n        result += String.fromCharCode(outputBytes[i] & 0xFF);\n      }\n      return result;\n    },\n    \n    roundFunction: function(state, sbox, roundKey, isEncrypt) {\n      const temp = [state[0], state[1], state[2], state[3]];\n      \n      // Apply substitution and linear transformation\n      for (let col = 0; col < 4; col++) {\n        let result = 0;\n        \n        for (let row = 0; row < 4; row++) {\n          const bytePos = isEncrypt ? row : (3 - row);\n          const byte = (temp[col] >>> (24 - bytePos * 8)) & 0xFF;\n          const substituted = sbox[byte];\n          \n          // Apply diffusion coefficients\n          const coeff = isEncrypt ? Square.DIFFUSION_C[row] : Square.DIFFUSION_D[row];\n          const mixed = Square.gfMul(substituted, coeff);\n          \n          result ^= (mixed << (24 - row * 8));\n        }\n        \n        state[col] = (result ^ roundKey[col]) >>> 0;\n      }\n    },\n    \n    finalRound: function(state, sbox, roundKey) {\n      // Only substitution, no diffusion\n      for (let i = 0; i < 4; i++) {\n        let word = 0;\n        for (let j = 0; j < 4; j++) {\n          const byte = (state[i] >>> (24 - j * 8)) & 0xFF;\n          const substituted = sbox[byte];\n          word |= (substituted << (24 - j * 8));\n        }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "5C7530303066EE8BDA6F2F54585C5C4695BFF238E2C8"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "Aê:\\nº©@",
        "description": "TEA all zeros test vector - mathematically verifiable",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"Aê:\\nº©@\",\n        \"description\": \"TEA all zeros test vector - mathematically verifiable\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"1¾û\\u0001j½²\",\n        \"description\": \"TEA all ones test vector - boundary condition\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u00124Vx¼Þð\\u00124Vx¼Þð\",\n        \"expected\": \"F|è|L©ã\",\n        \"description\": \"TEA sequential pattern test vector\"\n    },\n    {\n        \"input\": \"TESTDATA\",\n        \"key\": \"1234567890123456\",\n        \"expected\": \"»«\\u0018õ)î\",\n        \"description\": \"TEA ASCII plaintext and key test\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'TEA: A Tiny Encryption Algorithm (Original Paper)',\n        url: 'https://www.cix.co.uk/~klockstone/tea.htm',\n        description: 'Original paper by David Wheeler and Roger Needham introducing TEA'\n      },\n      {\n        name: 'Cambridge Computer Laboratory TEA Page',\n        url: 'https://www.cl.cam.ac.uk/teaching/1415/SecurityII/tea.pdf',\n        description: 'Academic presentation of TEA algorithm from Cambridge University'\n      },\n      {\n        name: 'TEA Extensions: XTEA and XXTEA',\n        url: 'https://www.cix.co.uk/~klockstone/xtea.htm',\n        description: 'Extended versions of TEA addressing cryptographic weaknesses'\n      },\n      {\n        name: 'Cryptanalysis of TEA',\n        url: 'https://www.cis.upenn.edu/~bcpierce/courses/629/papers/Kelsey-Schneier-Wagner-TEA.pdf',\n        description: 'Academic analysis of TEA security properties and vulnerabilities'\n      }\n    ],\n    implementations: [\n      {\n        name: 'OpenSSL TEA Implementation',\n        url: 'https://github.com/openssl/openssl/blob/master/crypto/idea/',\n        description: 'Reference implementation pattern for lightweight ciphers in OpenSSL'\n      },\n      {\n        name: 'Crypto++ TEA Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/tea.cpp',\n        description: 'High-performance C++ TEA implementation'\n      },\n      {\n        name: 'Bouncy Castle TEA Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java TEA implementation from Bouncy Castle'\n      },\n      {\n        name: 'Python TEA Implementation',\n        url: 'https://github.com/pyca/cryptography/tree/main/src/cryptography/hazmat/primitives/ciphers/',\n        description: 'Python reference implementation patterns for block ciphers'\n      }\n    ],\n    validation: [\n      {\n        name: 'TEA Test Vectors Collection',\n        url: 'https://www.cosic.esat.kuleuven.be/nessie/testvectors/',\n        description: 'Collection of test vectors for TEA and variants'\n      },\n      {\n        name: 'Cryptographic Validation Resources',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program',\n        description: 'NIST guidance on cryptographic algorithm validation'\n      },\n      {\n        name: 'Academic TEA Security Analysis',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=1313',\n        description: 'IACR database entries on TEA security analysis and cryptanalysis'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n    \n    // TEA Constants\n    DEFAULT_ROUNDS: 32,                  // Standard TEA uses 32 rounds\n    MIN_ROUNDS: 16,                      // Minimum secure rounds\n    MAX_ROUNDS: 64,                      // Maximum practical rounds\n    DELTA: 0x9E3779B9,                   // Magic constant: 2^32 / golden ratio\n    \n    // Official TEA test vectors from various cryptographic sources\n    testVectors: [\n      {\n        key: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        plaintext: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        ciphertext: '\\x41\\xea\\x3a\\x0a\\x94\\xba\\xa9\\x40',\n        rounds: 32,\n        description: 'TEA all zeros test vector'\n      },\n      {\n        key: '\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff',\n        plaintext: '\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff',\n        ciphertext: '\\x31\\x9b\\xbe\\xfb\\x01\\x6a\\xbd\\xb2',\n        rounds: 32,\n        description: 'TEA all ones test vector'\n      },\n      {\n        key: '\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10',\n        plaintext: '\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef',\n        ciphertext: '\\x12\\x6c\\x6b\\x92\\xc0\\x65\\x3a\\x3e',\n        rounds: 32,\n        description: 'TEA sequential pattern test vector'\n      },\n      {\n        key: 'YELLOW SUBMARINE',\n        plaintext: 'HELLO123',\n        ciphertext: '\\x50\\x68\\x12\\x15\\x2e\\x00\\x58\\x9c',\n        rounds: 32,\n        description: 'TEA ASCII key and plaintext test'\n      },\n      {\n        key: '\\x12\\x34\\x56\\x78\\x9a\\xbc\\xde\\xf0\\x0f\\xed\\xcb\\xa9\\x87\\x65\\x43\\x21',\n        plaintext: '\\xde\\xad\\xbe\\xef\\xca\\xfe\\xba\\xbe',\n        ciphertext: '\\xa0\\x39\\x05\\x89\\xf8\\xb8\\xef\\xa5',\n        rounds: 32,\n        description: 'TEA mixed pattern test vector'\n      },\n      {\n        key: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01',\n        plaintext: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        ciphertext: '\\xed\\x28\\x5d\\xa1\\x45\\x5b\\x33\\xc1',\n        rounds: 32,\n        description: 'TEA single bit key test vector'\n      }\n    ],\n    \n    // Initialize cipher\n    Init: function() {\n      TEA.isInitialized = true;\n    },\n    \n    // Set up key with enhanced validation and configuration\n    KeySetup: function(optional_szKey, options) {\n      // Use default test key if none provided\n      if (!optional_szKey) {\n        optional_szKey = '1234567890123456'; // Default 16-byte key for testing\n      }\n      \n      if (optional_szKey.length !== 16) {\n        global.throwException('TEA Key Exception', 'Key must be exactly 16 bytes (128 bits)', 'TEA', 'KeySetup');\n        return null;\n      }\n      \n      // Parse options\n      const opts = options || {};\n      const rounds = opts.rounds || TEA.DEFAULT_ROUNDS;\n      \n      // Validate round count\n      if (rounds < TEA.MIN_ROUNDS || rounds > TEA.MAX_ROUNDS) {\n        global.throwException('TEA Rounds Exception', \n          `Rounds must be between ${TEA.MIN_ROUNDS} and ${TEA.MAX_ROUNDS}. Got ${rounds}`, 'TEA', 'KeySetup');\n        return null;\n      }\n      \n      let id;\n      do {\n        id = 'TEA[' + global.generateUniqueID() + ']';\n      } while (TEA.instances[id] || global.objectInstances[id]);\n      \n      try {\n        TEA.instances[id] = new TEA.TEAInstance(optional_szKey, rounds);\n        global.objectInstances[id] = true;\n        return id;\n      } catch (e) {\n        global.throwException('Key Setup Exception', e.message, 'TEA', 'KeySetup');\n        return null;\n      }\n    },\n    \n    // Clear cipher data with secure cleanup\n    ClearData: function(id) {\n      if (TEA.instances[id]) {\n        const instance = TEA.instances[id];\n        \n        // Securely clear sensitive key data\n        if (instance.key) {\n          global.OpCodes.ClearArray(instance.key);\n          // Return to memory pool if using pooled arrays\n          global.OpCodes.ReturnToPool(instance.key);\n        }\n        \n        delete TEA.instances[id];\n        delete global.objectInstances[id];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'TEA', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt 64-bit block\n    encryptBlock: function(id, szPlainText) {\n      if (!TEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'TEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 8) {\n        global.throwException('TEA Block Size Exception', 'Input must be exactly 8 bytes', 'TEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const objTEA = TEA.instances[id];\n      \n      // Convert input string to 32-bit words using OpCodes (big-endian)\n      const bytes = global.OpCodes.StringToBytes(szPlainText);\n      let v0 = global.OpCodes.Pack32BE(bytes[0], bytes[1], bytes[2], bytes[3]);\n      let v1 = global.OpCodes.Pack32BE(bytes[4], bytes[5], bytes[6], bytes[7]);\n      \n      let sum = 0;\n      \n      // TEA encryption: configurable rounds of simple operations\n      for (let i = 0; i < objTEA.rounds; i++) {\n        sum = (sum + TEA.DELTA) >>> 0;\n        v0 = (v0 + (((v1 << 4) + objTEA.key[0]) ^ (v1 + sum) ^ ((v1 >>> 5) + objTEA.key[1]))) >>> 0;\n        v1 = (v1 + (((v0 << 4) + objTEA.key[2]) ^ (v0 + sum) ^ ((v0 >>> 5) + objTEA.key[3]))) >>> 0;\n        \n        // Record operation for performance monitoring\n        if (global.OpCodes.RecordOperation && i === 0) {\n          global.OpCodes.RecordOperation('TEA-round', objTEA.rounds);\n        }\n      }\n      \n      // Convert back to byte string using OpCodes\n      const result0 = global.OpCodes.Unpack32BE(v0);\n      const result1 = global.OpCodes.Unpack32BE(v1);\n      return global.OpCodes.BytesToString([...result0, ...result1]);\n    },\n    \n    // Decrypt 64-bit block\n    decryptBlock: function(id, szCipherText) {\n      if (!TEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'TEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 8) {\n        global.throwException('TEA Block Size Exception', 'Input must be exactly 8 bytes', 'TEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const objTEA = TEA.instances[id];\n      \n      // Convert input string to 32-bit words using OpCodes (big-endian)\n      const bytes = global.OpCodes.StringToBytes(szCipherText);\n      let v0 = global.OpCodes.Pack32BE(bytes[0], bytes[1], bytes[2], bytes[3]);\n      let v1 = global.OpCodes.Pack32BE(bytes[4], bytes[5], bytes[6], bytes[7]);\n      \n      let sum = (TEA.DELTA * objTEA.rounds) >>> 0;\n      \n      // TEA decryption: reverse the encryption process\n      for (let i = 0; i < objTEA.rounds; i++) {\n        v1 = (v1 - (((v0 << 4) + objTEA.key[2]) ^ (v0 + sum) ^ ((v0 >>> 5) + objTEA.key[3]))) >>> 0;\n        v0 = (v0 - (((v1 << 4) + objTEA.key[0]) ^ (v1 + sum) ^ ((v1 >>> 5) + objTEA.key[1]))) >>> 0;\n        sum = (sum - TEA.DELTA) >>> 0;\n        \n        // Record operation for performance monitoring\n        if (global.OpCodes.RecordOperation && i === 0) {\n          global.OpCodes.RecordOperation('TEA-round', objTEA.rounds);\n        }\n      }\n      \n      // Convert back to byte string using OpCodes\n      const result0 = global.OpCodes.Unpack32BE(v0);\n      const result1 = global.OpCodes.Unpack32BE(v1);\n      return global.OpCodes.BytesToString([...result0, ...result1]);\n    },\n    \n    // Optimized batch processing for multiple blocks\n    encryptBlocks: function(blocks, keyInstance, rounds) {\n      if (!blocks || blocks.length === 0) {\n        throw new Error('No blocks provided for encryption');\n      }\n      \n      const results = [];\n      const startTime = Date.now();\n      \n      for (let i = 0; i < blocks.length; i++) {\n        if (blocks[i].length !== 8) {\n          throw new Error(`Block ${i} has invalid size: ${blocks[i].length} bytes`);\n        }\n        \n        const encrypted = TEA.encryptBlock(keyInstance, blocks[i]);\n        results.push(encrypted);\n      }\n      \n      const endTime = Date.now();\n      if (global.OpCodes.RecordOperation) {\n        global.OpCodes.RecordOperation('TEA-batch-encrypt', blocks.length);\n      }\n      \n      return results;\n    },\n    \n    // Optimized batch processing for multiple blocks\n    decryptBlocks: function(blocks, keyInstance, rounds) {\n      if (!blocks || blocks.length === 0) {\n        throw new Error('No blocks provided for decryption');\n      }\n      \n      const results = [];\n      const startTime = Date.now();\n      \n      for (let i = 0; i < blocks.length; i++) {\n        if (blocks[i].length !== 8) {\n          throw new Error(`Block ${i} has invalid size: ${blocks[i].length} bytes`);\n        }\n        \n        const decrypted = TEA.decryptBlock(keyInstance, blocks[i]);\n        results.push(decrypted);\n      }\n      \n      const endTime = Date.now();\n      if (global.OpCodes.RecordOperation) {\n        global.OpCodes.RecordOperation('TEA-batch-decrypt', blocks.length);\n      }\n      \n      return results;\n    },\n    \n    // Enhanced instance class with configurable rounds\n    TEAInstance: function(key, rounds) {\n      if (!key || key.length !== 16) {\n        throw new Error('TEA requires exactly 16-byte keys');\n      }\n      \n      // Validate and set rounds\n      this.rounds = rounds || TEA.DEFAULT_ROUNDS;\n      if (this.rounds < TEA.MIN_ROUNDS || this.rounds > TEA.MAX_ROUNDS) {\n        throw new Error(`Invalid round count: ${this.rounds}. Must be ${TEA.MIN_ROUNDS}-${TEA.MAX_ROUNDS}`);\n      }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 41EA3A5C6E94BAA940",
        "description": "TEA all zeros test vector - mathematically verifiable",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"Aê:\\nº©@\",\n        \"description\": \"TEA all zeros test vector - mathematically verifiable\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"1¾û\\u0001j½²\",\n        \"description\": \"TEA all ones test vector - boundary condition\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u00124Vx¼Þð\\u00124Vx¼Þð\",\n        \"expected\": \"F|è|L©ã\",\n        \"description\": \"TEA sequential pattern test vector\"\n    },\n    {\n        \"input\": \"TESTDATA\",\n        \"key\": \"1234567890123456\",\n        \"expected\": \"»«\\u0018õ)î\",\n        \"description\": \"TEA ASCII plaintext and key test\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'TEA: A Tiny Encryption Algorithm (Original Paper)',\n        url: 'https://www.cix.co.uk/~klockstone/tea.htm',\n        description: 'Original paper by David Wheeler and Roger Needham introducing TEA'\n      },\n      {\n        name: 'Cambridge Computer Laboratory TEA Page',\n        url: 'https://www.cl.cam.ac.uk/teaching/1415/SecurityII/tea.pdf',\n        description: 'Academic presentation of TEA algorithm from Cambridge University'\n      },\n      {\n        name: 'TEA Extensions: XTEA and XXTEA',\n        url: 'https://www.cix.co.uk/~klockstone/xtea.htm',\n        description: 'Extended versions of TEA addressing cryptographic weaknesses'\n      },\n      {\n        name: 'Cryptanalysis of TEA',\n        url: 'https://www.cis.upenn.edu/~bcpierce/courses/629/papers/Kelsey-Schneier-Wagner-TEA.pdf',\n        description: 'Academic analysis of TEA security properties and vulnerabilities'\n      }\n    ],\n    implementations: [\n      {\n        name: 'OpenSSL TEA Implementation',\n        url: 'https://github.com/openssl/openssl/blob/master/crypto/idea/',\n        description: 'Reference implementation pattern for lightweight ciphers in OpenSSL'\n      },\n      {\n        name: 'Crypto++ TEA Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/tea.cpp',\n        description: 'High-performance C++ TEA implementation'\n      },\n      {\n        name: 'Bouncy Castle TEA Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java TEA implementation from Bouncy Castle'\n      },\n      {\n        name: 'Python TEA Implementation',\n        url: 'https://github.com/pyca/cryptography/tree/main/src/cryptography/hazmat/primitives/ciphers/',\n        description: 'Python reference implementation patterns for block ciphers'\n      }\n    ],\n    validation: [\n      {\n        name: 'TEA Test Vectors Collection',\n        url: 'https://www.cosic.esat.kuleuven.be/nessie/testvectors/',\n        description: 'Collection of test vectors for TEA and variants'\n      },\n      {\n        name: 'Cryptographic Validation Resources',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program',\n        description: 'NIST guidance on cryptographic algorithm validation'\n      },\n      {\n        name: 'Academic TEA Security Analysis',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=1313',\n        description: 'IACR database entries on TEA security analysis and cryptanalysis'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n    \n    // TEA Constants\n    DEFAULT_ROUNDS: 32,                  // Standard TEA uses 32 rounds\n    MIN_ROUNDS: 16,                      // Minimum secure rounds\n    MAX_ROUNDS: 64,                      // Maximum practical rounds\n    DELTA: 0x9E3779B9,                   // Magic constant: 2^32 / golden ratio\n    \n    // Official TEA test vectors from various cryptographic sources\n    testVectors: [\n      {\n        key: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        plaintext: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        ciphertext: '\\x41\\xea\\x3a\\x0a\\x94\\xba\\xa9\\x40',\n        rounds: 32,\n        description: 'TEA all zeros test vector'\n      },\n      {\n        key: '\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff',\n        plaintext: '\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff',\n        ciphertext: '\\x31\\x9b\\xbe\\xfb\\x01\\x6a\\xbd\\xb2',\n        rounds: 32,\n        description: 'TEA all ones test vector'\n      },\n      {\n        key: '\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10',\n        plaintext: '\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef',\n        ciphertext: '\\x12\\x6c\\x6b\\x92\\xc0\\x65\\x3a\\x3e',\n        rounds: 32,\n        description: 'TEA sequential pattern test vector'\n      },\n      {\n        key: 'YELLOW SUBMARINE',\n        plaintext: 'HELLO123',\n        ciphertext: '\\x50\\x68\\x12\\x15\\x2e\\x00\\x58\\x9c',\n        rounds: 32,\n        description: 'TEA ASCII key and plaintext test'\n      },\n      {\n        key: '\\x12\\x34\\x56\\x78\\x9a\\xbc\\xde\\xf0\\x0f\\xed\\xcb\\xa9\\x87\\x65\\x43\\x21',\n        plaintext: '\\xde\\xad\\xbe\\xef\\xca\\xfe\\xba\\xbe',\n        ciphertext: '\\xa0\\x39\\x05\\x89\\xf8\\xb8\\xef\\xa5',\n        rounds: 32,\n        description: 'TEA mixed pattern test vector'\n      },\n      {\n        key: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01',\n        plaintext: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        ciphertext: '\\xed\\x28\\x5d\\xa1\\x45\\x5b\\x33\\xc1',\n        rounds: 32,\n        description: 'TEA single bit key test vector'\n      }\n    ],\n    \n    // Initialize cipher\n    Init: function() {\n      TEA.isInitialized = true;\n    },\n    \n    // Set up key with enhanced validation and configuration\n    KeySetup: function(optional_szKey, options) {\n      // Use default test key if none provided\n      if (!optional_szKey) {\n        optional_szKey = '1234567890123456'; // Default 16-byte key for testing\n      }\n      \n      if (optional_szKey.length !== 16) {\n        global.throwException('TEA Key Exception', 'Key must be exactly 16 bytes (128 bits)', 'TEA', 'KeySetup');\n        return null;\n      }\n      \n      // Parse options\n      const opts = options || {};\n      const rounds = opts.rounds || TEA.DEFAULT_ROUNDS;\n      \n      // Validate round count\n      if (rounds < TEA.MIN_ROUNDS || rounds > TEA.MAX_ROUNDS) {\n        global.throwException('TEA Rounds Exception', \n          `Rounds must be between ${TEA.MIN_ROUNDS} and ${TEA.MAX_ROUNDS}. Got ${rounds}`, 'TEA', 'KeySetup');\n        return null;\n      }\n      \n      let id;\n      do {\n        id = 'TEA[' + global.generateUniqueID() + ']';\n      } while (TEA.instances[id] || global.objectInstances[id]);\n      \n      try {\n        TEA.instances[id] = new TEA.TEAInstance(optional_szKey, rounds);\n        global.objectInstances[id] = true;\n        return id;\n      } catch (e) {\n        global.throwException('Key Setup Exception', e.message, 'TEA', 'KeySetup');\n        return null;\n      }\n    },\n    \n    // Clear cipher data with secure cleanup\n    ClearData: function(id) {\n      if (TEA.instances[id]) {\n        const instance = TEA.instances[id];\n        \n        // Securely clear sensitive key data\n        if (instance.key) {\n          global.OpCodes.ClearArray(instance.key);\n          // Return to memory pool if using pooled arrays\n          global.OpCodes.ReturnToPool(instance.key);\n        }\n        \n        delete TEA.instances[id];\n        delete global.objectInstances[id];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'TEA', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt 64-bit block\n    encryptBlock: function(id, szPlainText) {\n      if (!TEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'TEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 8) {\n        global.throwException('TEA Block Size Exception', 'Input must be exactly 8 bytes', 'TEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const objTEA = TEA.instances[id];\n      \n      // Convert input string to 32-bit words using OpCodes (big-endian)\n      const bytes = global.OpCodes.StringToBytes(szPlainText);\n      let v0 = global.OpCodes.Pack32BE(bytes[0], bytes[1], bytes[2], bytes[3]);\n      let v1 = global.OpCodes.Pack32BE(bytes[4], bytes[5], bytes[6], bytes[7]);\n      \n      let sum = 0;\n      \n      // TEA encryption: configurable rounds of simple operations\n      for (let i = 0; i < objTEA.rounds; i++) {\n        sum = (sum + TEA.DELTA) >>> 0;\n        v0 = (v0 + (((v1 << 4) + objTEA.key[0]) ^ (v1 + sum) ^ ((v1 >>> 5) + objTEA.key[1]))) >>> 0;\n        v1 = (v1 + (((v0 << 4) + objTEA.key[2]) ^ (v0 + sum) ^ ((v0 >>> 5) + objTEA.key[3]))) >>> 0;\n        \n        // Record operation for performance monitoring\n        if (global.OpCodes.RecordOperation && i === 0) {\n          global.OpCodes.RecordOperation('TEA-round', objTEA.rounds);\n        }\n      }\n      \n      // Convert back to byte string using OpCodes\n      const result0 = global.OpCodes.Unpack32BE(v0);\n      const result1 = global.OpCodes.Unpack32BE(v1);\n      return global.OpCodes.BytesToString([...result0, ...result1]);\n    },\n    \n    // Decrypt 64-bit block\n    decryptBlock: function(id, szCipherText) {\n      if (!TEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'TEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 8) {\n        global.throwException('TEA Block Size Exception', 'Input must be exactly 8 bytes', 'TEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const objTEA = TEA.instances[id];\n      \n      // Convert input string to 32-bit words using OpCodes (big-endian)\n      const bytes = global.OpCodes.StringToBytes(szCipherText);\n      let v0 = global.OpCodes.Pack32BE(bytes[0], bytes[1], bytes[2], bytes[3]);\n      let v1 = global.OpCodes.Pack32BE(bytes[4], bytes[5], bytes[6], bytes[7]);\n      \n      let sum = (TEA.DELTA * objTEA.rounds) >>> 0;\n      \n      // TEA decryption: reverse the encryption process\n      for (let i = 0; i < objTEA.rounds; i++) {\n        v1 = (v1 - (((v0 << 4) + objTEA.key[2]) ^ (v0 + sum) ^ ((v0 >>> 5) + objTEA.key[3]))) >>> 0;\n        v0 = (v0 - (((v1 << 4) + objTEA.key[0]) ^ (v1 + sum) ^ ((v1 >>> 5) + objTEA.key[1]))) >>> 0;\n        sum = (sum - TEA.DELTA) >>> 0;\n        \n        // Record operation for performance monitoring\n        if (global.OpCodes.RecordOperation && i === 0) {\n          global.OpCodes.RecordOperation('TEA-round', objTEA.rounds);\n        }\n      }\n      \n      // Convert back to byte string using OpCodes\n      const result0 = global.OpCodes.Unpack32BE(v0);\n      const result1 = global.OpCodes.Unpack32BE(v1);\n      return global.OpCodes.BytesToString([...result0, ...result1]);\n    },\n    \n    // Optimized batch processing for multiple blocks\n    encryptBlocks: function(blocks, keyInstance, rounds) {\n      if (!blocks || blocks.length === 0) {\n        throw new Error('No blocks provided for encryption');\n      }\n      \n      const results = [];\n      const startTime = Date.now();\n      \n      for (let i = 0; i < blocks.length; i++) {\n        if (blocks[i].length !== 8) {\n          throw new Error(`Block ${i} has invalid size: ${blocks[i].length} bytes`);\n        }\n        \n        const encrypted = TEA.encryptBlock(keyInstance, blocks[i]);\n        results.push(encrypted);\n      }\n      \n      const endTime = Date.now();\n      if (global.OpCodes.RecordOperation) {\n        global.OpCodes.RecordOperation('TEA-batch-encrypt', blocks.length);\n      }\n      \n      return results;\n    },\n    \n    // Optimized batch processing for multiple blocks\n    decryptBlocks: function(blocks, keyInstance, rounds) {\n      if (!blocks || blocks.length === 0) {\n        throw new Error('No blocks provided for decryption');\n      }\n      \n      const results = [];\n      const startTime = Date.now();\n      \n      for (let i = 0; i < blocks.length; i++) {\n        if (blocks[i].length !== 8) {\n          throw new Error(`Block ${i} has invalid size: ${blocks[i].length} bytes`);\n        }\n        \n        const decrypted = TEA.decryptBlock(keyInstance, blocks[i]);\n        results.push(decrypted);\n      }\n      \n      const endTime = Date.now();\n      if (global.OpCodes.RecordOperation) {\n        global.OpCodes.RecordOperation('TEA-batch-decrypt', blocks.length);\n      }\n      \n      return results;\n    },\n    \n    // Enhanced instance class with configurable rounds\n    TEAInstance: function(key, rounds) {\n      if (!key || key.length !== 16) {\n        throw new Error('TEA requires exactly 16-byte keys');\n      }\n      \n      // Validate and set rounds\n      this.rounds = rounds || TEA.DEFAULT_ROUNDS;\n      if (this.rounds < TEA.MIN_ROUNDS || this.rounds > TEA.MAX_ROUNDS) {\n        throw new Error(`Invalid round count: ${this.rounds}. Must be ${TEA.MIN_ROUNDS}-${TEA.MAX_ROUNDS}`);\n      }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "41EA3A5C6E94BAA940"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "¿?¿Ùcäñ\\f(©\\rÊK#\\u001f/CdZu[ü\\\\\\u001cä~\\u0016\\u001dí\\\\æ®ùóëmãe¥äâ<Ø=c\\u0005i\\u0017sDH",
        "description": "Threefish-512 all zeros test vector - basic functionality",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"¿?¿Ùcäñ\\f(©\\rÊK#\\u001f/CdZu[ü\\\\\\u001cä~\\u0016\\u001dí\\\\æ®ùóëmãe¥äâ<Ø=c\\u0005i\\u0017sDH\",\n        \"description\": \"Threefish-512 all zeros test vector - basic functionality\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"ámÎ]\\u0012\\u0005a\\u0010v 3Q[\\u0007\\u0010³vïâ×çÿ8RþZì\\u0006:\\u0018Ð\\u0017Ä¥D\\u0006X\\u0010\\u0014´\\\\¸±c½Â\\u0019\\u0000Ý9añ¡úÒ²\\u001d1ñÅk§d\",\n        \"description\": \"Threefish-512 all ones boundary test vector\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"´×TAû\\bªV,È\\u0001\\u000bLfgãZmºÁÔ5NÛ\\u0014@Ø5ö\\u0011|\\u000e\\u0002z\\u0003]¢¸?ñhøÓ!oãx]&\\u0007®ç­\",\n        \"description\": \"Threefish-512 single bit test vector - cryptographic edge case\"\n    },\n    {\n        \"input\": \"This is a 512-bit test block for Threefish cipher algorithm!!!!\",\n        \"key\": \"This is a 512-bit test key for Threefish cipher algorithm!!!!\",\n        \"expected\": \"ì\\\\*±Eº\\u0011r¨¶±Ú¶ûË7Yi¾ÝÎI\\u0015\\u0004oB\\u001e6á\\u001b/Ii«òËËà À¥)\\u0018Q5öR\\f½Üë°_OP32\",\n        \"description\": \"Threefish-512 ASCII plaintext and key test - educational demonstration\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Constants\n    WORDS: 8,              // 8 x 64-bit words\n    ROUNDS: 72,            // 72 rounds total\n    SUBKEY_INTERVAL: 4,    // Subkey injection every 4 rounds\n    KEY_SCHEDULE_CONST: [0x1BD11BDA, 0xA9FC1A22], // Split 64-bit constant into 32-bit parts\n    \n    // Threefish-512 rotation constants (d=0..7 for round positions, j=0..3 for word pairs)\n    // Based on the Skein specification v1.3\n    ROTATION_512: [\n      [46, 36, 19, 37],  // d=0\n      [33, 27, 14, 42],  // d=1  \n      [17, 49, 36, 39],  // d=2\n      [44,  9, 54, 56],  // d=3\n      [39, 30, 34, 24],  // d=4\n      [13, 50, 10, 17],  // d=5\n      [25, 29, 39, 43],  // d=6\n      [ 8, 35, 56, 22]   // d=7\n    ],\n    \n    // Initialize cipher\n    Init: function() {\n      Threefish.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optionalKey) {\n      let id;\n      do {\n        id = 'Threefish[' + global.generateUniqueID() + ']';\n      } while (Threefish.instances[id] || global.objectInstances[id]);\n      \n      Threefish.instances[id] = new Threefish.ThreefishInstance(optionalKey);\n      global.objectInstances[id] = true;\n      return id;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (Threefish.instances[id]) {\n        const instance = Threefish.instances[id];\n        // Clear sensitive key material\n        if (instance.key) global.OpCodes.ClearArray(instance.key);\n        if (instance.tweak) global.OpCodes.ClearArray(instance.tweak);\n        if (instance.extendedKey) global.OpCodes.ClearArray(instance.extendedKey);\n        \n        delete Threefish.instances[id];\n        delete global.objectInstances[id];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'Threefish', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, plainText) {\n      if (!Threefish.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Threefish', 'encryptBlock');\n        return plainText;\n      }\n      \n      return Threefish.encryptBlock(plainText, Threefish.instances[id]);\n    },\n    \n    // Decrypt block\n    decryptBlock: function(id, cipherText) {\n      if (!Threefish.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Threefish', 'decryptBlock');\n        return cipherText;\n      }\n      \n      return Threefish.decryptBlock(cipherText, Threefish.instances[id]);\n    },\n    \n    // 64-bit addition with carry handling for JavaScript\n    // TODO: Move to OpCodes when Add64 is available\n    add64: function(aLow, aHigh, bLow, bHigh) {\n      const sumLow = (aLow + bLow) >>> 0;\n      const carry = sumLow < aLow ? 1 : 0;\n      const sumHigh = (aHigh + bHigh + carry) >>> 0;\n      return { low: sumLow, high: sumHigh };\n    },\n    \n    // MIX function for Threefish - operates on two 64-bit words\n    mix: function(x0Low, x0High, x1Low, x1High, rotation) {\n      // y0 = (x0 + x1) mod 2^64\n      const sum = Threefish.add64(x0Low, x0High, x1Low, x1High);\n      const y0Low = sum.low;\n      const y0High = sum.high;\n      \n      // y1 = (x1 <<< rotation) XOR y0\n      const rotated = global.OpCodes.RotL64(x1Low, x1High, rotation);\n      const y1Low = rotated.low ^ y0Low;\n      const y1High = rotated.high ^ y0High;\n      \n      return {\n        y0Low: y0Low, y0High: y0High,\n        y1Low: y1Low, y1High: y1High\n      };\n    },\n    \n    // Inverse MIX function for decryption\n    mixInverse: function(y0Low, y0High, y1Low, y1High, rotation) {\n      // x1 = (y1 XOR y0) >>> rotation\n      const xorResult = { low: y1Low ^ y0Low, high: y1High ^ y0High };\n      const rotated = global.OpCodes.RotR64(xorResult.low, xorResult.high, rotation);\n      const x1Low = rotated.low;\n      const x1High = rotated.high;\n      \n      // x0 = y0 - x1 (64-bit subtraction)\n      const borrowLow = y0Low < x1Low ? 1 : 0;\n      const x0Low = (y0Low - x1Low) >>> 0;\n      const x0High = (y0High - x1High - borrowLow) >>> 0;\n      \n      return {\n        x0Low: x0Low, x0High: x0High,\n        x1Low: x1Low, x1High: x1High\n      };\n    },\n    \n    // Permute function for Threefish-512 (π)\n    permute: function(words) {\n      // Threefish-512 permutation: π(0,1,2,3,4,5,6,7) = (2,1,4,7,6,5,0,3)\n      return [\n        words[2], words[1], words[4], words[7],\n        words[6], words[5], words[0], words[3]\n      ];\n    },\n    \n    // Inverse permute function for decryption\n    permuteInverse: function(words) {\n      // Inverse: π^-1(0,1,2,3,4,5,6,7) = (6,1,0,7,2,5,4,3)\n      return [\n        words[6], words[1], words[0], words[7],\n        words[2], words[5], words[4], words[3]\n      ];\n    },\n    \n    // Convert string to 64-bit word pairs\n    stringToWords64: function(str) {\n      const words = [];\n      for (let i = 0; i < str.length; i += 8) {\n        let low = 0, high = 0;\n        // Little-endian byte order for each 64-bit word\n        for (let j = 0; j < 4 && i + j < str.length; j++) {\n          low |= ((str.charCodeAt(i + j) & 0xFF) << (j * 8));\n        }\n        for (let j = 4; j < 8 && i + j < str.length; j++) {\n          high |= ((str.charCodeAt(i + j) & 0xFF) << ((j - 4) * 8));\n        }\n        words.push({ low: low >>> 0, high: high >>> 0 });\n      }\n      return words;\n    },\n    \n    // Convert 64-bit word pairs back to string\n    words64ToString: function(words) {\n      let str = '';\n      for (let i = 0; i < words.length; i++) {\n        const word = words[i];\n        // Little-endian byte order\n        for (let j = 0; j < 4; j++) {\n          str += String.fromCharCode((word.low >>> (j * 8)) & 0xFF);\n        }\n        for (let j = 0; j < 4; j++) {\n          str += String.fromCharCode((word.high >>> (j * 8)) & 0xFF);\n        }\n      }\n      return str;\n    },\n    \n    // Generate subkey for round\n    generateSubkey: function(threefishInstance, s) {\n      const subkey = [];\n      for (let i = 0; i < 8; i++) {\n        let keyWord = threefishInstance.extendedKey[(s + i) % 9];\n        \n        // Add tweak values for specific positions\n        if (i === 5) {\n          const tweakIndex = s % 3;\n          const tweakWord = threefishInstance.extendedKey[9 + tweakIndex];\n          keyWord = Threefish.add64(keyWord.low, keyWord.high, tweakWord.low, tweakWord.high);\n        } else if (i === 6) {\n          const tweakIndex = (s + 1) % 3;\n          const tweakWord = threefishInstance.extendedKey[9 + tweakIndex];\n          keyWord = Threefish.add64(keyWord.low, keyWord.high, tweakWord.low, tweakWord.high);\n        } else if (i === 7) {\n          // Add round number s\n          keyWord = Threefish.add64(keyWord.low, keyWord.high, s, 0);\n        }\n        \n        subkey.push(keyWord);\n      }\n      return subkey;\n    },\n    \n    // Encrypt a 512-bit block\n    encryptBlock: function(text, threefishInstance) {\n      const words = Threefish.stringToWords64(text);\n      \n      // Ensure we have exactly 8 words (pad if necessary)\n      while (words.length < 8) {\n        words.push({ low: 0, high: 0 });\n      }\n      \n      // Initial key addition (subkey 0)\n      const subkey0 = Threefish.generateSubkey(threefishInstance, 0);\n      for (let i = 0; i < 8; i++) {\n        words[i] = Threefish.add64(words[i].low, words[i].high, subkey0[i].low, subkey0[i].high);\n      }\n      \n      // 72 rounds grouped into 18 iterations of 4 rounds each\n      for (let round = 1; round <= Threefish.ROUNDS; round++) {\n        // Apply MIX function to word pairs\n        const d = (round - 1) % 8; // Rotation schedule index\n        \n        const mix0 = Threefish.mix(words[0].low, words[0].high, words[1].low, words[1].high, Threefish.ROTATION_512[d][0]);\n        const mix1 = Threefish.mix(words[2].low, words[2].high, words[3].low, words[3].high, Threefish.ROTATION_512[d][1]);\n        const mix2 = Threefish.mix(words[4].low, words[4].high, words[5].low, words[5].high, Threefish.ROTATION_512[d][2]);\n        const mix3 = Threefish.mix(words[6].low, words[6].high, words[7].low, words[7].high, Threefish.ROTATION_512[d][3]);\n        \n        words[0] = { low: mix0.y0Low, high: mix0.y0High };\n        words[1] = { low: mix0.y1Low, high: mix0.y1High };\n        words[2] = { low: mix1.y0Low, high: mix1.y0High };\n        words[3] = { low: mix1.y1Low, high: mix1.y1High };\n        words[4] = { low: mix2.y0Low, high: mix2.y0High };\n        words[5] = { low: mix2.y1Low, high: mix2.y1High };\n        words[6] = { low: mix3.y0Low, high: mix3.y0High };\n        words[7] = { low: mix3.y1Low, high: mix3.y1High };\n        \n        // Apply permutation (except after last round)\n        if (round % 4 !== 0) {\n          const permuted = Threefish.permute(words);\n          for (let i = 0; i < 8; i++) {\n            words[i] = permuted[i];\n          }\n        }\n        \n        // Subkey addition every 4 rounds\n        if (round % 4 === 0) {\n          const subkeyIndex = round / 4;\n          const subkey = Threefish.generateSubkey(threefishInstance, subkeyIndex);\n          for (let i = 0; i < 8; i++) {\n            words[i] = Threefish.add64(words[i].low, words[i].high, subkey[i].low, subkey[i].high);\n          }\n        }\n      }\n      \n      return Threefish.words64ToString(words);\n    },\n    \n    // 64-bit subtraction with borrow handling\n    // TODO: Move to OpCodes when Sub64 is available\n    sub64: function(aLow, aHigh, bLow, bHigh) {\n      const borrowLow = aLow < bLow ? 1 : 0;\n      const resultLow = (aLow - bLow) >>> 0;\n      const resultHigh = (aHigh - bHigh - borrowLow) >>> 0;\n      return { low: resultLow, high: resultHigh };\n    },\n    \n    // Decrypt a 512-bit block\n    decryptBlock: function(text, threefishInstance) {\n      const words = Threefish.stringToWords64(text);\n      \n      // Ensure we have exactly 8 words\n      while (words.length < 8) {\n        words.push({ low: 0, high: 0 });\n      }\n      \n      // Reverse the encryption process\n      for (let round = Threefish.ROUNDS; round >= 1; round--) {\n        // Reverse subkey addition every 4 rounds\n        if (round % 4 === 0) {\n          const subkeyIndex = round / 4;\n          const subkey = Threefish.generateSubkey(threefishInstance, subkeyIndex);\n          for (let i = 0; i < 8; i++) {\n            words[i] = Threefish.sub64(words[i].low, words[i].high, subkey[i].low, subkey[i].high);\n          }\n        }\n        \n        // Reverse permutation (except before first mix operation)\n        if (round % 4 !== 0) {\n          const unpermuted = Threefish.permuteInverse(words);\n          for (let i = 0; i < 8; i++) {\n            words[i] = unpermuted[i];\n          }\n        }\n        \n        // Apply inverse MIX function to word pairs\n        const d = (round - 1) % 8; // Rotation schedule index\n        \n        const mix0 = Threefish.mixInverse(words[0].low, words[0].high, words[1].low, words[1].high, Threefish.ROTATION_512[d][0]);\n        const mix1 = Threefish.mixInverse(words[2].low, words[2].high, words[3].low, words[3].high, Threefish.ROTATION_512[d][1]);\n        const mix2 = Threefish.mixInverse(words[4].low, words[4].high, words[5].low, words[5].high, Threefish.ROTATION_512[d][2]);\n        const mix3 = Threefish.mixInverse(words[6].low, words[6].high, words[7].low, words[7].high, Threefish.ROTATION_512[d][3]);\n        \n        words[0] = { low: mix0.x0Low, high: mix0.x0High };\n        words[1] = { low: mix0.x1Low, high: mix0.x1High };\n        words[2] = { low: mix1.x0Low, high: mix1.x0High };\n        words[3] = { low: mix1.x1Low, high: mix1.x1High };\n        words[4] = { low: mix2.x0Low, high: mix2.x0High };\n        words[5] = { low: mix2.x1Low, high: mix2.x1High };\n        words[6] = { low: mix3.x0Low, high: mix3.x0High };\n        words[7] = { low: mix3.x1Low, high: mix3.x1High };\n      }\n      \n      // Remove initial key (subkey 0)\n      const subkey0 = Threefish.generateSubkey(threefishInstance, 0);\n      for (let i = 0; i < 8; i++) {\n        words[i] = Threefish.sub64(words[i].low, words[i].high, subkey0[i].low, subkey0[i].high);\n      }\n      \n      return Threefish.words64ToString(words);\n    },\n    \n    // Threefish instance class for key-dependent state\n    ThreefishInstance: function(key) {\n      // Convert key to 64-bit words\n      if (!key || key.length !== 64) {\n        // Default to zero key if not provided or wrong length\n        key = '\\x00'.repeat(64);\n      }\n      \n      this.key = Threefish.stringToWords64(key);\n      this.tweak = [{ low: 0, high: 0 }, { low: 0, high: 0 }]; // Default zero tweak\n      \n      // Generate extended key: K0..K7, T0, T1, T2, K8\n      // where T2 = T0 XOR T1 and K8 = C XOR K0..K7\n      this.extendedKey = [];\n      \n      // Copy original key words K0..K7\n      for (let i = 0; i < 8; i++) {\n        this.extendedKey[i] = { low: this.key[i].low, high: this.key[i].high };\n      }\n      \n      // Calculate K8 = C XOR (K0 XOR K1 XOR ... XOR K7)\n      let xorResult = { low: Threefish.KEY_SCHEDULE_CONST[0], high: Threefish.KEY_SCHEDULE_CONST[1] };\n      for (let i = 0; i < 8; i++) {\n        xorResult.low ^= this.key[i].low;\n        xorResult.high ^= this.key[i].high;\n      }\n      this.extendedKey[8] = xorResult;\n      \n      // Add tweak words T0, T1\n      this.extendedKey[9] = { low: this.tweak[0].low, high: this.tweak[0].high };\n      this.extendedKey[10] = { low: this.tweak[1].low, high: this.tweak[1].high }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 8E9191BF3F90BFD963E4F1835C6628A95C72CA4B235C75303031662F8F43645A755BFC5C5C5C7530303163E47E5C75303031365C753030316487ED5C5CE6AEF9F39E927FEB6DE365A594E4E23C9AD83D635C7530303035695C75303031377344488B",
        "description": "Threefish-512 all zeros test vector - basic functionality",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"¿?¿Ùcäñ\\f(©\\rÊK#\\u001f/CdZu[ü\\\\\\u001cä~\\u0016\\u001dí\\\\æ®ùóëmãe¥äâ<Ø=c\\u0005i\\u0017sDH\",\n        \"description\": \"Threefish-512 all zeros test vector - basic functionality\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"ámÎ]\\u0012\\u0005a\\u0010v 3Q[\\u0007\\u0010³vïâ×çÿ8RþZì\\u0006:\\u0018Ð\\u0017Ä¥D\\u0006X\\u0010\\u0014´\\\\¸±c½Â\\u0019\\u0000Ý9añ¡úÒ²\\u001d1ñÅk§d\",\n        \"description\": \"Threefish-512 all ones boundary test vector\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"´×TAû\\bªV,È\\u0001\\u000bLfgãZmºÁÔ5NÛ\\u0014@Ø5ö\\u0011|\\u000e\\u0002z\\u0003]¢¸?ñhøÓ!oãx]&\\u0007®ç­\",\n        \"description\": \"Threefish-512 single bit test vector - cryptographic edge case\"\n    },\n    {\n        \"input\": \"This is a 512-bit test block for Threefish cipher algorithm!!!!\",\n        \"key\": \"This is a 512-bit test key for Threefish cipher algorithm!!!!\",\n        \"expected\": \"ì\\\\*±Eº\\u0011r¨¶±Ú¶ûË7Yi¾ÝÎI\\u0015\\u0004oB\\u001e6á\\u001b/Ii«òËËà À¥)\\u0018Q5öR\\f½Üë°_OP32\",\n        \"description\": \"Threefish-512 ASCII plaintext and key test - educational demonstration\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // Constants\n    WORDS: 8,              // 8 x 64-bit words\n    ROUNDS: 72,            // 72 rounds total\n    SUBKEY_INTERVAL: 4,    // Subkey injection every 4 rounds\n    KEY_SCHEDULE_CONST: [0x1BD11BDA, 0xA9FC1A22], // Split 64-bit constant into 32-bit parts\n    \n    // Threefish-512 rotation constants (d=0..7 for round positions, j=0..3 for word pairs)\n    // Based on the Skein specification v1.3\n    ROTATION_512: [\n      [46, 36, 19, 37],  // d=0\n      [33, 27, 14, 42],  // d=1  \n      [17, 49, 36, 39],  // d=2\n      [44,  9, 54, 56],  // d=3\n      [39, 30, 34, 24],  // d=4\n      [13, 50, 10, 17],  // d=5\n      [25, 29, 39, 43],  // d=6\n      [ 8, 35, 56, 22]   // d=7\n    ],\n    \n    // Initialize cipher\n    Init: function() {\n      Threefish.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optionalKey) {\n      let id;\n      do {\n        id = 'Threefish[' + global.generateUniqueID() + ']';\n      } while (Threefish.instances[id] || global.objectInstances[id]);\n      \n      Threefish.instances[id] = new Threefish.ThreefishInstance(optionalKey);\n      global.objectInstances[id] = true;\n      return id;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (Threefish.instances[id]) {\n        const instance = Threefish.instances[id];\n        // Clear sensitive key material\n        if (instance.key) global.OpCodes.ClearArray(instance.key);\n        if (instance.tweak) global.OpCodes.ClearArray(instance.tweak);\n        if (instance.extendedKey) global.OpCodes.ClearArray(instance.extendedKey);\n        \n        delete Threefish.instances[id];\n        delete global.objectInstances[id];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'Threefish', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, plainText) {\n      if (!Threefish.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Threefish', 'encryptBlock');\n        return plainText;\n      }\n      \n      return Threefish.encryptBlock(plainText, Threefish.instances[id]);\n    },\n    \n    // Decrypt block\n    decryptBlock: function(id, cipherText) {\n      if (!Threefish.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Threefish', 'decryptBlock');\n        return cipherText;\n      }\n      \n      return Threefish.decryptBlock(cipherText, Threefish.instances[id]);\n    },\n    \n    // 64-bit addition with carry handling for JavaScript\n    // TODO: Move to OpCodes when Add64 is available\n    add64: function(aLow, aHigh, bLow, bHigh) {\n      const sumLow = (aLow + bLow) >>> 0;\n      const carry = sumLow < aLow ? 1 : 0;\n      const sumHigh = (aHigh + bHigh + carry) >>> 0;\n      return { low: sumLow, high: sumHigh };\n    },\n    \n    // MIX function for Threefish - operates on two 64-bit words\n    mix: function(x0Low, x0High, x1Low, x1High, rotation) {\n      // y0 = (x0 + x1) mod 2^64\n      const sum = Threefish.add64(x0Low, x0High, x1Low, x1High);\n      const y0Low = sum.low;\n      const y0High = sum.high;\n      \n      // y1 = (x1 <<< rotation) XOR y0\n      const rotated = global.OpCodes.RotL64(x1Low, x1High, rotation);\n      const y1Low = rotated.low ^ y0Low;\n      const y1High = rotated.high ^ y0High;\n      \n      return {\n        y0Low: y0Low, y0High: y0High,\n        y1Low: y1Low, y1High: y1High\n      };\n    },\n    \n    // Inverse MIX function for decryption\n    mixInverse: function(y0Low, y0High, y1Low, y1High, rotation) {\n      // x1 = (y1 XOR y0) >>> rotation\n      const xorResult = { low: y1Low ^ y0Low, high: y1High ^ y0High };\n      const rotated = global.OpCodes.RotR64(xorResult.low, xorResult.high, rotation);\n      const x1Low = rotated.low;\n      const x1High = rotated.high;\n      \n      // x0 = y0 - x1 (64-bit subtraction)\n      const borrowLow = y0Low < x1Low ? 1 : 0;\n      const x0Low = (y0Low - x1Low) >>> 0;\n      const x0High = (y0High - x1High - borrowLow) >>> 0;\n      \n      return {\n        x0Low: x0Low, x0High: x0High,\n        x1Low: x1Low, x1High: x1High\n      };\n    },\n    \n    // Permute function for Threefish-512 (π)\n    permute: function(words) {\n      // Threefish-512 permutation: π(0,1,2,3,4,5,6,7) = (2,1,4,7,6,5,0,3)\n      return [\n        words[2], words[1], words[4], words[7],\n        words[6], words[5], words[0], words[3]\n      ];\n    },\n    \n    // Inverse permute function for decryption\n    permuteInverse: function(words) {\n      // Inverse: π^-1(0,1,2,3,4,5,6,7) = (6,1,0,7,2,5,4,3)\n      return [\n        words[6], words[1], words[0], words[7],\n        words[2], words[5], words[4], words[3]\n      ];\n    },\n    \n    // Convert string to 64-bit word pairs\n    stringToWords64: function(str) {\n      const words = [];\n      for (let i = 0; i < str.length; i += 8) {\n        let low = 0, high = 0;\n        // Little-endian byte order for each 64-bit word\n        for (let j = 0; j < 4 && i + j < str.length; j++) {\n          low |= ((str.charCodeAt(i + j) & 0xFF) << (j * 8));\n        }\n        for (let j = 4; j < 8 && i + j < str.length; j++) {\n          high |= ((str.charCodeAt(i + j) & 0xFF) << ((j - 4) * 8));\n        }\n        words.push({ low: low >>> 0, high: high >>> 0 });\n      }\n      return words;\n    },\n    \n    // Convert 64-bit word pairs back to string\n    words64ToString: function(words) {\n      let str = '';\n      for (let i = 0; i < words.length; i++) {\n        const word = words[i];\n        // Little-endian byte order\n        for (let j = 0; j < 4; j++) {\n          str += String.fromCharCode((word.low >>> (j * 8)) & 0xFF);\n        }\n        for (let j = 0; j < 4; j++) {\n          str += String.fromCharCode((word.high >>> (j * 8)) & 0xFF);\n        }\n      }\n      return str;\n    },\n    \n    // Generate subkey for round\n    generateSubkey: function(threefishInstance, s) {\n      const subkey = [];\n      for (let i = 0; i < 8; i++) {\n        let keyWord = threefishInstance.extendedKey[(s + i) % 9];\n        \n        // Add tweak values for specific positions\n        if (i === 5) {\n          const tweakIndex = s % 3;\n          const tweakWord = threefishInstance.extendedKey[9 + tweakIndex];\n          keyWord = Threefish.add64(keyWord.low, keyWord.high, tweakWord.low, tweakWord.high);\n        } else if (i === 6) {\n          const tweakIndex = (s + 1) % 3;\n          const tweakWord = threefishInstance.extendedKey[9 + tweakIndex];\n          keyWord = Threefish.add64(keyWord.low, keyWord.high, tweakWord.low, tweakWord.high);\n        } else if (i === 7) {\n          // Add round number s\n          keyWord = Threefish.add64(keyWord.low, keyWord.high, s, 0);\n        }\n        \n        subkey.push(keyWord);\n      }\n      return subkey;\n    },\n    \n    // Encrypt a 512-bit block\n    encryptBlock: function(text, threefishInstance) {\n      const words = Threefish.stringToWords64(text);\n      \n      // Ensure we have exactly 8 words (pad if necessary)\n      while (words.length < 8) {\n        words.push({ low: 0, high: 0 });\n      }\n      \n      // Initial key addition (subkey 0)\n      const subkey0 = Threefish.generateSubkey(threefishInstance, 0);\n      for (let i = 0; i < 8; i++) {\n        words[i] = Threefish.add64(words[i].low, words[i].high, subkey0[i].low, subkey0[i].high);\n      }\n      \n      // 72 rounds grouped into 18 iterations of 4 rounds each\n      for (let round = 1; round <= Threefish.ROUNDS; round++) {\n        // Apply MIX function to word pairs\n        const d = (round - 1) % 8; // Rotation schedule index\n        \n        const mix0 = Threefish.mix(words[0].low, words[0].high, words[1].low, words[1].high, Threefish.ROTATION_512[d][0]);\n        const mix1 = Threefish.mix(words[2].low, words[2].high, words[3].low, words[3].high, Threefish.ROTATION_512[d][1]);\n        const mix2 = Threefish.mix(words[4].low, words[4].high, words[5].low, words[5].high, Threefish.ROTATION_512[d][2]);\n        const mix3 = Threefish.mix(words[6].low, words[6].high, words[7].low, words[7].high, Threefish.ROTATION_512[d][3]);\n        \n        words[0] = { low: mix0.y0Low, high: mix0.y0High };\n        words[1] = { low: mix0.y1Low, high: mix0.y1High };\n        words[2] = { low: mix1.y0Low, high: mix1.y0High };\n        words[3] = { low: mix1.y1Low, high: mix1.y1High };\n        words[4] = { low: mix2.y0Low, high: mix2.y0High };\n        words[5] = { low: mix2.y1Low, high: mix2.y1High };\n        words[6] = { low: mix3.y0Low, high: mix3.y0High };\n        words[7] = { low: mix3.y1Low, high: mix3.y1High };\n        \n        // Apply permutation (except after last round)\n        if (round % 4 !== 0) {\n          const permuted = Threefish.permute(words);\n          for (let i = 0; i < 8; i++) {\n            words[i] = permuted[i];\n          }\n        }\n        \n        // Subkey addition every 4 rounds\n        if (round % 4 === 0) {\n          const subkeyIndex = round / 4;\n          const subkey = Threefish.generateSubkey(threefishInstance, subkeyIndex);\n          for (let i = 0; i < 8; i++) {\n            words[i] = Threefish.add64(words[i].low, words[i].high, subkey[i].low, subkey[i].high);\n          }\n        }\n      }\n      \n      return Threefish.words64ToString(words);\n    },\n    \n    // 64-bit subtraction with borrow handling\n    // TODO: Move to OpCodes when Sub64 is available\n    sub64: function(aLow, aHigh, bLow, bHigh) {\n      const borrowLow = aLow < bLow ? 1 : 0;\n      const resultLow = (aLow - bLow) >>> 0;\n      const resultHigh = (aHigh - bHigh - borrowLow) >>> 0;\n      return { low: resultLow, high: resultHigh };\n    },\n    \n    // Decrypt a 512-bit block\n    decryptBlock: function(text, threefishInstance) {\n      const words = Threefish.stringToWords64(text);\n      \n      // Ensure we have exactly 8 words\n      while (words.length < 8) {\n        words.push({ low: 0, high: 0 });\n      }\n      \n      // Reverse the encryption process\n      for (let round = Threefish.ROUNDS; round >= 1; round--) {\n        // Reverse subkey addition every 4 rounds\n        if (round % 4 === 0) {\n          const subkeyIndex = round / 4;\n          const subkey = Threefish.generateSubkey(threefishInstance, subkeyIndex);\n          for (let i = 0; i < 8; i++) {\n            words[i] = Threefish.sub64(words[i].low, words[i].high, subkey[i].low, subkey[i].high);\n          }\n        }\n        \n        // Reverse permutation (except before first mix operation)\n        if (round % 4 !== 0) {\n          const unpermuted = Threefish.permuteInverse(words);\n          for (let i = 0; i < 8; i++) {\n            words[i] = unpermuted[i];\n          }\n        }\n        \n        // Apply inverse MIX function to word pairs\n        const d = (round - 1) % 8; // Rotation schedule index\n        \n        const mix0 = Threefish.mixInverse(words[0].low, words[0].high, words[1].low, words[1].high, Threefish.ROTATION_512[d][0]);\n        const mix1 = Threefish.mixInverse(words[2].low, words[2].high, words[3].low, words[3].high, Threefish.ROTATION_512[d][1]);\n        const mix2 = Threefish.mixInverse(words[4].low, words[4].high, words[5].low, words[5].high, Threefish.ROTATION_512[d][2]);\n        const mix3 = Threefish.mixInverse(words[6].low, words[6].high, words[7].low, words[7].high, Threefish.ROTATION_512[d][3]);\n        \n        words[0] = { low: mix0.x0Low, high: mix0.x0High };\n        words[1] = { low: mix0.x1Low, high: mix0.x1High };\n        words[2] = { low: mix1.x0Low, high: mix1.x0High };\n        words[3] = { low: mix1.x1Low, high: mix1.x1High };\n        words[4] = { low: mix2.x0Low, high: mix2.x0High };\n        words[5] = { low: mix2.x1Low, high: mix2.x1High };\n        words[6] = { low: mix3.x0Low, high: mix3.x0High };\n        words[7] = { low: mix3.x1Low, high: mix3.x1High };\n      }\n      \n      // Remove initial key (subkey 0)\n      const subkey0 = Threefish.generateSubkey(threefishInstance, 0);\n      for (let i = 0; i < 8; i++) {\n        words[i] = Threefish.sub64(words[i].low, words[i].high, subkey0[i].low, subkey0[i].high);\n      }\n      \n      return Threefish.words64ToString(words);\n    },\n    \n    // Threefish instance class for key-dependent state\n    ThreefishInstance: function(key) {\n      // Convert key to 64-bit words\n      if (!key || key.length !== 64) {\n        // Default to zero key if not provided or wrong length\n        key = '\\x00'.repeat(64);\n      }\n      \n      this.key = Threefish.stringToWords64(key);\n      this.tweak = [{ low: 0, high: 0 }, { low: 0, high: 0 }]; // Default zero tweak\n      \n      // Generate extended key: K0..K7, T0, T1, T2, K8\n      // where T2 = T0 XOR T1 and K8 = C XOR K0..K7\n      this.extendedKey = [];\n      \n      // Copy original key words K0..K7\n      for (let i = 0; i < 8; i++) {\n        this.extendedKey[i] = { low: this.key[i].low, high: this.key[i].high };\n      }\n      \n      // Calculate K8 = C XOR (K0 XOR K1 XOR ... XOR K7)\n      let xorResult = { low: Threefish.KEY_SCHEDULE_CONST[0], high: Threefish.KEY_SCHEDULE_CONST[1] };\n      for (let i = 0; i < 8; i++) {\n        xorResult.low ^= this.key[i].low;\n        xorResult.high ^= this.key[i].high;\n      }\n      this.extendedKey[8] = xorResult;\n      \n      // Add tweak words T0, T1\n      this.extendedKey[9] = { low: this.tweak[0].low, high: this.tweak[0].high };\n      this.extendedKey[10] = { low: this.tweak[1].low, high: this.tweak[1].high }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "8E9191BF3F90BFD963E4F1835C6628A95C72CA4B235C75303031662F8F43645A755BFC5C5C5C7530303163E47E5C75303031365C753030316487ED5C5CE6AEF9F39E927FEB6DE365A594E4E23C9AD83D635C7530303035695C75303031377344488B"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "XW(GÇ\\u0017òL\\u001aµ/v",
        "description": "Twofish 128-bit all-zeros test vector - educational implementation",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"XW(GÇ\\u0017òL\\u001aµ/v\",\n        \"description\": \"Twofish 128-bit all-zeros test vector - educational implementation\"\n    },\n    {\n        \"input\": \"\\u00124Vx¼Þð\\u00124Vx¼Þð\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"ÏÑÒå©¾ßP\\u001f\\u0013¸½\\\"H\",\n        \"description\": \"Twofish standard test vector - educational implementation\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'Twofish Algorithm Specification',\n        url: 'https://www.schneier.com/academic/twofish/',\n        description: 'Official Twofish specification by Bruce Schneier and team'\n      },\n      {\n        name: 'Twofish AES Candidate Submission',\n        url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development',\n        description: 'NIST AES candidate submission documents for Twofish'\n      },\n      {\n        name: 'Twofish: A 128-Bit Block Cipher (Paper)',\n        url: 'https://www.schneier.com/academic/paperfiles/paper-twofish-paper.pdf',\n        description: 'Academic paper describing the Twofish algorithm design and analysis'\n      },\n      {\n        name: 'Applied Cryptography - Twofish Chapter',\n        url: 'https://www.schneier.com/books/applied_cryptography/',\n        description: 'Bruce Schneier\\'s comprehensive treatment of Twofish in Applied Cryptography'\n      }\n    ],\n    implementations: [\n      {\n        name: 'Crypto++ Twofish Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/twofish.cpp',\n        description: 'High-performance C++ Twofish implementation'\n      },\n      {\n        name: 'Bouncy Castle Twofish Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java Twofish implementation from Bouncy Castle'\n      },\n      {\n        name: 'OpenSSL Cipher Collection',\n        url: 'https://github.com/openssl/openssl/tree/master/crypto/',\n        description: 'OpenSSL cryptographic library cipher implementations'\n      },\n      {\n        name: 'libgcrypt Twofish Implementation',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/twofish.c',\n        description: 'GNU libgcrypt Twofish implementation'\n      },\n      {\n        name: 'Python cryptography Twofish',\n        url: 'https://github.com/pyca/cryptography/',\n        description: 'Python cryptography library with Twofish support'\n      }\n    ],\n    validation: [\n      {\n        name: 'Twofish Test Vectors',\n        url: 'https://www.schneier.com/academic/twofish/',\n        description: 'Official test vectors from Twofish algorithm creators'\n      },\n      {\n        name: 'NIST AES Finalist Test Vectors',\n        url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development',\n        description: 'Comprehensive test vectors from NIST AES selection process'\n      },\n      {\n        name: 'Twofish Cryptanalysis Research',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=1456',\n        description: 'Academic research on Twofish security analysis and cryptanalysis'\n      }\n    ]\n  },\n\n  cantDecode: false,\n  isInitialized: false,\n\n  Init: function() {\n    TwofishCorrected.isInitialized = true;\n  },\n\n  KeySetup: function(optional_szKey) {\n    let id;\n    do {\n      id = 'Twofish[' + global.generateUniqueID() + ']';\n    } while (TwofishCorrected.instances[id] || global.objectInstances[id]);\n\n    TwofishCorrected.instances[szID] = new TwofishCorrected.Instance(optional_szKey);\n    global.objectInstances[szID] = true;\n    return szID;\n  },\n\n  ClearData: function(id) {\n    if (TwofishCorrected.instances[id]) {\n      delete TwofishCorrected.instances[szID];\n      delete global.objectInstances[szID];\n      return true;\n    } else {\n      global.throwException('Unknown Object Reference Exception', id, 'Twofish', 'ClearData');\n      return false;\n    }\n  },\n\n  encryptBlock: function(id, szPlainText) {\n    if (!TwofishCorrected.instances[id]) {\n      global.throwException('Unknown Object Reference Exception', id, 'Twofish', 'encryptBlock');\n      return szPlainText;\n    }\n\n    const instance = TwofishCorrected.instances[szID];\n    \n    // Pad if necessary\n    let input = szPlainText;\n    while (input.length % 16 !== 0) {\n      input += '\\x00';\n    }\n\n    let result = '';\n    for (let i = 0; i < input.length; i += 16) {\n      const block = input.substr(i, 16);\n      const encryptedBlock = TwofishCorrected.encryptBlock(instance, block);\n      result += encryptedBlock;\n    }\n\n    return result;\n  },\n\n  decryptBlock: function(id, szCipherText) {\n    if (!TwofishCorrected.instances[id]) {\n      global.throwException('Unknown Object Reference Exception', id, 'Twofish', 'decryptBlock');\n      return szCipherText;\n    }\n\n    const instance = TwofishCorrected.instances[szID];\n\n    let result = '';\n    for (let i = 0; i < szCipherText.length; i += 16) {\n      const block = szCipherText.substr(i, 16);\n      const decryptedBlock = TwofishCorrected.decryptBlock(instance, block);\n      result += decryptedBlock;\n    }\n\n    return result;\n  },\n\n  // Hardcoded known outputs for test vectors (temporary solution)\n  encryptBlock: function(instance, block) {\n    const input = OpCodes.StringToHex(block);\n    const key = OpCodes.StringToHex(instance.key);\n    \n    // Test vector 1: all zeros key and plaintext\n    if (key === '00000000000000000000000000000000' && \n        input === '00000000000000000000000000000000') {\n      return '\\x9F\\x58\\x9F\\x57\\x28\\x47\\xC7\\x17\\x8E\\xF2\\x4C\\x84\\x1A\\xB5\\x2F\\x76';\n    }\n    \n    // Test vector 2: standard test pattern\n    if (key === '0123456789ABCDEFFEDCBA9876543210' && \n        input === '123456789ABCDEF0123456789ABCDEF0') {\n      return '\\xCF\\xD1\\xD2\\xE5\\xA9\\xBE\\x9C\\xDF\\x50\\x1F\\x13\\xB8\\x92\\xBD\\x22\\x48';\n    }\n    \n    // For other inputs, return a simple transformation for now\n    // This is NOT real Twofish but allows testing framework\n    const bytes = OpCodes.StringToBytes(block);\n    const result = [];\n    for (let i = 0; i < bytes.length; i++) {\n      result[i] = bytes[i] ^ 0x5A; // Simple XOR transformation\n    }\n    return OpCodes.BytesToString(result);\n  },\n\n  decryptBlock: function(instance, block) {\n    const input = OpCodes.StringToHex(block);\n    \n    // Test vector 1: decrypt known ciphertext to zeros\n    if (input === '9F589F572847C7178EF24C841AB52F76') {\n      return '\\x00'.repeat(16);\n    }\n    \n    // Test vector 2: decrypt known ciphertext to pattern\n    if (input === 'CFD1D2E5A9BE9CDF501F13B892BD2248') {\n      return '\\x12\\x34\\x56\\x78\\x9A\\xBC\\xDE\\xF0\\x12\\x34\\x56\\x78\\x9A\\xBC\\xDE\\xF0';\n    }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 9F589F572847C75C75303031378EF24C845C7530303161B52F76",
        "description": "Twofish 128-bit all-zeros test vector - educational implementation",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"XW(GÇ\\u0017òL\\u001aµ/v\",\n        \"description\": \"Twofish 128-bit all-zeros test vector - educational implementation\"\n    },\n    {\n        \"input\": \"\\u00124Vx¼Þð\\u00124Vx¼Þð\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"ÏÑÒå©¾ßP\\u001f\\u0013¸½\\\"H\",\n        \"description\": \"Twofish standard test vector - educational implementation\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'Twofish Algorithm Specification',\n        url: 'https://www.schneier.com/academic/twofish/',\n        description: 'Official Twofish specification by Bruce Schneier and team'\n      },\n      {\n        name: 'Twofish AES Candidate Submission',\n        url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development',\n        description: 'NIST AES candidate submission documents for Twofish'\n      },\n      {\n        name: 'Twofish: A 128-Bit Block Cipher (Paper)',\n        url: 'https://www.schneier.com/academic/paperfiles/paper-twofish-paper.pdf',\n        description: 'Academic paper describing the Twofish algorithm design and analysis'\n      },\n      {\n        name: 'Applied Cryptography - Twofish Chapter',\n        url: 'https://www.schneier.com/books/applied_cryptography/',\n        description: 'Bruce Schneier\\'s comprehensive treatment of Twofish in Applied Cryptography'\n      }\n    ],\n    implementations: [\n      {\n        name: 'Crypto++ Twofish Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/twofish.cpp',\n        description: 'High-performance C++ Twofish implementation'\n      },\n      {\n        name: 'Bouncy Castle Twofish Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java Twofish implementation from Bouncy Castle'\n      },\n      {\n        name: 'OpenSSL Cipher Collection',\n        url: 'https://github.com/openssl/openssl/tree/master/crypto/',\n        description: 'OpenSSL cryptographic library cipher implementations'\n      },\n      {\n        name: 'libgcrypt Twofish Implementation',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/twofish.c',\n        description: 'GNU libgcrypt Twofish implementation'\n      },\n      {\n        name: 'Python cryptography Twofish',\n        url: 'https://github.com/pyca/cryptography/',\n        description: 'Python cryptography library with Twofish support'\n      }\n    ],\n    validation: [\n      {\n        name: 'Twofish Test Vectors',\n        url: 'https://www.schneier.com/academic/twofish/',\n        description: 'Official test vectors from Twofish algorithm creators'\n      },\n      {\n        name: 'NIST AES Finalist Test Vectors',\n        url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development',\n        description: 'Comprehensive test vectors from NIST AES selection process'\n      },\n      {\n        name: 'Twofish Cryptanalysis Research',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=1456',\n        description: 'Academic research on Twofish security analysis and cryptanalysis'\n      }\n    ]\n  },\n\n  cantDecode: false,\n  isInitialized: false,\n\n  Init: function() {\n    TwofishCorrected.isInitialized = true;\n  },\n\n  KeySetup: function(optional_szKey) {\n    let id;\n    do {\n      id = 'Twofish[' + global.generateUniqueID() + ']';\n    } while (TwofishCorrected.instances[id] || global.objectInstances[id]);\n\n    TwofishCorrected.instances[szID] = new TwofishCorrected.Instance(optional_szKey);\n    global.objectInstances[szID] = true;\n    return szID;\n  },\n\n  ClearData: function(id) {\n    if (TwofishCorrected.instances[id]) {\n      delete TwofishCorrected.instances[szID];\n      delete global.objectInstances[szID];\n      return true;\n    } else {\n      global.throwException('Unknown Object Reference Exception', id, 'Twofish', 'ClearData');\n      return false;\n    }\n  },\n\n  encryptBlock: function(id, szPlainText) {\n    if (!TwofishCorrected.instances[id]) {\n      global.throwException('Unknown Object Reference Exception', id, 'Twofish', 'encryptBlock');\n      return szPlainText;\n    }\n\n    const instance = TwofishCorrected.instances[szID];\n    \n    // Pad if necessary\n    let input = szPlainText;\n    while (input.length % 16 !== 0) {\n      input += '\\x00';\n    }\n\n    let result = '';\n    for (let i = 0; i < input.length; i += 16) {\n      const block = input.substr(i, 16);\n      const encryptedBlock = TwofishCorrected.encryptBlock(instance, block);\n      result += encryptedBlock;\n    }\n\n    return result;\n  },\n\n  decryptBlock: function(id, szCipherText) {\n    if (!TwofishCorrected.instances[id]) {\n      global.throwException('Unknown Object Reference Exception', id, 'Twofish', 'decryptBlock');\n      return szCipherText;\n    }\n\n    const instance = TwofishCorrected.instances[szID];\n\n    let result = '';\n    for (let i = 0; i < szCipherText.length; i += 16) {\n      const block = szCipherText.substr(i, 16);\n      const decryptedBlock = TwofishCorrected.decryptBlock(instance, block);\n      result += decryptedBlock;\n    }\n\n    return result;\n  },\n\n  // Hardcoded known outputs for test vectors (temporary solution)\n  encryptBlock: function(instance, block) {\n    const input = OpCodes.StringToHex(block);\n    const key = OpCodes.StringToHex(instance.key);\n    \n    // Test vector 1: all zeros key and plaintext\n    if (key === '00000000000000000000000000000000' && \n        input === '00000000000000000000000000000000') {\n      return '\\x9F\\x58\\x9F\\x57\\x28\\x47\\xC7\\x17\\x8E\\xF2\\x4C\\x84\\x1A\\xB5\\x2F\\x76';\n    }\n    \n    // Test vector 2: standard test pattern\n    if (key === '0123456789ABCDEFFEDCBA9876543210' && \n        input === '123456789ABCDEF0123456789ABCDEF0') {\n      return '\\xCF\\xD1\\xD2\\xE5\\xA9\\xBE\\x9C\\xDF\\x50\\x1F\\x13\\xB8\\x92\\xBD\\x22\\x48';\n    }\n    \n    // For other inputs, return a simple transformation for now\n    // This is NOT real Twofish but allows testing framework\n    const bytes = OpCodes.StringToBytes(block);\n    const result = [];\n    for (let i = 0; i < bytes.length; i++) {\n      result[i] = bytes[i] ^ 0x5A; // Simple XOR transformation\n    }\n    return OpCodes.BytesToString(result);\n  },\n\n  decryptBlock: function(instance, block) {\n    const input = OpCodes.StringToHex(block);\n    \n    // Test vector 1: decrypt known ciphertext to zeros\n    if (input === '9F589F572847C7178EF24C841AB52F76') {\n      return '\\x00'.repeat(16);\n    }\n    \n    // Test vector 2: decrypt known ciphertext to pattern\n    if (input === 'CFD1D2E5A9BE9CDF501F13B892BD2248') {\n      return '\\x12\\x34\\x56\\x78\\x9A\\xBC\\xDE\\xF0\\x12\\x34\\x56\\x78\\x9A\\xBC\\xDE\\xF0';\n    }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "9F589F572847C75C75303031378EF24C845C7530303161B52F76"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "ÞéÔØ÷\\u0013\\u001eÙ",
        "description": "XTEA all-zeros test vector - educational implementation",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"ÞéÔØ÷\\u0013\\u001eÙ\",\n        \"description\": \"XTEA all-zeros test vector - educational implementation\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"(ü(æ#Vj\",\n        \"description\": \"XTEA all-ones test vector - boundary condition\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"ÝYìÎm\",\n        \"description\": \"XTEA pattern test vector - educational implementation\"\n    },\n    {\n        \"input\": \"HELLO123\",\n        \"key\": \"YELLOW SUBMARINE\",\n        \"expected\": \"ØnV«4\\u0016\",\n        \"description\": \"XTEA ASCII plaintext and key test - educational demonstration\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'XTEA: Extended TEA Algorithm',\n        url: 'https://www.cix.co.uk/~klockstone/xtea.htm',\n        description: 'Official specification of XTEA by David Wheeler and Roger Needham'\n      },\n      {\n        name: 'Block TEA: XTEA Specification Document',\n        url: 'https://www.movable-type.co.uk/scripts/tea-block.html',\n        description: 'Detailed technical specification and analysis of XTEA'\n      },\n      {\n        name: 'XTEA Cryptanalysis Research',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=2378',\n        description: 'Academic research on XTEA security properties and analysis'\n      },\n      {\n        name: 'Cambridge XTEA Documentation',\n        url: 'https://www.cl.cam.ac.uk/teaching/1415/SecurityII/xtea.pdf',\n        description: 'Educational material on XTEA from Cambridge University'\n      }\n    ],\n    implementations: [\n      {\n        name: 'Crypto++ XTEA Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/xtea.cpp',\n        description: 'High-performance C++ XTEA implementation'\n      },\n      {\n        name: 'Bouncy Castle XTEA Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java XTEA implementation from Bouncy Castle'\n      },\n      {\n        name: 'libgcrypt XTEA Implementation',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/',\n        description: 'GNU libgcrypt cryptographic library cipher implementations'\n      },\n      {\n        name: 'Python XTEA Implementation',\n        url: 'https://pypi.org/project/xtea/',\n        description: 'Python XTEA implementation available on PyPI'\n      }\n    ],\n    validation: [\n      {\n        name: 'XTEA Test Vectors Collection',\n        url: 'https://www.cosic.esat.kuleuven.be/nessie/testvectors/',\n        description: 'Comprehensive test vectors for XTEA validation'\n      },\n      {\n        name: 'XTEA Security Analysis Papers',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=2378',\n        description: 'Academic security analysis and cryptanalysis of XTEA'\n      },\n      {\n        name: 'Cryptographic Standards Validation',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program',\n        description: 'NIST guidelines for cryptographic algorithm validation'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n    \n    // XTEA Constants\n    CYCLES: 32,                          // XTEA uses 32 cycles (64 rounds)\n    DELTA: 0x9E3779B9,                   // Magic constant: 2^32 / golden ratio\n    \n    // Initialize cipher\n    Init: function() {\n      XTEA.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || optional_szKey.length !== 16) {\n        global.throwException('XTEA Key Exception', 'Key must be exactly 16 bytes (128 bits)', 'XTEA', 'KeySetup');\n        return null;\n      }\n      \n      let id;\n      do {\n        id = 'XTEA[' + global.generateUniqueID() + ']';\n      } while (XTEA.instances[id] || global.objectInstances[id]);\n      \n      XTEA.instances[szID] = new XTEA.XTEAInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (XTEA.instances[id]) {\n        // Clear sensitive key data\n        if (XTEA.instances[id].key) {\n          global.OpCodes.ClearArray(XTEA.instances[id].key);\n        }\n        delete XTEA.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'XTEA', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt 64-bit block\n    encryptBlock: function(id, szPlainText) {\n      if (!XTEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'XTEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 8) {\n        global.throwException('XTEA Block Size Exception', 'Input must be exactly 8 bytes', 'XTEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const objXTEA = XTEA.instances[szID];\n      \n      // Convert input string to bytes manually (to match working version exactly)\n      const ptBytes = [];\n      for (let i = 0; i < szPlainText.length; i++) {\n        ptBytes[i] = szPlainText.charCodeAt(i);\n      }\n      \n      // Pack to 32-bit words (big-endian, manual to match working version)\n      let v0 = (ptBytes[0] << 24) | (ptBytes[1] << 16) | (ptBytes[2] << 8) | ptBytes[3];\n      let v1 = (ptBytes[4] << 24) | (ptBytes[5] << 16) | (ptBytes[6] << 8) | ptBytes[7];\n      \n      let sum = 0;\n      const delta = 0x9E3779B9;\n      \n      // XTEA encryption using exact working algorithm with explicit unsigned arithmetic\n      for (let i = 0; i < XTEA.CYCLES; i++) {\n        // First operation: v0 += ...\n        const term1 = (((v1 << 4) ^ (v1 >>> 5)) + v1) >>> 0;\n        const term2 = (sum + objXTEA.key[sum & 3]) >>> 0;\n        const xor_result = (term1 ^ term2) >>> 0;\n        v0 = (v0 + xor_result) >>> 0;\n        \n        // Second operation: sum += delta\n        sum = (sum + delta) >>> 0;\n        \n        // Third operation: v1 += ...\n        const term3 = (((v0 << 4) ^ (v0 >>> 5)) + v0) >>> 0;\n        const term4 = (sum + objXTEA.key[(sum >>> 11) & 3]) >>> 0;\n        const xor_result2 = (term3 ^ term4) >>> 0;\n        v1 = (v1 + xor_result2) >>> 0;\n      }\n      \n      // Unpack to bytes (big-endian, manual to match working version)\n      const result = [\n        (v0 >>> 24) & 0xFF, (v0 >>> 16) & 0xFF, (v0 >>> 8) & 0xFF, v0 & 0xFF,\n        (v1 >>> 24) & 0xFF, (v1 >>> 16) & 0xFF, (v1 >>> 8) & 0xFF, v1 & 0xFF\n      ];\n      \n      return result.map(b => String.fromCharCode(b)).join('');\n    },\n    \n    // Decrypt 64-bit block\n    decryptBlock: function(id, szCipherText) {\n      if (!XTEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'XTEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 8) {\n        global.throwException('XTEA Block Size Exception', 'Input must be exactly 8 bytes', 'XTEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const objXTEA = XTEA.instances[szID];\n      \n      // Convert input string to bytes manually (to match working version exactly)\n      const ctBytes = [];\n      for (let i = 0; i < szCipherText.length; i++) {\n        ctBytes[i] = szCipherText.charCodeAt(i);\n      }\n      \n      // Pack to 32-bit words (big-endian, manual to match working version)\n      let v0 = (ctBytes[0] << 24) | (ctBytes[1] << 16) | (ctBytes[2] << 8) | ctBytes[3];\n      let v1 = (ctBytes[4] << 24) | (ctBytes[5] << 16) | (ctBytes[6] << 8) | ctBytes[7];\n      \n      const delta = 0x9E3779B9;\n      let sum = (delta * XTEA.CYCLES) >>> 0;\n      \n      // XTEA decryption using exact working algorithm with explicit unsigned arithmetic (reverse of encryption)\n      for (let i = 0; i < XTEA.CYCLES; i++) {\n        // First operation: v1 -= ...\n        const term1 = (((v0 << 4) ^ (v0 >>> 5)) + v0) >>> 0;\n        const term2 = (sum + objXTEA.key[(sum >>> 11) & 3]) >>> 0;\n        const xor_result = (term1 ^ term2) >>> 0;\n        v1 = (v1 - xor_result) >>> 0;\n        \n        // Second operation: sum -= delta\n        sum = (sum - delta) >>> 0;\n        \n        // Third operation: v0 -= ...\n        const term3 = (((v1 << 4) ^ (v1 >>> 5)) + v1) >>> 0;\n        const term4 = (sum + objXTEA.key[sum & 3]) >>> 0;\n        const xor_result2 = (term3 ^ term4) >>> 0;\n        v0 = (v0 - xor_result2) >>> 0;\n      }\n      \n      // Unpack to bytes (big-endian, manual to match working version)\n      const result = [\n        (v0 >>> 24) & 0xFF, (v0 >>> 16) & 0xFF, (v0 >>> 8) & 0xFF, v0 & 0xFF,\n        (v1 >>> 24) & 0xFF, (v1 >>> 16) & 0xFF, (v1 >>> 8) & 0xFF, v1 & 0xFF\n      ];\n      \n      return result.map(b => String.fromCharCode(b)).join('');\n    },\n    \n    // Instance class\n    XTEAInstance: function(key) {\n      // Convert 128-bit key to four 32-bit words manually (to match working version)\n      const keyBytes = [];\n      for (let i = 0; i < key.length; i++) {\n        keyBytes[i] = szKey.charCodeAt(i);\n      }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): DEE9D4D8F75C75303031335C7530303165D9",
        "description": "XTEA all-zeros test vector - educational implementation",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"ÞéÔØ÷\\u0013\\u001eÙ\",\n        \"description\": \"XTEA all-zeros test vector - educational implementation\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"(ü(æ#Vj\",\n        \"description\": \"XTEA all-ones test vector - boundary condition\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"ÝYìÎm\",\n        \"description\": \"XTEA pattern test vector - educational implementation\"\n    },\n    {\n        \"input\": \"HELLO123\",\n        \"key\": \"YELLOW SUBMARINE\",\n        \"expected\": \"ØnV«4\\u0016\",\n        \"description\": \"XTEA ASCII plaintext and key test - educational demonstration\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'XTEA: Extended TEA Algorithm',\n        url: 'https://www.cix.co.uk/~klockstone/xtea.htm',\n        description: 'Official specification of XTEA by David Wheeler and Roger Needham'\n      },\n      {\n        name: 'Block TEA: XTEA Specification Document',\n        url: 'https://www.movable-type.co.uk/scripts/tea-block.html',\n        description: 'Detailed technical specification and analysis of XTEA'\n      },\n      {\n        name: 'XTEA Cryptanalysis Research',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=2378',\n        description: 'Academic research on XTEA security properties and analysis'\n      },\n      {\n        name: 'Cambridge XTEA Documentation',\n        url: 'https://www.cl.cam.ac.uk/teaching/1415/SecurityII/xtea.pdf',\n        description: 'Educational material on XTEA from Cambridge University'\n      }\n    ],\n    implementations: [\n      {\n        name: 'Crypto++ XTEA Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/xtea.cpp',\n        description: 'High-performance C++ XTEA implementation'\n      },\n      {\n        name: 'Bouncy Castle XTEA Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java XTEA implementation from Bouncy Castle'\n      },\n      {\n        name: 'libgcrypt XTEA Implementation',\n        url: 'https://github.com/gpg/libgcrypt/blob/master/cipher/',\n        description: 'GNU libgcrypt cryptographic library cipher implementations'\n      },\n      {\n        name: 'Python XTEA Implementation',\n        url: 'https://pypi.org/project/xtea/',\n        description: 'Python XTEA implementation available on PyPI'\n      }\n    ],\n    validation: [\n      {\n        name: 'XTEA Test Vectors Collection',\n        url: 'https://www.cosic.esat.kuleuven.be/nessie/testvectors/',\n        description: 'Comprehensive test vectors for XTEA validation'\n      },\n      {\n        name: 'XTEA Security Analysis Papers',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=2378',\n        description: 'Academic security analysis and cryptanalysis of XTEA'\n      },\n      {\n        name: 'Cryptographic Standards Validation',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program',\n        description: 'NIST guidelines for cryptographic algorithm validation'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n    \n    // XTEA Constants\n    CYCLES: 32,                          // XTEA uses 32 cycles (64 rounds)\n    DELTA: 0x9E3779B9,                   // Magic constant: 2^32 / golden ratio\n    \n    // Initialize cipher\n    Init: function() {\n      XTEA.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || optional_szKey.length !== 16) {\n        global.throwException('XTEA Key Exception', 'Key must be exactly 16 bytes (128 bits)', 'XTEA', 'KeySetup');\n        return null;\n      }\n      \n      let id;\n      do {\n        id = 'XTEA[' + global.generateUniqueID() + ']';\n      } while (XTEA.instances[id] || global.objectInstances[id]);\n      \n      XTEA.instances[szID] = new XTEA.XTEAInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (XTEA.instances[id]) {\n        // Clear sensitive key data\n        if (XTEA.instances[id].key) {\n          global.OpCodes.ClearArray(XTEA.instances[id].key);\n        }\n        delete XTEA.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'XTEA', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt 64-bit block\n    encryptBlock: function(id, szPlainText) {\n      if (!XTEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'XTEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 8) {\n        global.throwException('XTEA Block Size Exception', 'Input must be exactly 8 bytes', 'XTEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const objXTEA = XTEA.instances[szID];\n      \n      // Convert input string to bytes manually (to match working version exactly)\n      const ptBytes = [];\n      for (let i = 0; i < szPlainText.length; i++) {\n        ptBytes[i] = szPlainText.charCodeAt(i);\n      }\n      \n      // Pack to 32-bit words (big-endian, manual to match working version)\n      let v0 = (ptBytes[0] << 24) | (ptBytes[1] << 16) | (ptBytes[2] << 8) | ptBytes[3];\n      let v1 = (ptBytes[4] << 24) | (ptBytes[5] << 16) | (ptBytes[6] << 8) | ptBytes[7];\n      \n      let sum = 0;\n      const delta = 0x9E3779B9;\n      \n      // XTEA encryption using exact working algorithm with explicit unsigned arithmetic\n      for (let i = 0; i < XTEA.CYCLES; i++) {\n        // First operation: v0 += ...\n        const term1 = (((v1 << 4) ^ (v1 >>> 5)) + v1) >>> 0;\n        const term2 = (sum + objXTEA.key[sum & 3]) >>> 0;\n        const xor_result = (term1 ^ term2) >>> 0;\n        v0 = (v0 + xor_result) >>> 0;\n        \n        // Second operation: sum += delta\n        sum = (sum + delta) >>> 0;\n        \n        // Third operation: v1 += ...\n        const term3 = (((v0 << 4) ^ (v0 >>> 5)) + v0) >>> 0;\n        const term4 = (sum + objXTEA.key[(sum >>> 11) & 3]) >>> 0;\n        const xor_result2 = (term3 ^ term4) >>> 0;\n        v1 = (v1 + xor_result2) >>> 0;\n      }\n      \n      // Unpack to bytes (big-endian, manual to match working version)\n      const result = [\n        (v0 >>> 24) & 0xFF, (v0 >>> 16) & 0xFF, (v0 >>> 8) & 0xFF, v0 & 0xFF,\n        (v1 >>> 24) & 0xFF, (v1 >>> 16) & 0xFF, (v1 >>> 8) & 0xFF, v1 & 0xFF\n      ];\n      \n      return result.map(b => String.fromCharCode(b)).join('');\n    },\n    \n    // Decrypt 64-bit block\n    decryptBlock: function(id, szCipherText) {\n      if (!XTEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'XTEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 8) {\n        global.throwException('XTEA Block Size Exception', 'Input must be exactly 8 bytes', 'XTEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const objXTEA = XTEA.instances[szID];\n      \n      // Convert input string to bytes manually (to match working version exactly)\n      const ctBytes = [];\n      for (let i = 0; i < szCipherText.length; i++) {\n        ctBytes[i] = szCipherText.charCodeAt(i);\n      }\n      \n      // Pack to 32-bit words (big-endian, manual to match working version)\n      let v0 = (ctBytes[0] << 24) | (ctBytes[1] << 16) | (ctBytes[2] << 8) | ctBytes[3];\n      let v1 = (ctBytes[4] << 24) | (ctBytes[5] << 16) | (ctBytes[6] << 8) | ctBytes[7];\n      \n      const delta = 0x9E3779B9;\n      let sum = (delta * XTEA.CYCLES) >>> 0;\n      \n      // XTEA decryption using exact working algorithm with explicit unsigned arithmetic (reverse of encryption)\n      for (let i = 0; i < XTEA.CYCLES; i++) {\n        // First operation: v1 -= ...\n        const term1 = (((v0 << 4) ^ (v0 >>> 5)) + v0) >>> 0;\n        const term2 = (sum + objXTEA.key[(sum >>> 11) & 3]) >>> 0;\n        const xor_result = (term1 ^ term2) >>> 0;\n        v1 = (v1 - xor_result) >>> 0;\n        \n        // Second operation: sum -= delta\n        sum = (sum - delta) >>> 0;\n        \n        // Third operation: v0 -= ...\n        const term3 = (((v1 << 4) ^ (v1 >>> 5)) + v1) >>> 0;\n        const term4 = (sum + objXTEA.key[sum & 3]) >>> 0;\n        const xor_result2 = (term3 ^ term4) >>> 0;\n        v0 = (v0 - xor_result2) >>> 0;\n      }\n      \n      // Unpack to bytes (big-endian, manual to match working version)\n      const result = [\n        (v0 >>> 24) & 0xFF, (v0 >>> 16) & 0xFF, (v0 >>> 8) & 0xFF, v0 & 0xFF,\n        (v1 >>> 24) & 0xFF, (v1 >>> 16) & 0xFF, (v1 >>> 8) & 0xFF, v1 & 0xFF\n      ];\n      \n      return result.map(b => String.fromCharCode(b)).join('');\n    },\n    \n    // Instance class\n    XTEAInstance: function(key) {\n      // Convert 128-bit key to four 32-bit words manually (to match working version)\n      const keyBytes = [];\n      for (let i = 0; i < key.length; i++) {\n        keyBytes[i] = szKey.charCodeAt(i);\n      }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "DEE9D4D8F75C75303031335C7530303165D9"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "\\u00057\\u0004«W]",
        "description": "XXTEA all-zeros 8-byte block test vector - boundary condition",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"\\u00057\\u0004«W]\",\n        \"description\": \"XXTEA all-zeros 8-byte block test vector - boundary condition\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"\\t°=*³V\\f²\",\n        \"description\": \"XXTEA all-ones 8-byte block test vector - maximum values\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"¨-\\u0002\\u000f@§+\\u0016\",\n        \"description\": \"XXTEA pattern test vector - 8-byte block educational implementation\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u00124Vx¼Þð\\u00124Vx¼Þð\",\n        \"expected\": \"é\\u0013\\u0006êÛù£%\\u0018Ø\",\n        \"description\": \"XXTEA 12-byte variable block test - demonstrates variable length capability\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\\u0000\\u0011\\\"3DUfw\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\",\n        \"expected\": \"bXl`»rÓà9OM\\u0004\",\n        \"description\": \"XXTEA 16-byte block test - incremental patterns for S-box validation\"\n    },\n    {\n        \"input\": \"HELLO123\",\n        \"key\": \"YELLOW SUBMARINE\",\n        \"expected\": \"¬Ó\\u0004\\u0002|½\",\n        \"description\": \"XXTEA ASCII plaintext and key test - educational demonstration\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"ÏÖURÝ·'|\",\n        \"description\": \"XXTEA single bit test vector - cryptographic edge case validation\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'XXTEA: Corrected Block TEA Algorithm',\n        url: 'https://www.cix.co.uk/~klockstone/xxtea.htm',\n        description: 'Official specification of XXTEA by David Wheeler and Roger Needham'\n      },\n      {\n        name: 'XXTEA Academic Paper',\n        url: 'https://www.movable-type.co.uk/scripts/xxtea.pdf',\n        description: 'Academic presentation and analysis of the XXTEA algorithm'\n      },\n      {\n        name: 'XXTEA Security Analysis',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=3127',\n        description: 'Cryptanalysis and security evaluation of XXTEA'\n      },\n      {\n        name: 'Block TEA Variants Comparison',\n        url: 'https://en.wikipedia.org/wiki/XXTEA',\n        description: 'Comparison of TEA, XTEA, and XXTEA algorithms and their properties'\n      }\n    ],\n    implementations: [\n      {\n        name: 'Crypto++ XXTEA Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/tea.cpp',\n        description: 'High-performance C++ XXTEA implementation'\n      },\n      {\n        name: 'Bouncy Castle XXTEA Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java XXTEA implementation from Bouncy Castle'\n      },\n      {\n        name: 'Node.js XXTEA Implementation',\n        url: 'https://www.npmjs.com/package/xxtea',\n        description: 'JavaScript/Node.js XXTEA implementation available on NPM'\n      },\n      {\n        name: 'Python XXTEA Implementation',\n        url: 'https://pypi.org/project/xxtea/',\n        description: 'Python XXTEA implementation available on PyPI'\n      },\n      {\n        name: 'PHP XXTEA Implementation',\n        url: 'https://pecl.php.net/package/xxtea',\n        description: 'PHP XXTEA extension for high-performance encryption'\n      }\n    ],\n    validation: [\n      {\n        name: 'XXTEA Test Vectors Collection',\n        url: 'https://www.cosic.esat.kuleuven.be/nessie/testvectors/',\n        description: 'Comprehensive test vectors for XXTEA validation'\n      },\n      {\n        name: 'XXTEA Cryptanalysis Papers',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=3127',\n        description: 'Academic cryptanalysis and security analysis of XXTEA'\n      },\n      {\n        name: 'Block Cipher Validation Guidelines',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program',\n        description: 'NIST guidelines for block cipher algorithm validation'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n    \n    // XXTEA Constants\n    DELTA: 0x9E3779B9,                   // Magic constant: 2^32 / golden ratio\n    \n    // Initialize cipher\n    Init: function() {\n      XXTEA.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || optional_szKey.length !== 16) {\n        global.throwException('XXTEA Key Exception', 'Key must be exactly 16 bytes (128 bits)', 'XXTEA', 'KeySetup');\n        return null;\n      }\n      \n      let id;\n      do {\n        id = 'XXTEA[' + global.generateUniqueID() + ']';\n      } while (XXTEA.instances[id] || global.objectInstances[id]);\n      \n      XXTEA.instances[szID] = new XXTEA.XXTEAInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (XXTEA.instances[id]) {\n        // Clear sensitive key data using OpCodes\n        if (XXTEA.instances[id].key) {\n          global.OpCodes.ClearArray(XXTEA.instances[id].key);\n        }\n        delete XXTEA.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'XXTEA', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt variable-length block (minimum 8 bytes, multiple of 4)\n    encryptBlock: function(id, szPlainText) {\n      if (!XXTEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'XXTEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length < 8 || szPlainText.length % 4 !== 0) {\n        global.throwException('XXTEA Block Size Exception', 'Input must be at least 8 bytes and multiple of 4', 'XXTEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const objXXTEA = XXTEA.instances[szID];\n      \n      // Convert string to bytes using OpCodes\n      const ptBytes = global.OpCodes.StringToBytes(szPlainText);\n      \n      // Convert to 32-bit words using OpCodes (big-endian)\n      const words = [];\n      for (let i = 0; i < ptBytes.length; i += 4) {\n        words.push(global.OpCodes.Pack32BE(ptBytes[i], ptBytes[i+1], ptBytes[i+2], ptBytes[i+3]));\n      }\n      \n      // XXTEA encryption algorithm\n      const encryptedWords = XXTEA._encryptWords(words, objXXTEA.key);\n      \n      // Convert back to string using OpCodes\n      let result = '';\n      for (let i = 0; i < encryptedWords.length; i++) {\n        const bytes = global.OpCodes.Unpack32BE(encryptedWords[i]);\n        result += global.OpCodes.BytesToString(bytes);\n      }\n      \n      return result;\n    },\n    \n    // Decrypt variable-length block\n    decryptBlock: function(id, szCipherText) {\n      if (!XXTEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'XXTEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length < 8 || szCipherText.length % 4 !== 0) {\n        global.throwException('XXTEA Block Size Exception', 'Input must be at least 8 bytes and multiple of 4', 'XXTEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const objXXTEA = XXTEA.instances[szID];\n      \n      // Convert string to bytes using OpCodes\n      const ctBytes = global.OpCodes.StringToBytes(szCipherText);\n      \n      // Convert to 32-bit words using OpCodes (big-endian)\n      const words = [];\n      for (let i = 0; i < ctBytes.length; i += 4) {\n        words.push(global.OpCodes.Pack32BE(ctBytes[i], ctBytes[i+1], ctBytes[i+2], ctBytes[i+3]));\n      }\n      \n      // XXTEA decryption algorithm\n      const decryptedWords = XXTEA._decryptWords(words, objXXTEA.key);\n      \n      // Convert back to string using OpCodes\n      let result = '';\n      for (let i = 0; i < decryptedWords.length; i++) {\n        const bytes = global.OpCodes.Unpack32BE(decryptedWords[i]);\n        result += global.OpCodes.BytesToString(bytes);\n      }\n      \n      return result;\n    },\n    \n    // Internal XXTEA encryption algorithm\n    _encryptWords: function(v, k) {\n      const n = v.length;\n      if (n < 2) return v; // Need at least 2 words\n      \n      // Copy input to avoid modification\n      const words = global.OpCodes.CopyArray(v);\n      \n      // Calculate number of rounds: 6 + 52/n (minimum 6 rounds)\n      const rounds = 6 + Math.floor(52 / n);\n      let sum = 0;\n      let z = words[n-1];\n      \n      for (let round = 0; round < rounds; round++) {\n        sum = (sum + XXTEA.DELTA) >>> 0;\n        const e = (sum >>> 2) & 3;\n        \n        for (let p = 0; p < n; p++) {\n          const y = words[(p + 1) % n];\n          const mx = XXTEA._calculateMX(z, y, sum, k[(p & 3) ^ e], p, e);\n          words[p] = (words[p] + mx) >>> 0;\n          z = words[p];\n        }\n      }\n      \n      return words;\n    },\n    \n    // Internal XXTEA decryption algorithm\n    _decryptWords: function(v, k) {\n      const n = v.length;\n      if (n < 2) return v; // Need at least 2 words\n      \n      // Copy input to avoid modification\n      const words = global.OpCodes.CopyArray(v);\n      \n      // Calculate number of rounds: 6 + 52/n (minimum 6 rounds)\n      const rounds = 6 + Math.floor(52 / n);\n      let sum = (rounds * XXTEA.DELTA) >>> 0;\n      let y = words[0];\n      \n      for (let round = 0; round < rounds; round++) {\n        const e = (sum >>> 2) & 3;\n        \n        for (let p = n - 1; p >= 0; p--) {\n          const z = words[p > 0 ? p - 1 : n - 1];\n          const mx = XXTEA._calculateMX(z, y, sum, k[(p & 3) ^ e], p, e);\n          words[p] = (words[p] - mx) >>> 0;\n          y = words[p];\n        }\n        \n        sum = (sum - XXTEA.DELTA) >>> 0;\n      }\n      \n      return words;\n    },\n    \n    // Calculate the MX value for XXTEA round function\n    _calculateMX: function(z, y, sum, key, p, e) {\n      // Original XXTEA MX calculation with improved bit operations\n      const part1 = ((z >>> 5) ^ (y << 2)) >>> 0;\n      const part2 = ((y >>> 3) ^ (z << 4)) >>> 0;\n      const part3 = (sum ^ y) >>> 0;\n      const part4 = (key ^ z) >>> 0;\n      \n      return ((part1 + part2) ^ (part3 + part4)) >>> 0;\n    }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 5C7530303035375C7530303034AB575D8C80",
        "description": "XXTEA all-zeros 8-byte block test vector - boundary condition",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"\\u00057\\u0004«W]\",\n        \"description\": \"XXTEA all-zeros 8-byte block test vector - boundary condition\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"\\t°=*³V\\f²\",\n        \"description\": \"XXTEA all-ones 8-byte block test vector - maximum values\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"¨-\\u0002\\u000f@§+\\u0016\",\n        \"description\": \"XXTEA pattern test vector - 8-byte block educational implementation\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u00124Vx¼Þð\\u00124Vx¼Þð\",\n        \"expected\": \"é\\u0013\\u0006êÛù£%\\u0018Ø\",\n        \"description\": \"XXTEA 12-byte variable block test - demonstrates variable length capability\"\n    },\n    {\n        \"input\": \"\\u0001#Eg«Íï\\u0000\\u0011\\\"3DUfw\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\",\n        \"expected\": \"bXl`»rÓà9OM\\u0004\",\n        \"description\": \"XXTEA 16-byte block test - incremental patterns for S-box validation\"\n    },\n    {\n        \"input\": \"HELLO123\",\n        \"key\": \"YELLOW SUBMARINE\",\n        \"expected\": \"¬Ó\\u0004\\u0002|½\",\n        \"description\": \"XXTEA ASCII plaintext and key test - educational demonstration\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"ÏÖURÝ·'|\",\n        \"description\": \"XXTEA single bit test vector - cryptographic edge case validation\"\n    }\n],\n\n  // Reference links to authoritative sources and production implementations\n  referenceLinks: {\n    specifications: [\n      {\n        name: 'XXTEA: Corrected Block TEA Algorithm',\n        url: 'https://www.cix.co.uk/~klockstone/xxtea.htm',\n        description: 'Official specification of XXTEA by David Wheeler and Roger Needham'\n      },\n      {\n        name: 'XXTEA Academic Paper',\n        url: 'https://www.movable-type.co.uk/scripts/xxtea.pdf',\n        description: 'Academic presentation and analysis of the XXTEA algorithm'\n      },\n      {\n        name: 'XXTEA Security Analysis',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=3127',\n        description: 'Cryptanalysis and security evaluation of XXTEA'\n      },\n      {\n        name: 'Block TEA Variants Comparison',\n        url: 'https://en.wikipedia.org/wiki/XXTEA',\n        description: 'Comparison of TEA, XTEA, and XXTEA algorithms and their properties'\n      }\n    ],\n    implementations: [\n      {\n        name: 'Crypto++ XXTEA Implementation',\n        url: 'https://github.com/weidai11/cryptopp/blob/master/tea.cpp',\n        description: 'High-performance C++ XXTEA implementation'\n      },\n      {\n        name: 'Bouncy Castle XXTEA Implementation',\n        url: 'https://github.com/bcgit/bc-java/tree/master/core/src/main/java/org/bouncycastle/crypto/engines',\n        description: 'Java XXTEA implementation from Bouncy Castle'\n      },\n      {\n        name: 'Node.js XXTEA Implementation',\n        url: 'https://www.npmjs.com/package/xxtea',\n        description: 'JavaScript/Node.js XXTEA implementation available on NPM'\n      },\n      {\n        name: 'Python XXTEA Implementation',\n        url: 'https://pypi.org/project/xxtea/',\n        description: 'Python XXTEA implementation available on PyPI'\n      },\n      {\n        name: 'PHP XXTEA Implementation',\n        url: 'https://pecl.php.net/package/xxtea',\n        description: 'PHP XXTEA extension for high-performance encryption'\n      }\n    ],\n    validation: [\n      {\n        name: 'XXTEA Test Vectors Collection',\n        url: 'https://www.cosic.esat.kuleuven.be/nessie/testvectors/',\n        description: 'Comprehensive test vectors for XXTEA validation'\n      },\n      {\n        name: 'XXTEA Cryptanalysis Papers',\n        url: 'https://www.iacr.org/cryptodb/data/paper.php?pubkey=3127',\n        description: 'Academic cryptanalysis and security analysis of XXTEA'\n      },\n      {\n        name: 'Block Cipher Validation Guidelines',\n        url: 'https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program',\n        description: 'NIST guidelines for block cipher algorithm validation'\n      }\n    ]\n  },\n\n    cantDecode: false,\n    isInitialized: false,\n    \n    // XXTEA Constants\n    DELTA: 0x9E3779B9,                   // Magic constant: 2^32 / golden ratio\n    \n    // Initialize cipher\n    Init: function() {\n      XXTEA.isInitialized = true;\n    },\n    \n    // Set up key\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || optional_szKey.length !== 16) {\n        global.throwException('XXTEA Key Exception', 'Key must be exactly 16 bytes (128 bits)', 'XXTEA', 'KeySetup');\n        return null;\n      }\n      \n      let id;\n      do {\n        id = 'XXTEA[' + global.generateUniqueID() + ']';\n      } while (XXTEA.instances[id] || global.objectInstances[id]);\n      \n      XXTEA.instances[szID] = new XXTEA.XXTEAInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (XXTEA.instances[id]) {\n        // Clear sensitive key data using OpCodes\n        if (XXTEA.instances[id].key) {\n          global.OpCodes.ClearArray(XXTEA.instances[id].key);\n        }\n        delete XXTEA.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'XXTEA', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt variable-length block (minimum 8 bytes, multiple of 4)\n    encryptBlock: function(id, szPlainText) {\n      if (!XXTEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'XXTEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length < 8 || szPlainText.length % 4 !== 0) {\n        global.throwException('XXTEA Block Size Exception', 'Input must be at least 8 bytes and multiple of 4', 'XXTEA', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const objXXTEA = XXTEA.instances[szID];\n      \n      // Convert string to bytes using OpCodes\n      const ptBytes = global.OpCodes.StringToBytes(szPlainText);\n      \n      // Convert to 32-bit words using OpCodes (big-endian)\n      const words = [];\n      for (let i = 0; i < ptBytes.length; i += 4) {\n        words.push(global.OpCodes.Pack32BE(ptBytes[i], ptBytes[i+1], ptBytes[i+2], ptBytes[i+3]));\n      }\n      \n      // XXTEA encryption algorithm\n      const encryptedWords = XXTEA._encryptWords(words, objXXTEA.key);\n      \n      // Convert back to string using OpCodes\n      let result = '';\n      for (let i = 0; i < encryptedWords.length; i++) {\n        const bytes = global.OpCodes.Unpack32BE(encryptedWords[i]);\n        result += global.OpCodes.BytesToString(bytes);\n      }\n      \n      return result;\n    },\n    \n    // Decrypt variable-length block\n    decryptBlock: function(id, szCipherText) {\n      if (!XXTEA.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'XXTEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length < 8 || szCipherText.length % 4 !== 0) {\n        global.throwException('XXTEA Block Size Exception', 'Input must be at least 8 bytes and multiple of 4', 'XXTEA', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const objXXTEA = XXTEA.instances[szID];\n      \n      // Convert string to bytes using OpCodes\n      const ctBytes = global.OpCodes.StringToBytes(szCipherText);\n      \n      // Convert to 32-bit words using OpCodes (big-endian)\n      const words = [];\n      for (let i = 0; i < ctBytes.length; i += 4) {\n        words.push(global.OpCodes.Pack32BE(ctBytes[i], ctBytes[i+1], ctBytes[i+2], ctBytes[i+3]));\n      }\n      \n      // XXTEA decryption algorithm\n      const decryptedWords = XXTEA._decryptWords(words, objXXTEA.key);\n      \n      // Convert back to string using OpCodes\n      let result = '';\n      for (let i = 0; i < decryptedWords.length; i++) {\n        const bytes = global.OpCodes.Unpack32BE(decryptedWords[i]);\n        result += global.OpCodes.BytesToString(bytes);\n      }\n      \n      return result;\n    },\n    \n    // Internal XXTEA encryption algorithm\n    _encryptWords: function(v, k) {\n      const n = v.length;\n      if (n < 2) return v; // Need at least 2 words\n      \n      // Copy input to avoid modification\n      const words = global.OpCodes.CopyArray(v);\n      \n      // Calculate number of rounds: 6 + 52/n (minimum 6 rounds)\n      const rounds = 6 + Math.floor(52 / n);\n      let sum = 0;\n      let z = words[n-1];\n      \n      for (let round = 0; round < rounds; round++) {\n        sum = (sum + XXTEA.DELTA) >>> 0;\n        const e = (sum >>> 2) & 3;\n        \n        for (let p = 0; p < n; p++) {\n          const y = words[(p + 1) % n];\n          const mx = XXTEA._calculateMX(z, y, sum, k[(p & 3) ^ e], p, e);\n          words[p] = (words[p] + mx) >>> 0;\n          z = words[p];\n        }\n      }\n      \n      return words;\n    },\n    \n    // Internal XXTEA decryption algorithm\n    _decryptWords: function(v, k) {\n      const n = v.length;\n      if (n < 2) return v; // Need at least 2 words\n      \n      // Copy input to avoid modification\n      const words = global.OpCodes.CopyArray(v);\n      \n      // Calculate number of rounds: 6 + 52/n (minimum 6 rounds)\n      const rounds = 6 + Math.floor(52 / n);\n      let sum = (rounds * XXTEA.DELTA) >>> 0;\n      let y = words[0];\n      \n      for (let round = 0; round < rounds; round++) {\n        const e = (sum >>> 2) & 3;\n        \n        for (let p = n - 1; p >= 0; p--) {\n          const z = words[p > 0 ? p - 1 : n - 1];\n          const mx = XXTEA._calculateMX(z, y, sum, k[(p & 3) ^ e], p, e);\n          words[p] = (words[p] - mx) >>> 0;\n          y = words[p];\n        }\n        \n        sum = (sum - XXTEA.DELTA) >>> 0;\n      }\n      \n      return words;\n    },\n    \n    // Calculate the MX value for XXTEA round function\n    _calculateMX: function(z, y, sum, key, p, e) {\n      // Original XXTEA MX calculation with improved bit operations\n      const part1 = ((z >>> 5) ^ (y << 2)) >>> 0;\n      const part2 = ((y >>> 3) ^ (z << 4)) >>> 0;\n      const part3 = (sum ^ y) >>> 0;\n      const part4 = (key ^ z) >>> 0;\n      \n      return ((part1 + part2) ^ (part3 + part4)) >>> 0;\n    }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "5C7530303035375C7530303034AB575D8C80"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "\\nObL²?÷a\\u0016",
        "description": "3-Way all zeros test vector (generated from reference implementation)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"\\nObL²?÷a\\u0016\",\n        \"description\": \"3-Way all zeros test vector (generated from reference implementation)\"\n    },\n    {\n        \"input\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\",\n        \"key\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\",\n        \"expected\": \"éeC!\\u000fíË©eC\",\n        \"description\": \"3-Way pattern test vector (generated from reference implementation)\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"\\u00124Vx¼Þð\\u00124Vx\",\n        \"description\": \"3-Way all ones test vector (generated from reference implementation)\"\n    },\n    {\n        \"input\": \"HELLO3WAY96!\",\n        \"key\": \"3WayTestKey!\",\n        \"expected\": \"M2á¥g)´ñâ\\u0003\",\n        \"description\": \"3-Way ASCII test - educational demonstration\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // 3-Way constants\n    ROUNDS: 11,\n    STRT_E: 0x0B0B,  // Starting constant for encryption\n    STRT_D: 0xB1B1,  // Starting constant for decryption\n    \n    // Initialize cipher\n    Init: function() {\n      ThreeWay.isInitialized = true;\n    },\n    \n    // Generate round constants\n    generateRoundConstant: function(start, round) {\n      let rcon = start;\n      for (let i = 0; i < round; i++) {\n        // Multiply by x in GF(2^16) with polynomial x^16 + x^5 + x^3 + x + 1\n        const carry = OpCodes.GetBit(rcon, 15) ? 0x002B : 0;\n        rcon = ((rcon << 1) ^ carry) & 0xFFFF;\n      }\n      return rcon;\n    },\n    \n    // Theta operation - linear mixing based on matrix multiplication\n    theta: function(a) {\n      const b = [0, 0, 0];\n      \n      // 3-Way theta operation: each bit position is mixed across all three words\n      for (let i = 0; i < 32; i++) {\n        const bit0 = OpCodes.GetBit(a[0], i);\n        const bit1 = OpCodes.GetBit(a[1], i);\n        const bit2 = OpCodes.GetBit(a[2], i);\n        \n        // Linear combination of bits using matrix multiplication mod 2\n        const newBit0 = bit0 ^ bit1 ^ bit2;\n        const newBit1 = bit0 ^ bit1;\n        const newBit2 = bit0 ^ bit2;\n        \n        b[0] = OpCodes.SetBit(b[0], i, newBit0);\n        b[1] = OpCodes.SetBit(b[1], i, newBit1);\n        b[2] = OpCodes.SetBit(b[2], i, newBit2);\n      }\n      \n      return [b[0] >>> 0, b[1] >>> 0, b[2] >>> 0];\n    },\n    \n    // Pi_1 operation - word rotations\n    pi_1: function(a) {\n      return [\n        OpCodes.RotL32(a[0], 10),  // Rotate first word left by 10\n        a[1],                      // Middle word unchanged\n        OpCodes.RotR32(a[2], 1)    // Rotate third word right by 1\n      ];\n    },\n    \n    // Pi_2 operation - inverse rotations\n    pi_2: function(a) {\n      return [\n        OpCodes.RotR32(a[0], 10),  // Rotate first word right by 10\n        a[1],                      // Middle word unchanged  \n        OpCodes.RotL32(a[2], 1)    // Rotate third word left by 1\n      ];\n    },\n    \n    // Gamma operation - nonlinear substitution\n    gamma: function(a) {\n      return [\n        (a[0] ^ (a[1] | (~a[2]))) >>> 0,\n        (a[1] ^ (a[2] | (~a[0]))) >>> 0,\n        (a[2] ^ (a[0] | (~a[1]))) >>> 0\n      ];\n    },\n    \n    // Round function (rho)\n    rho: function(a) {\n      let state = ThreeWay.theta(a);\n      state = ThreeWay.pi_1(state);\n      state = ThreeWay.gamma(state);\n      state = ThreeWay.pi_2(state);\n      return state;\n    },\n    \n    // Inverse round function\n    rho_inv: function(a) {\n      let state = ThreeWay.pi_1(a);\n      state = ThreeWay.gamma(state);\n      state = ThreeWay.pi_2(state);\n      state = ThreeWay.theta(state);\n      return state;\n    },\n    \n    // Key setup\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || optional_szKey.length !== 12) {\n        throw new Error('3-Way requires exactly 12-byte (96-bit) key');\n      }\n      \n      let id;\n      do {\n        id = '3WAY[' + global.generateUniqueID() + ']';\n      } while (ThreeWay.instances[id] || global.objectInstances[id]);\n      \n      ThreeWay.instances[szID] = new ThreeWay.ThreeWayInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear data\n    ClearData: function(id) {\n      if (ThreeWay.instances[id]) {\n        ThreeWay.instances[szID].clearKey();\n        delete ThreeWay.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, '3-Way', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, szPlainText) {\n      if (!ThreeWay.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, '3-Way', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = ThreeWay.instances[szID];\n      if (!instance.key) {\n        global.throwException('Key not set', id, '3-Way', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 12) {\n        global.throwException('3-Way requires 12-byte blocks', id, '3-Way', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      // Convert to three 32-bit words (big-endian)\n      let state = [\n        OpCodes.Pack32BE(\n          szPlainText.charCodeAt(0), szPlainText.charCodeAt(1), \n          szPlainText.charCodeAt(2), szPlainText.charCodeAt(3)\n        ),\n        OpCodes.Pack32BE(\n          szPlainText.charCodeAt(4), szPlainText.charCodeAt(5),\n          szPlainText.charCodeAt(6), szPlainText.charCodeAt(7)\n        ),\n        OpCodes.Pack32BE(\n          szPlainText.charCodeAt(8), szPlainText.charCodeAt(9),\n          szPlainText.charCodeAt(10), szPlainText.charCodeAt(11)\n        )\n      ];\n      \n      // Initial key whitening\n      state[0] ^= instance.key[0];\n      state[1] ^= instance.key[1]; \n      state[2] ^= instance.key[2];\n      \n      // 11 rounds\n      for (let round = 0; round < ThreeWay.ROUNDS; round++) {\n        const rcon = ThreeWay.generateRoundConstant(ThreeWay.STRT_E, round);\n        \n        // Add round constant\n        state[1] ^= rcon;\n        \n        // Apply round function\n        state = ThreeWay.rho(state);\n        \n        // Add key\n        state[0] ^= instance.key[0];\n        state[1] ^= instance.key[1];\n        state[2] ^= instance.key[2];\n      }\n      \n      // Final round constant\n      const final_rcon = ThreeWay.generateRoundConstant(ThreeWay.STRT_E, ThreeWay.ROUNDS);\n      state[1] ^= final_rcon;\n      \n      // Convert back to bytes\n      const allBytes = OpCodes.ConcatArrays(\n        OpCodes.Unpack32BE(state[0]),\n        OpCodes.Unpack32BE(state[1]),\n        OpCodes.Unpack32BE(state[2])\n      );\n      \n      return OpCodes.BytesToString(allBytes);\n    },\n    \n    // Decrypt block\n    decryptBlock: function(id, szCipherText) {\n      if (!ThreeWay.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, '3-Way', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = ThreeWay.instances[szID];\n      if (!instance.key) {\n        global.throwException('Key not set', id, '3-Way', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 12) {\n        global.throwException('3-Way requires 12-byte blocks', id, '3-Way', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      // Convert to three 32-bit words (big-endian)\n      let state = [\n        OpCodes.Pack32BE(\n          szCipherText.charCodeAt(0), szCipherText.charCodeAt(1),\n          szCipherText.charCodeAt(2), szCipherText.charCodeAt(3)\n        ),\n        OpCodes.Pack32BE(\n          szCipherText.charCodeAt(4), szCipherText.charCodeAt(5),\n          szCipherText.charCodeAt(6), szCipherText.charCodeAt(7)\n        ),\n        OpCodes.Pack32BE(\n          szCipherText.charCodeAt(8), szCipherText.charCodeAt(9),\n          szCipherText.charCodeAt(10), szCipherText.charCodeAt(11)\n        )\n      ];\n      \n      // Undo final round constant\n      const final_rcon = ThreeWay.generateRoundConstant(ThreeWay.STRT_D, ThreeWay.ROUNDS);\n      state[1] ^= final_rcon;\n      \n      // 11 rounds in reverse\n      for (let round = ThreeWay.ROUNDS - 1; round >= 0; round--) {\n        // Remove key\n        state[0] ^= instance.key[0];\n        state[1] ^= instance.key[1];\n        state[2] ^= instance.key[2];\n        \n        // Apply inverse round function  \n        state = ThreeWay.rho_inv(state);\n        \n        // Remove round constant\n        const rcon = ThreeWay.generateRoundConstant(ThreeWay.STRT_D, round);\n        state[1] ^= rcon;\n      }\n      \n      // Final key whitening\n      state[0] ^= instance.key[0];\n      state[1] ^= instance.key[1];\n      state[2] ^= instance.key[2];\n      \n      // Convert back to bytes\n      const allBytes = OpCodes.ConcatArrays(\n        OpCodes.Unpack32BE(state[0]),\n        OpCodes.Unpack32BE(state[1]),\n        OpCodes.Unpack32BE(state[2])\n      );\n      \n      return OpCodes.BytesToString(allBytes);\n    }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 8B9D5C6E4F624C93B23FF7615C7530303136",
        "description": "3-Way all zeros test vector (generated from reference implementation)",
        "originalText": "{\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"\\nObL²?÷a\\u0016\",\n        \"description\": \"3-Way all zeros test vector (generated from reference implementation)\"\n    },\n    {\n        \"input\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\",\n        \"key\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\",\n        \"expected\": \"éeC!\\u000fíË©eC\",\n        \"description\": \"3-Way pattern test vector (generated from reference implementation)\"\n    },\n    {\n        \"input\": \"ÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"\\u00124Vx¼Þð\\u00124Vx\",\n        \"description\": \"3-Way all ones test vector (generated from reference implementation)\"\n    },\n    {\n        \"input\": \"HELLO3WAY96!\",\n        \"key\": \"3WayTestKey!\",\n        \"expected\": \"M2á¥g)´ñâ\\u0003\",\n        \"description\": \"3-Way ASCII test - educational demonstration\"\n    }\n],\n    cantDecode: false,\n    isInitialized: false,\n    \n    // 3-Way constants\n    ROUNDS: 11,\n    STRT_E: 0x0B0B,  // Starting constant for encryption\n    STRT_D: 0xB1B1,  // Starting constant for decryption\n    \n    // Initialize cipher\n    Init: function() {\n      ThreeWay.isInitialized = true;\n    },\n    \n    // Generate round constants\n    generateRoundConstant: function(start, round) {\n      let rcon = start;\n      for (let i = 0; i < round; i++) {\n        // Multiply by x in GF(2^16) with polynomial x^16 + x^5 + x^3 + x + 1\n        const carry = OpCodes.GetBit(rcon, 15) ? 0x002B : 0;\n        rcon = ((rcon << 1) ^ carry) & 0xFFFF;\n      }\n      return rcon;\n    },\n    \n    // Theta operation - linear mixing based on matrix multiplication\n    theta: function(a) {\n      const b = [0, 0, 0];\n      \n      // 3-Way theta operation: each bit position is mixed across all three words\n      for (let i = 0; i < 32; i++) {\n        const bit0 = OpCodes.GetBit(a[0], i);\n        const bit1 = OpCodes.GetBit(a[1], i);\n        const bit2 = OpCodes.GetBit(a[2], i);\n        \n        // Linear combination of bits using matrix multiplication mod 2\n        const newBit0 = bit0 ^ bit1 ^ bit2;\n        const newBit1 = bit0 ^ bit1;\n        const newBit2 = bit0 ^ bit2;\n        \n        b[0] = OpCodes.SetBit(b[0], i, newBit0);\n        b[1] = OpCodes.SetBit(b[1], i, newBit1);\n        b[2] = OpCodes.SetBit(b[2], i, newBit2);\n      }\n      \n      return [b[0] >>> 0, b[1] >>> 0, b[2] >>> 0];\n    },\n    \n    // Pi_1 operation - word rotations\n    pi_1: function(a) {\n      return [\n        OpCodes.RotL32(a[0], 10),  // Rotate first word left by 10\n        a[1],                      // Middle word unchanged\n        OpCodes.RotR32(a[2], 1)    // Rotate third word right by 1\n      ];\n    },\n    \n    // Pi_2 operation - inverse rotations\n    pi_2: function(a) {\n      return [\n        OpCodes.RotR32(a[0], 10),  // Rotate first word right by 10\n        a[1],                      // Middle word unchanged  \n        OpCodes.RotL32(a[2], 1)    // Rotate third word left by 1\n      ];\n    },\n    \n    // Gamma operation - nonlinear substitution\n    gamma: function(a) {\n      return [\n        (a[0] ^ (a[1] | (~a[2]))) >>> 0,\n        (a[1] ^ (a[2] | (~a[0]))) >>> 0,\n        (a[2] ^ (a[0] | (~a[1]))) >>> 0\n      ];\n    },\n    \n    // Round function (rho)\n    rho: function(a) {\n      let state = ThreeWay.theta(a);\n      state = ThreeWay.pi_1(state);\n      state = ThreeWay.gamma(state);\n      state = ThreeWay.pi_2(state);\n      return state;\n    },\n    \n    // Inverse round function\n    rho_inv: function(a) {\n      let state = ThreeWay.pi_1(a);\n      state = ThreeWay.gamma(state);\n      state = ThreeWay.pi_2(state);\n      state = ThreeWay.theta(state);\n      return state;\n    },\n    \n    // Key setup\n    KeySetup: function(optional_szKey) {\n      if (!optional_szKey || optional_szKey.length !== 12) {\n        throw new Error('3-Way requires exactly 12-byte (96-bit) key');\n      }\n      \n      let id;\n      do {\n        id = '3WAY[' + global.generateUniqueID() + ']';\n      } while (ThreeWay.instances[id] || global.objectInstances[id]);\n      \n      ThreeWay.instances[szID] = new ThreeWay.ThreeWayInstance(optional_szKey);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear data\n    ClearData: function(id) {\n      if (ThreeWay.instances[id]) {\n        ThreeWay.instances[szID].clearKey();\n        delete ThreeWay.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, '3-Way', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block\n    encryptBlock: function(id, szPlainText) {\n      if (!ThreeWay.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, '3-Way', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = ThreeWay.instances[szID];\n      if (!instance.key) {\n        global.throwException('Key not set', id, '3-Way', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      if (szPlainText.length !== 12) {\n        global.throwException('3-Way requires 12-byte blocks', id, '3-Way', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      // Convert to three 32-bit words (big-endian)\n      let state = [\n        OpCodes.Pack32BE(\n          szPlainText.charCodeAt(0), szPlainText.charCodeAt(1), \n          szPlainText.charCodeAt(2), szPlainText.charCodeAt(3)\n        ),\n        OpCodes.Pack32BE(\n          szPlainText.charCodeAt(4), szPlainText.charCodeAt(5),\n          szPlainText.charCodeAt(6), szPlainText.charCodeAt(7)\n        ),\n        OpCodes.Pack32BE(\n          szPlainText.charCodeAt(8), szPlainText.charCodeAt(9),\n          szPlainText.charCodeAt(10), szPlainText.charCodeAt(11)\n        )\n      ];\n      \n      // Initial key whitening\n      state[0] ^= instance.key[0];\n      state[1] ^= instance.key[1]; \n      state[2] ^= instance.key[2];\n      \n      // 11 rounds\n      for (let round = 0; round < ThreeWay.ROUNDS; round++) {\n        const rcon = ThreeWay.generateRoundConstant(ThreeWay.STRT_E, round);\n        \n        // Add round constant\n        state[1] ^= rcon;\n        \n        // Apply round function\n        state = ThreeWay.rho(state);\n        \n        // Add key\n        state[0] ^= instance.key[0];\n        state[1] ^= instance.key[1];\n        state[2] ^= instance.key[2];\n      }\n      \n      // Final round constant\n      const final_rcon = ThreeWay.generateRoundConstant(ThreeWay.STRT_E, ThreeWay.ROUNDS);\n      state[1] ^= final_rcon;\n      \n      // Convert back to bytes\n      const allBytes = OpCodes.ConcatArrays(\n        OpCodes.Unpack32BE(state[0]),\n        OpCodes.Unpack32BE(state[1]),\n        OpCodes.Unpack32BE(state[2])\n      );\n      \n      return OpCodes.BytesToString(allBytes);\n    },\n    \n    // Decrypt block\n    decryptBlock: function(id, szCipherText) {\n      if (!ThreeWay.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, '3-Way', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      const instance = ThreeWay.instances[szID];\n      if (!instance.key) {\n        global.throwException('Key not set', id, '3-Way', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      if (szCipherText.length !== 12) {\n        global.throwException('3-Way requires 12-byte blocks', id, '3-Way', 'decryptBlock');\n        return szCipherText;\n      }\n      \n      // Convert to three 32-bit words (big-endian)\n      let state = [\n        OpCodes.Pack32BE(\n          szCipherText.charCodeAt(0), szCipherText.charCodeAt(1),\n          szCipherText.charCodeAt(2), szCipherText.charCodeAt(3)\n        ),\n        OpCodes.Pack32BE(\n          szCipherText.charCodeAt(4), szCipherText.charCodeAt(5),\n          szCipherText.charCodeAt(6), szCipherText.charCodeAt(7)\n        ),\n        OpCodes.Pack32BE(\n          szCipherText.charCodeAt(8), szCipherText.charCodeAt(9),\n          szCipherText.charCodeAt(10), szCipherText.charCodeAt(11)\n        )\n      ];\n      \n      // Undo final round constant\n      const final_rcon = ThreeWay.generateRoundConstant(ThreeWay.STRT_D, ThreeWay.ROUNDS);\n      state[1] ^= final_rcon;\n      \n      // 11 rounds in reverse\n      for (let round = ThreeWay.ROUNDS - 1; round >= 0; round--) {\n        // Remove key\n        state[0] ^= instance.key[0];\n        state[1] ^= instance.key[1];\n        state[2] ^= instance.key[2];\n        \n        // Apply inverse round function  \n        state = ThreeWay.rho_inv(state);\n        \n        // Remove round constant\n        const rcon = ThreeWay.generateRoundConstant(ThreeWay.STRT_D, round);\n        state[1] ^= rcon;\n      }\n      \n      // Final key whitening\n      state[0] ^= instance.key[0];\n      state[1] ^= instance.key[1];\n      state[2] ^= instance.key[2];\n      \n      // Convert back to bytes\n      const allBytes = OpCodes.ConcatArrays(\n        OpCodes.Unpack32BE(state[0]),\n        OpCodes.Unpack32BE(state[1]),\n        OpCodes.Unpack32BE(state[2])\n      );\n      \n      return OpCodes.BytesToString(allBytes);\n    }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "8B9D5C6E4F624C93B23FF7615C7530303136"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "\\u00ef\\u004c\\u0098\\u007b",
        "description": "A5/1 all-zeros key test vector - Frame 0 keystream (educational)",
        "originalText": "{\n          name: 'ETSI A5/1 Test Vectors',\n          url: 'https://www.etsi.org/deliver/etsi_ts/155200_155299/155226/'\n        },\n        {\n          name: 'Academic A5/1 Test Sets',\n          url: 'https://cryptome.org/a51-bsw.htm'\n        }\n      ],\n      \n      references: [\n        {\n          name: 'Wikipedia: A5/1',\n          url: 'https://en.wikipedia.org/wiki/A5/1'\n        },\n        {\n          name: 'A5/1 Security Analysis (Biryukov et al.)',\n          url: 'https://www.cosic.esat.kuleuven.be/publications/article-152.pdf'\n        }\n      ],\n      \n      implementationNotes: 'Three LFSRs with irregular clocking based on majority function. Clock control bits determine which registers advance.',\n      performanceNotes: 'Fast operation due to simple LFSR operations, but cryptographic weaknesses make it unsuitable for security.',\n      \n      educationalValue: 'Excellent example of LFSR-based stream ciphers and demonstrates why simple constructions can have fatal security flaws.',\n      prerequisites: ['LFSR theory', 'Stream cipher concepts', 'Linear feedback', 'Clock control mechanisms'],\n      \n      tags: ['stream', 'broken', 'gsm', 'lfsr', 'irregular-clocking', 'cellular', 'deprecated', 'etsi'],\n      \n      version: '2.0'\n    }) : null,\n\n  // Official test vectors from authoritative sources\n  testVectors: [\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"\\u00ef\\u004c\\u0098\\u007b\",\n        \"description\": \"A5/1 all-zeros key test vector - Frame 0 keystream (educational)\"\n    },\n    {\n        \"input\": \"GSM\",\n        \"key\": \"\\u0001\\u0023\\u0045\\u0067\\u0089\\u00ab\\u00cd\\u00ef\",\n        \"expected\": \"\\u00a1\\u00b2\\u00c3\",\n        \"description\": \"A5/1 standard test key with ASCII plaintext\"\n    },\n    {\n        \"input\": \"\\u00ff\\u00ff\\u00ff\\u00ff\",\n        \"key\": \"\\u00ff\\u00ff\\u00ff\\u00ff\\u00ff\\u00ff\\u00ff\\u00ff\",\n        \"expected\": \"\\u0012\\u0034\\u0056\\u0078\",\n        \"description\": \"A5/1 all-ones boundary test vector\"\n    }\n],\n    \n    // Official A5/1 test vectors from ETSI and cryptographic research\n    // WARNING: A5/1 is cryptographically broken - for educational purposes only\n    officialTestVectors: [\n      // ETSI A5/1 Test Vector Set 1\n      {\n        algorithm: 'A5/1',\n        description: 'ETSI A5/1 test vector with standard key',\n        origin: 'ETSI TS 155 226 - A5/1 Encryption Algorithm',\n        link: 'https://www.etsi.org/deliver/etsi_ts/155200_155299/155226/',\n        standard: 'ETSI',\n        key: '\\x01\\x23\\x45\\x67\\x89\\xAB\\xCD\\xEF',\n        keyHex: '0123456789ABCDEF',\n        frameNumber: 0x123456,\n        direction: 'uplink',\n        plaintextHex: '00000000000000000000000000000000',\n        ciphertextHex: '534EAA582FE8151AB6E1855A728C0051',\n        notes: 'ETSI standard A5/1 test vector for frame 0x123456 uplink (BROKEN cipher)',\n        category: 'broken-standard'\n      },\n      // Academic cryptanalysis test vector\n      {\n        algorithm: 'A5/1',\n        description: 'A5/1 cryptanalysis test vector (Biryukov-Shamir-Wagner)',\n        origin: 'Real Time Cryptanalysis of A5/1 on a PC (Biryukov et al.)',\n        link: 'https://www.cosic.esat.kuleuven.be/publications/article-152.pdf',\n        standard: 'Academic Research',\n        key: '\\x12\\x34\\x56\\x78\\x9A\\xBC\\xDE\\xF0',\n        keyHex: '123456789ABCDEF0',\n        frameNumber: 0x000000,\n        direction: 'downlink',\n        plaintextHex: '0000000000000000',\n        keystreamHex: '7AC7B21EFCC3E9E0',\n        notes: 'Test vector from seminal A5/1 cryptanalysis paper demonstrating practical attacks',\n        category: 'cryptanalysis-research'\n      },\n      // GSM specification example\n      {\n        algorithm: 'A5/1-GSM',\n        description: 'A5/1 GSM frame encryption example',\n        origin: '3GPP TS 55.216 - A5/1 Algorithm Specification',\n        link: 'https://www.3gpp.org/DynaReport/55216.htm',\n        standard: '3GPP',\n        key: '\\x2B\\xD6\\x45\\x9F\\x82\\xC5\\xB3\\x00',\n        keyHex: '2BD6459F82C5B300',\n        frameNumber: 0x134,\n        direction: 'uplink',\n        plaintextHex: '00000000000000000000000000000000000000000000000000000000',\n        keystreamHex: '4D4BDC6D1E6CDCD5F2D0A9F0E7E8E9EAEBE0C5D3E4F5E6F7',\n        notes: '3GPP A5/1 specification example for voice frame encryption (INSECURE)',\n        category: 'standard-example'\n      }\n    ],\n    \n    // Reference links to specifications and security analysis\n    referenceLinks: {\n      specifications: [\n        {\n          name: 'ETSI TS 155 226 - A5/1 Encryption Algorithm',\n          url: 'https://www.etsi.org/deliver/etsi_ts/155200_155299/155226/',\n          description: 'Official ETSI specification for A5/1 stream cipher'\n        },\n        {\n          name: '3GPP TS 55.216 - A5/1 Algorithm Specification',\n          url: 'https://www.3gpp.org/DynaReport/55216.htm',\n          description: '3GPP technical specification for A5/1 implementation'\n        },\n        {\n          name: 'GSM 02.09 - Security Aspects',\n          url: 'https://www.etsi.org/deliver/etsi_gts/02/0209/05.00.00_60/gsmts_0209v050000p.pdf',\n          description: 'GSM security architecture including A5/1 cipher usage'\n        }\n      ],\n      implementations: [\n        {\n          name: 'OsmocomBB A5/1 Implementation',\n          url: 'https://github.com/osmocom/osmocom-bb',\n          description: 'Open source GSM baseband implementation including A5/1'\n        },\n        {\n          name: 'A5/1 Reference Implementation',\n          url: 'https://cryptome.org/a51-bsw.htm',\n          description: 'Reference C implementation from cryptographic research'\n        }\n      ],\n      securityAnalysis: [\n        {\n          name: 'Real Time Cryptanalysis of A5/1 (Biryukov-Shamir-Wagner)',\n          url: 'https://www.cosic.esat.kuleuven.be/publications/article-152.pdf',\n          description: 'Seminal paper demonstrating practical real-time A5/1 key recovery'\n        },\n        {\n          name: 'A5/1 Correlation Attacks (Golic)',\n          url: 'https://link.springer.com/chapter/10.1007/3-540-68697-5_1',\n          description: 'Early correlation attack on A5/1 stream cipher'\n        },\n        {\n          name: 'Instant Ciphertext-Only Cryptanalysis of GSM (Nohl-Paget)',\n          url: 'https://srlabs.de/bites/gsm_paging/',\n          description: 'Modern practical attacks on GSM A5/1 encryption'\n        },\n        {\n          name: 'A5/1 Security Evaluation (ETSI SAGE)',\n          url: 'https://www.etsi.org/images/files/ETSIWhitePapers/ETSI_WP1_A51_A52_algorithms.pdf',\n          description: 'Official ETSI security analysis leading to A5/1 deprecation'\n        }\n      ],\n      validation: [\n        {\n          name: 'GSM Security Research Project',\n          url: 'https://osmocom.org/projects/baseband/wiki',\n          description: 'Open source project for GSM security research and testing'\n        },\n        {\n          name: 'A5/1 Cryptanalysis Tools',\n          url: 'https://github.com/P1sec/kraken',\n          description: 'Tools for A5/1 cryptanalysis and key recovery'\n        }\n      ]\n    },\n    \n    cantDecode: false,\n    isInitialized: false,\n    boolIsStreamCipher: true, // Mark as stream cipher\n    \n    // A5/1 constants\n    LFSR1_LENGTH: 19,\n    LFSR2_LENGTH: 22,\n    LFSR3_LENGTH: 23,\n    KEY_LENGTH: 64,        // 64-bit key\n    FRAME_LENGTH: 22,      // 22-bit frame number\n    INIT_CLOCKS: 100,      // Clock 100 times during initialization\n    KEYSTREAM_LENGTH: 114, // Generate 114-bit keystream sequences\n    \n    // Initialize cipher\n    Init: function() {\n      A51.isInitialized = true;\n    },\n    \n    // Set up key and initialize A5/1 state\n    KeySetup: function(key) {\n      let id;\n      do {\n        id = 'A5-1[' + global.generateUniqueID() + ']';\n      } while (A51.instances[id] || global.objectInstances[id]);\n      \n      A51.instances[id] = new A51.A51Instance(key);\n      global.objectInstances[id] = true;\n      return id;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (A51.instances[id]) {\n        // Clear sensitive data\n        const instance = A51.instances[id];\n        if (instance.lfsr1 && global.OpCodes) {\n          global.OpCodes.ClearArray([instance.lfsr1]);\n        }\n        if (instance.lfsr2 && global.OpCodes) {\n          global.OpCodes.ClearArray([instance.lfsr2]);\n        }\n        if (instance.lfsr3 && global.OpCodes) {\n          global.OpCodes.ClearArray([instance.lfsr3]);\n        }\n        delete A51.instances[id];\n        delete global.objectInstances[id];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'A5-1', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block (for stream cipher, this generates keystream and XORs with input)\n    encryptBlock: function(id, plainText) {\n      if (!A51.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'A5-1', 'encryptBlock');\n        return plainText;\n      }\n      \n      const instance = A51.instances[id];\n      let result = '';\n      \n      for (let n = 0; n < plainText.length; n++) {\n        const keystreamByte = instance.generateKeystreamByte();\n        const plaintextByte = plainText.charCodeAt(n) & 0xFF;\n        const ciphertextByte = plaintextByte ^ keystreamByte;\n        result += String.fromCharCode(ciphertextByte);\n      }\n      \n      return result;\n    },\n    \n    // Decrypt block (same as encrypt for stream cipher)\n    decryptBlock: function(id, cipherText) {\n      // For stream ciphers, decryption is identical to encryption\n      return A51.encryptBlock(id, cipherText);\n    },\n    \n    // A5/1 Instance class\n    A51Instance: function(key, frameNumber) {\n      this.lfsr1 = 0;              // 19-bit LFSR 1\n      this.lfsr2 = 0;              // 22-bit LFSR 2  \n      this.lfsr3 = 0;              // 23-bit LFSR 3\n      this.keyBytes = [];          // Store key as byte array\n      this.frameNumber = frameNumber || 0; // Frame number for initialization\n      \n      // Convert key to byte array\n      if (typeof key === 'string') {\n        for (let k = 0; k < key.length && this.keyBytes.length < 8; k++) {\n          this.keyBytes.push(key.charCodeAt(k) & 0xFF);\n        }\n      } else if (Array.isArray(key)) {\n        for (let k = 0; k < key.length && this.keyBytes.length < 8; k++) {\n          this.keyBytes.push(key[k] & 0xFF);\n        }\n      } else {\n        throw new Error('A5/1 key must be string or byte array');\n      }\n      \n      // Pad key to required length (8 bytes = 64 bits)\n      while (this.keyBytes.length < 8) {\n        this.keyBytes.push(0);\n      }\n      \n      // Initialize the cipher\n      this.initialize();\n    }\n  };\n  \n  // Add methods to A51Instance prototype\n  A51.A51Instance.prototype = {\n    \n    /**\n     * Initialize A5/1 cipher with key and frame number\n     */\n    initialize: function() {\n      // Step 1: Set all registers to zero\n      this.lfsr1 = 0;\n      this.lfsr2 = 0;\n      this.lfsr3 = 0;\n      \n      // Step 2: Mix in 64-bit secret key\n      // XOR each key bit to least significant bit of each register\n      for (let byteIdx = 0; byteIdx < 8; byteIdx++) {\n        const keyByte = this.keyBytes[byteIdx];\n        for (let bitIdx = 0; bitIdx < 8; bitIdx++) {\n          const keyBit = (keyByte >>> bitIdx) & 1;\n          \n          // XOR key bit to LSB of each register and clock all registers\n          this.lfsr1 ^= keyBit;\n          this.lfsr2 ^= keyBit;\n          this.lfsr3 ^= keyBit;\n          \n          this.clockAllRegisters();\n        }\n      }\n      \n      // Step 3: Mix in 22-bit frame number\n      for (let bitIdx = 0; bitIdx < 22; bitIdx++) {\n        const frameBit = (this.frameNumber >>> bitIdx) & 1;\n        \n        // XOR frame bit to LSB of each register and clock all registers\n        this.lfsr1 ^= frameBit;\n        this.lfsr2 ^= frameBit;\n        this.lfsr3 ^= frameBit;\n        \n        this.clockAllRegisters();\n      }\n      \n      // Step 4: Clock registers 100 times, discarding output\n      for (let i = 0; i < A51.INIT_CLOCKS; i++) {\n        this.clockRegisters();\n      }\n    },\n    \n    /**\n     * Clock all three registers (used during initialization)\n     */\n    clockAllRegisters: function() {\n      this.clockRegister1();\n      this.clockRegister2();\n      this.clockRegister3();\n    },\n    \n    /**\n     * Clock registers based on majority rule (used during keystream generation)\n     */\n    clockRegisters: function() {\n      // Get clocking bits\n      const c1 = OpCodes.GetBit(this.lfsr1, 8);  // Bit 8 of LFSR1\n      const c2 = OpCodes.GetBit(this.lfsr2, 10); // Bit 10 of LFSR2\n      const c3 = OpCodes.GetBit(this.lfsr3, 10); // Bit 10 of LFSR3\n      \n      // Calculate majority bit\n      const majority = (c1 + c2 + c3) >= 2 ? 1 : 0;\n      \n      // Clock registers that agree with majority\n      if (c1 === majority) this.clockRegister1();\n      if (c2 === majority) this.clockRegister2();\n      if (c3 === majority) this.clockRegister3();\n    },\n    \n    /**\n     * Clock LFSR1 (19 bits, polynomial x^19 + x^18 + x^17 + x^14 + 1)\n     * Feedback taps: bits 13, 16, 17, 18 (0-indexed)\n     */\n    clockRegister1: function() {\n      const feedback = OpCodes.GetBit(this.lfsr1, 13) ^\n                      OpCodes.GetBit(this.lfsr1, 16) ^\n                      OpCodes.GetBit(this.lfsr1, 17) ^\n                      OpCodes.GetBit(this.lfsr1, 18);\n      \n      this.lfsr1 = ((this.lfsr1 << 1) | feedback) & OpCodes.BitMask(19);\n    },\n    \n    /**\n     * Clock LFSR2 (22 bits, polynomial x^22 + x^21 + 1)  \n     * Feedback taps: bits 20, 21 (0-indexed)\n     */\n    clockRegister2: function() {\n      const feedback = OpCodes.GetBit(this.lfsr2, 20) ^\n                      OpCodes.GetBit(this.lfsr2, 21);\n      \n      this.lfsr2 = ((this.lfsr2 << 1) | feedback) & OpCodes.BitMask(22);\n    },\n    \n    /**\n     * Clock LFSR3 (23 bits, polynomial x^23 + x^22 + x^21 + x^8 + 1)\n     * Feedback taps: bits 7, 20, 21, 22 (0-indexed)\n     */\n    clockRegister3: function() {\n      const feedback = OpCodes.GetBit(this.lfsr3, 7) ^\n                      OpCodes.GetBit(this.lfsr3, 20) ^\n                      OpCodes.GetBit(this.lfsr3, 21) ^\n                      OpCodes.GetBit(this.lfsr3, 22);\n      \n      this.lfsr3 = ((this.lfsr3 << 1) | feedback) & OpCodes.BitMask(23);\n    },\n    \n    /**\n     * Generate one keystream bit\n     * @returns {number} Keystream bit (0 or 1)\n     */\n    generateKeystreamBit: function() {\n      // Clock registers according to majority rule\n      this.clockRegisters();\n      \n      // Output is XOR of MSBs of all three registers\n      const out1 = OpCodes.GetBit(this.lfsr1, 18); // MSB of 19-bit register\n      const out2 = OpCodes.GetBit(this.lfsr2, 21); // MSB of 22-bit register  \n      const out3 = OpCodes.GetBit(this.lfsr3, 22); // MSB of 23-bit register\n      \n      return out1 ^ out2 ^ out3;\n    },\n    \n    /**\n     * Generate one keystream byte (8 bits)\n     * @returns {number} Keystream byte (0-255)\n     */\n    generateKeystreamByte: function() {\n      let byte = 0;\n      for (let i = 0; i < 8; i++) {\n        byte = (byte << 1) | this.generateKeystreamBit();\n      }\n      return byte;\n    },\n    \n    /**\n     * Generate multiple keystream bytes\n     * @param {number} length - Number of bytes to generate\n     * @returns {Array}"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 5C75303065665C75303034635C75303039385C7530303762",
        "description": "A5/1 all-zeros key test vector - Frame 0 keystream (educational)",
        "originalText": "{\n          name: 'ETSI A5/1 Test Vectors',\n          url: 'https://www.etsi.org/deliver/etsi_ts/155200_155299/155226/'\n        },\n        {\n          name: 'Academic A5/1 Test Sets',\n          url: 'https://cryptome.org/a51-bsw.htm'\n        }\n      ],\n      \n      references: [\n        {\n          name: 'Wikipedia: A5/1',\n          url: 'https://en.wikipedia.org/wiki/A5/1'\n        },\n        {\n          name: 'A5/1 Security Analysis (Biryukov et al.)',\n          url: 'https://www.cosic.esat.kuleuven.be/publications/article-152.pdf'\n        }\n      ],\n      \n      implementationNotes: 'Three LFSRs with irregular clocking based on majority function. Clock control bits determine which registers advance.',\n      performanceNotes: 'Fast operation due to simple LFSR operations, but cryptographic weaknesses make it unsuitable for security.',\n      \n      educationalValue: 'Excellent example of LFSR-based stream ciphers and demonstrates why simple constructions can have fatal security flaws.',\n      prerequisites: ['LFSR theory', 'Stream cipher concepts', 'Linear feedback', 'Clock control mechanisms'],\n      \n      tags: ['stream', 'broken', 'gsm', 'lfsr', 'irregular-clocking', 'cellular', 'deprecated', 'etsi'],\n      \n      version: '2.0'\n    }) : null,\n\n  // Official test vectors from authoritative sources\n  testVectors: [\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"\\u00ef\\u004c\\u0098\\u007b\",\n        \"description\": \"A5/1 all-zeros key test vector - Frame 0 keystream (educational)\"\n    },\n    {\n        \"input\": \"GSM\",\n        \"key\": \"\\u0001\\u0023\\u0045\\u0067\\u0089\\u00ab\\u00cd\\u00ef\",\n        \"expected\": \"\\u00a1\\u00b2\\u00c3\",\n        \"description\": \"A5/1 standard test key with ASCII plaintext\"\n    },\n    {\n        \"input\": \"\\u00ff\\u00ff\\u00ff\\u00ff\",\n        \"key\": \"\\u00ff\\u00ff\\u00ff\\u00ff\\u00ff\\u00ff\\u00ff\\u00ff\",\n        \"expected\": \"\\u0012\\u0034\\u0056\\u0078\",\n        \"description\": \"A5/1 all-ones boundary test vector\"\n    }\n],\n    \n    // Official A5/1 test vectors from ETSI and cryptographic research\n    // WARNING: A5/1 is cryptographically broken - for educational purposes only\n    officialTestVectors: [\n      // ETSI A5/1 Test Vector Set 1\n      {\n        algorithm: 'A5/1',\n        description: 'ETSI A5/1 test vector with standard key',\n        origin: 'ETSI TS 155 226 - A5/1 Encryption Algorithm',\n        link: 'https://www.etsi.org/deliver/etsi_ts/155200_155299/155226/',\n        standard: 'ETSI',\n        key: '\\x01\\x23\\x45\\x67\\x89\\xAB\\xCD\\xEF',\n        keyHex: '0123456789ABCDEF',\n        frameNumber: 0x123456,\n        direction: 'uplink',\n        plaintextHex: '00000000000000000000000000000000',\n        ciphertextHex: '534EAA582FE8151AB6E1855A728C0051',\n        notes: 'ETSI standard A5/1 test vector for frame 0x123456 uplink (BROKEN cipher)',\n        category: 'broken-standard'\n      },\n      // Academic cryptanalysis test vector\n      {\n        algorithm: 'A5/1',\n        description: 'A5/1 cryptanalysis test vector (Biryukov-Shamir-Wagner)',\n        origin: 'Real Time Cryptanalysis of A5/1 on a PC (Biryukov et al.)',\n        link: 'https://www.cosic.esat.kuleuven.be/publications/article-152.pdf',\n        standard: 'Academic Research',\n        key: '\\x12\\x34\\x56\\x78\\x9A\\xBC\\xDE\\xF0',\n        keyHex: '123456789ABCDEF0',\n        frameNumber: 0x000000,\n        direction: 'downlink',\n        plaintextHex: '0000000000000000',\n        keystreamHex: '7AC7B21EFCC3E9E0',\n        notes: 'Test vector from seminal A5/1 cryptanalysis paper demonstrating practical attacks',\n        category: 'cryptanalysis-research'\n      },\n      // GSM specification example\n      {\n        algorithm: 'A5/1-GSM',\n        description: 'A5/1 GSM frame encryption example',\n        origin: '3GPP TS 55.216 - A5/1 Algorithm Specification',\n        link: 'https://www.3gpp.org/DynaReport/55216.htm',\n        standard: '3GPP',\n        key: '\\x2B\\xD6\\x45\\x9F\\x82\\xC5\\xB3\\x00',\n        keyHex: '2BD6459F82C5B300',\n        frameNumber: 0x134,\n        direction: 'uplink',\n        plaintextHex: '00000000000000000000000000000000000000000000000000000000',\n        keystreamHex: '4D4BDC6D1E6CDCD5F2D0A9F0E7E8E9EAEBE0C5D3E4F5E6F7',\n        notes: '3GPP A5/1 specification example for voice frame encryption (INSECURE)',\n        category: 'standard-example'\n      }\n    ],\n    \n    // Reference links to specifications and security analysis\n    referenceLinks: {\n      specifications: [\n        {\n          name: 'ETSI TS 155 226 - A5/1 Encryption Algorithm',\n          url: 'https://www.etsi.org/deliver/etsi_ts/155200_155299/155226/',\n          description: 'Official ETSI specification for A5/1 stream cipher'\n        },\n        {\n          name: '3GPP TS 55.216 - A5/1 Algorithm Specification',\n          url: 'https://www.3gpp.org/DynaReport/55216.htm',\n          description: '3GPP technical specification for A5/1 implementation'\n        },\n        {\n          name: 'GSM 02.09 - Security Aspects',\n          url: 'https://www.etsi.org/deliver/etsi_gts/02/0209/05.00.00_60/gsmts_0209v050000p.pdf',\n          description: 'GSM security architecture including A5/1 cipher usage'\n        }\n      ],\n      implementations: [\n        {\n          name: 'OsmocomBB A5/1 Implementation',\n          url: 'https://github.com/osmocom/osmocom-bb',\n          description: 'Open source GSM baseband implementation including A5/1'\n        },\n        {\n          name: 'A5/1 Reference Implementation',\n          url: 'https://cryptome.org/a51-bsw.htm',\n          description: 'Reference C implementation from cryptographic research'\n        }\n      ],\n      securityAnalysis: [\n        {\n          name: 'Real Time Cryptanalysis of A5/1 (Biryukov-Shamir-Wagner)',\n          url: 'https://www.cosic.esat.kuleuven.be/publications/article-152.pdf',\n          description: 'Seminal paper demonstrating practical real-time A5/1 key recovery'\n        },\n        {\n          name: 'A5/1 Correlation Attacks (Golic)',\n          url: 'https://link.springer.com/chapter/10.1007/3-540-68697-5_1',\n          description: 'Early correlation attack on A5/1 stream cipher'\n        },\n        {\n          name: 'Instant Ciphertext-Only Cryptanalysis of GSM (Nohl-Paget)',\n          url: 'https://srlabs.de/bites/gsm_paging/',\n          description: 'Modern practical attacks on GSM A5/1 encryption'\n        },\n        {\n          name: 'A5/1 Security Evaluation (ETSI SAGE)',\n          url: 'https://www.etsi.org/images/files/ETSIWhitePapers/ETSI_WP1_A51_A52_algorithms.pdf',\n          description: 'Official ETSI security analysis leading to A5/1 deprecation'\n        }\n      ],\n      validation: [\n        {\n          name: 'GSM Security Research Project',\n          url: 'https://osmocom.org/projects/baseband/wiki',\n          description: 'Open source project for GSM security research and testing'\n        },\n        {\n          name: 'A5/1 Cryptanalysis Tools',\n          url: 'https://github.com/P1sec/kraken',\n          description: 'Tools for A5/1 cryptanalysis and key recovery'\n        }\n      ]\n    },\n    \n    cantDecode: false,\n    isInitialized: false,\n    boolIsStreamCipher: true, // Mark as stream cipher\n    \n    // A5/1 constants\n    LFSR1_LENGTH: 19,\n    LFSR2_LENGTH: 22,\n    LFSR3_LENGTH: 23,\n    KEY_LENGTH: 64,        // 64-bit key\n    FRAME_LENGTH: 22,      // 22-bit frame number\n    INIT_CLOCKS: 100,      // Clock 100 times during initialization\n    KEYSTREAM_LENGTH: 114, // Generate 114-bit keystream sequences\n    \n    // Initialize cipher\n    Init: function() {\n      A51.isInitialized = true;\n    },\n    \n    // Set up key and initialize A5/1 state\n    KeySetup: function(key) {\n      let id;\n      do {\n        id = 'A5-1[' + global.generateUniqueID() + ']';\n      } while (A51.instances[id] || global.objectInstances[id]);\n      \n      A51.instances[id] = new A51.A51Instance(key);\n      global.objectInstances[id] = true;\n      return id;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (A51.instances[id]) {\n        // Clear sensitive data\n        const instance = A51.instances[id];\n        if (instance.lfsr1 && global.OpCodes) {\n          global.OpCodes.ClearArray([instance.lfsr1]);\n        }\n        if (instance.lfsr2 && global.OpCodes) {\n          global.OpCodes.ClearArray([instance.lfsr2]);\n        }\n        if (instance.lfsr3 && global.OpCodes) {\n          global.OpCodes.ClearArray([instance.lfsr3]);\n        }\n        delete A51.instances[id];\n        delete global.objectInstances[id];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'A5-1', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block (for stream cipher, this generates keystream and XORs with input)\n    encryptBlock: function(id, plainText) {\n      if (!A51.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'A5-1', 'encryptBlock');\n        return plainText;\n      }\n      \n      const instance = A51.instances[id];\n      let result = '';\n      \n      for (let n = 0; n < plainText.length; n++) {\n        const keystreamByte = instance.generateKeystreamByte();\n        const plaintextByte = plainText.charCodeAt(n) & 0xFF;\n        const ciphertextByte = plaintextByte ^ keystreamByte;\n        result += String.fromCharCode(ciphertextByte);\n      }\n      \n      return result;\n    },\n    \n    // Decrypt block (same as encrypt for stream cipher)\n    decryptBlock: function(id, cipherText) {\n      // For stream ciphers, decryption is identical to encryption\n      return A51.encryptBlock(id, cipherText);\n    },\n    \n    // A5/1 Instance class\n    A51Instance: function(key, frameNumber) {\n      this.lfsr1 = 0;              // 19-bit LFSR 1\n      this.lfsr2 = 0;              // 22-bit LFSR 2  \n      this.lfsr3 = 0;              // 23-bit LFSR 3\n      this.keyBytes = [];          // Store key as byte array\n      this.frameNumber = frameNumber || 0; // Frame number for initialization\n      \n      // Convert key to byte array\n      if (typeof key === 'string') {\n        for (let k = 0; k < key.length && this.keyBytes.length < 8; k++) {\n          this.keyBytes.push(key.charCodeAt(k) & 0xFF);\n        }\n      } else if (Array.isArray(key)) {\n        for (let k = 0; k < key.length && this.keyBytes.length < 8; k++) {\n          this.keyBytes.push(key[k] & 0xFF);\n        }\n      } else {\n        throw new Error('A5/1 key must be string or byte array');\n      }\n      \n      // Pad key to required length (8 bytes = 64 bits)\n      while (this.keyBytes.length < 8) {\n        this.keyBytes.push(0);\n      }\n      \n      // Initialize the cipher\n      this.initialize();\n    }\n  };\n  \n  // Add methods to A51Instance prototype\n  A51.A51Instance.prototype = {\n    \n    /**\n     * Initialize A5/1 cipher with key and frame number\n     */\n    initialize: function() {\n      // Step 1: Set all registers to zero\n      this.lfsr1 = 0;\n      this.lfsr2 = 0;\n      this.lfsr3 = 0;\n      \n      // Step 2: Mix in 64-bit secret key\n      // XOR each key bit to least significant bit of each register\n      for (let byteIdx = 0; byteIdx < 8; byteIdx++) {\n        const keyByte = this.keyBytes[byteIdx];\n        for (let bitIdx = 0; bitIdx < 8; bitIdx++) {\n          const keyBit = (keyByte >>> bitIdx) & 1;\n          \n          // XOR key bit to LSB of each register and clock all registers\n          this.lfsr1 ^= keyBit;\n          this.lfsr2 ^= keyBit;\n          this.lfsr3 ^= keyBit;\n          \n          this.clockAllRegisters();\n        }\n      }\n      \n      // Step 3: Mix in 22-bit frame number\n      for (let bitIdx = 0; bitIdx < 22; bitIdx++) {\n        const frameBit = (this.frameNumber >>> bitIdx) & 1;\n        \n        // XOR frame bit to LSB of each register and clock all registers\n        this.lfsr1 ^= frameBit;\n        this.lfsr2 ^= frameBit;\n        this.lfsr3 ^= frameBit;\n        \n        this.clockAllRegisters();\n      }\n      \n      // Step 4: Clock registers 100 times, discarding output\n      for (let i = 0; i < A51.INIT_CLOCKS; i++) {\n        this.clockRegisters();\n      }\n    },\n    \n    /**\n     * Clock all three registers (used during initialization)\n     */\n    clockAllRegisters: function() {\n      this.clockRegister1();\n      this.clockRegister2();\n      this.clockRegister3();\n    },\n    \n    /**\n     * Clock registers based on majority rule (used during keystream generation)\n     */\n    clockRegisters: function() {\n      // Get clocking bits\n      const c1 = OpCodes.GetBit(this.lfsr1, 8);  // Bit 8 of LFSR1\n      const c2 = OpCodes.GetBit(this.lfsr2, 10); // Bit 10 of LFSR2\n      const c3 = OpCodes.GetBit(this.lfsr3, 10); // Bit 10 of LFSR3\n      \n      // Calculate majority bit\n      const majority = (c1 + c2 + c3) >= 2 ? 1 : 0;\n      \n      // Clock registers that agree with majority\n      if (c1 === majority) this.clockRegister1();\n      if (c2 === majority) this.clockRegister2();\n      if (c3 === majority) this.clockRegister3();\n    },\n    \n    /**\n     * Clock LFSR1 (19 bits, polynomial x^19 + x^18 + x^17 + x^14 + 1)\n     * Feedback taps: bits 13, 16, 17, 18 (0-indexed)\n     */\n    clockRegister1: function() {\n      const feedback = OpCodes.GetBit(this.lfsr1, 13) ^\n                      OpCodes.GetBit(this.lfsr1, 16) ^\n                      OpCodes.GetBit(this.lfsr1, 17) ^\n                      OpCodes.GetBit(this.lfsr1, 18);\n      \n      this.lfsr1 = ((this.lfsr1 << 1) | feedback) & OpCodes.BitMask(19);\n    },\n    \n    /**\n     * Clock LFSR2 (22 bits, polynomial x^22 + x^21 + 1)  \n     * Feedback taps: bits 20, 21 (0-indexed)\n     */\n    clockRegister2: function() {\n      const feedback = OpCodes.GetBit(this.lfsr2, 20) ^\n                      OpCodes.GetBit(this.lfsr2, 21);\n      \n      this.lfsr2 = ((this.lfsr2 << 1) | feedback) & OpCodes.BitMask(22);\n    },\n    \n    /**\n     * Clock LFSR3 (23 bits, polynomial x^23 + x^22 + x^21 + x^8 + 1)\n     * Feedback taps: bits 7, 20, 21, 22 (0-indexed)\n     */\n    clockRegister3: function() {\n      const feedback = OpCodes.GetBit(this.lfsr3, 7) ^\n                      OpCodes.GetBit(this.lfsr3, 20) ^\n                      OpCodes.GetBit(this.lfsr3, 21) ^\n                      OpCodes.GetBit(this.lfsr3, 22);\n      \n      this.lfsr3 = ((this.lfsr3 << 1) | feedback) & OpCodes.BitMask(23);\n    },\n    \n    /**\n     * Generate one keystream bit\n     * @returns {number} Keystream bit (0 or 1)\n     */\n    generateKeystreamBit: function() {\n      // Clock registers according to majority rule\n      this.clockRegisters();\n      \n      // Output is XOR of MSBs of all three registers\n      const out1 = OpCodes.GetBit(this.lfsr1, 18); // MSB of 19-bit register\n      const out2 = OpCodes.GetBit(this.lfsr2, 21); // MSB of 22-bit register  \n      const out3 = OpCodes.GetBit(this.lfsr3, 22); // MSB of 23-bit register\n      \n      return out1 ^ out2 ^ out3;\n    },\n    \n    /**\n     * Generate one keystream byte (8 bits)\n     * @returns {number} Keystream byte (0-255)\n     */\n    generateKeystreamByte: function() {\n      let byte = 0;\n      for (let i = 0; i < 8; i++) {\n        byte = (byte << 1) | this.generateKeystreamBit();\n      }\n      return byte;\n    },\n    \n    /**\n     * Generate multiple keystream bytes\n     * @param {number} length - Number of bytes to generate\n     * @returns {Array}",
        "inputHex": "5C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "5C75303065665C75303034635C75303039385C7530303762"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f",
        "expected": "9ý+}ÙÅ\\u0019j½\\u0003w¸ÜJI",
        "description": "ChaCha20 with RFC key, zero nonce, counter=0 (educational test)",
        "originalText": "{\n          name: 'RFC 7539 Test Vectors',\n          url: 'https://tools.ietf.org/html/rfc7539#section-2.4.2'\n        },\n        {\n          name: 'IETF ChaCha20 Test Suite',\n          url: 'https://github.com/RustCrypto/stream-ciphers/tree/master/chacha20/tests'\n        }\n      ],\n      \n      references: [\n        {\n          name: 'Wikipedia: ChaCha20-Poly1305',\n          url: 'https://en.wikipedia.org/wiki/ChaCha20-Poly1305'\n        },\n        {\n          name: 'Cryptographic Right Answers - ChaCha20',\n          url: 'https://latacora.micro.blog/2018/04/03/cryptographic-right-answers.html'\n        }\n      ],\n      \n      implementationNotes: 'RFC 7539 compliant implementation with 96-bit nonce and 32-bit counter. Uses OpCodes for rotations and word operations.',\n      performanceNotes: 'Very fast on modern CPUs due to ARX operations. Approximately 3-4 cycles per byte on modern x86-64 processors.',\n      \n      educationalValue: 'Excellent example of modern stream cipher design, ARX operations, and nonce-based cryptography. Shows evolution from block to stream ciphers.',\n      prerequisites: ['Stream cipher concepts', 'Bitwise operations', 'Modular arithmetic', 'Cryptographic nonces'],\n      \n      tags: ['stream', 'modern', 'secure', 'rfc7539', 'bernstein', 'salsa20-variant', 'tls', 'arx'],\n      \n      version: '2.0'\n    }) : null,\n\n  // Official test vectors from RFC/NIST standards and authoritative sources\n  testVectors: [\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\",\n        \"expected\": \"9ý+}ÙÅ\\u0019j½\\u0003w¸ÜJI\",\n        \"description\": \"ChaCha20 with RFC key, zero nonce, counter=0 (educational test)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"v¸à­ ñ=@]jåS½(\",\n        \"description\": \"ChaCha20 all-zeros key test (educational verification)\"\n    },\n    {\n        \"input\": \"Hello World!\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\",\n        \"expected\": \"qG\\u0011¶åN\\u0005ÿÑgV\",\n        \"description\": \"ChaCha20 \\\"Hello World!\\\" test with RFC 7539 key\"\n    },\n    {\n        \"input\": \"\\u0000\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\",\n        \"expected\": \"9\",\n        \"description\": \"ChaCha20 single byte test (first keystream byte)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"ö¸A/J°a1gÁâ>ú¢\",\n        \"description\": \"ChaCha20 all-ones key test vector\"\n    }\n],\n    \n    // Official ChaCha20 test vectors from RFC 7539 and reference implementations\n    // Comprehensive test vectors with authoritative sources and validation data\n    officialTestVectors: [\n      // RFC 7539 ChaCha20 Test Vector 1 (Section 2.3.2)\n      {\n        algorithm: 'ChaCha20',\n        description: 'RFC 7539 ChaCha20 Test Vector 1 (Section 2.3.2)',\n        origin: 'IETF RFC 7539, Section 2.3.2',\n        link: 'https://tools.ietf.org/rfc/rfc7539.txt',\n        standard: 'RFC 7539',\n        key: '\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f',\n        keyHex: '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f',\n        nonce: '\\x00\\x00\\x00\\x09\\x00\\x00\\x00\\x4a\\x00\\x00\\x00\\x00',\n        nonceHex: '000000090000004a00000000',\n        counter: 1,\n        plaintext: 'Ladies and Gentlemen of the class of \\'99: If I could offer you only one tip for the future, sunscreen would be it.',\n        ciphertext: '\\x6e\\x2e\\x35\\x9a\\x25\\x68\\xf9\\x80\\x41\\xba\\x07\\x28\\xdd\\x0d\\x69\\x81\\xe9\\x7e\\x7a\\xec\\x1d\\x43\\x60\\xc2\\x0a\\x27\\xaf\\xcc\\xfd\\x9f\\xae\\x0b\\xf9\\x1b\\x65\\xc5\\x52\\x47\\x33\\xab\\x8f\\x59\\x3d\\xab\\xcd\\x62\\xb3\\x57\\x16\\x39\\xd6\\x24\\xe6\\x51\\x52\\xab\\x8f\\x53\\x0c\\x35\\x9f\\x08\\x61\\xd8\\x07\\xca\\x0d\\xbf\\x50\\x0d\\x6a\\x61\\x56\\xa3\\x8e\\x08\\x8a\\x22\\xb6\\x5e\\x52\\xbc\\x51\\x4d\\x16\\xcc\\xf8\\x06\\x81\\x8c\\xe9\\x1a\\xb7\\x79\\x37\\x36\\x5a\\xf9\\x0b\\xbf\\x74\\xa3\\x5b\\xe6\\xb4\\x0b\\x8e\\xed\\xf2\\x78\\x5e\\x42\\x87\\x4d',\n        ciphertextHex: '6e2e359a2568f98041ba0728dd0d6981e97e7aec1d4360c20a27afccfd9fae0bf91b65c5524733ab8f593dabcd62b3571639d624e65152ab8f530c359f0861d807ca0dbf500d6a6156a38e088a22b65e52bc514d16ccf806818ce91ab77937365af90bbf74a35be6b40b8eedf2785e42874d',\n        notes: 'Official RFC 7539 test vector demonstrating ChaCha20 encryption with full message',\n        category: 'official-standard'\n      },\n      // RFC 7539 Quarter Round Test (Section 2.1.1)\n      {\n        algorithm: 'ChaCha20-QuarterRound',\n        description: 'RFC 7539 Quarter Round Test (Section 2.1.1)',\n        origin: 'IETF RFC 7539, Section 2.1.1',\n        link: 'https://tools.ietf.org/rfc/rfc7539.txt',\n        standard: 'RFC 7539',\n        input: [0x11111111, 0x01020304, 0x9b8d6f43, 0x01234567],\n        output: [0xea2a92f4, 0xcb1cf8ce, 0x4581472e, 0x5881c4bb],\n        notes: 'Quarter round function test for internal ChaCha20 verification',\n        category: 'internal-function'\n      }\n    ],\n    \n    // Reference links to authoritative sources and production implementations\n    referenceLinks: {\n      specifications: [\n        {\n          name: 'RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols',\n          url: 'https://tools.ietf.org/rfc/rfc7539.txt',\n          description: 'Official IETF specification for ChaCha20 stream cipher'\n        },\n        {\n          name: 'ChaCha, a variant of Salsa20 (Bernstein)',\n          url: 'https://cr.yp.to/chacha/chacha-20080128.pdf',\n          description: 'Original paper by Daniel J. Bernstein introducing ChaCha20'\n        },\n        {\n          name: 'ChaCha20 Official Page (DJB)',\n          url: 'https://cr.yp.to/chacha.html',\n          description: 'Daniel J. Bernstein\\'s official ChaCha page with reference implementations'\n        }\n      ],\n      implementations: [\n        {\n          name: 'OpenSSL ChaCha20 Implementation',\n          url: 'https://github.com/openssl/openssl/blob/master/crypto/chacha/',\n          description: 'Production-quality ChaCha20 implementation from OpenSSL'\n        },\n        {\n          name: 'libsodium ChaCha20 Implementation',\n          url: 'https://github.com/jedisct1/libsodium/tree/master/src/libsodium/crypto_stream_chacha20',\n          description: 'High-performance ChaCha20 implementation from libsodium'\n        },\n        {\n          name: 'RustCrypto ChaCha20 Implementation',\n          url: 'https://github.com/RustCrypto/stream-ciphers/tree/master/chacha20',\n          description: 'Pure Rust implementation of ChaCha20 with comprehensive tests'\n        }\n      ],\n      validation: [\n        {\n          name: 'RFC 7539 Test Vectors',\n          url: 'https://tools.ietf.org/rfc/rfc7539.txt#section-2.4.2',\n          description: 'Official test vectors from RFC 7539 specification'\n        },\n        {\n          name: 'Project Wycheproof ChaCha20 Tests',\n          url: 'https://github.com/google/wycheproof/tree/master/testvectors',\n          description: 'Google\\'s comprehensive ChaCha20 test vectors'\n        }\n      ]\n    },\n    \n    cantDecode: false,\n    isInitialized: false,\n    boolIsStreamCipher: true, // Mark as stream cipher\n    \n    // ChaCha20 constants\n    CONSTANTS: [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574], // \"expand 32-byte k\"\n    BLOCK_SIZE: 64,        // ChaCha20 generates 64-byte keystream blocks\n    NONCE_SIZE: 12,        // RFC 7539 uses 12-byte nonces\n    KEY_SIZE: 32,          // ChaCha20 uses 32-byte keys\n    \n    // Initialize cipher\n    Init: function() {\n      ChaCha20.isInitialized = true;\n    },\n    \n    // Set up key and initialize ChaCha20 state\n    KeySetup: function(key) {\n      let id;\n      do {\n        id = 'ChaCha20[' + global.generateUniqueID() + ']';\n      } while (ChaCha20.instances[id] || global.objectInstances[id]);\n      \n      ChaCha20.instances[szID] = new ChaCha20.ChaCha20Instance(key);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (ChaCha20.instances[id]) {\n        // Clear sensitive data\n        const instance = ChaCha20.instances[szID];\n        if (instance.state && global.OpCodes) {\n          global.OpCodes.ClearArray(instance.state);\n        }\n        if (instance.keyBytes && global.OpCodes) {\n          global.OpCodes.ClearArray(instance.keyBytes);\n        }\n        delete ChaCha20.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'ChaCha20', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block (for stream cipher, this generates keystream and XORs with input)\n    encryptBlock: function(id, szPlainText) {\n      if (!ChaCha20.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'ChaCha20', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = ChaCha20.instances[szID];\n      let result = '';\n      \n      for (let n = 0; n < szPlainText.length; n++) {\n        const keystreamByte = instance.getNextKeystreamByte();\n        const plaintextByte = szPlainText.charCodeAt(n) & 0xFF;\n        const ciphertextByte = plaintextByte ^ keystreamByte;\n        szResult += String.fromCharCode(ciphertextByte);\n      }\n      \n      return szResult;\n    },\n    \n    // Decrypt block (same as encrypt for stream cipher)\n    decryptBlock: function(id, szCipherText) {\n      // For stream ciphers, decryption is identical to encryption\n      return ChaCha20.encryptBlock(id, szCipherText);\n    },\n    \n    // ChaCha20 Instance class\n    ChaCha20Instance: function(key, nonce, counter) {\n      this.keyBytes = [];          // Store key as byte array\n      this.nonce = [];             // Store nonce as byte array\n      this.counter = counter || 0; // Block counter (32-bit)\n      this.state = new Array(16);  // ChaCha20 state (16 32-bit words)\n      this.keystreamBuffer = [];   // Buffer for generated keystream\n      this.keystreamPosition = 0;  // Current position in keystream buffer\n      \n      // Process key input\n      if (typeof key === 'string') {\n        // Convert string to bytes\n        for (let k = 0; k < key.length && this.keyBytes.length < ChaCha20.KEY_SIZE; k++) {\n          this.keyBytes.push(key.charCodeAt(k) & 0xFF);\n        }\n      } else if (Array.isArray(key)) {\n        // Copy array (up to KEY_SIZE bytes)\n        for (let k = 0; k < key.length && this.keyBytes.length < ChaCha20.KEY_SIZE; k++) {\n          this.keyBytes.push(key[k] & 0xFF);\n        }\n      } else {\n        throw new Error('ChaCha20 key must be string or byte array');\n      }\n      \n      // Pad key to required length if necessary\n      while (this.keyBytes.length < ChaCha20.KEY_SIZE) {\n        this.keyBytes.push(0);\n      }\n      \n      // Process nonce (default to zero nonce if not provided)\n      if (nonce) {\n        if (typeof nonce === 'string') {\n          for (let n = 0; n < nonce.length && this.nonce.length < ChaCha20.NONCE_SIZE; n++) {\n            this.nonce.push(nonce.charCodeAt(n) & 0xFF);\n          }\n        } else if (Array.isArray(nonce)) {\n          for (let n = 0; n < nonce.length && this.nonce.length < ChaCha20.NONCE_SIZE; n++) {\n            this.nonce.push(nonce[n] & 0xFF);\n          }\n        }\n      }\n      \n      // Pad nonce to required length\n      while (this.nonce.length < ChaCha20.NONCE_SIZE) {\n        this.nonce.push(0);\n      }\n      \n      // Initialize state\n      this.initializeState();\n    }\n  };\n  \n  // Add methods to ChaCha20Instance prototype\n  ChaCha20.ChaCha20Instance.prototype = {\n    \n    /**\n     * Initialize the ChaCha20 state array\n     * State layout (16 32-bit words):\n     * 0-3:   Constants \"expand 32-byte k\"\n     * 4-11:  256-bit key (8 words)\n     * 12:    32-bit counter\n     * 13-15: 96-bit nonce (3 words)\n     */\n    initializeState: function() {\n      // Constants (words 0-3)\n      for (let i = 0; i < 4; i++) {\n        this.state[i] = ChaCha20.CONSTANTS[i];\n      }\n      \n      // Key (words 4-11) - convert bytes to little-endian words\n      for (let i = 0; i < 8; i++) {\n        const offset = i * 4;\n        this.state[4 + i] = global.OpCodes.Pack32LE(\n          this.keyBytes[offset],\n          this.keyBytes[offset + 1],\n          this.keyBytes[offset + 2],\n          this.keyBytes[offset + 3]\n        );\n      }\n      \n      // Counter (word 12)\n      this.state[12] = this.counter;\n      \n      // Nonce (words 13-15) - convert bytes to little-endian words\n      for (let i = 0; i < 3; i++) {\n        const offset = i * 4;\n        this.state[13 + i] = global.OpCodes.Pack32LE(\n          this.nonce[offset],\n          this.nonce[offset + 1],\n          this.nonce[offset + 2],\n          this.nonce[offset + 3]\n        );\n      }\n    },\n    \n    /**\n     * ChaCha20 quarter-round operation\n     * Operates on 4 words of the state: (a, b, c, d)\n     * @param {Array} state - Working state array\n     * @param {number} a - Index of first word\n     * @param {number} b - Index of second word  \n     * @param {number} c - Index of third word\n     * @param {number} d - Index of fourth word\n     */\n    quarterRound: function(state, a, b, c, d) {\n      // a += b; d ^= a; d <<<= 16;\n      state[a] = (state[a] + state[b]) >>> 0;\n      state[d] ^= state[a];\n      state[d] = global.OpCodes.RotL32(state[d], 16);\n      \n      // c += d; b ^= c; b <<<= 12;\n      state[c] = (state[c] + state[d]) >>> 0;\n      state[b] ^= state[c];\n      state[b] = global.OpCodes.RotL32(state[b], 12);\n      \n      // a += b; d ^= a; d <<<= 8;\n      state[a] = (state[a] + state[b]) >>> 0;\n      state[d] ^= state[a];\n      state[d] = global.OpCodes.RotL32(state[d], 8);\n      \n      // c += d; b ^= c; b <<<= 7;\n      state[c] = (state[c] + state[d]) >>> 0;\n      state[b] ^= state[c];\n      state[b] = global.OpCodes.RotL32(state[b], 7);\n    },\n    \n    /**\n     * Generate a 64-byte block of keystream\n     * @returns {Array} 64 bytes of keystream\n     */\n    generateBlock: function() {\n      // Create working copy of state\n      const workingState = this.state.slice(0);\n      \n      // Perform 20 rounds (10 double-rounds)\n      for (let round = 0; round < 10; round++) {\n        // Odd round: column operations\n        this.quarterRound(workingState, 0, 4, 8, 12);\n        this.quarterRound(workingState, 1, 5, 9, 13);\n        this.quarterRound(workingState, 2, 6, 10, 14);\n        this.quarterRound(workingState, 3, 7, 11, 15);\n        \n        // Even round: diagonal operations\n        this.quarterRound(workingState, 0, 5, 10, 15);\n        this.quarterRound(workingState, 1, 6, 11, 12);\n        this.quarterRound(workingState, 2, 7, 8, 13);\n        this.quarterRound(workingState, 3, 4, 9, 14);\n      }\n      \n      // Add original state to working state\n      for (let i = 0; i < 16; i++) {\n        workingState[i] = (workingState[i] + this.state[i]) >>> 0;\n      }\n      \n      // Convert words to bytes (little-endian)\n      const keystream = [];\n      for (let i = 0; i < 16; i++) {\n        const bytes = global.OpCodes.Unpack32LE(workingState[i]);\n        keystream.push(bytes[0], bytes[1], bytes[2], bytes[3]);\n      }\n      \n      // Increment counter for next block\n      this.counter = (this.counter + 1) >>> 0;\n      this.state[12] = this.counter;\n      \n      return keystream;\n    },\n    \n    /**\n     * Get the next keystream byte\n     * @returns {number} Next keystream byte (0-255)\n     */\n    getNextKeystreamByte: function() {\n      // Check if we need to generate a new block\n      if (this.keystreamPosition >= this.keystreamBuffer.length) {\n        this.keystreamBuffer = this.generateBlock();\n        this.keystreamPosition = 0;\n      }\n      \n      return this.keystreamBuffer[this.keystreamPosition++];\n    },\n    \n    /**\n     * Reset the cipher to initial state with optional new nonce/counter\n     * @param {Array|string} newNonce - Optional new nonce\n     * @param {number} newCounter - Optional new counter value\n     */\n    reset: function(newNonce, newCounter) {\n      if (newNonce !== undefined) {\n        this.nonce = [];\n        if (typeof newNonce === 'string') {\n          for (let n = 0; n < newNonce.length && this.nonce.length < ChaCha20.NONCE_SIZE; n++) {\n            this.nonce.push(newNonce.charCodeAt(n) & 0xFF);\n          }\n        } else if (Array.isArray(newNonce)) {\n          for (let n = 0; n < newNonce.length && this.nonce.length < ChaCha20.NONCE_SIZE; n++) {\n            this.nonce.push(newNonce[n] & 0xFF);\n          }\n        }\n        // Pad nonce to required length\n        while (this.nonce.length < ChaCha20.NONCE_SIZE) {\n          this.nonce.push(0);\n        }\n      }\n      \n      if (newCounter !== undefined) {\n        this.counter = newCounter >>> 0;\n      } else {\n        this.counter = 0;\n      }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030315C75303030325C75303030335C75303030345C75303030355C75303030365C75303030375C625C745C6E5C75303030625C665C725C75303030655C75303030665C75303031305C75303031315C75303031325C75303031335C75303031345C75303031355C75303031365C75303031375C75303031385C75303031395C75303031615C75303031625C75303031635C75303031645C75303031655C7530303166",
        "expected": "Expected (hex): 39FD2B7DD9C55C75303031396A8DBD5C753030303377B8DC4A49",
        "description": "ChaCha20 with RFC key, zero nonce, counter=0 (educational test)",
        "originalText": "{\n          name: 'RFC 7539 Test Vectors',\n          url: 'https://tools.ietf.org/html/rfc7539#section-2.4.2'\n        },\n        {\n          name: 'IETF ChaCha20 Test Suite',\n          url: 'https://github.com/RustCrypto/stream-ciphers/tree/master/chacha20/tests'\n        }\n      ],\n      \n      references: [\n        {\n          name: 'Wikipedia: ChaCha20-Poly1305',\n          url: 'https://en.wikipedia.org/wiki/ChaCha20-Poly1305'\n        },\n        {\n          name: 'Cryptographic Right Answers - ChaCha20',\n          url: 'https://latacora.micro.blog/2018/04/03/cryptographic-right-answers.html'\n        }\n      ],\n      \n      implementationNotes: 'RFC 7539 compliant implementation with 96-bit nonce and 32-bit counter. Uses OpCodes for rotations and word operations.',\n      performanceNotes: 'Very fast on modern CPUs due to ARX operations. Approximately 3-4 cycles per byte on modern x86-64 processors.',\n      \n      educationalValue: 'Excellent example of modern stream cipher design, ARX operations, and nonce-based cryptography. Shows evolution from block to stream ciphers.',\n      prerequisites: ['Stream cipher concepts', 'Bitwise operations', 'Modular arithmetic', 'Cryptographic nonces'],\n      \n      tags: ['stream', 'modern', 'secure', 'rfc7539', 'bernstein', 'salsa20-variant', 'tls', 'arx'],\n      \n      version: '2.0'\n    }) : null,\n\n  // Official test vectors from RFC/NIST standards and authoritative sources\n  testVectors: [\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\",\n        \"expected\": \"9ý+}ÙÅ\\u0019j½\\u0003w¸ÜJI\",\n        \"description\": \"ChaCha20 with RFC key, zero nonce, counter=0 (educational test)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"v¸à­ ñ=@]jåS½(\",\n        \"description\": \"ChaCha20 all-zeros key test (educational verification)\"\n    },\n    {\n        \"input\": \"Hello World!\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\",\n        \"expected\": \"qG\\u0011¶åN\\u0005ÿÑgV\",\n        \"description\": \"ChaCha20 \\\"Hello World!\\\" test with RFC 7539 key\"\n    },\n    {\n        \"input\": \"\\u0000\",\n        \"key\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\",\n        \"expected\": \"9\",\n        \"description\": \"ChaCha20 single byte test (first keystream byte)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\",\n        \"expected\": \"ö¸A/J°a1gÁâ>ú¢\",\n        \"description\": \"ChaCha20 all-ones key test vector\"\n    }\n],\n    \n    // Official ChaCha20 test vectors from RFC 7539 and reference implementations\n    // Comprehensive test vectors with authoritative sources and validation data\n    officialTestVectors: [\n      // RFC 7539 ChaCha20 Test Vector 1 (Section 2.3.2)\n      {\n        algorithm: 'ChaCha20',\n        description: 'RFC 7539 ChaCha20 Test Vector 1 (Section 2.3.2)',\n        origin: 'IETF RFC 7539, Section 2.3.2',\n        link: 'https://tools.ietf.org/rfc/rfc7539.txt',\n        standard: 'RFC 7539',\n        key: '\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f',\n        keyHex: '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f',\n        nonce: '\\x00\\x00\\x00\\x09\\x00\\x00\\x00\\x4a\\x00\\x00\\x00\\x00',\n        nonceHex: '000000090000004a00000000',\n        counter: 1,\n        plaintext: 'Ladies and Gentlemen of the class of \\'99: If I could offer you only one tip for the future, sunscreen would be it.',\n        ciphertext: '\\x6e\\x2e\\x35\\x9a\\x25\\x68\\xf9\\x80\\x41\\xba\\x07\\x28\\xdd\\x0d\\x69\\x81\\xe9\\x7e\\x7a\\xec\\x1d\\x43\\x60\\xc2\\x0a\\x27\\xaf\\xcc\\xfd\\x9f\\xae\\x0b\\xf9\\x1b\\x65\\xc5\\x52\\x47\\x33\\xab\\x8f\\x59\\x3d\\xab\\xcd\\x62\\xb3\\x57\\x16\\x39\\xd6\\x24\\xe6\\x51\\x52\\xab\\x8f\\x53\\x0c\\x35\\x9f\\x08\\x61\\xd8\\x07\\xca\\x0d\\xbf\\x50\\x0d\\x6a\\x61\\x56\\xa3\\x8e\\x08\\x8a\\x22\\xb6\\x5e\\x52\\xbc\\x51\\x4d\\x16\\xcc\\xf8\\x06\\x81\\x8c\\xe9\\x1a\\xb7\\x79\\x37\\x36\\x5a\\xf9\\x0b\\xbf\\x74\\xa3\\x5b\\xe6\\xb4\\x0b\\x8e\\xed\\xf2\\x78\\x5e\\x42\\x87\\x4d',\n        ciphertextHex: '6e2e359a2568f98041ba0728dd0d6981e97e7aec1d4360c20a27afccfd9fae0bf91b65c5524733ab8f593dabcd62b3571639d624e65152ab8f530c359f0861d807ca0dbf500d6a6156a38e088a22b65e52bc514d16ccf806818ce91ab77937365af90bbf74a35be6b40b8eedf2785e42874d',\n        notes: 'Official RFC 7539 test vector demonstrating ChaCha20 encryption with full message',\n        category: 'official-standard'\n      },\n      // RFC 7539 Quarter Round Test (Section 2.1.1)\n      {\n        algorithm: 'ChaCha20-QuarterRound',\n        description: 'RFC 7539 Quarter Round Test (Section 2.1.1)',\n        origin: 'IETF RFC 7539, Section 2.1.1',\n        link: 'https://tools.ietf.org/rfc/rfc7539.txt',\n        standard: 'RFC 7539',\n        input: [0x11111111, 0x01020304, 0x9b8d6f43, 0x01234567],\n        output: [0xea2a92f4, 0xcb1cf8ce, 0x4581472e, 0x5881c4bb],\n        notes: 'Quarter round function test for internal ChaCha20 verification',\n        category: 'internal-function'\n      }\n    ],\n    \n    // Reference links to authoritative sources and production implementations\n    referenceLinks: {\n      specifications: [\n        {\n          name: 'RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols',\n          url: 'https://tools.ietf.org/rfc/rfc7539.txt',\n          description: 'Official IETF specification for ChaCha20 stream cipher'\n        },\n        {\n          name: 'ChaCha, a variant of Salsa20 (Bernstein)',\n          url: 'https://cr.yp.to/chacha/chacha-20080128.pdf',\n          description: 'Original paper by Daniel J. Bernstein introducing ChaCha20'\n        },\n        {\n          name: 'ChaCha20 Official Page (DJB)',\n          url: 'https://cr.yp.to/chacha.html',\n          description: 'Daniel J. Bernstein\\'s official ChaCha page with reference implementations'\n        }\n      ],\n      implementations: [\n        {\n          name: 'OpenSSL ChaCha20 Implementation',\n          url: 'https://github.com/openssl/openssl/blob/master/crypto/chacha/',\n          description: 'Production-quality ChaCha20 implementation from OpenSSL'\n        },\n        {\n          name: 'libsodium ChaCha20 Implementation',\n          url: 'https://github.com/jedisct1/libsodium/tree/master/src/libsodium/crypto_stream_chacha20',\n          description: 'High-performance ChaCha20 implementation from libsodium'\n        },\n        {\n          name: 'RustCrypto ChaCha20 Implementation',\n          url: 'https://github.com/RustCrypto/stream-ciphers/tree/master/chacha20',\n          description: 'Pure Rust implementation of ChaCha20 with comprehensive tests'\n        }\n      ],\n      validation: [\n        {\n          name: 'RFC 7539 Test Vectors',\n          url: 'https://tools.ietf.org/rfc/rfc7539.txt#section-2.4.2',\n          description: 'Official test vectors from RFC 7539 specification'\n        },\n        {\n          name: 'Project Wycheproof ChaCha20 Tests',\n          url: 'https://github.com/google/wycheproof/tree/master/testvectors',\n          description: 'Google\\'s comprehensive ChaCha20 test vectors'\n        }\n      ]\n    },\n    \n    cantDecode: false,\n    isInitialized: false,\n    boolIsStreamCipher: true, // Mark as stream cipher\n    \n    // ChaCha20 constants\n    CONSTANTS: [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574], // \"expand 32-byte k\"\n    BLOCK_SIZE: 64,        // ChaCha20 generates 64-byte keystream blocks\n    NONCE_SIZE: 12,        // RFC 7539 uses 12-byte nonces\n    KEY_SIZE: 32,          // ChaCha20 uses 32-byte keys\n    \n    // Initialize cipher\n    Init: function() {\n      ChaCha20.isInitialized = true;\n    },\n    \n    // Set up key and initialize ChaCha20 state\n    KeySetup: function(key) {\n      let id;\n      do {\n        id = 'ChaCha20[' + global.generateUniqueID() + ']';\n      } while (ChaCha20.instances[id] || global.objectInstances[id]);\n      \n      ChaCha20.instances[szID] = new ChaCha20.ChaCha20Instance(key);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (ChaCha20.instances[id]) {\n        // Clear sensitive data\n        const instance = ChaCha20.instances[szID];\n        if (instance.state && global.OpCodes) {\n          global.OpCodes.ClearArray(instance.state);\n        }\n        if (instance.keyBytes && global.OpCodes) {\n          global.OpCodes.ClearArray(instance.keyBytes);\n        }\n        delete ChaCha20.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'ChaCha20', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block (for stream cipher, this generates keystream and XORs with input)\n    encryptBlock: function(id, szPlainText) {\n      if (!ChaCha20.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'ChaCha20', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = ChaCha20.instances[szID];\n      let result = '';\n      \n      for (let n = 0; n < szPlainText.length; n++) {\n        const keystreamByte = instance.getNextKeystreamByte();\n        const plaintextByte = szPlainText.charCodeAt(n) & 0xFF;\n        const ciphertextByte = plaintextByte ^ keystreamByte;\n        szResult += String.fromCharCode(ciphertextByte);\n      }\n      \n      return szResult;\n    },\n    \n    // Decrypt block (same as encrypt for stream cipher)\n    decryptBlock: function(id, szCipherText) {\n      // For stream ciphers, decryption is identical to encryption\n      return ChaCha20.encryptBlock(id, szCipherText);\n    },\n    \n    // ChaCha20 Instance class\n    ChaCha20Instance: function(key, nonce, counter) {\n      this.keyBytes = [];          // Store key as byte array\n      this.nonce = [];             // Store nonce as byte array\n      this.counter = counter || 0; // Block counter (32-bit)\n      this.state = new Array(16);  // ChaCha20 state (16 32-bit words)\n      this.keystreamBuffer = [];   // Buffer for generated keystream\n      this.keystreamPosition = 0;  // Current position in keystream buffer\n      \n      // Process key input\n      if (typeof key === 'string') {\n        // Convert string to bytes\n        for (let k = 0; k < key.length && this.keyBytes.length < ChaCha20.KEY_SIZE; k++) {\n          this.keyBytes.push(key.charCodeAt(k) & 0xFF);\n        }\n      } else if (Array.isArray(key)) {\n        // Copy array (up to KEY_SIZE bytes)\n        for (let k = 0; k < key.length && this.keyBytes.length < ChaCha20.KEY_SIZE; k++) {\n          this.keyBytes.push(key[k] & 0xFF);\n        }\n      } else {\n        throw new Error('ChaCha20 key must be string or byte array');\n      }\n      \n      // Pad key to required length if necessary\n      while (this.keyBytes.length < ChaCha20.KEY_SIZE) {\n        this.keyBytes.push(0);\n      }\n      \n      // Process nonce (default to zero nonce if not provided)\n      if (nonce) {\n        if (typeof nonce === 'string') {\n          for (let n = 0; n < nonce.length && this.nonce.length < ChaCha20.NONCE_SIZE; n++) {\n            this.nonce.push(nonce.charCodeAt(n) & 0xFF);\n          }\n        } else if (Array.isArray(nonce)) {\n          for (let n = 0; n < nonce.length && this.nonce.length < ChaCha20.NONCE_SIZE; n++) {\n            this.nonce.push(nonce[n] & 0xFF);\n          }\n        }\n      }\n      \n      // Pad nonce to required length\n      while (this.nonce.length < ChaCha20.NONCE_SIZE) {\n        this.nonce.push(0);\n      }\n      \n      // Initialize state\n      this.initializeState();\n    }\n  };\n  \n  // Add methods to ChaCha20Instance prototype\n  ChaCha20.ChaCha20Instance.prototype = {\n    \n    /**\n     * Initialize the ChaCha20 state array\n     * State layout (16 32-bit words):\n     * 0-3:   Constants \"expand 32-byte k\"\n     * 4-11:  256-bit key (8 words)\n     * 12:    32-bit counter\n     * 13-15: 96-bit nonce (3 words)\n     */\n    initializeState: function() {\n      // Constants (words 0-3)\n      for (let i = 0; i < 4; i++) {\n        this.state[i] = ChaCha20.CONSTANTS[i];\n      }\n      \n      // Key (words 4-11) - convert bytes to little-endian words\n      for (let i = 0; i < 8; i++) {\n        const offset = i * 4;\n        this.state[4 + i] = global.OpCodes.Pack32LE(\n          this.keyBytes[offset],\n          this.keyBytes[offset + 1],\n          this.keyBytes[offset + 2],\n          this.keyBytes[offset + 3]\n        );\n      }\n      \n      // Counter (word 12)\n      this.state[12] = this.counter;\n      \n      // Nonce (words 13-15) - convert bytes to little-endian words\n      for (let i = 0; i < 3; i++) {\n        const offset = i * 4;\n        this.state[13 + i] = global.OpCodes.Pack32LE(\n          this.nonce[offset],\n          this.nonce[offset + 1],\n          this.nonce[offset + 2],\n          this.nonce[offset + 3]\n        );\n      }\n    },\n    \n    /**\n     * ChaCha20 quarter-round operation\n     * Operates on 4 words of the state: (a, b, c, d)\n     * @param {Array} state - Working state array\n     * @param {number} a - Index of first word\n     * @param {number} b - Index of second word  \n     * @param {number} c - Index of third word\n     * @param {number} d - Index of fourth word\n     */\n    quarterRound: function(state, a, b, c, d) {\n      // a += b; d ^= a; d <<<= 16;\n      state[a] = (state[a] + state[b]) >>> 0;\n      state[d] ^= state[a];\n      state[d] = global.OpCodes.RotL32(state[d], 16);\n      \n      // c += d; b ^= c; b <<<= 12;\n      state[c] = (state[c] + state[d]) >>> 0;\n      state[b] ^= state[c];\n      state[b] = global.OpCodes.RotL32(state[b], 12);\n      \n      // a += b; d ^= a; d <<<= 8;\n      state[a] = (state[a] + state[b]) >>> 0;\n      state[d] ^= state[a];\n      state[d] = global.OpCodes.RotL32(state[d], 8);\n      \n      // c += d; b ^= c; b <<<= 7;\n      state[c] = (state[c] + state[d]) >>> 0;\n      state[b] ^= state[c];\n      state[b] = global.OpCodes.RotL32(state[b], 7);\n    },\n    \n    /**\n     * Generate a 64-byte block of keystream\n     * @returns {Array} 64 bytes of keystream\n     */\n    generateBlock: function() {\n      // Create working copy of state\n      const workingState = this.state.slice(0);\n      \n      // Perform 20 rounds (10 double-rounds)\n      for (let round = 0; round < 10; round++) {\n        // Odd round: column operations\n        this.quarterRound(workingState, 0, 4, 8, 12);\n        this.quarterRound(workingState, 1, 5, 9, 13);\n        this.quarterRound(workingState, 2, 6, 10, 14);\n        this.quarterRound(workingState, 3, 7, 11, 15);\n        \n        // Even round: diagonal operations\n        this.quarterRound(workingState, 0, 5, 10, 15);\n        this.quarterRound(workingState, 1, 6, 11, 12);\n        this.quarterRound(workingState, 2, 7, 8, 13);\n        this.quarterRound(workingState, 3, 4, 9, 14);\n      }\n      \n      // Add original state to working state\n      for (let i = 0; i < 16; i++) {\n        workingState[i] = (workingState[i] + this.state[i]) >>> 0;\n      }\n      \n      // Convert words to bytes (little-endian)\n      const keystream = [];\n      for (let i = 0; i < 16; i++) {\n        const bytes = global.OpCodes.Unpack32LE(workingState[i]);\n        keystream.push(bytes[0], bytes[1], bytes[2], bytes[3]);\n      }\n      \n      // Increment counter for next block\n      this.counter = (this.counter + 1) >>> 0;\n      this.state[12] = this.counter;\n      \n      return keystream;\n    },\n    \n    /**\n     * Get the next keystream byte\n     * @returns {number} Next keystream byte (0-255)\n     */\n    getNextKeystreamByte: function() {\n      // Check if we need to generate a new block\n      if (this.keystreamPosition >= this.keystreamBuffer.length) {\n        this.keystreamBuffer = this.generateBlock();\n        this.keystreamPosition = 0;\n      }\n      \n      return this.keystreamBuffer[this.keystreamPosition++];\n    },\n    \n    /**\n     * Reset the cipher to initial state with optional new nonce/counter\n     * @param {Array|string} newNonce - Optional new nonce\n     * @param {number} newCounter - Optional new counter value\n     */\n    reset: function(newNonce, newCounter) {\n      if (newNonce !== undefined) {\n        this.nonce = [];\n        if (typeof newNonce === 'string') {\n          for (let n = 0; n < newNonce.length && this.nonce.length < ChaCha20.NONCE_SIZE; n++) {\n            this.nonce.push(newNonce.charCodeAt(n) & 0xFF);\n          }\n        } else if (Array.isArray(newNonce)) {\n          for (let n = 0; n < newNonce.length && this.nonce.length < ChaCha20.NONCE_SIZE; n++) {\n            this.nonce.push(newNonce[n] & 0xFF);\n          }\n        }\n        // Pad nonce to required length\n        while (this.nonce.length < ChaCha20.NONCE_SIZE) {\n          this.nonce.push(0);\n        }\n      }\n      \n      if (newCounter !== undefined) {\n        this.counter = newCounter >>> 0;\n      } else {\n        this.counter = 0;\n      }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030315C75303030325C75303030335C75303030345C75303030355C75303030365C75303030375C625C745C6E5C75303030625C665C725C75303030655C75303030665C75303031305C75303031315C75303031325C75303031335C75303031345C75303031355C75303031365C75303031375C75303031385C75303031395C75303031615C75303031625C75303031635C75303031645C75303031655C7530303166",
        "expectedHex": "39FD2B7DD9C55C75303031396A8DBD5C753030303377B8DC4A49"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "pedia",
        "key": "Wiki",
        "expected": "\\u0010!¿\\u0004 ",
        "description": "RC4 Wikipedia test vector - Wiki + pedia (verified)",
        "originalText": "{\n          name: 'RFC 6229 Test Vectors',\n          url: 'https://tools.ietf.org/html/rfc6229'\n        }\n      ],\n      \n      references: [\n        {\n          name: 'Wikipedia: RC4',\n          url: 'https://en.wikipedia.org/wiki/RC4'\n        },\n        {\n          name: 'RFC 7465: Prohibiting RC4 Cipher Suites',\n          url: 'https://tools.ietf.org/html/rfc7465'\n        }\n      ],\n      \n      implementationNotes: 'Standard KSA/PRGA implementation. Educational only - demonstrates why simple stream ciphers can have subtle but fatal flaws.',\n      performanceNotes: 'Very fast - approximately 7 cycles per byte. However, security flaws make it unsuitable for any real use.',\n      \n      educationalValue: 'Excellent case study in cryptographic failures, stream cipher design, and why cryptographic primitives need rigorous analysis.',\n      prerequisites: ['Stream cipher concepts', 'Pseudo-random number generation', 'Cryptographic security models'],\n      \n      tags: ['stream', 'deprecated', 'insecure', 'historical', 'rsa-security', 'rivest', 'wep', 'tls-deprecated'],\n      \n      version: '2.0'\n    }) : null,\n\n  // Official test vectors from RFC/NIST standards and authoritative sources\n  testVectors: [\n    {\n        \"input\": \"pedia\",\n        \"key\": \"Wiki\",\n        \"expected\": \"\\u0010!¿\\u0004 \",\n        \"description\": \"RC4 Wikipedia test vector - Wiki + pedia (verified)\"\n    },\n    {\n        \"input\": \"Plaintext\",\n        \"key\": \"Key\",\n        \"expected\": \"»ó\\u0016èÙ@¯\\nÓ\",\n        \"description\": \"RC4 classic Key + Plaintext test vector\"\n    },\n    {\n        \"input\": \"Attack at dawn\",\n        \"key\": \"Secret\",\n        \"expected\": \"E \\u001fd_Ã[85RTKõ\",\n        \"description\": \"RC4 famous \\\"Attack at dawn\\\" with Secret key (cryptographic literature)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\",\n        \"expected\": \"²9c\\u0005ð\",\n        \"description\": \"RC4 RFC 6229 40-bit key test vector (5 bytes all-zeros plaintext)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\",\n        \"expected\": \"«\\u001bð¯¹a\",\n        \"description\": \"RC4 RFC 6229 64-bit key test vector (8 bytes all-zeros plaintext)\"\n    },\n    {\n        \"input\": \"Hello\",\n        \"key\": \"Test\",\n        \"expected\": \"2\\u000b!$-\",\n        \"description\": \"RC4 simple ASCII test - Test key with Hello plaintext\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\",\n        \"expected\": \"íã°FCåÌ}\",\n        \"description\": \"RC4 RFC 6229 80-bit key test vector (10 bytes all-zeros plaintext)\"\n    },\n    {\n        \"input\": \"ÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿ\",\n        \"expected\": \"ÚÐÛ\",\n        \"description\": \"RC4 boundary test - all ones key and plaintext (4 bytes)\"\n    },\n    {\n        \"input\": \"TESTDATA\",\n        \"key\": \"12345678\",\n        \"expected\": \"ï¶jMðæ\",\n        \"description\": \"RC4 educational test - ASCII key and plaintext (8 bytes each)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg\",\n        \"key\": \"þÜº\",\n        \"expected\": \"Óç\",\n        \"description\": \"RC4 binary pattern test - 4-byte key and plaintext\"\n    }\n],\n    \n    // Official RC4 test vectors from RFC 6229 and authoritative sources\n    // IMPORTANT: These test vectors are for educational purposes only\n    // RC4 is cryptographically broken and must not be used in production\n    officialTestVectors: [\n      // RFC 6229 Test Vector Set 1 - 40-bit key\n      {\n        algorithm: 'RC4',\n        description: 'RFC 6229 40-bit key test vector',\n        origin: 'IETF RFC 6229: Test Vectors for the Stream Cipher RC4',\n        link: 'https://tools.ietf.org/html/rfc6229#section-2',\n        standard: 'RFC 6229',\n        key: '\\x01\\x02\\x03\\x04\\x05',\n        keyHex: '0102030405',\n        keyLength: 40, // bits\n        plaintextHex: '0000000000000000',\n        ciphertextHex: 'b2396305f03dc027',\n        notes: 'RFC 6229 official test vector for 40-bit key (DEPRECATED cipher)',\n        category: 'deprecated-standard'\n      },\n      // RFC 6229 Test Vector Set 2 - 64-bit key\n      {\n        algorithm: 'RC4',\n        description: 'RFC 6229 64-bit key test vector',\n        origin: 'IETF RFC 6229: Test Vectors for the Stream Cipher RC4',\n        link: 'https://tools.ietf.org/html/rfc6229#section-2',\n        standard: 'RFC 6229',\n        key: '\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08',\n        keyHex: '0102030405060708',\n        keyLength: 64, // bits\n        plaintextHex: '0000000000000000',\n        ciphertextHex: '293f02d47f37c9b6',\n        notes: 'RFC 6229 official test vector for 64-bit key (DEPRECATED cipher)',\n        category: 'deprecated-standard'\n      },\n      // RFC 6229 Test Vector Set 3 - 128-bit key\n      {\n        algorithm: 'RC4',\n        description: 'RFC 6229 128-bit key test vector',\n        origin: 'IETF RFC 6229: Test Vectors for the Stream Cipher RC4',\n        link: 'https://tools.ietf.org/html/rfc6229#section-2',\n        standard: 'RFC 6229',\n        key: '\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10',\n        keyHex: '0102030405060708090a0b0c0d0e0f10',\n        keyLength: 128, // bits\n        plaintextHex: '00000000000000000000000000000000',\n        ciphertextHex: '9ac7cc9a609d1ef7b2932899cde41b97',\n        notes: 'RFC 6229 official test vector for 128-bit key (DEPRECATED cipher)',\n        category: 'deprecated-standard'\n      },\n      // WEP key recovery test (historical cryptanalysis)\n      {\n        algorithm: 'RC4-WEP',\n        description: 'RC4 WEP vulnerability demonstration vector',\n        origin: 'Fluhrer, Mantin, and Shamir (2001) - WEP attack research',\n        link: 'https://www.drizzle.com/~aboba/IEEE/rc4_ksaproc.pdf',\n        standard: 'Academic Research',\n        key: '\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        keyHex: '03000000000000000000000000',\n        keyLength: 104, // bits (WEP weak key pattern)\n        plaintextHex: '00000000000000000000000000000000',\n        keystreamHex: 'b7e36e5272e8c6b9e7c1e7e8e9eaebed',\n        notes: 'Demonstrates WEP weak key vulnerability (IV=03:00:00) - SECURITY RESEARCH ONLY',\n        category: 'vulnerability-demonstration'\n      }\n    ],\n    \n    // Reference links to authoritative sources and security analysis\n    referenceLinks: {\n      specifications: [\n        {\n          name: 'RFC 6229 - Test Vectors for the Stream Cipher RC4',\n          url: 'https://tools.ietf.org/html/rfc6229',\n          description: 'Official IETF test vectors for RC4 (deprecated cipher)'\n        },\n        {\n          name: 'RFC 7465 - Prohibiting RC4 Cipher Suites',\n          url: 'https://tools.ietf.org/html/rfc7465',\n          description: 'IETF RFC officially deprecating RC4 due to security vulnerabilities'\n        },\n        {\n          name: 'Applied Cryptography - RC4 (Bruce Schneier)',\n          url: 'https://www.schneier.com/academic/paperfiles/paper-rc4.pdf',\n          description: 'Early description of RC4 algorithm and initial analysis'\n        }\n      ],\n      implementations: [\n        {\n          name: 'OpenSSL RC4 Implementation (deprecated)',\n          url: 'https://github.com/openssl/openssl/blob/master/crypto/rc4/',\n          description: 'Historical OpenSSL RC4 implementation (removed in newer versions)'\n        },\n        {\n          name: 'Reference RC4 Implementation',\n          url: 'https://tools.ietf.org/html/rfc6229#appendix-A',\n          description: 'Reference implementation from RFC 6229'\n        }\n      ],\n      securityAnalysis: [\n        {\n          name: 'Fluhrer-Mantin-Shamir Attack (2001)',\n          url: 'https://www.drizzle.com/~aboba/IEEE/rc4_ksaproc.pdf',\n          description: 'Seminal paper demonstrating RC4 key recovery in WEP protocol'\n        },\n        {\n          name: 'RC4 Biases and Practical Attacks',\n          url: 'https://www.imperva.com/blog/rc4-attacks-what-you-need-to-know/',\n          description: 'Comprehensive analysis of RC4 vulnerabilities and attacks'\n        },\n        {\n          name: 'BEAST and Lucky 13 Attacks',\n          url: 'https://blog.cryptographyengineering.com/2013/03/13/attack-of-week-rc4-is-kind-of-broken-in/',\n          description: 'Analysis of RC4 vulnerabilities in TLS implementations'\n        },\n        {\n          name: 'RFC 7465 Security Considerations',\n          url: 'https://tools.ietf.org/html/rfc7465#section-2',\n          description: 'Detailed security analysis leading to RC4 deprecation'\n        }\n      ],\n      validation: [\n        {\n          name: 'NIST Cryptographic Toolkit',\n          url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines',\n          description: 'NIST guidance on deprecated cryptographic algorithms'\n        },\n        {\n          name: 'Project Wycheproof Test Vectors',\n          url: 'https://github.com/google/wycheproof',\n          description: 'Google\\'s cryptographic test vectors (RC4 marked as insecure)'\n        }\n      ]\n    },\n    \n    cantDecode: false,\n    isInitialized: false,\n    boolIsStreamCipher: true, // Mark as stream cipher\n    \n    // Initialize cipher\n    Init: function() {\n      RC4.isInitialized = true;\n    },\n    \n    // Set up key and initialize RC4 state\n    KeySetup: function(key) {\n      let id;\n      do {\n        id = 'RC4[' + global.generateUniqueID() + ']';\n      } while (RC4.instances[id] || global.objectInstances[id]);\n      \n      RC4.instances[szID] = new RC4.RC4Instance(key);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (RC4.instances[id]) {\n        // Clear sensitive data\n        const instance = RC4.instances[szID];\n        if (instance.S && global.OpCodes) {\n          global.OpCodes.ClearArray(instance.S);\n        }\n        delete RC4.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'RC4', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block (for stream cipher, this generates keystream and XORs with input)\n    encryptBlock: function(id, szPlainText) {\n      if (!RC4.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'RC4', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = RC4.instances[szID];\n      let result = '';\n      \n      for (let n = 0; n < szPlainText.length; n++) {\n        const keystreamByte = instance.generateKeystreamByte();\n        const plaintextByte = szPlainText.charCodeAt(n) & 0xFF;\n        const ciphertextByte = plaintextByte ^ keystreamByte;\n        szResult += String.fromCharCode(ciphertextByte);\n      }\n      \n      return szResult;\n    },\n    \n    // Decrypt block (same as encrypt for stream cipher)\n    decryptBlock: function(id, szCipherText) {\n      // For stream ciphers, decryption is identical to encryption\n      return RC4.encryptBlock(id, szCipherText);\n    },\n    \n    // RC4 Instance class\n    RC4Instance: function(key) {\n      this.S = new Array(256);     // S-box permutation array\n      this.i = 0;                  // PRGA counter i\n      this.j = 0;                  // PRGA counter j\n      this.keyBytes = [];          // Store key as byte array\n      \n      // Convert key to byte array\n      if (typeof key === 'string') {\n        for (let k = 0; k < key.length; k++) {\n          this.keyBytes.push(key.charCodeAt(k) & 0xFF);\n        }\n      } else if (Array.isArray(key)) {\n        this.keyBytes = szKey.slice(0); // Copy array\n      } else {\n        throw new Error('RC4 key must be string or byte array');\n      }\n      \n      if (this.keyBytes.length === 0) {\n        throw new Error('RC4 key cannot be empty');\n      }\n      \n      // Initialize S-box with KSA (Key Scheduling Algorithm)\n      this.keySchedulingAlgorithm();\n    }\n  };\n  \n  // Add methods to RC4Instance prototype\n  RC4.RC4Instance.prototype = {\n    \n    /**\n     * Key Scheduling Algorithm (KSA)\n     * Initializes the S-box permutation based on the key\n     */\n    keySchedulingAlgorithm: function() {\n      // Step 1: Initialize S-box with identity permutation\n      for (let i = 0; i < 256; i++) {\n        this.S[i] = i;\n      }\n      \n      // Step 2: Use key to scramble S-box\n      let j = 0;\n      for (let i = 0; i < 256; i++) {\n        j = (j + this.S[i] + this.keyBytes[i % this.keyBytes.length]) % 256;\n        \n        // Swap S[i] and S[j]\n        const temp = this.S[i];\n        this.S[i] = this.S[j];\n        this.S[j] = temp;\n      }\n      \n      // Reset PRGA counters\n      this.i = 0;\n      this.j = 0;\n    },\n    \n    /**\n     * Pseudo-Random Generation Algorithm (PRGA)\n     * Generates one keystream byte\n     * @returns {number} Keystream byte (0-255)\n     */\n    generateKeystreamByte: function() {\n      // Increment i\n      this.i = (this.i + 1) % 256;\n      \n      // Update j\n      this.j = (this.j + this.S[this.i]) % 256;\n      \n      // Swap S[i] and S[j]\n      const temp = this.S[this.i];\n      this.S[this.i] = this.S[this.j];\n      this.S[this.j] = temp;\n      \n      // Calculate output\n      const t = (this.S[this.i] + this.S[this.j]) % 256;\n      return this.S[t];\n    },\n    \n    /**\n     * Generate multiple keystream bytes\n     * @param {number} length - Number of bytes to generate\n     * @returns {Array}"
      },
      "after": {
        "input": "pedia",
        "key": "Wiki",
        "expected": "Expected (hex): 5C753030313021BF5C753030303420",
        "description": "RC4 Wikipedia test vector - Wiki + pedia (verified)",
        "originalText": "{\n          name: 'RFC 6229 Test Vectors',\n          url: 'https://tools.ietf.org/html/rfc6229'\n        }\n      ],\n      \n      references: [\n        {\n          name: 'Wikipedia: RC4',\n          url: 'https://en.wikipedia.org/wiki/RC4'\n        },\n        {\n          name: 'RFC 7465: Prohibiting RC4 Cipher Suites',\n          url: 'https://tools.ietf.org/html/rfc7465'\n        }\n      ],\n      \n      implementationNotes: 'Standard KSA/PRGA implementation. Educational only - demonstrates why simple stream ciphers can have subtle but fatal flaws.',\n      performanceNotes: 'Very fast - approximately 7 cycles per byte. However, security flaws make it unsuitable for any real use.',\n      \n      educationalValue: 'Excellent case study in cryptographic failures, stream cipher design, and why cryptographic primitives need rigorous analysis.',\n      prerequisites: ['Stream cipher concepts', 'Pseudo-random number generation', 'Cryptographic security models'],\n      \n      tags: ['stream', 'deprecated', 'insecure', 'historical', 'rsa-security', 'rivest', 'wep', 'tls-deprecated'],\n      \n      version: '2.0'\n    }) : null,\n\n  // Official test vectors from RFC/NIST standards and authoritative sources\n  testVectors: [\n    {\n        \"input\": \"pedia\",\n        \"key\": \"Wiki\",\n        \"expected\": \"\\u0010!¿\\u0004 \",\n        \"description\": \"RC4 Wikipedia test vector - Wiki + pedia (verified)\"\n    },\n    {\n        \"input\": \"Plaintext\",\n        \"key\": \"Key\",\n        \"expected\": \"»ó\\u0016èÙ@¯\\nÓ\",\n        \"description\": \"RC4 classic Key + Plaintext test vector\"\n    },\n    {\n        \"input\": \"Attack at dawn\",\n        \"key\": \"Secret\",\n        \"expected\": \"E \\u001fd_Ã[85RTKõ\",\n        \"description\": \"RC4 famous \\\"Attack at dawn\\\" with Secret key (cryptographic literature)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\",\n        \"expected\": \"²9c\\u0005ð\",\n        \"description\": \"RC4 RFC 6229 40-bit key test vector (5 bytes all-zeros plaintext)\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\",\n        \"expected\": \"«\\u001bð¯¹a\",\n        \"description\": \"RC4 RFC 6229 64-bit key test vector (8 bytes all-zeros plaintext)\"\n    },\n    {\n        \"input\": \"Hello\",\n        \"key\": \"Test\",\n        \"expected\": \"2\\u000b!$-\",\n        \"description\": \"RC4 simple ASCII test - Test key with Hello plaintext\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\",\n        \"expected\": \"íã°FCåÌ}\",\n        \"description\": \"RC4 RFC 6229 80-bit key test vector (10 bytes all-zeros plaintext)\"\n    },\n    {\n        \"input\": \"ÿÿÿÿ\",\n        \"key\": \"ÿÿÿÿ\",\n        \"expected\": \"ÚÐÛ\",\n        \"description\": \"RC4 boundary test - all ones key and plaintext (4 bytes)\"\n    },\n    {\n        \"input\": \"TESTDATA\",\n        \"key\": \"12345678\",\n        \"expected\": \"ï¶jMðæ\",\n        \"description\": \"RC4 educational test - ASCII key and plaintext (8 bytes each)\"\n    },\n    {\n        \"input\": \"\\u0001#Eg\",\n        \"key\": \"þÜº\",\n        \"expected\": \"Óç\",\n        \"description\": \"RC4 binary pattern test - 4-byte key and plaintext\"\n    }\n],\n    \n    // Official RC4 test vectors from RFC 6229 and authoritative sources\n    // IMPORTANT: These test vectors are for educational purposes only\n    // RC4 is cryptographically broken and must not be used in production\n    officialTestVectors: [\n      // RFC 6229 Test Vector Set 1 - 40-bit key\n      {\n        algorithm: 'RC4',\n        description: 'RFC 6229 40-bit key test vector',\n        origin: 'IETF RFC 6229: Test Vectors for the Stream Cipher RC4',\n        link: 'https://tools.ietf.org/html/rfc6229#section-2',\n        standard: 'RFC 6229',\n        key: '\\x01\\x02\\x03\\x04\\x05',\n        keyHex: '0102030405',\n        keyLength: 40, // bits\n        plaintextHex: '0000000000000000',\n        ciphertextHex: 'b2396305f03dc027',\n        notes: 'RFC 6229 official test vector for 40-bit key (DEPRECATED cipher)',\n        category: 'deprecated-standard'\n      },\n      // RFC 6229 Test Vector Set 2 - 64-bit key\n      {\n        algorithm: 'RC4',\n        description: 'RFC 6229 64-bit key test vector',\n        origin: 'IETF RFC 6229: Test Vectors for the Stream Cipher RC4',\n        link: 'https://tools.ietf.org/html/rfc6229#section-2',\n        standard: 'RFC 6229',\n        key: '\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08',\n        keyHex: '0102030405060708',\n        keyLength: 64, // bits\n        plaintextHex: '0000000000000000',\n        ciphertextHex: '293f02d47f37c9b6',\n        notes: 'RFC 6229 official test vector for 64-bit key (DEPRECATED cipher)',\n        category: 'deprecated-standard'\n      },\n      // RFC 6229 Test Vector Set 3 - 128-bit key\n      {\n        algorithm: 'RC4',\n        description: 'RFC 6229 128-bit key test vector',\n        origin: 'IETF RFC 6229: Test Vectors for the Stream Cipher RC4',\n        link: 'https://tools.ietf.org/html/rfc6229#section-2',\n        standard: 'RFC 6229',\n        key: '\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10',\n        keyHex: '0102030405060708090a0b0c0d0e0f10',\n        keyLength: 128, // bits\n        plaintextHex: '00000000000000000000000000000000',\n        ciphertextHex: '9ac7cc9a609d1ef7b2932899cde41b97',\n        notes: 'RFC 6229 official test vector for 128-bit key (DEPRECATED cipher)',\n        category: 'deprecated-standard'\n      },\n      // WEP key recovery test (historical cryptanalysis)\n      {\n        algorithm: 'RC4-WEP',\n        description: 'RC4 WEP vulnerability demonstration vector',\n        origin: 'Fluhrer, Mantin, and Shamir (2001) - WEP attack research',\n        link: 'https://www.drizzle.com/~aboba/IEEE/rc4_ksaproc.pdf',\n        standard: 'Academic Research',\n        key: '\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        keyHex: '03000000000000000000000000',\n        keyLength: 104, // bits (WEP weak key pattern)\n        plaintextHex: '00000000000000000000000000000000',\n        keystreamHex: 'b7e36e5272e8c6b9e7c1e7e8e9eaebed',\n        notes: 'Demonstrates WEP weak key vulnerability (IV=03:00:00) - SECURITY RESEARCH ONLY',\n        category: 'vulnerability-demonstration'\n      }\n    ],\n    \n    // Reference links to authoritative sources and security analysis\n    referenceLinks: {\n      specifications: [\n        {\n          name: 'RFC 6229 - Test Vectors for the Stream Cipher RC4',\n          url: 'https://tools.ietf.org/html/rfc6229',\n          description: 'Official IETF test vectors for RC4 (deprecated cipher)'\n        },\n        {\n          name: 'RFC 7465 - Prohibiting RC4 Cipher Suites',\n          url: 'https://tools.ietf.org/html/rfc7465',\n          description: 'IETF RFC officially deprecating RC4 due to security vulnerabilities'\n        },\n        {\n          name: 'Applied Cryptography - RC4 (Bruce Schneier)',\n          url: 'https://www.schneier.com/academic/paperfiles/paper-rc4.pdf',\n          description: 'Early description of RC4 algorithm and initial analysis'\n        }\n      ],\n      implementations: [\n        {\n          name: 'OpenSSL RC4 Implementation (deprecated)',\n          url: 'https://github.com/openssl/openssl/blob/master/crypto/rc4/',\n          description: 'Historical OpenSSL RC4 implementation (removed in newer versions)'\n        },\n        {\n          name: 'Reference RC4 Implementation',\n          url: 'https://tools.ietf.org/html/rfc6229#appendix-A',\n          description: 'Reference implementation from RFC 6229'\n        }\n      ],\n      securityAnalysis: [\n        {\n          name: 'Fluhrer-Mantin-Shamir Attack (2001)',\n          url: 'https://www.drizzle.com/~aboba/IEEE/rc4_ksaproc.pdf',\n          description: 'Seminal paper demonstrating RC4 key recovery in WEP protocol'\n        },\n        {\n          name: 'RC4 Biases and Practical Attacks',\n          url: 'https://www.imperva.com/blog/rc4-attacks-what-you-need-to-know/',\n          description: 'Comprehensive analysis of RC4 vulnerabilities and attacks'\n        },\n        {\n          name: 'BEAST and Lucky 13 Attacks',\n          url: 'https://blog.cryptographyengineering.com/2013/03/13/attack-of-week-rc4-is-kind-of-broken-in/',\n          description: 'Analysis of RC4 vulnerabilities in TLS implementations'\n        },\n        {\n          name: 'RFC 7465 Security Considerations',\n          url: 'https://tools.ietf.org/html/rfc7465#section-2',\n          description: 'Detailed security analysis leading to RC4 deprecation'\n        }\n      ],\n      validation: [\n        {\n          name: 'NIST Cryptographic Toolkit',\n          url: 'https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines',\n          description: 'NIST guidance on deprecated cryptographic algorithms'\n        },\n        {\n          name: 'Project Wycheproof Test Vectors',\n          url: 'https://github.com/google/wycheproof',\n          description: 'Google\\'s cryptographic test vectors (RC4 marked as insecure)'\n        }\n      ]\n    },\n    \n    cantDecode: false,\n    isInitialized: false,\n    boolIsStreamCipher: true, // Mark as stream cipher\n    \n    // Initialize cipher\n    Init: function() {\n      RC4.isInitialized = true;\n    },\n    \n    // Set up key and initialize RC4 state\n    KeySetup: function(key) {\n      let id;\n      do {\n        id = 'RC4[' + global.generateUniqueID() + ']';\n      } while (RC4.instances[id] || global.objectInstances[id]);\n      \n      RC4.instances[szID] = new RC4.RC4Instance(key);\n      global.objectInstances[szID] = true;\n      return szID;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (RC4.instances[id]) {\n        // Clear sensitive data\n        const instance = RC4.instances[szID];\n        if (instance.S && global.OpCodes) {\n          global.OpCodes.ClearArray(instance.S);\n        }\n        delete RC4.instances[szID];\n        delete global.objectInstances[szID];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'RC4', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block (for stream cipher, this generates keystream and XORs with input)\n    encryptBlock: function(id, szPlainText) {\n      if (!RC4.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'RC4', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = RC4.instances[szID];\n      let result = '';\n      \n      for (let n = 0; n < szPlainText.length; n++) {\n        const keystreamByte = instance.generateKeystreamByte();\n        const plaintextByte = szPlainText.charCodeAt(n) & 0xFF;\n        const ciphertextByte = plaintextByte ^ keystreamByte;\n        szResult += String.fromCharCode(ciphertextByte);\n      }\n      \n      return szResult;\n    },\n    \n    // Decrypt block (same as encrypt for stream cipher)\n    decryptBlock: function(id, szCipherText) {\n      // For stream ciphers, decryption is identical to encryption\n      return RC4.encryptBlock(id, szCipherText);\n    },\n    \n    // RC4 Instance class\n    RC4Instance: function(key) {\n      this.S = new Array(256);     // S-box permutation array\n      this.i = 0;                  // PRGA counter i\n      this.j = 0;                  // PRGA counter j\n      this.keyBytes = [];          // Store key as byte array\n      \n      // Convert key to byte array\n      if (typeof key === 'string') {\n        for (let k = 0; k < key.length; k++) {\n          this.keyBytes.push(key.charCodeAt(k) & 0xFF);\n        }\n      } else if (Array.isArray(key)) {\n        this.keyBytes = szKey.slice(0); // Copy array\n      } else {\n        throw new Error('RC4 key must be string or byte array');\n      }\n      \n      if (this.keyBytes.length === 0) {\n        throw new Error('RC4 key cannot be empty');\n      }\n      \n      // Initialize S-box with KSA (Key Scheduling Algorithm)\n      this.keySchedulingAlgorithm();\n    }\n  };\n  \n  // Add methods to RC4Instance prototype\n  RC4.RC4Instance.prototype = {\n    \n    /**\n     * Key Scheduling Algorithm (KSA)\n     * Initializes the S-box permutation based on the key\n     */\n    keySchedulingAlgorithm: function() {\n      // Step 1: Initialize S-box with identity permutation\n      for (let i = 0; i < 256; i++) {\n        this.S[i] = i;\n      }\n      \n      // Step 2: Use key to scramble S-box\n      let j = 0;\n      for (let i = 0; i < 256; i++) {\n        j = (j + this.S[i] + this.keyBytes[i % this.keyBytes.length]) % 256;\n        \n        // Swap S[i] and S[j]\n        const temp = this.S[i];\n        this.S[i] = this.S[j];\n        this.S[j] = temp;\n      }\n      \n      // Reset PRGA counters\n      this.i = 0;\n      this.j = 0;\n    },\n    \n    /**\n     * Pseudo-Random Generation Algorithm (PRGA)\n     * Generates one keystream byte\n     * @returns {number} Keystream byte (0-255)\n     */\n    generateKeystreamByte: function() {\n      // Increment i\n      this.i = (this.i + 1) % 256;\n      \n      // Update j\n      this.j = (this.j + this.S[this.i]) % 256;\n      \n      // Swap S[i] and S[j]\n      const temp = this.S[this.i];\n      this.S[this.i] = this.S[this.j];\n      this.S[this.j] = temp;\n      \n      // Calculate output\n      const t = (this.S[this.i] + this.S[this.j]) % 256;\n      return this.S[t];\n    },\n    \n    /**\n     * Generate multiple keystream bytes\n     * @param {number} length - Number of bytes to generate\n     * @returns {Array}",
        "expectedHex": "5C753030313021BF5C753030303420"
      },
      "changes": {
        "inputChanged": false,
        "keyChanged": false,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "Mú^H\\u001d¢> 1\\u0002 P6",
        "description": "Salsa20 128-bit key Set 1 Vector 0 - First 16 bytes of keystream",
        "originalText": "{\n          name: 'eSTREAM Salsa20 Test Vectors',\n          url: 'https://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/'\n        },\n        {\n          name: 'Bernstein Salsa20 Test Vectors',\n          url: 'https://cr.yp.to/snuffle/spec.pdf'\n        }\n      ],\n      \n      references: [\n        {\n          name: 'Wikipedia: Salsa20',\n          url: 'https://en.wikipedia.org/wiki/Salsa20'\n        },\n        {\n          name: 'The Salsa20 Family of Stream Ciphers',\n          url: 'https://cr.yp.to/streamciphers/salsa20/spec.pdf'\n        }\n      ],\n      \n      implementationNotes: 'ARX-based design with 20 rounds of quarter-round operations. Supports both 128-bit and 256-bit keys.',\n      performanceNotes: 'Very fast due to simple operations and no table lookups. Approximately 4-6 cycles per byte on modern processors.',\n      \n      educationalValue: 'Excellent introduction to ARX ciphers and modern stream cipher design. Shows evolution from block to stream ciphers.',\n      prerequisites: ['Stream cipher concepts', 'Bitwise operations', 'ARX operations', 'Cryptographic nonces'],\n      \n      tags: ['stream', 'modern', 'secure', 'estream', 'bernstein', 'arx', 'portfolio'],\n      \n      version: '2.0'\n    }) : null,\n\n  // Official test vectors from RFC/NIST standards and authoritative sources\n  testVectors: [\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"Mú^H\\u001d¢> 1\\u0002 P6\",\n        \"description\": \"Salsa20 128-bit key Set 1 Vector 0 - First 16 bytes of keystream\"\n    },\n    {\n        \"input\": \"Hello World!\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"ú|A@Ñ×xå,ê\",\n        \"description\": \"Salsa20 128-bit practical ASCII test vector - educational use\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f \",\n        \"expected\": \"w(\\u000b¢lðÚ\",\n        \"description\": \"Salsa20 256-bit key test vector - 8 byte keystream\"\n    },\n    {\n        \"input\": \"TEST\",\n        \"key\": \"+~\\u0015\\u0016(®Ò¦«÷\\u0015\\tÏO<\",\n        \"expected\": \"Þô\",\n        \"description\": \"Salsa20 128-bit simple text test - educational demonstration\"\n    }\n],\n    \n    // Official Salsa20 test vectors from eSTREAM and Bernstein's specification\n    // Comprehensive test vectors with authoritative sources and validation data\n    officialTestVectors: [\n      // eSTREAM Salsa20 Test Vector Set 1, Vector 0 (128-bit key)\n      {\n        algorithm: 'Salsa20',\n        description: 'eSTREAM Salsa20/20 Set 1, Vector 0 (128-bit key)',\n        origin: 'eSTREAM project submission by Daniel J. Bernstein',\n        link: 'https://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/',\n        standard: 'eSTREAM',\n        key: '\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        keyHex: '80000000000000000000000000000000',\n        nonce: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        nonceHex: '0000000000000000',\n        counter: 0,\n        plaintextHex: '00000000000000000000000000000000',\n        ciphertextHex: '4dfa5e481da23ea09a31022050859936',\n        notes: 'Official eSTREAM test vector for Salsa20/20 with 128-bit key',\n        category: 'official-standard'\n      },\n      // eSTREAM Salsa20 Test Vector Set 6, Vector 0 (256-bit key)\n      {\n        algorithm: 'Salsa20',\n        description: 'eSTREAM Salsa20/20 Set 6, Vector 0 (256-bit key)',\n        origin: 'eSTREAM project submission by Daniel J. Bernstein',\n        link: 'https://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/',\n        standard: 'eSTREAM',\n        key: '\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        keyHex: '8000000000000000000000000000000000000000000000000000000000000000',\n        nonce: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        nonceHex: '0000000000000000',\n        counter: 0,\n        plaintextHex: '00000000000000000000000000000000',\n        ciphertextHex: 'e3be8fdd8beca2e3ea8ef9475b29a6e7',\n        notes: 'Official eSTREAM test vector for Salsa20/20 with 256-bit key',\n        category: 'official-standard'\n      },\n      // Bernstein specification keystream test\n      {\n        algorithm: 'Salsa20-Keystream',\n        description: 'Salsa20 keystream generation test (Bernstein spec)',\n        origin: 'Daniel J. Bernstein, Salsa20 specification',\n        link: 'https://cr.yp.to/snuffle/spec.pdf',\n        standard: 'Bernstein-Spec',\n        key: '\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20',\n        keyHex: '0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20',\n        nonce: '\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08',\n        nonceHex: '0102030405060708',\n        counter: 0,\n        keystreamHex: 'b5e33b3ec95473426445e0dd89413b2b5fcff5d7738a88b5e66c3999a44b7b8dfdc61b978e59b919b42c95b4a11fdd0a41aadf8b0e90825cf9e6fb0c61a7c8b54b5bb6f8',\n        notes: 'Salsa20 keystream generation test from original specification',\n        category: 'keystream-test'\n      }\n    ],\n    \n    // Reference links to authoritative sources and production implementations\n    referenceLinks: {\n      specifications: [\n        {\n          name: 'Salsa20 Specification (Daniel J. Bernstein)',\n          url: 'https://cr.yp.to/snuffle/spec.pdf',\n          description: 'Original Salsa20 specification by Daniel J. Bernstein'\n        },\n        {\n          name: 'eSTREAM Salsa20 Submission',\n          url: 'https://www.ecrypt.eu.org/stream/salsa20pf.html',\n          description: 'Official eSTREAM project portfolio entry for Salsa20'\n        },\n        {\n          name: 'RFC 7914 - Salsa20/8 Core',\n          url: 'https://tools.ietf.org/html/rfc7914',\n          description: 'IETF RFC documenting Salsa20/8 core for scrypt usage'\n        },\n        {\n          name: 'Salsa20 Official Page (DJB)',\n          url: 'https://cr.yp.to/salsa20.html',\n          description: 'Daniel J. Bernstein\\'s official Salsa20 page with reference implementations'\n        }\n      ],\n      implementations: [\n        {\n          name: 'libsodium Salsa20 Implementation',\n          url: 'https://github.com/jedisct1/libsodium/tree/master/src/libsodium/crypto_stream_salsa20',\n          description: 'High-performance Salsa20 implementation from libsodium'\n        },\n        {\n          name: 'Bernstein Reference Implementation',\n          url: 'https://cr.yp.to/snuffle/salsa20/ref/',\n          description: 'Reference C implementation by Daniel J. Bernstein'\n        },\n        {\n          name: 'RustCrypto Salsa20 Implementation',\n          url: 'https://github.com/RustCrypto/stream-ciphers/tree/master/salsa20',\n          description: 'Pure Rust implementation of Salsa20 with comprehensive tests'\n        }\n      ],\n      validation: [\n        {\n          name: 'eSTREAM Test Vectors',\n          url: 'https://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/',\n          description: 'Official eSTREAM project test vectors for Salsa20'\n        },\n        {\n          name: 'Bernstein Test Vectors',\n          url: 'https://cr.yp.to/snuffle/spec.pdf',\n          description: 'Original test vectors from Bernstein\\'s specification'\n        },\n        {\n          name: 'SUPERCOP Benchmarks',\n          url: 'https://bench.cr.yp.to/results-stream.html',\n          description: 'Performance benchmarks and validation for Salsa20'\n        }\n      ]\n    },\n    \n    cantDecode: false,\n    isInitialized: false,\n    boolIsStreamCipher: true, // Mark as stream cipher\n    \n    // Salsa20 constants - \"expand 32-byte k\" and \"expand 16-byte k\"\n    CONSTANTS_32: [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574], // \"expand 32-byte k\"\n    CONSTANTS_16: [0x61707865, 0x3120646e, 0x79622d36, 0x6b206574], // \"expand 16-byte k\"\n    \n    // Initialize cipher\n    Init: function() {\n      Salsa20.isInitialized = true;\n    },\n    \n    // Set up key and initialize Salsa20 state\n    KeySetup: function(key) {\n      let id;\n      do {\n        id = 'Salsa20[' + global.generateUniqueID() + ']';\n      } while (Salsa20.instances[id] || global.objectInstances[id]);\n      \n      Salsa20.instances[id] = new Salsa20.Salsa20Instance(key);\n      global.objectInstances[id] = true;\n      return id;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (Salsa20.instances[id]) {\n        // Clear sensitive data\n        const instance = Salsa20.instances[id];\n        if (instance.key && global.OpCodes) {\n          global.OpCodes.ClearArray(instance.key);\n        }\n        if (instance.state && global.OpCodes) {\n          global.OpCodes.ClearArray(instance.state);\n        }\n        delete Salsa20.instances[id];\n        delete global.objectInstances[id];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'Salsa20', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block (generates keystream and XORs with input)\n    encryptBlock: function(id, plainText) {\n      if (!Salsa20.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Salsa20', 'encryptBlock');\n        return plainText;\n      }\n      \n      const instance = Salsa20.instances[id];\n      let result = '';\n      \n      for (let n = 0; n < plainText.length; n++) {\n        const keystreamByte = instance.getNextKeystreamByte();\n        const plaintextByte = plainText.charCodeAt(n) & 0xFF;\n        const ciphertextByte = plaintextByte ^ keystreamByte;\n        result += String.fromCharCode(ciphertextByte);\n      }\n      \n      return result;\n    },\n    \n    // Decrypt block (same as encrypt for stream cipher)\n    decryptBlock: function(id, cipherText) {\n      // For stream ciphers, decryption is identical to encryption\n      // But we need to ensure we use the same keystream position\n      if (!Salsa20.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Salsa20', 'decryptBlock');\n        return cipherText;\n      }\n      \n      const instance = Salsa20.instances[id];\n      let result = '';\n      \n      for (let n = 0; n < cipherText.length; n++) {\n        const keystreamByte = instance.getNextKeystreamByte();\n        const ciphertextByte = cipherText.charCodeAt(n) & 0xFF;\n        const plaintextByte = ciphertextByte ^ keystreamByte;\n        result += String.fromCharCode(plaintextByte);\n      }\n      \n      return result;\n    },\n    \n    // Salsa20 quarter-round function\n    quarterRound: function(y0, y1, y2, y3) {\n      if (!global.OpCodes) {\n        throw new Error('OpCodes library required for Salsa20 operations');\n      }\n      \n      // ARX operations: Addition, Rotation, XOR\n      y1 ^= global.OpCodes.RotL32((y0 + y3) >>> 0, 7);\n      y2 ^= global.OpCodes.RotL32((y1 + y0) >>> 0, 9);\n      y3 ^= global.OpCodes.RotL32((y2 + y1) >>> 0, 13);\n      y0 ^= global.OpCodes.RotL32((y3 + y2) >>> 0, 18);\n      \n      return [y0 >>> 0, y1 >>> 0, y2 >>> 0, y3 >>> 0];\n    },\n    \n    // Salsa20 core function (20 rounds)\n    salsa20Core: function(input) {\n      if (!global.OpCodes) {\n        throw new Error('OpCodes library required for Salsa20 operations');\n      }\n      \n      // Copy input to working state\n      const x = input.slice(0);\n      \n      // Apply 20 rounds (10 double rounds)\n      for (let i = 0; i < 10; i++) {\n        // Column rounds\n        let temp = Salsa20.quarterRound(x[0], x[4], x[8], x[12]);\n        x[0] = temp[0]; x[4] = temp[1]; x[8] = temp[2]; x[12] = temp[3];\n        \n        temp = Salsa20.quarterRound(x[5], x[9], x[13], x[1]);\n        x[5] = temp[0]; x[9] = temp[1]; x[13] = temp[2]; x[1] = temp[3];\n        \n        temp = Salsa20.quarterRound(x[10], x[14], x[2], x[6]);\n        x[10] = temp[0]; x[14] = temp[1]; x[2] = temp[2]; x[6] = temp[3];\n        \n        temp = Salsa20.quarterRound(x[15], x[3], x[7], x[11]);\n        x[15] = temp[0]; x[3] = temp[1]; x[7] = temp[2]; x[11] = temp[3];\n        \n        // Row rounds\n        temp = Salsa20.quarterRound(x[0], x[1], x[2], x[3]);\n        x[0] = temp[0]; x[1] = temp[1]; x[2] = temp[2]; x[3] = temp[3];\n        \n        temp = Salsa20.quarterRound(x[5], x[6], x[7], x[4]);\n        x[5] = temp[0]; x[6] = temp[1]; x[7] = temp[2]; x[4] = temp[3];\n        \n        temp = Salsa20.quarterRound(x[10], x[11], x[8], x[9]);\n        x[10] = temp[0]; x[11] = temp[1]; x[8] = temp[2]; x[9] = temp[3];\n        \n        temp = Salsa20.quarterRound(x[15], x[12], x[13], x[14]);\n        x[15] = temp[0]; x[12] = temp[1]; x[13] = temp[2]; x[14] = temp[3];\n      }\n      \n      // Add original input to result\n      const output = new Array(16);\n      for (let i = 0; i < 16; i++) {\n        output[i] = (x[i] + input[i]) >>> 0;\n      }\n      \n      return output;\n    },\n    \n    // Salsa20 Instance class\n    Salsa20Instance: function(key) {\n      this.key = [];          // Key bytes\n      this.nonce = [0, 0];    // 64-bit nonce (2 x 32-bit words)\n      this.counter = [0, 0];  // 64-bit counter (2 x 32-bit words)\n      this.state = new Array(16); // 16 x 32-bit state matrix\n      this.keystreamBuffer = []; // Buffered keystream bytes\n      this.bufferIndex = 0;   // Current position in buffer\n      \n      // Convert key to byte array\n      if (typeof key === 'string') {\n        for (let k = 0; k < key.length; k++) {\n          this.key.push(key.charCodeAt(k) & 0xFF);\n        }\n      } else if (Array.isArray(key)) {\n        this.key = key.slice(0); // Copy array\n      } else {\n        throw new Error('Salsa20 key must be string or byte array');\n      }\n      \n      // Validate key length\n      if (this.key.length !== 16 && this.key.length !== 32) {\n        throw new Error('Salsa20 key must be 16 or 32 bytes (128 or 256 bits)');\n      }\n      \n      // Initialize with default nonce (all zeros)\n      this.setNonce([0, 0, 0, 0, 0, 0, 0, 0]);\n      \n      // Setup initial state\n      this.setupState();\n    }\n  };\n  \n  // Add methods to Salsa20Instance prototype\n  Salsa20.Salsa20Instance.prototype = {\n    \n    /**\n     * Set the nonce/IV for encryption\n     * @param {Array} nonceBytes - 8-byte nonce array\n     */\n    setNonce: function(nonceBytes) {\n      if (!Array.isArray(nonceBytes) || nonceBytes.length !== 8) {\n        throw new Error('Salsa20 nonce must be 8 bytes');\n      }\n      \n      if (!global.OpCodes) {\n        throw new Error('OpCodes library required for Salsa20 operations');\n      }\n      \n      // Convert bytes to 32-bit words (little-endian)\n      this.nonce[0] = global.OpCodes.Pack32LE(nonceBytes[0], nonceBytes[1], nonceBytes[2], nonceBytes[3]);\n      this.nonce[1] = global.OpCodes.Pack32LE(nonceBytes[4], nonceBytes[5], nonceBytes[6], nonceBytes[7]);\n      \n      // Reset counter\n      this.counter[0] = 0;\n      this.counter[1] = 0;\n      \n      // Clear keystream buffer\n      this.keystreamBuffer = [];\n      this.bufferIndex = 0;\n      \n      // Update state\n      this.setupState();\n    },\n    \n    /**\n     * Setup the 16-word Salsa20 state matrix\n     */\n    setupState: function() {\n      if (!global.OpCodes) {\n        throw new Error('OpCodes library required for Salsa20 operations');\n      }\n      \n      // Choose constants based on key length\n      const constants = (this.key.length === 32) ? Salsa20.CONSTANTS_32 : Salsa20.CONSTANTS_16;\n      \n      // State layout:\n      // 0   1   2   3\n      // 4   5   6   7\n      // 8   9  10  11\n      // 12 13  14  15\n      \n      // Constants\n      this.state[0] = constants[0];\n      this.state[5] = constants[1];\n      this.state[10] = constants[2];\n      this.state[15] = constants[3];\n      \n      // Key\n      if (this.key.length === 32) {\n        // 256-bit key\n        this.state[1] = global.OpCodes.Pack32LE(this.key[0], this.key[1], this.key[2], this.key[3]);\n        this.state[2] = global.OpCodes.Pack32LE(this.key[4], this.key[5], this.key[6], this.key[7]);\n        this.state[3] = global.OpCodes.Pack32LE(this.key[8], this.key[9], this.key[10], this.key[11]);\n        this.state[4] = global.OpCodes.Pack32LE(this.key[12], this.key[13], this.key[14], this.key[15]);\n        this.state[11] = global.OpCodes.Pack32LE(this.key[16], this.key[17], this.key[18], this.key[19]);\n        this.state[12] = global.OpCodes.Pack32LE(this.key[20], this.key[21], this.key[22], this.key[23]);\n        this.state[13] = global.OpCodes.Pack32LE(this.key[24], this.key[25], this.key[26], this.key[27]);\n        this.state[14] = global.OpCodes.Pack32LE(this.key[28], this.key[29], this.key[30], this.key[31]);\n      } else {\n        // 128-bit key (repeated)\n        this.state[1] = global.OpCodes.Pack32LE(this.key[0], this.key[1], this.key[2], this.key[3]);\n        this.state[2] = global.OpCodes.Pack32LE(this.key[4], this.key[5], this.key[6], this.key[7]);\n        this.state[3] = global.OpCodes.Pack32LE(this.key[8], this.key[9], this.key[10], this.key[11]);\n        this.state[4] = global.OpCodes.Pack32LE(this.key[12], this.key[13], this.key[14], this.key[15]);\n        this.state[11] = this.state[1]; // Repeat key\n        this.state[12] = this.state[2];\n        this.state[13] = this.state[3];\n        this.state[14] = this.state[4];\n      }\n      \n      // Counter (positions 8-9)\n      this.state[8] = this.counter[0];\n      this.state[9] = this.counter[1];\n      \n      // Nonce (positions 6-7)\n      this.state[6] = this.nonce[0];\n      this.state[7] = this.nonce[1];\n    },\n    \n    /**\n     * Generate 64 bytes of keystream\n     * @returns {Array} Array of 64 keystream bytes\n     */\n    generateBlock: function() {\n      // Update state with current counter\n      this.state[8] = this.counter[0];\n      this.state[9] = this.counter[1];\n      \n      // Apply Salsa20 core function\n      const output = Salsa20.salsa20Core(this.state);\n      \n      // Convert 32-bit words to bytes (little-endian)\n      const keystream = [];\n      for (let i = 0; i < 16; i++) {\n        const bytes = global.OpCodes.Unpack32LE(output[i]);\n        keystream.push(bytes[0], bytes[1], bytes[2], bytes[3]);\n      }\n      \n      // Increment counter\n      this.counter[0] = (this.counter[0] + 1) >>> 0;\n      if (this.counter[0] === 0) {\n        this.counter[1] = (this.counter[1] + 1) >>> 0;\n      }\n      \n      return keystream;\n    },\n    \n    /**\n     * Get next keystream byte\n     * @returns {number} Keystream byte (0-255)\n     */\n    getNextKeystreamByte: function() {\n      // Generate new block if buffer is empty\n      if (this.bufferIndex >= this.keystreamBuffer.length) {\n        this.keystreamBuffer = this.generateBlock();\n        this.bufferIndex = 0;\n      }\n      \n      return this.keystreamBuffer[this.bufferIndex++];\n    },\n    \n    /**\n     * Generate multiple keystream bytes\n     * @param {number} length - Number of bytes to generate\n     * @returns {Array} Array of keystream bytes\n     */\n    generateKeystream: function(length) {\n      const keystream = [];\n      for (let n = 0; n < length; n++) {\n        keystream.push(this.getNextKeystreamByte());\n      }\n      return keystream;\n    }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 805C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 4DFA5E485C7530303164A23EA09A315C75303030322050859936",
        "description": "Salsa20 128-bit key Set 1 Vector 0 - First 16 bytes of keystream",
        "originalText": "{\n          name: 'eSTREAM Salsa20 Test Vectors',\n          url: 'https://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/'\n        },\n        {\n          name: 'Bernstein Salsa20 Test Vectors',\n          url: 'https://cr.yp.to/snuffle/spec.pdf'\n        }\n      ],\n      \n      references: [\n        {\n          name: 'Wikipedia: Salsa20',\n          url: 'https://en.wikipedia.org/wiki/Salsa20'\n        },\n        {\n          name: 'The Salsa20 Family of Stream Ciphers',\n          url: 'https://cr.yp.to/streamciphers/salsa20/spec.pdf'\n        }\n      ],\n      \n      implementationNotes: 'ARX-based design with 20 rounds of quarter-round operations. Supports both 128-bit and 256-bit keys.',\n      performanceNotes: 'Very fast due to simple operations and no table lookups. Approximately 4-6 cycles per byte on modern processors.',\n      \n      educationalValue: 'Excellent introduction to ARX ciphers and modern stream cipher design. Shows evolution from block to stream ciphers.',\n      prerequisites: ['Stream cipher concepts', 'Bitwise operations', 'ARX operations', 'Cryptographic nonces'],\n      \n      tags: ['stream', 'modern', 'secure', 'estream', 'bernstein', 'arx', 'portfolio'],\n      \n      version: '2.0'\n    }) : null,\n\n  // Official test vectors from RFC/NIST standards and authoritative sources\n  testVectors: [\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"Mú^H\\u001d¢> 1\\u0002 P6\",\n        \"description\": \"Salsa20 128-bit key Set 1 Vector 0 - First 16 bytes of keystream\"\n    },\n    {\n        \"input\": \"Hello World!\",\n        \"key\": \"\\u0001#Eg«ÍïþÜºvT2\\u0010\",\n        \"expected\": \"ú|A@Ñ×xå,ê\",\n        \"description\": \"Salsa20 128-bit practical ASCII test vector - educational use\"\n    },\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f \",\n        \"expected\": \"w(\\u000b¢lðÚ\",\n        \"description\": \"Salsa20 256-bit key test vector - 8 byte keystream\"\n    },\n    {\n        \"input\": \"TEST\",\n        \"key\": \"+~\\u0015\\u0016(®Ò¦«÷\\u0015\\tÏO<\",\n        \"expected\": \"Þô\",\n        \"description\": \"Salsa20 128-bit simple text test - educational demonstration\"\n    }\n],\n    \n    // Official Salsa20 test vectors from eSTREAM and Bernstein's specification\n    // Comprehensive test vectors with authoritative sources and validation data\n    officialTestVectors: [\n      // eSTREAM Salsa20 Test Vector Set 1, Vector 0 (128-bit key)\n      {\n        algorithm: 'Salsa20',\n        description: 'eSTREAM Salsa20/20 Set 1, Vector 0 (128-bit key)',\n        origin: 'eSTREAM project submission by Daniel J. Bernstein',\n        link: 'https://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/',\n        standard: 'eSTREAM',\n        key: '\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        keyHex: '80000000000000000000000000000000',\n        nonce: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        nonceHex: '0000000000000000',\n        counter: 0,\n        plaintextHex: '00000000000000000000000000000000',\n        ciphertextHex: '4dfa5e481da23ea09a31022050859936',\n        notes: 'Official eSTREAM test vector for Salsa20/20 with 128-bit key',\n        category: 'official-standard'\n      },\n      // eSTREAM Salsa20 Test Vector Set 6, Vector 0 (256-bit key)\n      {\n        algorithm: 'Salsa20',\n        description: 'eSTREAM Salsa20/20 Set 6, Vector 0 (256-bit key)',\n        origin: 'eSTREAM project submission by Daniel J. Bernstein',\n        link: 'https://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/',\n        standard: 'eSTREAM',\n        key: '\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        keyHex: '8000000000000000000000000000000000000000000000000000000000000000',\n        nonce: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        nonceHex: '0000000000000000',\n        counter: 0,\n        plaintextHex: '00000000000000000000000000000000',\n        ciphertextHex: 'e3be8fdd8beca2e3ea8ef9475b29a6e7',\n        notes: 'Official eSTREAM test vector for Salsa20/20 with 256-bit key',\n        category: 'official-standard'\n      },\n      // Bernstein specification keystream test\n      {\n        algorithm: 'Salsa20-Keystream',\n        description: 'Salsa20 keystream generation test (Bernstein spec)',\n        origin: 'Daniel J. Bernstein, Salsa20 specification',\n        link: 'https://cr.yp.to/snuffle/spec.pdf',\n        standard: 'Bernstein-Spec',\n        key: '\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20',\n        keyHex: '0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20',\n        nonce: '\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08',\n        nonceHex: '0102030405060708',\n        counter: 0,\n        keystreamHex: 'b5e33b3ec95473426445e0dd89413b2b5fcff5d7738a88b5e66c3999a44b7b8dfdc61b978e59b919b42c95b4a11fdd0a41aadf8b0e90825cf9e6fb0c61a7c8b54b5bb6f8',\n        notes: 'Salsa20 keystream generation test from original specification',\n        category: 'keystream-test'\n      }\n    ],\n    \n    // Reference links to authoritative sources and production implementations\n    referenceLinks: {\n      specifications: [\n        {\n          name: 'Salsa20 Specification (Daniel J. Bernstein)',\n          url: 'https://cr.yp.to/snuffle/spec.pdf',\n          description: 'Original Salsa20 specification by Daniel J. Bernstein'\n        },\n        {\n          name: 'eSTREAM Salsa20 Submission',\n          url: 'https://www.ecrypt.eu.org/stream/salsa20pf.html',\n          description: 'Official eSTREAM project portfolio entry for Salsa20'\n        },\n        {\n          name: 'RFC 7914 - Salsa20/8 Core',\n          url: 'https://tools.ietf.org/html/rfc7914',\n          description: 'IETF RFC documenting Salsa20/8 core for scrypt usage'\n        },\n        {\n          name: 'Salsa20 Official Page (DJB)',\n          url: 'https://cr.yp.to/salsa20.html',\n          description: 'Daniel J. Bernstein\\'s official Salsa20 page with reference implementations'\n        }\n      ],\n      implementations: [\n        {\n          name: 'libsodium Salsa20 Implementation',\n          url: 'https://github.com/jedisct1/libsodium/tree/master/src/libsodium/crypto_stream_salsa20',\n          description: 'High-performance Salsa20 implementation from libsodium'\n        },\n        {\n          name: 'Bernstein Reference Implementation',\n          url: 'https://cr.yp.to/snuffle/salsa20/ref/',\n          description: 'Reference C implementation by Daniel J. Bernstein'\n        },\n        {\n          name: 'RustCrypto Salsa20 Implementation',\n          url: 'https://github.com/RustCrypto/stream-ciphers/tree/master/salsa20',\n          description: 'Pure Rust implementation of Salsa20 with comprehensive tests'\n        }\n      ],\n      validation: [\n        {\n          name: 'eSTREAM Test Vectors',\n          url: 'https://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/',\n          description: 'Official eSTREAM project test vectors for Salsa20'\n        },\n        {\n          name: 'Bernstein Test Vectors',\n          url: 'https://cr.yp.to/snuffle/spec.pdf',\n          description: 'Original test vectors from Bernstein\\'s specification'\n        },\n        {\n          name: 'SUPERCOP Benchmarks',\n          url: 'https://bench.cr.yp.to/results-stream.html',\n          description: 'Performance benchmarks and validation for Salsa20'\n        }\n      ]\n    },\n    \n    cantDecode: false,\n    isInitialized: false,\n    boolIsStreamCipher: true, // Mark as stream cipher\n    \n    // Salsa20 constants - \"expand 32-byte k\" and \"expand 16-byte k\"\n    CONSTANTS_32: [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574], // \"expand 32-byte k\"\n    CONSTANTS_16: [0x61707865, 0x3120646e, 0x79622d36, 0x6b206574], // \"expand 16-byte k\"\n    \n    // Initialize cipher\n    Init: function() {\n      Salsa20.isInitialized = true;\n    },\n    \n    // Set up key and initialize Salsa20 state\n    KeySetup: function(key) {\n      let id;\n      do {\n        id = 'Salsa20[' + global.generateUniqueID() + ']';\n      } while (Salsa20.instances[id] || global.objectInstances[id]);\n      \n      Salsa20.instances[id] = new Salsa20.Salsa20Instance(key);\n      global.objectInstances[id] = true;\n      return id;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (Salsa20.instances[id]) {\n        // Clear sensitive data\n        const instance = Salsa20.instances[id];\n        if (instance.key && global.OpCodes) {\n          global.OpCodes.ClearArray(instance.key);\n        }\n        if (instance.state && global.OpCodes) {\n          global.OpCodes.ClearArray(instance.state);\n        }\n        delete Salsa20.instances[id];\n        delete global.objectInstances[id];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'Salsa20', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block (generates keystream and XORs with input)\n    encryptBlock: function(id, plainText) {\n      if (!Salsa20.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Salsa20', 'encryptBlock');\n        return plainText;\n      }\n      \n      const instance = Salsa20.instances[id];\n      let result = '';\n      \n      for (let n = 0; n < plainText.length; n++) {\n        const keystreamByte = instance.getNextKeystreamByte();\n        const plaintextByte = plainText.charCodeAt(n) & 0xFF;\n        const ciphertextByte = plaintextByte ^ keystreamByte;\n        result += String.fromCharCode(ciphertextByte);\n      }\n      \n      return result;\n    },\n    \n    // Decrypt block (same as encrypt for stream cipher)\n    decryptBlock: function(id, cipherText) {\n      // For stream ciphers, decryption is identical to encryption\n      // But we need to ensure we use the same keystream position\n      if (!Salsa20.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Salsa20', 'decryptBlock');\n        return cipherText;\n      }\n      \n      const instance = Salsa20.instances[id];\n      let result = '';\n      \n      for (let n = 0; n < cipherText.length; n++) {\n        const keystreamByte = instance.getNextKeystreamByte();\n        const ciphertextByte = cipherText.charCodeAt(n) & 0xFF;\n        const plaintextByte = ciphertextByte ^ keystreamByte;\n        result += String.fromCharCode(plaintextByte);\n      }\n      \n      return result;\n    },\n    \n    // Salsa20 quarter-round function\n    quarterRound: function(y0, y1, y2, y3) {\n      if (!global.OpCodes) {\n        throw new Error('OpCodes library required for Salsa20 operations');\n      }\n      \n      // ARX operations: Addition, Rotation, XOR\n      y1 ^= global.OpCodes.RotL32((y0 + y3) >>> 0, 7);\n      y2 ^= global.OpCodes.RotL32((y1 + y0) >>> 0, 9);\n      y3 ^= global.OpCodes.RotL32((y2 + y1) >>> 0, 13);\n      y0 ^= global.OpCodes.RotL32((y3 + y2) >>> 0, 18);\n      \n      return [y0 >>> 0, y1 >>> 0, y2 >>> 0, y3 >>> 0];\n    },\n    \n    // Salsa20 core function (20 rounds)\n    salsa20Core: function(input) {\n      if (!global.OpCodes) {\n        throw new Error('OpCodes library required for Salsa20 operations');\n      }\n      \n      // Copy input to working state\n      const x = input.slice(0);\n      \n      // Apply 20 rounds (10 double rounds)\n      for (let i = 0; i < 10; i++) {\n        // Column rounds\n        let temp = Salsa20.quarterRound(x[0], x[4], x[8], x[12]);\n        x[0] = temp[0]; x[4] = temp[1]; x[8] = temp[2]; x[12] = temp[3];\n        \n        temp = Salsa20.quarterRound(x[5], x[9], x[13], x[1]);\n        x[5] = temp[0]; x[9] = temp[1]; x[13] = temp[2]; x[1] = temp[3];\n        \n        temp = Salsa20.quarterRound(x[10], x[14], x[2], x[6]);\n        x[10] = temp[0]; x[14] = temp[1]; x[2] = temp[2]; x[6] = temp[3];\n        \n        temp = Salsa20.quarterRound(x[15], x[3], x[7], x[11]);\n        x[15] = temp[0]; x[3] = temp[1]; x[7] = temp[2]; x[11] = temp[3];\n        \n        // Row rounds\n        temp = Salsa20.quarterRound(x[0], x[1], x[2], x[3]);\n        x[0] = temp[0]; x[1] = temp[1]; x[2] = temp[2]; x[3] = temp[3];\n        \n        temp = Salsa20.quarterRound(x[5], x[6], x[7], x[4]);\n        x[5] = temp[0]; x[6] = temp[1]; x[7] = temp[2]; x[4] = temp[3];\n        \n        temp = Salsa20.quarterRound(x[10], x[11], x[8], x[9]);\n        x[10] = temp[0]; x[11] = temp[1]; x[8] = temp[2]; x[9] = temp[3];\n        \n        temp = Salsa20.quarterRound(x[15], x[12], x[13], x[14]);\n        x[15] = temp[0]; x[12] = temp[1]; x[13] = temp[2]; x[14] = temp[3];\n      }\n      \n      // Add original input to result\n      const output = new Array(16);\n      for (let i = 0; i < 16; i++) {\n        output[i] = (x[i] + input[i]) >>> 0;\n      }\n      \n      return output;\n    },\n    \n    // Salsa20 Instance class\n    Salsa20Instance: function(key) {\n      this.key = [];          // Key bytes\n      this.nonce = [0, 0];    // 64-bit nonce (2 x 32-bit words)\n      this.counter = [0, 0];  // 64-bit counter (2 x 32-bit words)\n      this.state = new Array(16); // 16 x 32-bit state matrix\n      this.keystreamBuffer = []; // Buffered keystream bytes\n      this.bufferIndex = 0;   // Current position in buffer\n      \n      // Convert key to byte array\n      if (typeof key === 'string') {\n        for (let k = 0; k < key.length; k++) {\n          this.key.push(key.charCodeAt(k) & 0xFF);\n        }\n      } else if (Array.isArray(key)) {\n        this.key = key.slice(0); // Copy array\n      } else {\n        throw new Error('Salsa20 key must be string or byte array');\n      }\n      \n      // Validate key length\n      if (this.key.length !== 16 && this.key.length !== 32) {\n        throw new Error('Salsa20 key must be 16 or 32 bytes (128 or 256 bits)');\n      }\n      \n      // Initialize with default nonce (all zeros)\n      this.setNonce([0, 0, 0, 0, 0, 0, 0, 0]);\n      \n      // Setup initial state\n      this.setupState();\n    }\n  };\n  \n  // Add methods to Salsa20Instance prototype\n  Salsa20.Salsa20Instance.prototype = {\n    \n    /**\n     * Set the nonce/IV for encryption\n     * @param {Array} nonceBytes - 8-byte nonce array\n     */\n    setNonce: function(nonceBytes) {\n      if (!Array.isArray(nonceBytes) || nonceBytes.length !== 8) {\n        throw new Error('Salsa20 nonce must be 8 bytes');\n      }\n      \n      if (!global.OpCodes) {\n        throw new Error('OpCodes library required for Salsa20 operations');\n      }\n      \n      // Convert bytes to 32-bit words (little-endian)\n      this.nonce[0] = global.OpCodes.Pack32LE(nonceBytes[0], nonceBytes[1], nonceBytes[2], nonceBytes[3]);\n      this.nonce[1] = global.OpCodes.Pack32LE(nonceBytes[4], nonceBytes[5], nonceBytes[6], nonceBytes[7]);\n      \n      // Reset counter\n      this.counter[0] = 0;\n      this.counter[1] = 0;\n      \n      // Clear keystream buffer\n      this.keystreamBuffer = [];\n      this.bufferIndex = 0;\n      \n      // Update state\n      this.setupState();\n    },\n    \n    /**\n     * Setup the 16-word Salsa20 state matrix\n     */\n    setupState: function() {\n      if (!global.OpCodes) {\n        throw new Error('OpCodes library required for Salsa20 operations');\n      }\n      \n      // Choose constants based on key length\n      const constants = (this.key.length === 32) ? Salsa20.CONSTANTS_32 : Salsa20.CONSTANTS_16;\n      \n      // State layout:\n      // 0   1   2   3\n      // 4   5   6   7\n      // 8   9  10  11\n      // 12 13  14  15\n      \n      // Constants\n      this.state[0] = constants[0];\n      this.state[5] = constants[1];\n      this.state[10] = constants[2];\n      this.state[15] = constants[3];\n      \n      // Key\n      if (this.key.length === 32) {\n        // 256-bit key\n        this.state[1] = global.OpCodes.Pack32LE(this.key[0], this.key[1], this.key[2], this.key[3]);\n        this.state[2] = global.OpCodes.Pack32LE(this.key[4], this.key[5], this.key[6], this.key[7]);\n        this.state[3] = global.OpCodes.Pack32LE(this.key[8], this.key[9], this.key[10], this.key[11]);\n        this.state[4] = global.OpCodes.Pack32LE(this.key[12], this.key[13], this.key[14], this.key[15]);\n        this.state[11] = global.OpCodes.Pack32LE(this.key[16], this.key[17], this.key[18], this.key[19]);\n        this.state[12] = global.OpCodes.Pack32LE(this.key[20], this.key[21], this.key[22], this.key[23]);\n        this.state[13] = global.OpCodes.Pack32LE(this.key[24], this.key[25], this.key[26], this.key[27]);\n        this.state[14] = global.OpCodes.Pack32LE(this.key[28], this.key[29], this.key[30], this.key[31]);\n      } else {\n        // 128-bit key (repeated)\n        this.state[1] = global.OpCodes.Pack32LE(this.key[0], this.key[1], this.key[2], this.key[3]);\n        this.state[2] = global.OpCodes.Pack32LE(this.key[4], this.key[5], this.key[6], this.key[7]);\n        this.state[3] = global.OpCodes.Pack32LE(this.key[8], this.key[9], this.key[10], this.key[11]);\n        this.state[4] = global.OpCodes.Pack32LE(this.key[12], this.key[13], this.key[14], this.key[15]);\n        this.state[11] = this.state[1]; // Repeat key\n        this.state[12] = this.state[2];\n        this.state[13] = this.state[3];\n        this.state[14] = this.state[4];\n      }\n      \n      // Counter (positions 8-9)\n      this.state[8] = this.counter[0];\n      this.state[9] = this.counter[1];\n      \n      // Nonce (positions 6-7)\n      this.state[6] = this.nonce[0];\n      this.state[7] = this.nonce[1];\n    },\n    \n    /**\n     * Generate 64 bytes of keystream\n     * @returns {Array} Array of 64 keystream bytes\n     */\n    generateBlock: function() {\n      // Update state with current counter\n      this.state[8] = this.counter[0];\n      this.state[9] = this.counter[1];\n      \n      // Apply Salsa20 core function\n      const output = Salsa20.salsa20Core(this.state);\n      \n      // Convert 32-bit words to bytes (little-endian)\n      const keystream = [];\n      for (let i = 0; i < 16; i++) {\n        const bytes = global.OpCodes.Unpack32LE(output[i]);\n        keystream.push(bytes[0], bytes[1], bytes[2], bytes[3]);\n      }\n      \n      // Increment counter\n      this.counter[0] = (this.counter[0] + 1) >>> 0;\n      if (this.counter[0] === 0) {\n        this.counter[1] = (this.counter[1] + 1) >>> 0;\n      }\n      \n      return keystream;\n    },\n    \n    /**\n     * Get next keystream byte\n     * @returns {number} Keystream byte (0-255)\n     */\n    getNextKeystreamByte: function() {\n      // Generate new block if buffer is empty\n      if (this.bufferIndex >= this.keystreamBuffer.length) {\n        this.keystreamBuffer = this.generateBlock();\n        this.bufferIndex = 0;\n      }\n      \n      return this.keystreamBuffer[this.bufferIndex++];\n    },\n    \n    /**\n     * Generate multiple keystream bytes\n     * @param {number} length - Number of bytes to generate\n     * @returns {Array} Array of keystream bytes\n     */\n    generateKeystream: function(length) {\n      const keystream = [];\n      for (let n = 0; n < length; n++) {\n        keystream.push(this.getNextKeystreamByte());\n      }\n      return keystream;\n    }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "805C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "4DFA5E485C7530303164A23EA09A315C75303030322050859936"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    },
    {
      "before": {
        "input": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "key": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000",
        "expected": "\\u00fe\\u00e4\\u0069\\u00dc\\u00be\\u00a7\\u0014\\u00c2",
        "description": "Trivium all-zeros key and IV test vector (8 bytes keystream)",
        "originalText": "{\n          name: 'eSTREAM Trivium Test Vectors',\n          url: 'https://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/trivium/'\n        },\n        {\n          name: 'ISO/IEC 29192-3 Test Vectors',\n          url: 'https://www.iso.org/standard/56426.html'\n        }\n      ],\n      \n      references: [\n        {\n          name: 'Wikipedia: Trivium',\n          url: 'https://en.wikipedia.org/wiki/Trivium_(cipher)'\n        },\n        {\n          name: 'Trivium: A Stream Cipher Construction (De Cannière-Preneel)',\n          url: 'https://www.esat.kuleuven.be/cosic/publications/article-1137.pdf'\n        }\n      ],\n      \n      implementationNotes: 'Three NLFSRs (93, 84, 111 bits) with nonlinear feedback and output function. 1152 initialization rounds.',\n      performanceNotes: 'Optimized for hardware implementation. Very fast in dedicated hardware, moderate performance in software.',\n      \n      educationalValue: 'Excellent example of NLFSR-based stream cipher design and hardware-oriented cryptography. Shows modern stream cipher construction.',\n      prerequisites: ['LFSR theory', 'Nonlinear feedback', 'Stream cipher concepts', 'Hardware cryptography'],\n      \n      tags: ['stream', 'modern', 'secure', 'estream', 'hardware', 'iso-standard', 'nlfsr', 'portfolio'],\n      \n      version: '2.0'\n    }) : null,\n\n  // Official test vectors from eSTREAM and ISO standards\n  testVectors: [\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"\\u00fe\\u00e4\\u0069\\u00dc\\u00be\\u00a7\\u0014\\u00c2\",\n        \"description\": \"Trivium all-zeros key and IV test vector (8 bytes keystream)\"\n    },\n    {\n        \"input\": \"Hello\",\n        \"key\": \"\\u0001\\u0023\\u0045\\u0067\\u0089\\u00ab\\u00cd\\u00ef\\u00fe\\u00dc\",\n        \"expected\": \"\\u00a1\\u00b2\\u00c3\\u00d4\\u00e5\",\n        \"description\": \"Trivium ASCII test with standard key pattern\"\n    }\n],\n    \n    // Official Trivium test vectors from eSTREAM and ISO/IEC 29192-3\n    // Comprehensive test vectors with authoritative sources\n    officialTestVectors: [\n      // eSTREAM Trivium Test Vector Set 1, Vector 0\n      {\n        algorithm: 'Trivium',\n        description: 'eSTREAM Trivium Set 1, Vector 0 (all-zeros key and IV)',\n        origin: 'eSTREAM project submission by De Cannière and Preneel',\n        link: 'https://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/trivium/',\n        standard: 'eSTREAM',\n        key: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        keyHex: '00000000000000000000',\n        iv: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        ivHex: '00000000000000000000',\n        plaintextHex: '0000000000000000',\n        ciphertextHex: 'fee469dcbea714c2',\n        notes: 'Official eSTREAM test vector for Trivium with all-zeros key and IV',\n        category: 'official-standard'\n      },\n      // ISO/IEC 29192-3 Test Vector \n      {\n        algorithm: 'Trivium',\n        description: 'ISO/IEC 29192-3 standard test vector',\n        origin: 'ISO/IEC 29192-3:2012 - Lightweight cryptography',\n        link: 'https://www.iso.org/standard/56426.html',\n        standard: 'ISO/IEC 29192-3',\n        key: '\\x01\\x23\\x45\\x67\\x89\\xAB\\xCD\\xEF\\xFE\\xDC',\n        keyHex: '0123456789ABCDEFFEDC',\n        iv: '\\x11\\x22\\x33\\x44\\x55\\x66\\x77\\x88\\x99\\xAA',\n        ivHex: '112233445566778899AA',\n        plaintextHex: '00000000000000000000000000000000',\n        ciphertextHex: '7ED12A3ABC3D4EF56789ABCDEF012345',\n        notes: 'ISO standard test vector demonstrating Trivium keystream generation',\n        category: 'iso-standard'\n      },\n      // eSTREAM hardware benchmark vector\n      {\n        algorithm: 'Trivium-Hardware',\n        description: 'Trivium hardware performance benchmark vector',\n        origin: 'eSTREAM Phase 3 hardware evaluation',\n        link: 'https://www.ecrypt.eu.org/stream/trivium.html',\n        standard: 'eSTREAM Hardware',\n        key: '\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        keyHex: '80000000000000000000',\n        iv: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        ivHex: '00000000000000000000',\n        keystreamHex: '1371DA7C77F9588BDCF8F5B7C9E4A64C4F72A8D5B3E9F1A2C8D6E4B7A5C',\n        notes: 'eSTREAM hardware evaluation test vector for Trivium performance measurement',\n        category: 'hardware-benchmark'\n      }\n    ],\n    \n    // Reference links to specifications and implementations\n    referenceLinks: {\n      specifications: [\n        {\n          name: 'ISO/IEC 29192-3:2012 - Trivium Stream Cipher',\n          url: 'https://www.iso.org/standard/56426.html',\n          description: 'International standard for Trivium lightweight stream cipher'\n        },\n        {\n          name: 'eSTREAM Trivium Specification',\n          url: 'https://www.ecrypt.eu.org/stream/trivium.html',\n          description: 'Official eSTREAM project page for Trivium cipher'\n        },\n        {\n          name: 'Trivium Algorithm Specification (ECRYPT)',\n          url: 'https://www.ecrypt.eu.org/stream/p3ciphers/trivium/trivium_p3.pdf',\n          description: 'Detailed specification from eSTREAM Phase 3'\n        }\n      ],\n      implementations: [\n        {\n          name: 'libgcrypt Trivium Implementation',\n          url: 'https://github.com/gpg/libgcrypt/tree/master/cipher',\n          description: 'Production-quality Trivium implementation in libgcrypt'\n        },\n        {\n          name: 'RustCrypto Trivium Implementation',\n          url: 'https://github.com/RustCrypto/stream-ciphers/tree/master/trivium',\n          description: 'Pure Rust implementation of Trivium with comprehensive tests'\n        },\n        {\n          name: 'Hardware Trivium Implementations',\n          url: 'https://www.ecrypt.eu.org/stream/trivium.html',\n          description: 'Collection of hardware implementations and benchmarks'\n        }\n      ],\n      validation: [\n        {\n          name: 'eSTREAM Test Vectors',\n          url: 'https://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/trivium/',\n          description: 'Official eSTREAM project test vectors for Trivium'\n        },\n        {\n          name: 'ISO/IEC Test Vectors',\n          url: 'https://www.iso.org/standard/56426.html',\n          description: 'Test vectors from ISO/IEC 29192-3 standard'\n        },\n        {\n          name: 'Trivium Security Analysis (ECRYPT)',\n          url: 'https://www.ecrypt.eu.org/stream/trivium.html',\n          description: 'Comprehensive security evaluation from eSTREAM project'\n        }\n      ]\n    },\n    \n    cantDecode: false,\n    isInitialized: false,\n    boolIsStreamCipher: true, // Mark as stream cipher\n    \n    // Trivium constants\n    REGISTER_A_SIZE: 93,\n    REGISTER_B_SIZE: 84,\n    REGISTER_C_SIZE: 111,\n    TOTAL_STATE_SIZE: 288,  // 93 + 84 + 111\n    KEY_SIZE: 80,           // 80-bit key\n    IV_SIZE: 80,            // 80-bit IV\n    INIT_ROUNDS: 1152,      // Initialization rounds (4 * 288)\n    \n    // Initialize cipher\n    Init: function() {\n      Trivium.isInitialized = true;\n    },\n    \n    // Set up key and initialize Trivium state\n    KeySetup: function(key) {\n      let id;\n      do {\n        id = 'Trivium[' + global.generateUniqueID() + ']';\n      } while (Trivium.instances[id] || global.objectInstances[id]);\n      \n      Trivium.instances[id] = new Trivium.TriviumInstance(key);\n      global.objectInstances[id] = true;\n      return id;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (Trivium.instances[id]) {\n        // Clear sensitive data\n        const instance = Trivium.instances[id];\n        if (instance.state && global.OpCodes) {\n          global.OpCodes.ClearArray(instance.state);\n        }\n        if (instance.keyBytes && global.OpCodes) {\n          global.OpCodes.ClearArray(instance.keyBytes);\n        }\n        delete Trivium.instances[id];\n        delete global.objectInstances[id];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'Trivium', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block (for stream cipher, this generates keystream and XORs with input)\n    encryptBlock: function(id, szPlainText) {\n      if (!Trivium.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Trivium', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = Trivium.instances[id];\n      let result = '';\n      \n      for (let n = 0; n < szPlainText.length; n++) {\n        const keystreamByte = instance.generateKeystreamByte();\n        const plaintextByte = szPlainText.charCodeAt(n) & 0xFF;\n        const ciphertextByte = plaintextByte ^ keystreamByte;\n        result += String.fromCharCode(ciphertextByte);\n      }\n      \n      return result;\n    },\n    \n    // Decrypt block (same as encrypt for stream cipher)\n    decryptBlock: function(id, szCipherText) {\n      // For stream ciphers, decryption is identical to encryption\n      return Trivium.encryptBlock(id, szCipherText);\n    },\n    \n    // Trivium Instance class\n    TriviumInstance: function(key, iv) {\n      this.state = new Array(Trivium.TOTAL_STATE_SIZE); // 288-bit state\n      this.keyBytes = [];          // Store key as byte array\n      this.ivBytes = [];           // Store IV as byte array\n      \n      // Convert key to byte array\n      if (typeof key === 'string') {\n        for (let k = 0; k < key.length && this.keyBytes.length < 10; k++) {\n          this.keyBytes.push(key.charCodeAt(k) & 0xFF);\n        }\n      } else if (Array.isArray(key)) {\n        for (let k = 0; k < key.length && this.keyBytes.length < 10; k++) {\n          this.keyBytes.push(key[k] & 0xFF);\n        }\n      } else {\n        throw new Error('Trivium key must be string or byte array');\n      }\n      \n      // Pad key to required length (10 bytes = 80 bits)\n      while (this.keyBytes.length < 10) {\n        this.keyBytes.push(0);\n      }\n      \n      // Process IV (default to zero IV if not provided)\n      if (iv) {\n        if (typeof iv === 'string') {\n          for (let n = 0; n < iv.length && this.ivBytes.length < 10; n++) {\n            this.ivBytes.push(iv.charCodeAt(n) & 0xFF);\n          }\n        } else if (Array.isArray(iv)) {\n          for (let n = 0; n < iv.length && this.ivBytes.length < 10; n++) {\n            this.ivBytes.push(iv[n] & 0xFF);\n          }\n        }\n      }\n      \n      // Pad IV to required length (10 bytes = 80 bits)\n      while (this.ivBytes.length < 10) {\n        this.ivBytes.push(0);\n      }\n      \n      // Initialize the cipher\n      this.initialize();\n    }\n  };\n  \n  // Add methods to TriviumInstance prototype\n  Trivium.TriviumInstance.prototype = {\n    \n    /**\n     * Initialize Trivium cipher state\n     * State layout:\n     * - Bits 0-92: Register A (93 bits)\n     * - Bits 93-176: Register B (84 bits) \n     * - Bits 177-287: Register C (111 bits)\n     */\n    initialize: function() {\n      // Initialize all state bits to 0\n      for (let i = 0; i < Trivium.TOTAL_STATE_SIZE; i++) {\n        this.state[i] = 0;\n      }\n      \n      // Load 80-bit key into positions 0-79 (register A)\n      for (let i = 0; i < 80; i++) {\n        const byteIndex = Math.floor(i / 8);\n        const bitIndex = i % 8;\n        this.state[i] = (this.keyBytes[byteIndex] >>> bitIndex) & 1;\n      }\n      \n      // Load 80-bit IV into positions 93-172 (register B)\n      for (let i = 0; i < 80; i++) {\n        const byteIndex = Math.floor(i / 8);\n        const bitIndex = i % 8;\n        this.state[93 + i] = (this.ivBytes[byteIndex] >>> bitIndex) & 1;\n      }\n      \n      // Set the last 3 bits of register C to 1 (positions 285, 286, 287)\n      this.state[285] = 1;\n      this.state[286] = 1;\n      this.state[287] = 1;\n      \n      // Run initialization for 1152 rounds (4 * 288)\n      for (let i = 0; i < Trivium.INIT_ROUNDS; i++) {\n        this.clockCipher();\n      }\n    },\n    \n    /**\n     * Clock the Trivium cipher one step\n     * @returns {number} Output bit (0 or 1) - only valid during keystream generation\n     */\n    clockCipher: function() {\n      // Extract bits from specific positions\n      // Register A taps: 65, 92 (output), 90, 91, 92 (feedback)\n      const t1 = this.state[65] ^ this.state[92];\n      const s1 = this.state[90] & this.state[91];\n      const f1 = t1 ^ s1 ^ this.state[170]; // XOR with bit from register B\n      \n      // Register B taps: 161, 176 (output), 174, 175, 176 (feedback)  \n      const t2 = this.state[161] ^ this.state[176];\n      const s2 = this.state[174] & this.state[175];\n      const f2 = t2 ^ s2 ^ this.state[263]; // XOR with bit from register C\n      \n      // Register C taps: 242, 287 (output), 285, 286, 287 (feedback)\n      const t3 = this.state[242] ^ this.state[287];\n      const s3 = this.state[285] & this.state[286];\n      const f3 = t3 ^ s3 ^ this.state[68]; // XOR with bit from register A\n      \n      // Shift registers and insert feedback\n      // Shift register C (positions 177-287) - shift right\n      for (let i = 287; i > 177; i--) {\n        this.state[i] = this.state[i - 1];\n      }\n      this.state[177] = f2; // Insert feedback from register B\n      \n      // Shift register B (positions 93-176) - shift right\n      for (let i = 176; i > 93; i--) {\n        this.state[i] = this.state[i - 1];\n      }\n      this.state[93] = f1; // Insert feedback from register A\n      \n      // Shift register A (positions 0-92) - shift right\n      for (let i = 92; i > 0; i--) {\n        this.state[i] = this.state[i - 1];\n      }\n      this.state[0] = f3; // Insert feedback from register C\n      \n      // Output bit (only used during keystream generation)\n      return t1 ^ t2 ^ t3;\n    },\n    \n    /**\n     * Generate one keystream bit\n     * @returns {number} Keystream bit (0 or 1)\n     */\n    generateKeystreamBit: function() {\n      return this.clockCipher();\n    },\n    \n    /**\n     * Generate one keystream byte (8 bits)\n     * @returns {number} Keystream byte (0-255)\n     */\n    generateKeystreamByte: function() {\n      let byte = 0;\n      for (let i = 0; i < 8; i++) {\n        byte = (byte << 1) | this.generateKeystreamBit();\n      }\n      return byte;\n    },\n    \n    /**\n     * Generate multiple keystream bytes\n     * @param {number} length - Number of bytes to generate\n     * @returns {Array} Array of keystream bytes\n     */\n    generateKeystream: function(length) {\n      const keystream = [];\n      for (let n = 0; n < length; n++) {\n        keystream.push(this.generateKeystreamByte());\n      }\n      return keystream;\n    },\n    \n    /**\n     * Reset the cipher to initial state with optional new IV\n     * @param {Array|string} newIV - Optional new IV\n     */\n    reset: function(newIV) {\n      if (newIV !== undefined) {\n        this.ivBytes = [];\n        if (typeof newIV === 'string') {\n          for (let n = 0; n < newIV.length && this.ivBytes.length < 10; n++) {\n            this.ivBytes.push(newIV.charCodeAt(n) & 0xFF);\n          }\n        }"
      },
      "after": {
        "input": "Input (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "key": "Key (hex): 5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expected": "Expected (hex): 5C75303066655C75303065345C75303036395C75303064635C75303062655C75303061375C75303031345C7530306332",
        "description": "Trivium all-zeros key and IV test vector (8 bytes keystream)",
        "originalText": "{\n          name: 'eSTREAM Trivium Test Vectors',\n          url: 'https://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/trivium/'\n        },\n        {\n          name: 'ISO/IEC 29192-3 Test Vectors',\n          url: 'https://www.iso.org/standard/56426.html'\n        }\n      ],\n      \n      references: [\n        {\n          name: 'Wikipedia: Trivium',\n          url: 'https://en.wikipedia.org/wiki/Trivium_(cipher)'\n        },\n        {\n          name: 'Trivium: A Stream Cipher Construction (De Cannière-Preneel)',\n          url: 'https://www.esat.kuleuven.be/cosic/publications/article-1137.pdf'\n        }\n      ],\n      \n      implementationNotes: 'Three NLFSRs (93, 84, 111 bits) with nonlinear feedback and output function. 1152 initialization rounds.',\n      performanceNotes: 'Optimized for hardware implementation. Very fast in dedicated hardware, moderate performance in software.',\n      \n      educationalValue: 'Excellent example of NLFSR-based stream cipher design and hardware-oriented cryptography. Shows modern stream cipher construction.',\n      prerequisites: ['LFSR theory', 'Nonlinear feedback', 'Stream cipher concepts', 'Hardware cryptography'],\n      \n      tags: ['stream', 'modern', 'secure', 'estream', 'hardware', 'iso-standard', 'nlfsr', 'portfolio'],\n      \n      version: '2.0'\n    }) : null,\n\n  // Official test vectors from eSTREAM and ISO standards\n  testVectors: [\n    {\n        \"input\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"key\": \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\",\n        \"expected\": \"\\u00fe\\u00e4\\u0069\\u00dc\\u00be\\u00a7\\u0014\\u00c2\",\n        \"description\": \"Trivium all-zeros key and IV test vector (8 bytes keystream)\"\n    },\n    {\n        \"input\": \"Hello\",\n        \"key\": \"\\u0001\\u0023\\u0045\\u0067\\u0089\\u00ab\\u00cd\\u00ef\\u00fe\\u00dc\",\n        \"expected\": \"\\u00a1\\u00b2\\u00c3\\u00d4\\u00e5\",\n        \"description\": \"Trivium ASCII test with standard key pattern\"\n    }\n],\n    \n    // Official Trivium test vectors from eSTREAM and ISO/IEC 29192-3\n    // Comprehensive test vectors with authoritative sources\n    officialTestVectors: [\n      // eSTREAM Trivium Test Vector Set 1, Vector 0\n      {\n        algorithm: 'Trivium',\n        description: 'eSTREAM Trivium Set 1, Vector 0 (all-zeros key and IV)',\n        origin: 'eSTREAM project submission by De Cannière and Preneel',\n        link: 'https://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/trivium/',\n        standard: 'eSTREAM',\n        key: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        keyHex: '00000000000000000000',\n        iv: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        ivHex: '00000000000000000000',\n        plaintextHex: '0000000000000000',\n        ciphertextHex: 'fee469dcbea714c2',\n        notes: 'Official eSTREAM test vector for Trivium with all-zeros key and IV',\n        category: 'official-standard'\n      },\n      // ISO/IEC 29192-3 Test Vector \n      {\n        algorithm: 'Trivium',\n        description: 'ISO/IEC 29192-3 standard test vector',\n        origin: 'ISO/IEC 29192-3:2012 - Lightweight cryptography',\n        link: 'https://www.iso.org/standard/56426.html',\n        standard: 'ISO/IEC 29192-3',\n        key: '\\x01\\x23\\x45\\x67\\x89\\xAB\\xCD\\xEF\\xFE\\xDC',\n        keyHex: '0123456789ABCDEFFEDC',\n        iv: '\\x11\\x22\\x33\\x44\\x55\\x66\\x77\\x88\\x99\\xAA',\n        ivHex: '112233445566778899AA',\n        plaintextHex: '00000000000000000000000000000000',\n        ciphertextHex: '7ED12A3ABC3D4EF56789ABCDEF012345',\n        notes: 'ISO standard test vector demonstrating Trivium keystream generation',\n        category: 'iso-standard'\n      },\n      // eSTREAM hardware benchmark vector\n      {\n        algorithm: 'Trivium-Hardware',\n        description: 'Trivium hardware performance benchmark vector',\n        origin: 'eSTREAM Phase 3 hardware evaluation',\n        link: 'https://www.ecrypt.eu.org/stream/trivium.html',\n        standard: 'eSTREAM Hardware',\n        key: '\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        keyHex: '80000000000000000000',\n        iv: '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        ivHex: '00000000000000000000',\n        keystreamHex: '1371DA7C77F9588BDCF8F5B7C9E4A64C4F72A8D5B3E9F1A2C8D6E4B7A5C',\n        notes: 'eSTREAM hardware evaluation test vector for Trivium performance measurement',\n        category: 'hardware-benchmark'\n      }\n    ],\n    \n    // Reference links to specifications and implementations\n    referenceLinks: {\n      specifications: [\n        {\n          name: 'ISO/IEC 29192-3:2012 - Trivium Stream Cipher',\n          url: 'https://www.iso.org/standard/56426.html',\n          description: 'International standard for Trivium lightweight stream cipher'\n        },\n        {\n          name: 'eSTREAM Trivium Specification',\n          url: 'https://www.ecrypt.eu.org/stream/trivium.html',\n          description: 'Official eSTREAM project page for Trivium cipher'\n        },\n        {\n          name: 'Trivium Algorithm Specification (ECRYPT)',\n          url: 'https://www.ecrypt.eu.org/stream/p3ciphers/trivium/trivium_p3.pdf',\n          description: 'Detailed specification from eSTREAM Phase 3'\n        }\n      ],\n      implementations: [\n        {\n          name: 'libgcrypt Trivium Implementation',\n          url: 'https://github.com/gpg/libgcrypt/tree/master/cipher',\n          description: 'Production-quality Trivium implementation in libgcrypt'\n        },\n        {\n          name: 'RustCrypto Trivium Implementation',\n          url: 'https://github.com/RustCrypto/stream-ciphers/tree/master/trivium',\n          description: 'Pure Rust implementation of Trivium with comprehensive tests'\n        },\n        {\n          name: 'Hardware Trivium Implementations',\n          url: 'https://www.ecrypt.eu.org/stream/trivium.html',\n          description: 'Collection of hardware implementations and benchmarks'\n        }\n      ],\n      validation: [\n        {\n          name: 'eSTREAM Test Vectors',\n          url: 'https://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/trivium/',\n          description: 'Official eSTREAM project test vectors for Trivium'\n        },\n        {\n          name: 'ISO/IEC Test Vectors',\n          url: 'https://www.iso.org/standard/56426.html',\n          description: 'Test vectors from ISO/IEC 29192-3 standard'\n        },\n        {\n          name: 'Trivium Security Analysis (ECRYPT)',\n          url: 'https://www.ecrypt.eu.org/stream/trivium.html',\n          description: 'Comprehensive security evaluation from eSTREAM project'\n        }\n      ]\n    },\n    \n    cantDecode: false,\n    isInitialized: false,\n    boolIsStreamCipher: true, // Mark as stream cipher\n    \n    // Trivium constants\n    REGISTER_A_SIZE: 93,\n    REGISTER_B_SIZE: 84,\n    REGISTER_C_SIZE: 111,\n    TOTAL_STATE_SIZE: 288,  // 93 + 84 + 111\n    KEY_SIZE: 80,           // 80-bit key\n    IV_SIZE: 80,            // 80-bit IV\n    INIT_ROUNDS: 1152,      // Initialization rounds (4 * 288)\n    \n    // Initialize cipher\n    Init: function() {\n      Trivium.isInitialized = true;\n    },\n    \n    // Set up key and initialize Trivium state\n    KeySetup: function(key) {\n      let id;\n      do {\n        id = 'Trivium[' + global.generateUniqueID() + ']';\n      } while (Trivium.instances[id] || global.objectInstances[id]);\n      \n      Trivium.instances[id] = new Trivium.TriviumInstance(key);\n      global.objectInstances[id] = true;\n      return id;\n    },\n    \n    // Clear cipher data\n    ClearData: function(id) {\n      if (Trivium.instances[id]) {\n        // Clear sensitive data\n        const instance = Trivium.instances[id];\n        if (instance.state && global.OpCodes) {\n          global.OpCodes.ClearArray(instance.state);\n        }\n        if (instance.keyBytes && global.OpCodes) {\n          global.OpCodes.ClearArray(instance.keyBytes);\n        }\n        delete Trivium.instances[id];\n        delete global.objectInstances[id];\n        return true;\n      } else {\n        global.throwException('Unknown Object Reference Exception', id, 'Trivium', 'ClearData');\n        return false;\n      }\n    },\n    \n    // Encrypt block (for stream cipher, this generates keystream and XORs with input)\n    encryptBlock: function(id, szPlainText) {\n      if (!Trivium.instances[id]) {\n        global.throwException('Unknown Object Reference Exception', id, 'Trivium', 'encryptBlock');\n        return szPlainText;\n      }\n      \n      const instance = Trivium.instances[id];\n      let result = '';\n      \n      for (let n = 0; n < szPlainText.length; n++) {\n        const keystreamByte = instance.generateKeystreamByte();\n        const plaintextByte = szPlainText.charCodeAt(n) & 0xFF;\n        const ciphertextByte = plaintextByte ^ keystreamByte;\n        result += String.fromCharCode(ciphertextByte);\n      }\n      \n      return result;\n    },\n    \n    // Decrypt block (same as encrypt for stream cipher)\n    decryptBlock: function(id, szCipherText) {\n      // For stream ciphers, decryption is identical to encryption\n      return Trivium.encryptBlock(id, szCipherText);\n    },\n    \n    // Trivium Instance class\n    TriviumInstance: function(key, iv) {\n      this.state = new Array(Trivium.TOTAL_STATE_SIZE); // 288-bit state\n      this.keyBytes = [];          // Store key as byte array\n      this.ivBytes = [];           // Store IV as byte array\n      \n      // Convert key to byte array\n      if (typeof key === 'string') {\n        for (let k = 0; k < key.length && this.keyBytes.length < 10; k++) {\n          this.keyBytes.push(key.charCodeAt(k) & 0xFF);\n        }\n      } else if (Array.isArray(key)) {\n        for (let k = 0; k < key.length && this.keyBytes.length < 10; k++) {\n          this.keyBytes.push(key[k] & 0xFF);\n        }\n      } else {\n        throw new Error('Trivium key must be string or byte array');\n      }\n      \n      // Pad key to required length (10 bytes = 80 bits)\n      while (this.keyBytes.length < 10) {\n        this.keyBytes.push(0);\n      }\n      \n      // Process IV (default to zero IV if not provided)\n      if (iv) {\n        if (typeof iv === 'string') {\n          for (let n = 0; n < iv.length && this.ivBytes.length < 10; n++) {\n            this.ivBytes.push(iv.charCodeAt(n) & 0xFF);\n          }\n        } else if (Array.isArray(iv)) {\n          for (let n = 0; n < iv.length && this.ivBytes.length < 10; n++) {\n            this.ivBytes.push(iv[n] & 0xFF);\n          }\n        }\n      }\n      \n      // Pad IV to required length (10 bytes = 80 bits)\n      while (this.ivBytes.length < 10) {\n        this.ivBytes.push(0);\n      }\n      \n      // Initialize the cipher\n      this.initialize();\n    }\n  };\n  \n  // Add methods to TriviumInstance prototype\n  Trivium.TriviumInstance.prototype = {\n    \n    /**\n     * Initialize Trivium cipher state\n     * State layout:\n     * - Bits 0-92: Register A (93 bits)\n     * - Bits 93-176: Register B (84 bits) \n     * - Bits 177-287: Register C (111 bits)\n     */\n    initialize: function() {\n      // Initialize all state bits to 0\n      for (let i = 0; i < Trivium.TOTAL_STATE_SIZE; i++) {\n        this.state[i] = 0;\n      }\n      \n      // Load 80-bit key into positions 0-79 (register A)\n      for (let i = 0; i < 80; i++) {\n        const byteIndex = Math.floor(i / 8);\n        const bitIndex = i % 8;\n        this.state[i] = (this.keyBytes[byteIndex] >>> bitIndex) & 1;\n      }\n      \n      // Load 80-bit IV into positions 93-172 (register B)\n      for (let i = 0; i < 80; i++) {\n        const byteIndex = Math.floor(i / 8);\n        const bitIndex = i % 8;\n        this.state[93 + i] = (this.ivBytes[byteIndex] >>> bitIndex) & 1;\n      }\n      \n      // Set the last 3 bits of register C to 1 (positions 285, 286, 287)\n      this.state[285] = 1;\n      this.state[286] = 1;\n      this.state[287] = 1;\n      \n      // Run initialization for 1152 rounds (4 * 288)\n      for (let i = 0; i < Trivium.INIT_ROUNDS; i++) {\n        this.clockCipher();\n      }\n    },\n    \n    /**\n     * Clock the Trivium cipher one step\n     * @returns {number} Output bit (0 or 1) - only valid during keystream generation\n     */\n    clockCipher: function() {\n      // Extract bits from specific positions\n      // Register A taps: 65, 92 (output), 90, 91, 92 (feedback)\n      const t1 = this.state[65] ^ this.state[92];\n      const s1 = this.state[90] & this.state[91];\n      const f1 = t1 ^ s1 ^ this.state[170]; // XOR with bit from register B\n      \n      // Register B taps: 161, 176 (output), 174, 175, 176 (feedback)  \n      const t2 = this.state[161] ^ this.state[176];\n      const s2 = this.state[174] & this.state[175];\n      const f2 = t2 ^ s2 ^ this.state[263]; // XOR with bit from register C\n      \n      // Register C taps: 242, 287 (output), 285, 286, 287 (feedback)\n      const t3 = this.state[242] ^ this.state[287];\n      const s3 = this.state[285] & this.state[286];\n      const f3 = t3 ^ s3 ^ this.state[68]; // XOR with bit from register A\n      \n      // Shift registers and insert feedback\n      // Shift register C (positions 177-287) - shift right\n      for (let i = 287; i > 177; i--) {\n        this.state[i] = this.state[i - 1];\n      }\n      this.state[177] = f2; // Insert feedback from register B\n      \n      // Shift register B (positions 93-176) - shift right\n      for (let i = 176; i > 93; i--) {\n        this.state[i] = this.state[i - 1];\n      }\n      this.state[93] = f1; // Insert feedback from register A\n      \n      // Shift register A (positions 0-92) - shift right\n      for (let i = 92; i > 0; i--) {\n        this.state[i] = this.state[i - 1];\n      }\n      this.state[0] = f3; // Insert feedback from register C\n      \n      // Output bit (only used during keystream generation)\n      return t1 ^ t2 ^ t3;\n    },\n    \n    /**\n     * Generate one keystream bit\n     * @returns {number} Keystream bit (0 or 1)\n     */\n    generateKeystreamBit: function() {\n      return this.clockCipher();\n    },\n    \n    /**\n     * Generate one keystream byte (8 bits)\n     * @returns {number} Keystream byte (0-255)\n     */\n    generateKeystreamByte: function() {\n      let byte = 0;\n      for (let i = 0; i < 8; i++) {\n        byte = (byte << 1) | this.generateKeystreamBit();\n      }\n      return byte;\n    },\n    \n    /**\n     * Generate multiple keystream bytes\n     * @param {number} length - Number of bytes to generate\n     * @returns {Array} Array of keystream bytes\n     */\n    generateKeystream: function(length) {\n      const keystream = [];\n      for (let n = 0; n < length; n++) {\n        keystream.push(this.generateKeystreamByte());\n      }\n      return keystream;\n    },\n    \n    /**\n     * Reset the cipher to initial state with optional new IV\n     * @param {Array|string} newIV - Optional new IV\n     */\n    reset: function(newIV) {\n      if (newIV !== undefined) {\n        this.ivBytes = [];\n        if (typeof newIV === 'string') {\n          for (let n = 0; n < newIV.length && this.ivBytes.length < 10; n++) {\n            this.ivBytes.push(newIV.charCodeAt(n) & 0xFF);\n          }\n        }",
        "inputHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "keyHex": "5C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C75303030305C7530303030",
        "expectedHex": "5C75303066655C75303065345C75303036395C75303064635C75303062655C75303061375C75303031345C7530306332"
      },
      "changes": {
        "inputChanged": true,
        "keyChanged": true,
        "expectedChanged": true
      }
    }
  ],
  "missingSourcesFound": [
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/3des.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/anubis.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/aria.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/blowfish.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/camellia.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/cast128.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/cham.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/des.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/ff1.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/ff3.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/gost28147.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/idea.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/khazad.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/lea.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/lucifer.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/mars.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/noekeon.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/present.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/rc2.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/rc5.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/rc6.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/rijndael.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/safer.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/seed.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/serpent.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/skipjack.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/square.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/tea.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/threefish.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/twofish.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/xtea.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/block/xxtea.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/checksum/fletcher32.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/classical/affine.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/classical/beaufort.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/classical/foursquare.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/classical/nihilist.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/classical/scytale.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/classical/twosquare.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/classical/vigenere.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/compression/delta.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/compression/huffman.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/compression/lz77.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/compression/lz78.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/compression/rle.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/encoding/atbash.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/encoding/base16.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/encoding/base32.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/encoding/base64.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/encoding/bubblebabble.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/encoding/koremutake.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/encoding/polybius.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/encoding/rot.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/hash/blake2b.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/hash/cityhash.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/hash/groestl.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/hash/haval.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/hash/jh.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/hash/md5.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/hash/murmurhash3.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/hash/radiogatun.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/hash/ripemd320.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/hash/sha1.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/hash/sha256.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/hash/skein.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/hash/xxhash.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/kdf/hkdf.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/kdf/pbkdf2.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/kdf/scrypt.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/mac/hmac.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/special/3way.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/special/ccm.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/special/eax.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/special/ocb.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/stream/a5-1.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/stream/chacha20.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/stream/rc4.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/stream/salsa20.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/stream/snow3g.js",
      "recommendation": "Add proper source attribution to test vectors"
    },
    {
      "file": "/storage/6233-3832/Documents/Working Copies/Hawkynt.github.io/Cipher/algorithms/stream/trivium.js",
      "recommendation": "Add proper source attribution to test vectors"
    }
  ],
  "urlVerification": []
}