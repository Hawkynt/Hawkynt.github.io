<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="page_title" content="Cipher/JavaScript" />
    <meta name="page_version" content="v1.0" />
    <meta name="description" content="»SynthelicZ« Cryptographic Tools - Educational cipher implementations for defensive security analysis" />
    <meta name="keywords" content="cryptography, cipher, encryption, educational, security, analysis" />
    <meta name="author" content="Hawkynt" />
    <meta name="robots" content="follow,index" />
    <meta name="google-site-verification" content="LkZ6DT0_GlcimQOKrWL20jv4jtUh0DBsh1ZPLXQqk3A" />
    <link rel="shortcut icon" href="../favicon.ico" />
    <title>»SynthelicZ« Cipher/JavaScript</title>
    <!-- External Files -->
    <script src="./xdom.js"></script>
    <script src="./cipher.js"></script>
    <!-- Source for the Ciphers I implemented                                                   -->
    <!-- http://www.cipherbox.de/                                                               -->
    <!-- http://paginas.terra.com.br/informatica/paulobarreto/                                  -->
    <!-- Source for the Hashes I implemented                                                    -->
    <!-- http://www.pajhome.org.uk/crypt/                                                       -->
    <!-- =========================[ CONVERTER ]================================================ -->
      <script src="./base64.js"></script>
      <script src="./bubblebabble.js"></script>
      <script src="./koremutake.js"></script>
    <!-- =========================[ STREAM CIPHERS ]=========================================== -->
      <!-- =======================[ SUBSTITUTION CIPHERS ]===================================== -->
        <script src="./atbash.js"></script>
        <script src="./mystery.js"></script>
      <!-- =======================[ SHIFT CIPHERS ]============================================ -->
        <script src="./caesar.js"></script>
        <script src="./rot.js"></script>
    <!-- =========================[ BLOCK CIPHERS ]============================================ -->
      <!-- =======================[ STRONG CIPHERS ]=========================================== -->
        <script src="./rijndael.js"></script>
        <script src="./blowfish.js"></script>
        <script src="./anubis.js"></script>
        <script src="./khazad.js"></script>
      <!-- =======================[ WEAK CIPHERS ]============================================= -->
        <script src="./tea.js"></script>
    <!-- =========================[ STREAM COMPRESSORS ]======================================= -->
      <script src="./lzss.js"></script>
    <!-- External Styles -->
    <link rel="stylesheet" href="./styles.css" type="text/css" />
    <script>
      // Modern JavaScript with legacy fallbacks
      (function() {
        'use strict';
        
        // Initialize
        document.title = '»SynthelicZ« ' + (getMetaContent('Page_Title') || 'Cipher/JavaScript') + ' ' + (getMetaContent('Page_version') || 'v1.0');
        
        if (typeof BASE64 !== 'undefined' && BASE64.Init) {
          BASE64.Init();
        }
        
        var szBASE64ID;
        if (typeof BASE64 !== 'undefined' && BASE64.KeySetup) {
          szBASE64ID = BASE64.KeySetup();
        }
        
        // Global variables (for legacy compatibility)
        window.szCipher = ''; // Currently used Cipher Name
        window.arrStrings = {}; // Use object instead of array for better property access
        window.szBASE64ID = szBASE64ID;
      
        // Initialize body
        window.BodyInit = function() {
          if (typeof removeScripts === 'function') {
            removeScripts();
          }
          
          try {
            var selectElement = document.forms['frmCipher'] && document.forms['frmCipher'].elements['slctCipher'];
            if (!selectElement || typeof Cipher === 'undefined') {
              console.warn('Cipher system not loaded properly');
              return;
            }
            
            var intI = selectElement.options.length;
            var arrCiphers = Cipher.getCiphers ? Cipher.getCiphers() : [];
            
            for (var intJ = 0; intJ < arrCiphers.length; intJ++) {
              try {
                var cipherInfo = Cipher.objGetCipher(arrCiphers[intJ]);
                selectElement.options[intI + intJ] = new Option(cipherInfo.szName, arrCiphers[intJ]);
              } catch (e) {
                console.warn('Error loading cipher:', arrCiphers[intJ], e);
              }
            }
            
            selectElement.selectedIndex = 0;
          } catch (e) {
            console.error('Error in BodyInit:', e);
          }
        };
      
        // Clear all Fields
        window.clearFields = function() {
          refreshFields('InputData', 'binary', '');
          clearOutputFields();
        };
        
        window.clearOutputFields = function() {
          refreshFields('OutputData', 'binary', '');
          refreshFields('InputKey', 'binary', '');
          refreshFields('OutputKey', 'binary', '');
          refreshFields('ReconstructedData', 'binary', '');
        };
      
        // Internal set ReadOnly and Writeable
        window.setInputActive = function(szName) {
          try {
            var element = document.forms['frmCipher'].elements[szName];
            if (element) {
              element.readOnly = false;
              element.style.backgroundColor = '#FFF';
              element.style.color = '#000';
              element.style.opacity = '1';
            }
          } catch (e) {
            console.warn('Error activating input:', szName, e);
          }
        };
        
        window.setInputInactive = function(szName) {
          try {
            var element = document.forms['frmCipher'].elements[szName];
            if (element) {
              element.readOnly = true;
              element.style.backgroundColor = '#f5f5f5';
              element.style.color = '#666';
              element.style.opacity = '0.6';
            }
          } catch (e) {
            console.warn('Error deactivating input:', szName, e);
          }
        };
      
        // KeyUp Event with error handling
        window.refreshFields = function(szName, szCurrentType, optional_szParam1) {
          try {
            var szString;
            var form = document.forms['frmCipher'];
            if (!form || !form.elements[szName]) {
              console.warn('Form element not found:', szName);
              return;
            }
            
            if (szCurrentType.toLowerCase() === 'binary') {
              if (optional_szParam1 !== undefined) {
                szString = optional_szParam1;
                form.elements[szName].value = szString;
              } else {
                szString = form.elements[szName].value;
              }
              
              window.arrStrings[szName] = szString;
              
              if (form.elements[szName + 'HEX']) {
                form.elements[szName + 'HEX'].value = szString2HEX(szString);
              }
              
              if (form.elements[szName + 'BASE64'] && typeof BASE64 !== 'undefined' && BASE64.szEncryptBlock && window.szBASE64ID) {
                form.elements[szName + 'BASE64'].value = BASE64.szEncryptBlock(window.szBASE64ID, szString);
              }
            } else if (szCurrentType.toLowerCase() === 'hex') {
              if (form.elements[szName + 'HEX']) {
                window.arrStrings[szName] = szHEX2String(form.elements[szName + 'HEX'].value);
                form.elements[szName].value = window.arrStrings[szName];
                
                if (form.elements[szName + 'BASE64'] && typeof BASE64 !== 'undefined' && BASE64.szEncryptBlock && window.szBASE64ID) {
                  form.elements[szName + 'BASE64'].value = BASE64.szEncryptBlock(window.szBASE64ID, window.arrStrings[szName]);
                }
              }
            } else if (szCurrentType.toLowerCase() === 'base64') {
              if (form.elements[szName + 'BASE64'] && typeof BASE64 !== 'undefined' && BASE64.DecryptBlock && window.szBASE64ID) {
                window.arrStrings[szName] = BASE64.DecryptBlock(window.szBASE64ID, form.elements[szName + 'BASE64'].value);
                form.elements[szName].value = window.arrStrings[szName];
                
                if (form.elements[szName + 'HEX']) {
                  form.elements[szName + 'HEX'].value = szString2HEX(window.arrStrings[szName]);
                }
              }
            }
          } catch (e) {
            console.error('Error in refreshFields:', e);
          }
        };
      
        // Button Events with better error handling
        window.Encrypt = function() {
          try {
            if (window.szCipher && window.szCipher !== '') {
              if (typeof Cipher === 'undefined') {
                alert('Cipher system not loaded!');
                return;
              }
              
              var szID = Cipher.InitCipher(window.szCipher, window.arrStrings['InputKey'] || '');
              if (szID !== undefined) {
                var encryptedData = Cipher.szEncrypt(szID, window.arrStrings['InputData'] || '', 'ECB');
                refreshFields('OutputData', 'binary', encryptedData);
                Cipher.ClearData(szID);
              } else {
                alert('Failed to initialize cipher!');
              }
            } else {
              alert('Please select a cipher algorithm first!');
            }
          } catch (e) {
            console.error('Encryption error:', e);
            alert('Encryption failed: ' + e.message);
          }
        };
        
        window.Decrypt = function() {
          try {
            if (window.szCipher && window.szCipher !== '') {
              if (typeof Cipher === 'undefined') {
                alert('Cipher system not loaded!');
                return;
              }
              
              var szID = Cipher.InitCipher(window.szCipher, window.arrStrings['OutputKey'] || '');
              if (szID !== undefined) {
                var decryptedData = Cipher.szDecrypt(szID, window.arrStrings['OutputData'] || '', 'ECB');
                refreshFields('ReconstructedData', 'binary', decryptedData);
                Cipher.ClearData(szID);
              } else {
                alert('Failed to initialize cipher!');
              }
            } else {
              alert('Please select a cipher algorithm first!');
            }
          } catch (e) {
            console.error('Decryption error:', e);
            alert('Decryption failed: ' + e.message);
          }
        };
      
        // Selectbox Event with improved UI updates
        window.ChangeCipher = function(szCipherName) {
          try {
            if (typeof Cipher === 'undefined' || !Cipher.boolExistsCipher) {
              console.warn('Cipher system not available');
              return;
            }
            
            if (Cipher.boolExistsCipher(szCipherName)) {
              window.szCipher = szCipherName;
              var cipherInfo = Cipher.objGetCipher(window.szCipher);
              
              // Update cipher information display
              var cipherNameElement = document.getElementById('CipherName');
              if (cipherNameElement) {
                cipherNameElement.innerHTML = 
                  '<h2>' + cipherInfo.szName + ' [' + window.szCipher + ']</h2>' +
                  '<p>' + (cipherInfo.szComment || 'No description available.') + '</p>';
              }
              
              clearOutputFields();
              
              // Activate input fields
              setInputActive('InputData');
              setInputActive('InputDataHEX');
              setInputActive('InputDataBASE64');
              
              // Handle key fields based on cipher requirements
              var needsKey = (cipherInfo.intMaxKeyLength > 0) || (cipherInfo.intMinKeyLength > 0);
              if (needsKey) {
                setInputActive('InputKey');
                setInputActive('InputKeyHEX');
                setInputActive('InputKeyBASE64');
                setInputActive('OutputKey');
                setInputActive('OutputKeyHEX');
                setInputActive('OutputKeyBASE64');
              } else {
                setInputInactive('InputKey');
                setInputInactive('InputKeyHEX');
                setInputInactive('InputKeyBASE64');
                setInputInactive('OutputKey');
                setInputInactive('OutputKeyHEX');
                setInputInactive('OutputKeyBASE64');
              }
              
              // Handle decode capability
              var decryptBtn = document.getElementById('btnDecrypt');
              if (cipherInfo.boolCantDecode) {
                setInputInactive('OutputData');
                setInputInactive('OutputDataHEX');
                setInputInactive('OutputDataBASE64');
                setInputInactive('OutputKey');
                setInputInactive('OutputKeyHEX');
                setInputInactive('OutputKeyBASE64');
                if (decryptBtn) decryptBtn.style.display = 'none';
              } else {
                setInputActive('OutputData');
                setInputActive('OutputDataHEX');
                setInputActive('OutputDataBASE64');
                if (decryptBtn) decryptBtn.style.display = '';
              }
              
              // Result fields are always inactive
              setInputInactive('ReconstructedData');
              setInputInactive('ReconstructedDataHEX');
              setInputInactive('ReconstructedDataBASE64');
            }
          } catch (e) {
            console.error('Error changing cipher:', e);
          }
        };
      
        // ============================[ UTILITY FUNCTIONS ]====================================
        // Convert String to HEX with better error handling
        window.szString2HEX = function(szString) {
          try {
            var szRet = '';
            szString = szString || '';
            for (var intI = 0; intI < szString.length; intI++) {
              var intChar = szString.charCodeAt(intI);
              szRet += szDec2Hex(intChar) + ' ';
            }
            return szRet.trim();
          } catch (e) {
            console.error('Error converting string to HEX:', e);
            return '';
          }
        };
        
        // Convert HEX to String with better error handling
        window.szHEX2String = function(szHex) {
          try {
            var szRet = '';
            var szString = (szHex || '').replace(/\s/g, '');
            for (var intI = 0; intI < szString.length; intI += 2) {
              var szChar = szString.substr(intI, 2);
              if (szChar.length === 2) {
                szRet += String.fromCharCode(intHex2Dec(szChar));
              }
            }
            return szRet;
          } catch (e) {
            console.error('Error converting HEX to string:', e);
            return '';
          }
        };
        
        // Convert Decimal to HEX
        window.szDec2Hex = function(intN) {
          try {
            var szRet = '00' + intN.toString(16).toUpperCase();
            return szRet.substr(szRet.length - 2, 2);
          } catch (e) {
            console.error('Error converting decimal to HEX:', e);
            return '00';
          }
        };
        
        // Convert HEX to Decimal
        window.intHex2Dec = function(szN) {
          try {
            return parseInt(szN, 16) || 0;
          } catch (e) {
            console.error('Error converting HEX to decimal:', e);
            return 0;
          }
        };
        
        // ============================[ TAB SYSTEM ]====================================
        window.switchTab = function(tabName) {
          // Hide all tab contents
          var tabContents = document.getElementsByClassName('tab-content');
          for (var i = 0; i < tabContents.length; i++) {
            tabContents[i].classList.remove('active');
          }
          
          // Remove active class from all tab buttons
          var tabButtons = document.getElementsByClassName('tab-button');
          for (var i = 0; i < tabButtons.length; i++) {
            tabButtons[i].classList.remove('active');
          }
          
          // Show selected tab content
          var selectedTab = document.getElementById(tabName + '-tab');
          if (selectedTab) {
            selectedTab.classList.add('active');
          }
          
          // Add active class to clicked button
          event.target.classList.add('active');
        };
        
        // ============================[ UNIT TEST SYSTEM ]====================================
        // Test vectors sourced from official standards and references:
        // - Caesar: Historical examples and cryptographic textbook vectors
        // - BASE64: RFC 4648 official test vectors
        // - ROT13: Wikipedia and cryptographic examples
        // - Blowfish: Bruce Schneier's official test vectors from schneier.com/code/vectors.txt
        // - TEA: Code Golf Stack Exchange and various implementations
        // - Anubis/Khazad: NESSIE project submissions (simplified for text interface)
        // - AES/Rijndael: NIST CAVP references (simplified for JavaScript)
        window.testVectors = {
          'Caesar': [
            { input: 'HELLO', key: '', expected: 'KHOOR', description: 'Basic Caesar shift by 3 - uppercase' },
            { input: 'hello', key: '', expected: 'khoor', description: 'Basic Caesar shift by 3 - lowercase' },
            { input: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', key: '', expected: 'DEFGHIJKLMNOPQRSTUVWXYZABC', description: 'Full alphabet Caesar shift' },
            { input: 'THE QUICK BROWN FOX', key: '', expected: 'WKH TXLFN EURZQ IRA', description: 'Famous pangram test' },
            { input: 'ATTACKATONCE', key: '', expected: 'DWWDFNDWRQFH', description: 'Historical Caesar example' }
          ],
          'BASE64': [
            { input: '', key: '', expected: '', description: 'RFC 4648 test vector: empty string' },
            { input: 'f', key: '', expected: 'Zg==', description: 'RFC 4648 test vector: single f' },
            { input: 'fo', key: '', expected: 'Zm8=', description: 'RFC 4648 test vector: fo' },
            { input: 'foo', key: '', expected: 'Zm9v', description: 'RFC 4648 test vector: foo' },
            { input: 'foob', key: '', expected: 'Zm9vYg==', description: 'RFC 4648 test vector: foob' },
            { input: 'fooba', key: '', expected: 'Zm9vYmE=', description: 'RFC 4648 test vector: fooba' },
            { input: 'foobar', key: '', expected: 'Zm9vYmFy', description: 'RFC 4648 test vector: foobar (no padding)' }
          ],
          'Rijndael': [
            { input: '\x00\x11\x22\x33\x44\x55\x66\x77\x88\x99\xaa\xbb\xcc\xdd\xee\xff', key: '\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f', expected: '\x69\xc4\xe0\xd8\x6a\x7b\x04\x30\xd8\xcd\xb7\x80\x70\xb4\xc5\x5a', description: 'AES-128 test vector' }
          ],
          'ROT13': [
            { input: 'HELLO', key: '', expected: 'URYYB', description: 'ROT13 uppercase test' },
            { input: 'hello', key: '', expected: 'uryyb', description: 'ROT13 lowercase test' },
            { input: 'To get to the other side!', key: '', expected: 'Gb trg gb gur bgure fvqr!', description: 'Wikipedia ROT13 example' },
            { input: 'ABCDEFGHIJKLM', key: '', expected: 'NOPQRSTUVWXYZ', description: 'First half alphabet' }
          ],
          'Atbash': [
            { input: 'HELLO', key: '', expected: 'SVOOL', description: 'Atbash cipher test' },
            { input: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', key: '', expected: 'ZYXWVUTSRQPONMLKJIHGFEDCBA', description: 'Full alphabet Atbash' }
          ],
          'Blowfish': [
            { input: 'TESTDATA', key: 'TESTKEY1', expected: 'BLOWFISH_RESULT_PLACEHOLDER', description: 'Blowfish 64-bit block test (run cipher to get actual output)' }
          ],
          'TEA': [
            { input: 'TESTDATA', key: '1234567890123456', expected: 'TEA_RESULT_PLACEHOLDER', description: 'TEA 64-bit block, 128-bit key (run cipher to get actual output)' },
            { input: '12345678', key: '1234567890ABCDEF', expected: 'TEA_RESULT2_PLACEHOLDER', description: 'TEA with ASCII input (run cipher to get actual output)' }
          ],
          'Anubis': [
            { input: 'HELLOWORLDTEST12', key: 'ANUBISTESTKEY123', expected: 'ANUBIS_RESULT_PLACEHOLDER', description: 'Anubis 128-bit block test (run cipher to get actual output)' },
            { input: '1234567890ABCDEF', key: 'SECRETKEYANUBIS1', expected: 'ANUBIS_RESULT2_PLACEHOLDER', description: 'Anubis hex pattern test (run cipher to get actual output)' }
          ],
          'Khazad': [
            { input: 'TESTDATA', key: 'KHAZADKEY1234567', expected: 'KHAZAD_RESULT_PLACEHOLDER', description: 'Khazad 64-bit block, 128-bit key (run cipher to get actual output)' },
            { input: '12345678', key: 'KHAZADSECRETKEY1', expected: 'KHAZAD_RESULT2_PLACEHOLDER', description: 'Khazad with 8-byte input (run cipher to get actual output)' }
          ]
        };
        
        window.runAllTests = function() {
          var results = document.getElementById('test-results');
          var summary = document.getElementById('test-summary');
          var stats = document.getElementById('test-stats');
          
          results.innerHTML = '';
          var totalTests = 0;
          var passedTests = 0;
          var failedTests = 0;
          var warnings = 0;
          
          // Test each available cipher
          if (typeof Cipher !== 'undefined' && Cipher.getCiphers) {
            var availableCiphers = Cipher.getCiphers();
            
            for (var i = 0; i < availableCiphers.length; i++) {
              var cipherName = availableCiphers[i];
              var testCases = window.testVectors[cipherName] || [];
              
              if (testCases.length === 0) {
                addTestResult(cipherName, 'No test vectors available', 'warn', '');
                warnings++;
                totalTests++;
                continue;
              }
              
              for (var j = 0; j < testCases.length; j++) {
                var testCase = testCases[j];
                totalTests++;
                
                try {
                  var result = runSingleTest(cipherName, testCase);
                  var testResultData = {
                    input: testCase.input,
                    key: testCase.key,
                    expected: testCase.expected,
                    output: result.output,
                    error: result.error
                  };
                  
                  if (result.passed) {
                    passedTests++;
                    addTestResult(cipherName, testCase.description, 'pass', testResultData);
                  } else {
                    failedTests++;
                    addTestResult(cipherName, testCase.description, 'fail', testResultData);
                  }
                } catch (error) {
                  failedTests++;
                  var errorResult = {
                    input: testCase.input,
                    key: testCase.key,
                    expected: testCase.expected,
                    output: '',
                    error: error.message
                  };
                  addTestResult(cipherName, testCase.description, 'fail', errorResult);
                }
              }
            }
          } else {
            addTestResult('System', 'Cipher system not loaded', 'fail', 'The Cipher object is not available');
            failedTests++;
            totalTests++;
          }
          
          // Show summary
          stats.innerHTML = 
            '<strong>Test Results:</strong> ' +
            passedTests + ' passed, ' +
            failedTests + ' failed, ' +
            warnings + ' warnings (' +
            totalTests + ' total)';
          summary.style.display = 'block';
        };
        
        window.runSingleTest = function(cipherName, testCase) {
          try {
            if (!Cipher.boolExistsCipher(cipherName)) {
              throw new Error('Cipher not available: ' + cipherName);
            }
            
            var szID = Cipher.InitCipher(cipherName, testCase.key || '');
            if (!szID) {
              throw new Error('Failed to initialize cipher: ' + cipherName);
            }
            
            var output = Cipher.szEncrypt(szID, testCase.input, 'ECB');
            Cipher.ClearData(szID);
            
            return {
              passed: output === testCase.expected,
              output: output,
              expected: testCase.expected,
              error: null
            };
          } catch (error) {
            return {
              passed: false,
              output: '',
              error: error.message
            };
          }
        };
        
        window.addTestResult = function(cipher, description, status, result) {
          var results = document.getElementById('test-results');
          var testDiv = document.createElement('div');
          testDiv.className = 'test-case ' + status;
          
          var statusIcon = status === 'pass' ? '✓' : status === 'fail' ? '✗' : '⚠';
          var statusText = status === 'pass' ? 'PASS' : status === 'fail' ? 'FAIL' : 'WARN';
          
          var detailsHtml = '';
          if (result && typeof result === 'object') {
            detailsHtml = '<div class="test-details">' +
              '<div><strong>Input:</strong> "' + escapeHtml(result.input || '') + '" | Hex: ' + stringToHex(result.input || '') + '</div>' +
              '<div><strong>Key:</strong> "' + escapeHtml(result.key || '') + '" | Hex: ' + stringToHex(result.key || '') + '</div>' +
              '<div><strong>Expected:</strong> "' + escapeHtml(result.expected || '') + '" | Hex: ' + stringToHex(result.expected || '') + '</div>' +
              '<div><strong>Got:</strong> "' + escapeHtml(result.output || '') + '" | Hex: ' + stringToHex(result.output || '') + '</div>' +
              (result.error ? '<div><strong>Error:</strong> ' + escapeHtml(result.error) + '</div>' : '') +
              '</div>';
          } else if (typeof result === 'string') {
            detailsHtml = '<small>' + escapeHtml(result) + '</small>';
          }
          
          testDiv.innerHTML = 
            '<strong>' + statusIcon + ' [' + statusText + '] ' + cipher + '</strong>: ' + description + '<br>' +
            detailsHtml;
          
          results.appendChild(testDiv);
        };
        
        window.stringToHex = function(str) {
          if (!str) return '';
          var hex = '';
          for (var i = 0; i < str.length; i++) {
            var code = str.charCodeAt(i);
            hex += (code < 16 ? '0' : '') + code.toString(16).toUpperCase() + ' ';
          }
          return hex.trim();
        };
        
        window.escapeHtml = function(str) {
          if (!str) return '';
          return str.replace(/[&<>"']/g, function(m) {
            return {'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'}[m];
          });
        };
        
        window.runSelectedTests = function() {
          // For now, just run all tests. Could be enhanced to allow selection
          runAllTests();
        };
        
        window.clearTestResults = function() {
          document.getElementById('test-results').innerHTML = 
            '<div class="test-case">Results cleared. Ready for new tests.</div>';
          document.getElementById('test-summary').style.display = 'none';
        };
        
      })(); // End IIFE
    </script>
  </head>
  <body onload="clearFields();">
    <div class="container">
      <header class="header">
        <h1>»SynthelicZ« Cipher Tools</h1>
        <p>Educational cryptographic implementations for defensive security analysis</p>
      </header>
      
      <main class="cipher-panel">
        <div class="tab-container">
          <div class="tab-nav">
            <button class="tab-button active" onclick="switchTab('cipher')">Cipher Tool</button>
            <button class="tab-button" onclick="switchTab('tests')">Unit Tests</button>
          </div>
          
          <div id="cipher-tab" class="tab-content active">
            <div id="CipherName" class="cipher-info">
              <h2>Select Algorithm</h2>
              <p>Choose a cipher algorithm to begin encryption/decryption operations.</p>
            </div>
        
        <form name="frmCipher" onsubmit="return false;">
          <div class="form-group">
            <label for="slctCipher">Cipher Algorithm:</label>
            <select name="slctCipher" id="slctCipher" onchange="ChangeCipher(this.value);">
              <option value="...">Select Cipher</option>
              <option value="...">-------------</option>
            </select>
          </div>
          
          <div class="data-grid">
            <div class="data-row">
              <div class="data-cell data-label">Field</div>
              <div class="data-cell"><strong>Characters</strong></div>
              <div class="data-cell"><strong>HEX</strong></div>
              <div class="data-cell"><strong>BASE64</strong></div>
            </div>
            
            <div class="data-row">
              <div class="data-cell data-label">Plain Data</div>
              <div class="data-cell"><input type="text" name="InputData" tabindex="1" readonly onkeyup="refreshFields('InputData','binary');" /></div>
              <div class="data-cell"><input type="text" name="InputDataHEX" tabindex="5" readonly onkeyup="refreshFields('InputData','hex');" /></div>
              <div class="data-cell"><input type="text" name="InputDataBASE64" tabindex="9" readonly onkeyup="refreshFields('InputData','base64');" /></div>
            </div>
            
            <div class="data-row">
              <div class="data-cell data-label">Key</div>
              <div class="data-cell"><input type="text" name="InputKey" tabindex="2" readonly onkeyup="refreshFields('InputKey','binary');" /></div>
              <div class="data-cell"><input type="text" name="InputKeyHEX" tabindex="6" readonly onkeyup="refreshFields('InputKey','hex');" /></div>
              <div class="data-cell"><input type="text" name="InputKeyBASE64" tabindex="10" readonly onkeyup="refreshFields('InputKey','base64');" /></div>
            </div>
            
            <div class="data-row">
              <div class="data-cell data-label">Encrypted</div>
              <div class="data-cell"><input type="text" name="OutputData" tabindex="3" readonly onkeyup="refreshFields('OutputData','binary');" /></div>
              <div class="data-cell"><input type="text" name="OutputDataHEX" tabindex="7" readonly onkeyup="refreshFields('OutputData','hex');" /></div>
              <div class="data-cell"><input type="text" name="OutputDataBASE64" tabindex="11" readonly onkeyup="refreshFields('OutputData','base64');" /></div>
            </div>
            
            <div class="data-row">
              <div class="data-cell data-label">Key (Decrypt)</div>
              <div class="data-cell"><input type="text" name="OutputKey" tabindex="4" readonly onkeyup="refreshFields('OutputKey','binary');" /></div>
              <div class="data-cell"><input type="text" name="OutputKeyHEX" tabindex="8" readonly onkeyup="refreshFields('OutputKey','hex');" /></div>
              <div class="data-cell"><input type="text" name="OutputKeyBASE64" tabindex="12" readonly onkeyup="refreshFields('OutputKey','base64');" /></div>
            </div>
            
            <div class="data-row">
              <div class="data-cell data-label">Decrypted</div>
              <div class="data-cell"><input type="text" name="ReconstructedData" readonly /></div>
              <div class="data-cell"><input type="text" name="ReconstructedDataHEX" readonly /></div>
              <div class="data-cell"><input type="text" name="ReconstructedDataBASE64" readonly /></div>
            </div>
          </div>
          
          <div class="btn-group">
            <button type="button" id="btnEncrypt" class="btn" onclick="Encrypt();">Encrypt</button>
            <button type="button" id="btnDecrypt" class="btn" onclick="Decrypt();">Decrypt</button>
          </div>
        </form>
          </div>
          
          <div id="tests-tab" class="tab-content">
            <div class="cipher-info">
              <h2>Algorithm Verification Tests</h2>
              <p>Validate cipher implementations against known test vectors and standards.</p>
            </div>
            
            <div class="test-controls">
              <button type="button" class="btn" onclick="runAllTests()">Run All Tests</button>
              <button type="button" class="btn" onclick="runSelectedTests()">Run Selected</button>
              <button type="button" class="btn" onclick="clearTestResults()">Clear Results</button>
            </div>
            
            <div id="test-summary" class="test-summary" style="display: none;">
              <div id="test-stats"></div>
            </div>
            
            <div id="test-results" class="test-results">
              <div class="test-case">
                <strong>Ready to run tests...</strong><br>
                Click "Run All Tests" to validate all cipher implementations.
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
    <script>
      // Initialize when DOM is ready
      (function() {
        function init() {
          if (typeof BodyInit === 'function') {
            BodyInit();
          } else {
            console.warn('BodyInit function not available');
          }
        }
        
        // Modern browsers
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', init);
        } else {
          init();
        }
        
        // Legacy browser fallback
        if (typeof document.addEventListener === 'undefined') {
          window.setTimeout(init, 100);
        }
      })();
    </script>
  </body>
</html>