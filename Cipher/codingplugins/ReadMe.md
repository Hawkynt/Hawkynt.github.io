# Cipher Coding Plugins - Multi-Language Code Generation Engine

> Transform cryptographic algorithm implementations from JavaScript into **15 programming languages** through a powerful AST-based transformation pipeline with type inference.

## Table of Contents

- [Architecture Overview](#architecture-overview)
- [The Two-Phase Parser](#the-two-phase-parser)
- [Plugin Architecture](#plugin-architecture)
- [AST Pipeline Deep Dive](#ast-pipeline-deep-dive)
- [JavaScript Pattern Handling](#javascript-pattern-handling)
- [File Structure](#file-structure)
- [Creating a New AST Pipeline Plugin](#creating-a-new-ast-pipeline-plugin)
- [Testing](#testing)
- [Supported Languages](#supported-languages)

---

## Architecture Overview

The code generation system uses a **five-stage pipeline** that parses JavaScript source code, builds an intermediate representation with types, and transforms it into target language code.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      COMPLETE CODE GENERATION PIPELINE                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ JavaScript â”‚   â”‚   JS AST   â”‚   â”‚   IL AST   â”‚   â”‚  Target    â”‚   â”‚ Target â”‚â”‚
â”‚  â”‚   Source   â”‚â”€â”€>â”‚  (Plain)   â”‚â”€â”€>â”‚  (Typed)   â”‚â”€â”€>â”‚ Lang AST   â”‚â”€â”€>â”‚  Code  â”‚â”‚
â”‚  â”‚            â”‚   â”‚            â”‚   â”‚            â”‚   â”‚            â”‚   â”‚        â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚        â”‚                â”‚                â”‚                â”‚              â”‚      â”‚
â”‚        â–¼                â–¼                â–¼                â–¼              â–¼      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Tokenizerâ”‚   â”‚  Parser   â”‚   â”‚    IL     â”‚   â”‚Transformerâ”‚   â”‚  Emitter  â”‚ â”‚
â”‚  â”‚           â”‚   â”‚           â”‚   â”‚  Builder  â”‚   â”‚(per lang) â”‚   â”‚(per lang) â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                                  â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â”‚
â”‚     STAGE 1         STAGE 2          STAGE 3          STAGE 4       STAGE 5     â”‚
â”‚    Tokenizing       Parsing        IL Building     Transformation   Emission    â”‚
â”‚                                                                                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚            TypeAwareJSASTParser                                                 â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Terminology

- **JS AST** - Plain JavaScript Abstract Syntax Tree (direct parse of JS syntax)
- **IL AST** - Intermediate Language AST (with types inferred and syntax flattened)
- **Target AST** - Language-specific AST (Rust, Go, Java, etc.)

### What Plugins Receive: The IL AST

Language plugins receive the **IL AST**, not the raw JS AST. The IL AST has:

- **Type annotations** on expressions, variables, parameters, and return values
- **Flattened method definitions** (prototype assignments, object methods â†’ unified format)
- **Unwrapped module patterns** (IIFE, UMD, CommonJS wrappers removed)
- **Resolved constants** (IIFE-computed values extracted)

---

## The Two-Phase Parser

The `TypeAwareJSASTParser` in `type-aware-transpiler.js` performs two distinct phases:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     TypeAwareJSASTParser: TWO-PHASE PROCESS                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚  PHASE 1: JavaScript Parsing (JS AST)                                           â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                           â”‚
â”‚                                                                                  â”‚
â”‚  Input: Raw JavaScript source code                                              â”‚
â”‚  Output: Plain JS AST (syntax tree only, no type information)                   â”‚
â”‚                                                                                  â”‚
â”‚  Steps:                                                                          â”‚
â”‚  1. Tokenization - Break source into tokens (identifiers, operators, etc.)      â”‚
â”‚  2. Parsing - Build syntax tree from tokens                                     â”‚
â”‚  3. Comment extraction - Capture JSDoc comments for Phase 2                     â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  JavaScript Source                    JS AST (Plain)                    â”‚    â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                    â”‚    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â”‚  class AES {                          {                                 â”‚    â”‚
â”‚  â”‚    encrypt(data) {                      type: "ClassDeclaration",       â”‚    â”‚
â”‚  â”‚      return data;         â”€â”€â”€â”€â”€â”€â”€â”€>     id: { name: "AES" },            â”‚    â”‚
â”‚  â”‚    }                                    body: { body: [...] }           â”‚    â”‚
â”‚  â”‚  }                                    }                                 â”‚    â”‚
â”‚  â”‚                                       (no type information yet)         â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                        â”‚                                        â”‚
â”‚                                        â–¼                                        â”‚
â”‚  PHASE 2: IL Building (IL AST)                                                  â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                  â”‚
â”‚                                                                                  â”‚
â”‚  Input: JS AST + JSDoc comments + source context                                â”‚
â”‚  Output: IL AST (with types and flattened structures)                           â”‚
â”‚                                                                                  â”‚
â”‚  Steps:                                                                          â”‚
â”‚  1. Type inference - Add typeAnnotation to all typed nodes                      â”‚
â”‚  2. Syntax flattening - Normalize different method definition styles            â”‚
â”‚  3. Module unwrapping - Extract content from IIFE/UMD wrappers                  â”‚
â”‚  4. Constant resolution - Evaluate IIFE-computed constants                      â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  JS AST (Plain)                       IL AST (Typed + Flattened)        â”‚    â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”‚    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â”‚  {                                    {                                 â”‚    â”‚
â”‚  â”‚    type: "ClassDeclaration",            type: "ClassDeclaration",       â”‚    â”‚
â”‚  â”‚    id: { name: "AES" },                 id: { name: "AES" },            â”‚    â”‚
â”‚  â”‚    body: {                  â”€â”€â”€â”€â”€â”€â”€â”€>   body: {                         â”‚    â”‚
â”‚  â”‚      body: [{                             body: [{                      â”‚    â”‚
â”‚  â”‚        type: "MethodDefinition",            type: "MethodDefinition",   â”‚    â”‚
â”‚  â”‚        key: { name: "encrypt" },            key: { name: "encrypt" },   â”‚    â”‚
â”‚  â”‚        value: {                             value: {                    â”‚    â”‚
â”‚  â”‚          params: [{ name: "data" }]           params: [{                â”‚    â”‚
â”‚  â”‚        }                                        name: "data",           â”‚    â”‚
â”‚  â”‚      }]                                         typeAnnotation: {       â”‚    â”‚
â”‚  â”‚    }                                              name: "byte[]"        â”‚    â”‚
â”‚  â”‚  }                                              }                       â”‚    â”‚
â”‚  â”‚                                               }],                       â”‚    â”‚
â”‚  â”‚  (no types)                                   returnType: {             â”‚    â”‚
â”‚  â”‚                                                 name: "byte[]"          â”‚    â”‚
â”‚  â”‚                                               }                         â”‚    â”‚
â”‚  â”‚                                             }                           â”‚    â”‚
â”‚  â”‚                                           }]                            â”‚    â”‚
â”‚  â”‚                                         }                               â”‚    â”‚
â”‚  â”‚                                       }                                 â”‚    â”‚
â”‚  â”‚                                       (with types!)                     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Phase 2: IL Building Details

Type information is inferred from multiple sources:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          TYPE INFERENCE SOURCES                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ 1. JSDoc Comments (Highest Priority)                                    â”‚    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â”‚   /** @param {byte[]} key - The encryption key */                       â”‚    â”‚
â”‚  â”‚   /** @returns {dword} - Packed 32-bit value */                         â”‚    â”‚
â”‚  â”‚   /** @type {uint32} */                                                 â”‚    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â”‚   Recognized types: byte, word, dword, qword, sbyte, short, int, long,  â”‚    â”‚
â”‚  â”‚                     float, double, uint8, uint16, uint32, uint64,       â”‚    â”‚
â”‚  â”‚                     byte[], dword[], string, boolean, void              â”‚    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ 2. OpCodes Library Signatures                                           â”‚    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â”‚   OpCodes.RotL32(value, bits)  â†’ returns dword                          â”‚    â”‚
â”‚  â”‚   OpCodes.Pack32BE(b0,b1,b2,b3) â†’ returns dword                         â”‚    â”‚
â”‚  â”‚   OpCodes.Hex8ToBytes(hex)     â†’ returns byte[]                         â”‚    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â”‚   Signatures loaded from OpCodes.js JSDoc at initialization             â”‚    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ 3. Variable Name Patterns                                               â”‚    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â”‚   Pattern                    Inferred Type                              â”‚    â”‚
â”‚  â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                          â”‚    â”‚
â”‚  â”‚   key, Key                   byte[]                                     â”‚    â”‚
â”‚  â”‚   iv, IV, nonce              byte[]                                     â”‚    â”‚
â”‚  â”‚   block, Block, data         byte[]                                     â”‚    â”‚
â”‚  â”‚   state, State               dword[]                                    â”‚    â”‚
â”‚  â”‚   sbox, SBox                 byte[]                                     â”‚    â”‚
â”‚  â”‚   index, length, size        int                                        â”‚    â”‚
â”‚  â”‚   byte, b0, b1               byte                                       â”‚    â”‚
â”‚  â”‚   word, w0, w1               word                                       â”‚    â”‚
â”‚  â”‚   temp, mask                 dword                                      â”‚    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ 4. TypedArray Constructors                                              â”‚    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â”‚   new Uint8Array(...)   â†’ byte[]                                        â”‚    â”‚
â”‚  â”‚   new Uint16Array(...)  â†’ word[]                                        â”‚    â”‚
â”‚  â”‚   new Uint32Array(...)  â†’ dword[]                                       â”‚    â”‚
â”‚  â”‚   new Int8Array(...)    â†’ sbyte[]                                       â”‚    â”‚
â”‚  â”‚   new Int32Array(...)   â†’ int[]                                         â”‚    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ 5. Literal Value Analysis                                               â”‚    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â”‚   0-255           â†’ byte                                                â”‚    â”‚
â”‚  â”‚   0-65535         â†’ word                                                â”‚    â”‚
â”‚  â”‚   0-4294967295    â†’ dword                                               â”‚    â”‚
â”‚  â”‚   0x prefix       â†’ appropriate unsigned type based on value            â”‚    â”‚
â”‚  â”‚   true/false      â†’ boolean                                             â”‚    â”‚
â”‚  â”‚   "string"        â†’ string                                              â”‚    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Syntax Flattening in IL AST

JavaScript has multiple ways to define the same thing. The IL AST normalizes these:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SYNTAX FLATTENING EXAMPLES                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚  Different JS Syntaxes                    Unified IL AST Representation          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ METHOD DEFINITIONS                                                        â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚                                                                            â”‚  â”‚
â”‚  â”‚  class Foo {                                                              â”‚  â”‚
â”‚  â”‚    method1() { }              â”€â”                                          â”‚  â”‚
â”‚  â”‚  }                             â”‚      All become:                         â”‚  â”‚
â”‚  â”‚                                â”‚      {                                   â”‚  â”‚
â”‚  â”‚  Foo.prototype.method2 =       â”œâ”€â”€â”€>    type: "MethodDefinition",         â”‚  â”‚
â”‚  â”‚    function() { }              â”‚        key: { name: "methodN" },         â”‚  â”‚
â”‚  â”‚                                â”‚        value: { body: {...} }            â”‚  â”‚
â”‚  â”‚  const obj = {                 â”‚      }                                   â”‚  â”‚
â”‚  â”‚    method3: function() { }    â”€â”˜                                          â”‚  â”‚
â”‚  â”‚  }                                                                        â”‚  â”‚
â”‚  â”‚                                                                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ CONSTANT DEFINITIONS                                                      â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚                                                                            â”‚  â”‚
â”‚  â”‚  const SBOX = [1, 2, 3];      â”€â”                                          â”‚  â”‚
â”‚  â”‚                                â”‚      Both become:                        â”‚  â”‚
â”‚  â”‚  const SBOX = (function() {    â”‚      {                                   â”‚  â”‚
â”‚  â”‚    const arr = [];             â”œâ”€â”€â”€>    type: "VariableDeclaration",      â”‚  â”‚
â”‚  â”‚    // compute values           â”‚        declarations: [{                  â”‚  â”‚
â”‚  â”‚    return arr;                 â”‚          id: { name: "SBOX" },           â”‚  â”‚
â”‚  â”‚  })();                        â”€â”˜          init: { /* resolved value */ }  â”‚  â”‚
â”‚  â”‚                                         }]                                â”‚  â”‚
â”‚  â”‚                                       }                                   â”‚  â”‚
â”‚  â”‚                                                                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ MODULE PATTERNS                                                           â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚                                                                            â”‚  â”‚
â”‚  â”‚  (function(global) {                                                      â”‚  â”‚
â”‚  â”‚    'use strict';                       Wrapper removed, inner content     â”‚  â”‚
â”‚  â”‚    class Algorithm { ... }    â”€â”€â”€â”€>    extracted directly:                â”‚  â”‚
â”‚  â”‚    module.exports = Algorithm;         { type: "ClassDeclaration", ... }  â”‚  â”‚
â”‚  â”‚  })(globalThis);                                                          â”‚  â”‚
â”‚  â”‚                                                                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## From IL AST to Target Code

### Stage 4: Transformation (Language-Specific)

The transformer converts the **IL AST** to a **language-specific Target AST**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     TRANSFORMER RESPONSIBILITIES                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚  The transformer handles SEMANTIC conversions:                                  â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ 1. IL Type â†’ Target Type Mapping                                          â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚                                                                            â”‚  â”‚
â”‚  â”‚   IL AST Type         Rust          Go          Java         C#           â”‚  â”‚
â”‚  â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”€â”€â”€â”€          â”€â”€          â”€â”€â”€â”€         â”€â”€           â”‚  â”‚
â”‚  â”‚   byte                u8            uint8       byte         byte         â”‚  â”‚
â”‚  â”‚   word                u16           uint16      short        ushort       â”‚  â”‚
â”‚  â”‚   dword               u32           uint32      int          uint         â”‚  â”‚
â”‚  â”‚   qword               u64           uint64      long         ulong        â”‚  â”‚
â”‚  â”‚   byte[]              Vec<u8>       []uint8     byte[]       byte[]       â”‚  â”‚
â”‚  â”‚   dword[]             Vec<u32>      []uint32    int[]        uint[]       â”‚  â”‚
â”‚  â”‚   boolean             bool          bool        boolean      bool         â”‚  â”‚
â”‚  â”‚   string              String        string      String       string       â”‚  â”‚
â”‚  â”‚                                                                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ 2. Name Convention Conversion                                             â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚                                                                            â”‚  â”‚
â”‚  â”‚   IL AST Name        Rust               Go              Python            â”‚  â”‚
â”‚  â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€        â”€â”€â”€â”€               â”€â”€              â”€â”€â”€â”€â”€â”€            â”‚  â”‚
â”‚  â”‚   encryptBlock       encrypt_block      EncryptBlock    encrypt_block     â”‚  â”‚
â”‚  â”‚   AES                Aes                AES             AES               â”‚  â”‚
â”‚  â”‚   SBOX               SBOX               SBOX            SBOX              â”‚  â”‚
â”‚  â”‚                                                                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ 3. Semantic Mapping (IL Class â†’ Language Constructs)                      â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚                                                                            â”‚  â”‚
â”‚  â”‚   IL AST Class                   Target Language                          â”‚  â”‚
â”‚  â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                          â”‚  â”‚
â”‚  â”‚   ClassDeclaration "AES"                                                  â”‚  â”‚
â”‚  â”‚           â”‚                                                               â”‚  â”‚
â”‚  â”‚           â”œâ”€â”€â–º Rust:   struct Aes { } + impl Aes { }                     â”‚  â”‚
â”‚  â”‚           â”œâ”€â”€â–º Go:     type Aes struct { } + func (a *Aes) Method() { }  â”‚  â”‚
â”‚  â”‚           â”œâ”€â”€â–º Java:   public class AES { }                               â”‚  â”‚
â”‚  â”‚           â”œâ”€â”€â–º Python: class AES: ...                                     â”‚  â”‚
â”‚  â”‚           â””â”€â”€â–º C++:    class AES { };                                     â”‚  â”‚
â”‚  â”‚                                                                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Stage 5: Emission (Language-Specific)

The emitter converts the **Target AST** to actual source code:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        EMITTER RESPONSIBILITIES                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚  The emitter handles SYNTACTIC concerns:                                        â”‚
â”‚                                                                                  â”‚
â”‚  â€¢ Keyword generation (fn, func, def, void, etc.)                              â”‚
â”‚  â€¢ Operator syntax (+, +=, ++, etc.)                                           â”‚
â”‚  â€¢ Delimiter placement ({ }, begin/end, indentation)                           â”‚
â”‚  â€¢ Doc comment formatting (///, /**, #, ''')                                   â”‚
â”‚  â€¢ Import/use statement generation                                             â”‚
â”‚  â€¢ Operator precedence and parenthesization                                    â”‚
â”‚  â€¢ Language-specific idioms (derives, decorators, annotations)                 â”‚
â”‚                                                                                  â”‚
â”‚  Does NOT care about: JavaScript semantics, type inference                     â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Plugin Architecture

All 15 language plugins use the full AST pipeline architecture:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         AST PIPELINE ARCHITECTURE                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚  4 files per language:                                                          â”‚
â”‚  â”œâ”€â”€ XXX.js           Plugin entry point, coordinates pipeline                  â”‚
â”‚  â”œâ”€â”€ XXXAST.js        Language-specific AST node definitions                    â”‚
â”‚  â”œâ”€â”€ XXXTransformer.js IL AST â†’ Target AST                                      â”‚
â”‚  â””â”€â”€ XXXEmitter.js    Target AST â†’ Source code                                  â”‚
â”‚                                                                                  â”‚
â”‚  All 15 Languages:                                                              â”‚
â”‚  Basic, C, C++, C#, Delphi, Go, Java, JavaScript, Kotlin,                      â”‚
â”‚  Perl, PHP, Python, Ruby, Rust, TypeScript                                      â”‚
â”‚                                                                                  â”‚
â”‚  âœ… Full type preservation through pipeline                                     â”‚
â”‚  âœ… Handles all 16 statement types, 19 expression types                        â”‚
â”‚  âœ… 100% transformer coverage across all languages                              â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## AST Pipeline Deep Dive

### The Four Files Per Language

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        COMPONENT ARCHITECTURE                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                            â”‚
â”‚  â”‚   RustAST.js    â”‚  AST Node Definitions                                      â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚  â”‚                 â”‚                                                            â”‚
â”‚  â”‚  â€¢ RustModule   â”‚  Root node containing all code                             â”‚
â”‚  â”‚  â€¢ RustStruct   â”‚  Struct definitions                                        â”‚
â”‚  â”‚  â€¢ RustImpl     â”‚  Implementation blocks                                     â”‚
â”‚  â”‚  â€¢ RustFunction â”‚  Function/method definitions                               â”‚
â”‚  â”‚  â€¢ RustType     â”‚  Type representations (u8, Vec<T>, etc.)                   â”‚
â”‚  â”‚  â€¢ RustBlock    â”‚  Code blocks { ... }                                       â”‚
â”‚  â”‚  â€¢ RustLiteral  â”‚  Literal values (numbers, strings)                         â”‚
â”‚  â”‚  â€¢ RustConst    â”‚  Constant declarations                                     â”‚
â”‚  â”‚  â€¢ ...          â”‚  Statements, expressions, etc.                             â”‚
â”‚  â”‚                 â”‚                                                            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                            â”‚
â”‚           â”‚                                                                      â”‚
â”‚           â”‚ uses                                                                 â”‚
â”‚           â–¼                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                            â”‚
â”‚  â”‚ RustTransformer â”‚  IL AST â†’ Rust AST (Target AST)                            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                            â”‚
â”‚  â”‚                 â”‚                                                            â”‚
â”‚  â”‚  transform()    â”‚  Entry point - transforms entire program                   â”‚
â”‚  â”‚  â”œâ”€ transformClassDeclaration()   â†’ RustStruct + RustImpl                    â”‚
â”‚  â”‚  â”œâ”€ transformMethodDefinition()   â†’ RustFunction                             â”‚
â”‚  â”‚  â”œâ”€ transformVariableDeclaration()â†’ RustLet / RustConst                      â”‚
â”‚  â”‚  â”œâ”€ transformStatement()          â†’ Various statement nodes                  â”‚
â”‚  â”‚  â”œâ”€ transformExpression()         â†’ Various expression nodes                 â”‚
â”‚  â”‚  â”œâ”€ mapType()                     â†’ IL type â†’ RustType                       â”‚
â”‚  â”‚  â””â”€ inferTypeFromValue()          â†’ Literal â†’ RustType                       â”‚
â”‚  â”‚                 â”‚                                                            â”‚
â”‚  â”‚  Uses typeAnnotation from IL AST nodes                                      â”‚
â”‚  â”‚                 â”‚                                                            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                            â”‚
â”‚           â”‚                                                                      â”‚
â”‚           â”‚ produces                                                             â”‚
â”‚           â–¼                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                            â”‚
â”‚  â”‚  RustEmitter    â”‚  Rust AST â†’ Rust Code                                      â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚  â”‚                 â”‚                                                            â”‚
â”‚  â”‚  emit()         â”‚  Dispatches to specific emitter by nodeType                â”‚
â”‚  â”‚  â”œâ”€ emitModule()     â†’ file header, uses, items                              â”‚
â”‚  â”‚  â”œâ”€ emitStruct()     â†’ struct Name { fields }                                â”‚
â”‚  â”‚  â”œâ”€ emitImpl()       â†’ impl Name { methods }                                 â”‚
â”‚  â”‚  â”œâ”€ emitFunction()   â†’ fn name(params) -> Type { body }                      â”‚
â”‚  â”‚  â”œâ”€ emitBlock()      â†’ { statements }                                        â”‚
â”‚  â”‚  â””â”€ emitExpression() â†’ formatted expressions                                 â”‚
â”‚  â”‚                 â”‚                                                            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                            â”‚
â”‚           â”‚                                                                      â”‚
â”‚           â”‚ used by                                                              â”‚
â”‚           â–¼                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                            â”‚
â”‚  â”‚    rust.js      â”‚  Plugin Entry Point                                        â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                        â”‚
â”‚  â”‚                 â”‚                                                            â”‚
â”‚  â”‚  Extends LanguagePlugin                                                      â”‚
â”‚  â”‚  â€¢ name = "Rust"                                                             â”‚
â”‚  â”‚  â€¢ extension = "rs"                                                          â”‚
â”‚  â”‚  â€¢ icon = "ğŸ¦€"                                                               â”‚
â”‚  â”‚                 â”‚                                                            â”‚
â”‚  â”‚  GenerateFromAST(ilAst, options) {                                           â”‚
â”‚  â”‚    // ilAst is the IL AST with typeAnnotation on nodes                       â”‚
â”‚  â”‚    transformer = new RustTransformer(options)                                â”‚
â”‚  â”‚    rustAst = transformer.transform(ilAst) // Target AST                      â”‚
â”‚  â”‚    emitter = new RustEmitter(options)                                        â”‚
â”‚  â”‚    return emitter.emit(rustAst)                                              â”‚
â”‚  â”‚  }                                                                           â”‚
â”‚  â”‚                 â”‚                                                            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                            â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Complete Data Flow Example

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          COMPLETE DATA FLOW                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚  Input: JavaScript with JSDoc                                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                   â”‚
â”‚                                                                                  â”‚
â”‚  /**                                                                            â”‚
â”‚   * @param {byte[]} data - Input data                                          â”‚
â”‚   * @returns {byte[]} - Encrypted data                                         â”‚
â”‚   */                                                                            â”‚
â”‚  class MyAlgo {                                                                  â”‚
â”‚    constructor() {                                                               â”‚
â”‚      this.key = new Uint8Array(16);                                             â”‚
â”‚    }                                                                             â”‚
â”‚    encrypt(data) {                                                               â”‚
â”‚      return data.map(b => b ^ this.key[0]);                                     â”‚
â”‚    }                                                                             â”‚
â”‚  }                                                                               â”‚
â”‚         â”‚                                                                        â”‚
â”‚         â”‚ TypeAwareJSASTParser (Phase 1 + Phase 2)                               â”‚
â”‚         â–¼                                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  IL AST (Intermediate Language AST with Types)                          â”‚    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â”‚  {                                                                       â”‚    â”‚
â”‚  â”‚    type: "ClassDeclaration",                                            â”‚    â”‚
â”‚  â”‚    id: { name: "MyAlgo" },                                              â”‚    â”‚
â”‚  â”‚    body: {                                                               â”‚    â”‚
â”‚  â”‚      body: [                                                             â”‚    â”‚
â”‚  â”‚        {                                                                 â”‚    â”‚
â”‚  â”‚          type: "MethodDefinition",                                      â”‚    â”‚
â”‚  â”‚          kind: "constructor",                                            â”‚    â”‚
â”‚  â”‚          value: {                                                        â”‚    â”‚
â”‚  â”‚            body: {                                                       â”‚    â”‚
â”‚  â”‚              body: [{                                                    â”‚    â”‚
â”‚  â”‚                // this.key = new Uint8Array(16)                         â”‚    â”‚
â”‚  â”‚                right: {                                                  â”‚    â”‚
â”‚  â”‚                  typeAnnotation: { name: "byte[]" }  â—„â”€â”€ TYPE ADDED    â”‚    â”‚
â”‚  â”‚                }                                                         â”‚    â”‚
â”‚  â”‚              }]                                                          â”‚    â”‚
â”‚  â”‚            }                                                             â”‚    â”‚
â”‚  â”‚          }                                                               â”‚    â”‚
â”‚  â”‚        },                                                                â”‚    â”‚
â”‚  â”‚        {                                                                 â”‚    â”‚
â”‚  â”‚          type: "MethodDefinition",                                      â”‚    â”‚
â”‚  â”‚          key: { name: "encrypt" },                                      â”‚    â”‚
â”‚  â”‚          value: {                                                        â”‚    â”‚
â”‚  â”‚            params: [{                                                    â”‚    â”‚
â”‚  â”‚              name: "data",                                               â”‚    â”‚
â”‚  â”‚              typeAnnotation: { name: "byte[]" }  â—„â”€â”€ FROM JSDOC        â”‚    â”‚
â”‚  â”‚            }],                                                           â”‚    â”‚
â”‚  â”‚            returnType: { name: "byte[]" }  â—„â”€â”€ FROM JSDOC              â”‚    â”‚
â”‚  â”‚          }                                                               â”‚    â”‚
â”‚  â”‚        }                                                                 â”‚    â”‚
â”‚  â”‚      ]                                                                   â”‚    â”‚
â”‚  â”‚    }                                                                     â”‚    â”‚
â”‚  â”‚  }                                                                       â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚                                                                        â”‚
â”‚         â”‚ RustTransformer.transform()                                            â”‚
â”‚         â–¼                                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Target AST: Rust AST (RustModule)                                      â”‚    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â”‚  RustModule {                                                            â”‚    â”‚
â”‚  â”‚    items: [                                                              â”‚    â”‚
â”‚  â”‚      RustStruct {                                                        â”‚    â”‚
â”‚  â”‚        name: "MyAlgo",                                                   â”‚    â”‚
â”‚  â”‚        fields: [                                                         â”‚    â”‚
â”‚  â”‚          RustStructField { name: "key", type: RustType.Vec(U8) }        â”‚    â”‚
â”‚  â”‚        ]                                                                 â”‚    â”‚
â”‚  â”‚      },                                                                  â”‚    â”‚
â”‚  â”‚      RustImpl {                                                          â”‚    â”‚
â”‚  â”‚        structName: "MyAlgo",                                             â”‚    â”‚
â”‚  â”‚        methods: [                                                        â”‚    â”‚
â”‚  â”‚          RustFunction {                                                  â”‚    â”‚
â”‚  â”‚            name: "new",                                                  â”‚    â”‚
â”‚  â”‚            returnType: RustType.SelfType(),                              â”‚    â”‚
â”‚  â”‚            body: RustBlock { ... }                                       â”‚    â”‚
â”‚  â”‚          },                                                              â”‚    â”‚
â”‚  â”‚          RustFunction {                                                  â”‚    â”‚
â”‚  â”‚            name: "encrypt",                                              â”‚    â”‚
â”‚  â”‚            params: [                                                     â”‚    â”‚
â”‚  â”‚              RustParameter { name: "data", type: RustType.Slice(U8) }   â”‚    â”‚
â”‚  â”‚            ],                                                            â”‚    â”‚
â”‚  â”‚            returnType: RustType.Vec(U8),                                 â”‚    â”‚
â”‚  â”‚            body: RustBlock { ... }                                       â”‚    â”‚
â”‚  â”‚          }                                                               â”‚    â”‚
â”‚  â”‚        ]                                                                 â”‚    â”‚
â”‚  â”‚      }                                                                   â”‚    â”‚
â”‚  â”‚    ]                                                                     â”‚    â”‚
â”‚  â”‚  }                                                                       â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚                                                                        â”‚
â”‚         â”‚ RustEmitter.emit()                                                     â”‚
â”‚         â–¼                                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Generated Rust Code                                                    â”‚    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â”‚  #[derive(Debug, Clone)]                                                 â”‚    â”‚
â”‚  â”‚  pub struct MyAlgo {                                                     â”‚    â”‚
â”‚  â”‚      key: Vec<u8>,                                                       â”‚    â”‚
â”‚  â”‚  }                                                                       â”‚    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â”‚  impl MyAlgo {                                                           â”‚    â”‚
â”‚  â”‚      pub fn new() -> Self {                                              â”‚    â”‚
â”‚  â”‚          Self {                                                          â”‚    â”‚
â”‚  â”‚              key: vec![0u8; 16],                                         â”‚    â”‚
â”‚  â”‚          }                                                               â”‚    â”‚
â”‚  â”‚      }                                                                   â”‚    â”‚
â”‚  â”‚                                                                          â”‚    â”‚
â”‚  â”‚      pub fn encrypt(&self, data: &[u8]) -> Vec<u8> {                     â”‚    â”‚
â”‚  â”‚          data.iter().map(|b| b ^ self.key[0]).collect()                  â”‚    â”‚
â”‚  â”‚      }                                                                   â”‚    â”‚
â”‚  â”‚  }                                                                       â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## JavaScript Pattern Handling

The transformers recognize and convert common JavaScript patterns:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      JAVASCRIPT PATTERN TRANSFORMATIONS                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚  JavaScript Pattern              Target Language Equivalents                     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                     â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ new Uint8Array([1, 2, 3])                                                 â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ Rust:   vec![1u8, 2u8, 3u8]                                              â”‚  â”‚
â”‚  â”‚ Go:     []uint8{1, 2, 3}                                                  â”‚  â”‚
â”‚  â”‚ Java:   new byte[] { 1, 2, 3 }                                            â”‚  â”‚
â”‚  â”‚ C#:     new byte[] { 1, 2, 3 }                                            â”‚  â”‚
â”‚  â”‚ Python: bytes([1, 2, 3])                                                  â”‚  â”‚
â”‚  â”‚ C++:    std::vector<uint8_t>{1, 2, 3}                                    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ new Uint8Array(16)  (sized allocation)                                    â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ Rust:   vec![0u8; 16]                                                    â”‚  â”‚
â”‚  â”‚ Go:     make([]uint8, 16)                                                 â”‚  â”‚
â”‚  â”‚ Java:   new byte[16]                                                      â”‚  â”‚
â”‚  â”‚ C#:     new byte[16]                                                      â”‚  â”‚
â”‚  â”‚ Python: bytearray(16)                                                     â”‚  â”‚
â”‚  â”‚ C++:    std::vector<uint8_t>(16, 0)                                      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Object.freeze(obj)                                                        â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ Rust:   obj  (Rust has immutability by default)                          â”‚  â”‚
â”‚  â”‚ Go:     obj  (no-op, use convention)                                      â”‚  â”‚
â”‚  â”‚ Java:   Collections.unmodifiableMap(obj)                                  â”‚  â”‚
â”‚  â”‚ C#:     obj.AsReadOnly() or ImmutableDictionary                          â”‚  â”‚
â”‚  â”‚ Python: types.MappingProxyType(obj)                                       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Object.keys(obj) / Object.values(obj) / Object.entries(obj)              â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ Rust:   obj.keys() / obj.values() / obj.iter()                           â”‚  â”‚
â”‚  â”‚ Go:     maps.Keys(obj) / maps.Values(obj)                                 â”‚  â”‚
â”‚  â”‚ Java:   obj.keySet() / obj.values() / obj.entrySet()                      â”‚  â”‚
â”‚  â”‚ Python: list(obj.keys()) / list(obj.values()) / list(obj.items())        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ const SBOX = (function() { ... return result; })();  (IIFE)              â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ All languages: Extract the return value as a constant                    â”‚  â”‚
â”‚  â”‚                                                                           â”‚  â”‚
â”‚  â”‚ Rust:   const SBOX: [u8; N] = [...];                                     â”‚  â”‚
â”‚  â”‚ Go:     var SBOX = [...]uint8{...}                                        â”‚  â”‚
â”‚  â”‚ Java:   static final byte[] SBOX = {...};                                 â”‚  â”‚
â”‚  â”‚ C#:     static readonly byte[] SBOX = {...};                              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ const { A, B } = require('./module')  (Destructuring Import)             â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ All:    Skipped (framework imports, not algorithm code)                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ class Foo extends Bar { }                                                 â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ Rust:   struct Foo { } + impl Bar for Foo { }  (trait)                   â”‚  â”‚
â”‚  â”‚ Go:     type Foo struct { Bar }  (embedding)                              â”‚  â”‚
â”‚  â”‚ Java:   class Foo extends Bar { }                                         â”‚  â”‚
â”‚  â”‚ C#:     class Foo : Bar { }                                               â”‚  â”‚
â”‚  â”‚ Python: class Foo(Bar): ...                                               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ UMD/CommonJS Module Pattern (IIFE wrapper)                                â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚                                                                           â”‚  â”‚
â”‚  â”‚ (function(global) {                                                       â”‚  â”‚
â”‚  â”‚   'use strict';                                                           â”‚  â”‚
â”‚  â”‚   class Algorithm { ... }        â”€â”€â–º  Extract inner content               â”‚  â”‚
â”‚  â”‚   module.exports = Algorithm;                                             â”‚  â”‚
â”‚  â”‚ })(globalThis);                                                           â”‚  â”‚
â”‚  â”‚                                                                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## File Structure

```
codingplugins/
â”œâ”€â”€ LanguagePlugin.js              # Base plugin class and registry
â”œâ”€â”€ ReadMe.md                      # This documentation
â”‚
â””â”€â”€ [All 15 Languages - 4 files each]
    â”‚
    â”œâ”€â”€ [Basic]
    â”‚   â”œâ”€â”€ basic.js               # Plugin entry point
    â”‚   â”œâ”€â”€ BasicAST.js            # Basic AST node definitions
    â”‚   â”œâ”€â”€ BasicTransformer.js    # IL AST â†’ Basic AST
    â”‚   â””â”€â”€ BasicEmitter.js        # Basic AST â†’ Basic source code
    â”‚
    â”œâ”€â”€ [C]
    â”‚   â”œâ”€â”€ c.js
    â”‚   â”œâ”€â”€ CAST.js
    â”‚   â”œâ”€â”€ CTransformer.js
    â”‚   â””â”€â”€ CEmitter.js
    â”‚
    â”œâ”€â”€ [C++]
    â”‚   â”œâ”€â”€ cpp.js
    â”‚   â”œâ”€â”€ CppAST.js
    â”‚   â”œâ”€â”€ CppTransformer.js
    â”‚   â””â”€â”€ CppEmitter.js
    â”‚
    â”œâ”€â”€ [C#]
    â”‚   â”œâ”€â”€ csharp.js
    â”‚   â”œâ”€â”€ CSharpAST.js
    â”‚   â”œâ”€â”€ CSharpTransformer.js
    â”‚   â””â”€â”€ CSharpEmitter.js
    â”‚
    â”œâ”€â”€ [Delphi]
    â”‚   â”œâ”€â”€ delphi.js
    â”‚   â”œâ”€â”€ DelphiAST.js
    â”‚   â”œâ”€â”€ DelphiTransformer.js
    â”‚   â””â”€â”€ DelphiEmitter.js
    â”‚
    â”œâ”€â”€ [Go]
    â”‚   â”œâ”€â”€ go.js
    â”‚   â”œâ”€â”€ GoAST.js
    â”‚   â”œâ”€â”€ GoTransformer.js
    â”‚   â””â”€â”€ GoEmitter.js
    â”‚
    â”œâ”€â”€ [Java]
    â”‚   â”œâ”€â”€ java.js
    â”‚   â”œâ”€â”€ JavaAST.js
    â”‚   â”œâ”€â”€ JavaTransformer.js
    â”‚   â””â”€â”€ JavaEmitter.js
    â”‚
    â”œâ”€â”€ [JavaScript]
    â”‚   â”œâ”€â”€ javascript.js
    â”‚   â”œâ”€â”€ JavaScriptAST.js
    â”‚   â”œâ”€â”€ JavaScriptTransformer.js
    â”‚   â””â”€â”€ JavaScriptEmitter.js
    â”‚
    â”œâ”€â”€ [Kotlin]
    â”‚   â”œâ”€â”€ kotlin.js
    â”‚   â”œâ”€â”€ KotlinAST.js
    â”‚   â”œâ”€â”€ KotlinTransformer.js
    â”‚   â””â”€â”€ KotlinEmitter.js
    â”‚
    â”œâ”€â”€ [Perl]
    â”‚   â”œâ”€â”€ perl.js
    â”‚   â”œâ”€â”€ PerlAST.js
    â”‚   â”œâ”€â”€ PerlTransformer.js
    â”‚   â””â”€â”€ PerlEmitter.js
    â”‚
    â”œâ”€â”€ [PHP]
    â”‚   â”œâ”€â”€ php.js
    â”‚   â”œâ”€â”€ PhpAST.js
    â”‚   â”œâ”€â”€ PhpTransformer.js
    â”‚   â””â”€â”€ PhpEmitter.js
    â”‚
    â”œâ”€â”€ [Python]
    â”‚   â”œâ”€â”€ python.js
    â”‚   â”œâ”€â”€ PythonAST.js
    â”‚   â”œâ”€â”€ PythonTransformer.js
    â”‚   â””â”€â”€ PythonEmitter.js
    â”‚
    â”œâ”€â”€ [Ruby]
    â”‚   â”œâ”€â”€ ruby.js
    â”‚   â”œâ”€â”€ RubyAST.js
    â”‚   â”œâ”€â”€ RubyTransformer.js
    â”‚   â””â”€â”€ RubyEmitter.js
    â”‚
    â”œâ”€â”€ [Rust]
    â”‚   â”œâ”€â”€ rust.js
    â”‚   â”œâ”€â”€ RustAST.js
    â”‚   â”œâ”€â”€ RustTransformer.js
    â”‚   â””â”€â”€ RustEmitter.js
    â”‚
    â””â”€â”€ [TypeScript]
        â”œâ”€â”€ typescript.js
        â”œâ”€â”€ TypeScriptAST.js
        â”œâ”€â”€ TypeScriptTransformer.js
        â””â”€â”€ TypeScriptEmitter.js
```

---

## Creating a New AST Pipeline Plugin

### Step 1: Define the AST (MyLangAST.js)

```javascript
(function(global) {
  'use strict';

  // Base node class
  class MyLangNode {
    constructor(nodeType) {
      this.nodeType = nodeType;
    }
  }

  // Type system - maps to language's type system
  class MyLangType extends MyLangNode {
    constructor(name) {
      super('Type');
      this.name = name;
    }

    // Factory methods for common types
    static Byte() { return new MyLangType('byte'); }
    static Int() { return new MyLangType('int'); }
    static String() { return new MyLangType('string'); }
    static Array(elementType) {
      const t = new MyLangType('array');
      t.elementType = elementType;
      return t;
    }
  }

  // Module/File level
  class MyLangModule extends MyLangNode {
    constructor() {
      super('Module');
      this.imports = [];
      this.classes = [];
      this.functions = [];
    }
  }

  // Class definition
  class MyLangClass extends MyLangNode {
    constructor(name) {
      super('Class');
      this.name = name;
      this.fields = [];
      this.methods = [];
    }
  }

  // ... more nodes for all language constructs

  const MyLangAST = {
    MyLangNode, MyLangType, MyLangModule, MyLangClass
    // Export all node types
  };

  if (typeof module !== 'undefined') module.exports = MyLangAST;
  if (typeof global !== 'undefined') global.MyLangAST = MyLangAST;
})(globalThis);
```

### Step 2: Create the Transformer (MyLangTransformer.js)

```javascript
(function(global) {
  'use strict';

  // Load AST definitions
  let MyLangAST;
  if (typeof require !== 'undefined') {
    MyLangAST = require('./MyLangAST.js');
  } else {
    MyLangAST = global.MyLangAST;
  }

  const { MyLangModule, MyLangClass, MyLangType } = MyLangAST;

  // Type mapping from intermediate types to target language
  const TYPE_MAP = {
    'byte': 'byte', 'word': 'ushort', 'dword': 'uint', 'qword': 'ulong',
    'sbyte': 'sbyte', 'short': 'short', 'int': 'int', 'long': 'long',
    'float': 'float', 'double': 'double',
    'boolean': 'bool', 'string': 'string', 'void': 'void'
  };

  class MyLangTransformer {
    constructor(options = {}) {
      this.options = options;
      this.variableTypes = new Map();
    }

    // Map intermediate type to target type
    mapType(typeName) {
      if (!typeName) return MyLangType.Int(); // Default

      // Handle arrays
      if (typeName.endsWith('[]')) {
        const elementType = this.mapType(typeName.slice(0, -2));
        return MyLangType.Array(elementType);
      }

      const mapped = TYPE_MAP[typeName];
      return mapped ? new MyLangType(mapped) : new MyLangType(typeName);
    }

    // Entry point
    transform(jsAst) {
      const module = new MyLangModule();

      if (jsAst.type === 'Program') {
        for (const node of jsAst.body) {
          this.transformTopLevel(node, module);
        }
      }

      return module;
    }

    transformTopLevel(node, module) {
      switch (node.type) {
        case 'ClassDeclaration':
          module.classes.push(this.transformClassDeclaration(node));
          break;
        case 'FunctionDeclaration':
          module.functions.push(this.transformFunctionDeclaration(node));
          break;
        case 'VariableDeclaration':
          this.transformVariableDeclaration(node, module);
          break;
        case 'ExpressionStatement':
          // Handle IIFE wrappers
          this.transformExpressionStatement(node, module);
          break;
      }
    }

    transformClassDeclaration(node) {
      const myClass = new MyLangClass(node.id.name);

      for (const member of node.body.body) {
        if (member.type === 'MethodDefinition') {
          // Use typeAnnotation if present
          const method = this.transformMethod(member);
          myClass.methods.push(method);
        } else if (member.type === 'PropertyDefinition') {
          // Extract field with type from typeAnnotation
          const field = this.transformProperty(member);
          myClass.fields.push(field);
        }
      }

      return myClass;
    }

    transformMethod(node) {
      // Get return type from node.value.returnType (added by type inference)
      const returnType = node.value.returnType
        ? this.mapType(node.value.returnType.name)
        : MyLangType.Void();

      // Get parameter types from typeAnnotation on each param
      const params = node.value.params.map(p => ({
        name: p.name,
        type: p.typeAnnotation
          ? this.mapType(p.typeAnnotation.name)
          : this.inferTypeFromName(p.name)
      }));

      // ... transform body
    }

    // Handle all 16 statement types
    transformStatement(node) {
      switch (node.type) {
        case 'BlockStatement':
          return this.transformBlockStatement(node);
        case 'ReturnStatement':
          return this.transformReturnStatement(node);
        case 'IfStatement':
          return this.transformIfStatement(node);
        case 'ForStatement':
          return this.transformForStatement(node);
        case 'ForOfStatement':
          return this.transformForOfStatement(node);
        case 'ForInStatement':
          return this.transformForInStatement(node);
        case 'WhileStatement':
          return this.transformWhileStatement(node);
        case 'DoWhileStatement':
          return this.transformDoWhileStatement(node);
        case 'SwitchStatement':
          return this.transformSwitchStatement(node);
        case 'TryStatement':
          return this.transformTryStatement(node);
        case 'ThrowStatement':
          return this.transformThrowStatement(node);
        case 'BreakStatement':
          return this.transformBreakStatement(node);
        case 'ContinueStatement':
          return this.transformContinueStatement(node);
        case 'VariableDeclaration':
          return this.transformVariableDeclaration(node);
        case 'ExpressionStatement':
          return this.transformExpressionStatement(node);
        case 'ClassDeclaration':
          return this.transformClassDeclaration(node);
        case 'FunctionDeclaration':
          return this.transformFunctionDeclaration(node);
        default:
          return this.transformNode(node);
      }
    }

    // Handle all 19 expression types
    transformExpression(node) {
      switch (node.type) {
        case 'Literal':
          return this.transformLiteral(node);
        case 'Identifier':
          return this.transformIdentifier(node);
        case 'BinaryExpression':
          return this.transformBinaryExpression(node);
        case 'UnaryExpression':
          return this.transformUnaryExpression(node);
        case 'UpdateExpression':
          return this.transformUpdateExpression(node);
        case 'AssignmentExpression':
          return this.transformAssignmentExpression(node);
        case 'LogicalExpression':
          return this.transformLogicalExpression(node);
        case 'MemberExpression':
          return this.transformMemberExpression(node);
        case 'CallExpression':
          return this.transformCallExpression(node);
        case 'NewExpression':
          return this.transformNewExpression(node);
        case 'ArrayExpression':
          return this.transformArrayExpression(node);
        case 'ObjectExpression':
          return this.transformObjectExpression(node);
        case 'ConditionalExpression':
          return this.transformConditionalExpression(node);
        case 'ArrowFunctionExpression':
          return this.transformArrowFunctionExpression(node);
        case 'FunctionExpression':
          return this.transformFunctionExpression(node);
        case 'ThisExpression':
          return this.transformThisExpression(node);
        case 'SpreadElement':
          return this.transformSpreadElement(node);
        case 'SequenceExpression':
          return this.transformSequenceExpression(node);
        case 'TemplateLiteral':
          return this.transformTemplateLiteral(node);
        default:
          return this.transformNode(node);
      }
    }

    // Type inference from variable name patterns
    inferTypeFromName(name) {
      const lower = name.toLowerCase();
      if (lower.includes('byte') || lower === 'b') return MyLangType.Byte();
      if (lower.includes('key') || lower.includes('data')) return MyLangType.Array(MyLangType.Byte());
      if (lower.includes('index') || lower.includes('length')) return MyLangType.Int();
      return MyLangType.Int(); // Default
    }
  }

  if (typeof module !== 'undefined') module.exports = { MyLangTransformer };
  if (typeof global !== 'undefined') global.MyLangTransformer = MyLangTransformer;
})(globalThis);
```

### Step 3: Create the Emitter (MyLangEmitter.js)

```javascript
(function(global) {
  'use strict';

  class MyLangEmitter {
    constructor(options = {}) {
      this.indentStr = options.indent || '    ';
      this.indentLevel = 0;
      this.newline = options.lineEnding || '\n';
    }

    // Entry point - dispatches by nodeType
    emit(node) {
      if (!node) return '';

      const emitter = `emit${node.nodeType}`;
      if (typeof this[emitter] === 'function') {
        return this[emitter](node);
      }

      console.warn(`No emitter for: ${node.nodeType}`);
      return '';
    }

    // Helpers
    indent() {
      return this.indentStr.repeat(this.indentLevel);
    }

    line(content = '') {
      return content ? `${this.indent()}${content}${this.newline}` : this.newline;
    }

    // Emitters for each node type...
    emitModule(node) { /* ... */ }
    emitClass(node) { /* ... */ }
    emitMethod(node) { /* ... */ }
    emitType(node) { /* ... */ }
    // ... emitters for all node types
  }

  if (typeof module !== 'undefined') module.exports = { MyLangEmitter };
  if (typeof global !== 'undefined') global.MyLangEmitter = MyLangEmitter;
})(globalThis);
```

### Step 4: Create the Plugin (mylang.js)

```javascript
(function(global) {
  'use strict';

  let LanguagePlugin, LanguagePlugins, MyLangTransformer, MyLangEmitter;

  if (typeof require !== 'undefined') {
    const lp = require('./LanguagePlugin.js');
    LanguagePlugin = lp.LanguagePlugin;
    LanguagePlugins = lp.LanguagePlugins;
    MyLangTransformer = require('./MyLangTransformer.js').MyLangTransformer;
    MyLangEmitter = require('./MyLangEmitter.js').MyLangEmitter;
  }

  class MyLangPlugin extends LanguagePlugin {
    constructor() {
      super();
      this.name = 'MyLang';
      this.extension = 'ml';
      this.icon = 'ğŸ”·';
      this.description = 'MyLang code generator';
    }

    GenerateFromAST(ast, options = {}) {
      try {
        // ast already has typeAnnotation properties from TypeAwareJSASTParser

        // Stage 3: Transform to language-specific AST
        const transformer = new MyLangTransformer(options);
        const myLangAst = transformer.transform(ast);

        // Stage 4: Emit to source code
        const emitter = new MyLangEmitter(options);
        const code = emitter.emit(myLangAst);

        return this.CreateSuccessResult(code, [], transformer.warnings || []);
      } catch (error) {
        return this.CreateErrorResult(error.message);
      }
    }
  }

  // Register the plugin
  LanguagePlugins.Add(new MyLangPlugin());

  if (typeof module !== 'undefined') module.exports = { MyLangPlugin };
})(globalThis);
```

---

## Testing

### Running the Coverage Test

```bash
node tests/TransformerCoverageTest.js
```

### Expected Output (AST Pipeline Languages)

```
================================================================================
TRANSFORMER COVERAGE TEST
================================================================================

1. ANALYZING ALGORITHM AST USAGE
----------------------------------------
Scanned 710 algorithm files
Statement types used: 18
Expression types used: 22

2. TRANSFORMER COVERAGE ANALYSIS
----------------------------------------

RustTransformer.js:
  Statement coverage: 100% (16/16)
  Expression coverage: 100% (19/19)

GoTransformer.js:
  Statement coverage: 100% (16/16)
  Expression coverage: 100% (19/19)

... (all AST pipeline transformers at 100%)

3. CODE GENERATION QUALITY TEST
----------------------------------------

Language       Success     Functional     Issues
--------------------------------------------------------------------------------
Rust           100%        100%           None
Go             100%        100%           None
Java           100%        100%           None
... (all at 100%)
```

### Coverage Requirements

| Metric | Requirement |
|--------|-------------|
| Statement Coverage | 100% (16/16 types) |
| Expression Coverage | 100% (19/19 types) |
| Code Generation Success | 100% on all test algorithms |

### Critical Statement Types (16)

```
BlockStatement, BreakStatement, ClassDeclaration, ContinueStatement,
DoWhileStatement, ExpressionStatement, ForInStatement, ForOfStatement,
ForStatement, FunctionDeclaration, IfStatement, ReturnStatement,
SwitchStatement, ThrowStatement, TryStatement, WhileStatement
```

### Critical Expression Types (19)

```
ArrayExpression, ArrowFunctionExpression, AssignmentExpression,
BinaryExpression, CallExpression, ConditionalExpression, FunctionExpression,
Identifier, Literal, LogicalExpression, MemberExpression, NewExpression,
ObjectExpression, SequenceExpression, SpreadElement, TemplateLiteral,
ThisExpression, UnaryExpression, UpdateExpression
```

---

## Supported Languages

| Language | Icon | Extension | Architecture | Status |
|----------|------|-----------|--------------|--------|
| Basic | ğŸ“Ÿ | `.bas` | AST Pipeline | âœ… 100% |
| C | ğŸ”§ | `.c` | AST Pipeline | âœ… 100% |
| C++ | âš™ï¸ | `.cpp` | AST Pipeline | âœ… 100% |
| C# | ğŸ¯ | `.cs` | AST Pipeline | âœ… 100% |
| Delphi | ğŸ›ï¸ | `.pas` | AST Pipeline | âœ… 100% |
| Go | ğŸ¹ | `.go` | AST Pipeline | âœ… 100% |
| Java | â˜• | `.java` | AST Pipeline | âœ… 100% |
| JavaScript | ğŸŸ¨ | `.js` | AST Pipeline | âœ… 100% |
| Kotlin | ğŸ¨ | `.kt` | AST Pipeline | âœ… 100% |
| Perl | ğŸª | `.pl` | AST Pipeline | âœ… 100% |
| PHP | ğŸ˜ | `.php` | AST Pipeline | âœ… 100% |
| Python | ğŸ | `.py` | AST Pipeline | âœ… 100% |
| Ruby | ğŸ’ | `.rb` | AST Pipeline | âœ… 100% |
| Rust | ğŸ¦€ | `.rs` | AST Pipeline | âœ… 100% |
| TypeScript | ğŸ”· | `.ts` | AST Pipeline | âœ… 100% |

---

## Design Principles

1. **Type Preservation** - Types inferred from JSDoc flow through the entire pipeline
2. **Separation of Concerns** - Parser, type inference, transformation, and emission are separate stages
3. **Language-Specific AST** - Each language has typed nodes matching its constructs
4. **Extensibility** - Add new languages without modifying existing code
5. **Testability** - Each component can be tested independently
6. **Idiomatic Output** - Generated code follows target language conventions

---

## License

Part of the SynthelicZ Cipher Tools project.
