(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define(['../../AlgorithmFramework', '../../OpCodes'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // Node.js/CommonJS
    module.exports = factory(
      require('../../AlgorithmFramework'),
      require('../../OpCodes')
    );
  } else {
    // Browser/Worker global
    factory(root.AlgorithmFramework, root.OpCodes);
  }
}((function() {
  if (typeof globalThis !== 'undefined') return globalThis;
  if (typeof window !== 'undefined') return window;
  if (typeof global !== 'undefined') return global;
  if (typeof self !== 'undefined') return self;
  throw new Error('Unable to locate global object');
})(), function (AlgorithmFramework, OpCodes) {
  'use strict';

  if (!AlgorithmFramework) {
    throw new Error('AlgorithmFramework dependency is required');
  }

  if (!OpCodes) {
    throw new Error('OpCodes dependency is required');
  }

  // Extract framework components
  const { RegisterAlgorithm, CategoryType, SecurityStatus, ComplexityType, CountryCode,
          StreamCipherAlgorithm, IAlgorithmInstance, LinkItem, KeySize } = AlgorithmFramework;

  // ===== ALGORITHM IMPLEMENTATION =====

class XSalsa20 extends StreamCipherAlgorithm {
  constructor() {
    super();

    this.name = "XSalsa20";
    this.description = "Extended-nonce variant of Salsa20 stream cipher with 192-bit nonces. Uses HSalsa20 for subkey derivation enabling longer nonces without increased collision risk. Widely deployed in NaCl/LibSodium cryptographic library.";
    this.inventor = "Daniel J. Bernstein";
    this.year = 2008;
    this.category = CategoryType.STREAM;
    this.subCategory = "Stream Cipher";
    this.securityStatus = SecurityStatus.SECURE;
    this.complexity = ComplexityType.INTERMEDIATE;
    this.country = CountryCode.US;

    this.SupportedKeySizes = [new KeySize(32, 32, 1)];
    this.SupportedBlockSizes = [new KeySize(1, 65536, 1)];

    this.documentation = [
      new LinkItem("XSalsa20 Specification", "https://cr.yp.to/snuffle/xsalsa-20081128.pdf"),
      new LinkItem("NaCl: Networking and Cryptography library", "https://nacl.cr.yp.to/"),
      new LinkItem("LibSodium Documentation", "https://doc.libsodium.org/")
    ];

    // Test vectors from BouncyCastle/NaCl (generated by naclcrypto-20090308)
    // Source: https://github.com/bcgit/bc-java/blob/master/core/src/test/java/org/bouncycastle/crypto/test/XSalsa20Test.java
    this.tests = [
      {
        text: "NaCl Test Vector 1 (192-bit nonce, 256-bit key)",
        uri: "https://github.com/bcgit/bc-java/blob/master/core/src/test/java/org/bouncycastle/crypto/test/XSalsa20Test.java",
        key: OpCodes.Hex8ToBytes("a6a7251c1e72916d11c2cb214d3c252539121d8e234e652d651fa4c8cff88030"),
        nonce: OpCodes.Hex8ToBytes("9e645a74e9e0a60d8243acd9177ab51a1beb8d5a2f5d700c"),
        input: OpCodes.Hex8ToBytes("093c5e5585579625337bd3ab619d615760d8c5b224a85b1d0efe0eb8a7ee163abb0376529fcc09bab506c618e13ce777d82c3ae9d1a6f972d4160287cbfe60bf2130fc0a6ff6049d0a5c8a82f429231f008082e845d7e189d37f9ed2b464e6b919e6523a8c1210bd52a02a4c3fe406d3085f5068d1909eeeca6369abc981a42e87fe665583f0ab85ae71f6f84f528e6b397af86f6917d9754b7320dbdc2fea81496f2732f532ac78c4e9c6cfb18f8e9bdf74622eb126141416776971a84f94d156beaf67aecbf2ad412e76e66e8fad7633f5b6d7f3d64b5c6c69ce29003c6024465ae3b89be78e915d88b4b5621d"),
        expected: OpCodes.Hex8ToBytes("b2af688e7d8fc4b508c05cc39dd583d6714322c64d7f3e63147aede2d9534934b04ff6f337b031815cd094bdbc6d7a92077dce709412286822ef0737ee47f6b7ffa22f9d53f11dd2b0a3bb9fc01d9a88f9d53c26e9365c2c3c063bc4840bfc812e4b80463e69d179530b25c158f543191cff993106511aa036043bbc75866ab7e34afc57e2cce4934a5faae6eabe4f221770183dd060467827c27a354159a081275a291f69d946d6fe28ed0b9ce08206cf484925a51b9498dbde178ddd3ae91a8581b91682d860f840782f6eea49dbb9bd721501d2c67122dea3b7283848c5f13e0c0de876bd227a856e4de593a3")
      },
      {
        text: "NaCl Test Vector 2",
        uri: "https://github.com/bcgit/bc-java/blob/master/core/src/test/java/org/bouncycastle/crypto/test/XSalsa20Test.java",
        key: OpCodes.Hex8ToBytes("9e1da239d155f52ad37f75c7368a536668b051952923ad44f57e75ab588e475a"),
        nonce: OpCodes.Hex8ToBytes("af06f17859dffa799891c4288f6635b5c5a45eee9017fd72"),
        input: OpCodes.Hex8ToBytes("feac9d54fc8c115ae247d9a7e919dd76cfcbc72d32cae4944860817cbdfb8c04e6b1df76a16517cd33ccf1acda9206389e9e318f5966c093cfb3ec2d9ee2de856437ed581f552f26ac2907609df8c613b9e33d44bfc21ff79153e9ef81a9d66cc317857f752cc175fd8891fefebb7d041e6517c3162d197e2112837d3bc4104312ad35b75ea686e7c70d4ec04746b52ff09c421451459fb59f"),
        expected: OpCodes.Hex8ToBytes("2c261a2f4e61a62e1b27689916bf03453fcbc97bb2af6f329391ef063b5a219bf984d07d70f602d85f6db61474e9d9f5a2deecb4fcd90184d16f3b5b5e168ee03ea8c93f3933a22bc3d1a5ae8c2d8b02757c87c073409052a2a8a41e7f487e041f9a49a0997b540e18621cad3a24f0a56d9b19227929057ab3ba950f6274b121f193e32e06e5388781a1cb57317c0ba6305e910961d01002f0")
      },
      {
        text: "NaCl Test Vector 3",
        uri: "https://github.com/bcgit/bc-java/blob/master/core/src/test/java/org/bouncycastle/crypto/test/XSalsa20Test.java",
        key: OpCodes.Hex8ToBytes("d5c7f6797b7e7e9c1d7fd2610b2abf2bc5a7885fb3ff78092fb3abe8986d35e2"),
        nonce: OpCodes.Hex8ToBytes("744e17312b27969d826444640e9c4a378ae334f185369c95"),
        input: OpCodes.Hex8ToBytes("7758298c628eb3a4b6963c5445ef66971222be5d1a4ad839715d1188071739b77cc6e05d5410f963a64167629757"),
        expected: OpCodes.Hex8ToBytes("27b8cfe81416a76301fd1eec6a4d99675069b2da2776c360db1bdfea7c0aa613913e10f7a60fec04d11e65f2d64e")
      },
      {
        text: "NaCl Test Vector 4 (3-byte input)",
        uri: "https://github.com/bcgit/bc-java/blob/master/core/src/test/java/org/bouncycastle/crypto/test/XSalsa20Test.java",
        key: OpCodes.Hex8ToBytes("6799d76e5ffb5b4920bc2768bafd3f8c16554e65efcf9a16f4683a7a06927c11"),
        nonce: OpCodes.Hex8ToBytes("61ab951921e54ff06d9b77f313a4e49df7a057d5fd627989"),
        input: OpCodes.Hex8ToBytes("472766"),
        expected: OpCodes.Hex8ToBytes("8fd7df")
      },
      {
        text: "NaCl Test Vector 5 (long input)",
        uri: "https://github.com/bcgit/bc-java/blob/master/core/src/test/java/org/bouncycastle/crypto/test/XSalsa20Test.java",
        key: OpCodes.Hex8ToBytes("f68238c08365bb293d26980a606488d09c2f109edafa0bbae9937b5cc219a49c"),
        nonce: OpCodes.Hex8ToBytes("5190b51e9b708624820b5abdf4e40fad1fb950ad1adc2d26"),
        input: OpCodes.Hex8ToBytes("47ec6b1f73c4b7ff5274a0bfd7f45f864812c85a12fbcb3c2cf8a3e90cf66ccf2eacb521e748363c77f52eb426ae57a0c6c78f75af71284569e79d1a92f949a9d69c4efc0b69902f1e36d7562765543e2d3942d9f6ff5948d8a312cff72c1afd9ea3088aff7640bfd265f7a9946e606abc77bcedae6bddc75a0dba0bd917d73e3bd1268f727e0096345da1ed25cf553ea7a98fea6b6f285732de37431561ee1b3064887fbcbd71935e02"),
        expected: OpCodes.Hex8ToBytes("36160e88d3500529ba4edba17bc24d8cfaca9a0680b3b1fc97cf03f3675b7ac301c883a68c071bc54acdd3b63af4a2d72f985e51f9d60a4c7fd481af10b2fc75e252fdee7ea6b6453190617dcc6e2fe1cd56585fc2f0b0e97c5c3f8ad7eb4f31bc4890c03882aac24cc53acc1982296526690a220271c2f6e326750d3fbda5d5b63512c831f67830f59ac49aae330b3e0e02c9ea0091d19841f1b0e13d69c9fbfe8a12d6f30bb734d9d2")
      }
    ];
  }

  CreateInstance(isInverse = false) {
    return new XSalsa20Instance(this, isInverse);
  }
}

class XSalsa20Instance extends IAlgorithmInstance {
  constructor(algorithm, isInverse = false) {
    super(algorithm);
    this.isInverse = isInverse;
    this.inputBuffer = [];
    this._key = null;
    this._nonce = null;
    this.state = new Array(16);
    this.keystreamBuffer = [];
    this.bufferIndex = 0;
    this.counter = [0, 0];

    // Salsa20 constants: "expand 32-byte k"
    this.SIGMA = [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574];
  }

  set key(keyBytes) {
    if (!keyBytes) {
      this._key = null;
      return;
    }

    if (keyBytes.length !== 32) {
      throw new Error(`Invalid key size: ${keyBytes.length} bytes`);
    }

    this._key = [...keyBytes];
    if (this._nonce) {
      this._setupState();
    }
  }

  get key() { return this._key ? [...this._key] : null; }

  set nonce(nonceBytes) {
    if (!nonceBytes || nonceBytes.length !== 24) {
      throw new Error(`XSalsa20 requires 24-byte nonce, got ${nonceBytes ? nonceBytes.length : 0} bytes`);
    }
    this._nonce = [...nonceBytes];
    if (this._key) {
      this._setupState();
    }
  }

  get nonce() { return this._nonce ? [...this._nonce] : null; }

  Feed(data) {
    if (!data || data.length === 0) return;
    if (!this._key) throw new Error("Key not set");
    if (!this._nonce) throw new Error("Nonce not set");
    this.inputBuffer.push(...data);
  }

  Result() {
    if (!this._key) throw new Error("Key not set");
    if (!this._nonce) throw new Error("Nonce not set");
    if (this.inputBuffer.length === 0) throw new Error("No data fed");

    const output = [];
    for (let i = 0; i < this.inputBuffer.length; i++) {
      const keystreamByte = this._getNextKeystreamByte();
      output.push(this.inputBuffer[i] ^ keystreamByte);
    }

    this.inputBuffer = [];
    return output;
  }

  _setupState() {
    if (!this._key || !this._nonce) return;

    // XSalsa20: Use HSalsa20 to derive subkey from first 16 bytes of nonce
    const subkey = this._hsalsa20(this._key, this._nonce.slice(0, 16));

    // Initialize Salsa20 state with derived subkey and last 8 bytes of nonce
    this.state[0] = this.SIGMA[0];
    this.state[5] = this.SIGMA[1];
    this.state[10] = this.SIGMA[2];
    this.state[15] = this.SIGMA[3];

    // Subkey (256 bits)
    this.state[1] = OpCodes.Pack32LE(subkey[0], subkey[1], subkey[2], subkey[3]);
    this.state[2] = OpCodes.Pack32LE(subkey[4], subkey[5], subkey[6], subkey[7]);
    this.state[3] = OpCodes.Pack32LE(subkey[8], subkey[9], subkey[10], subkey[11]);
    this.state[4] = OpCodes.Pack32LE(subkey[12], subkey[13], subkey[14], subkey[15]);
    this.state[11] = OpCodes.Pack32LE(subkey[16], subkey[17], subkey[18], subkey[19]);
    this.state[12] = OpCodes.Pack32LE(subkey[20], subkey[21], subkey[22], subkey[23]);
    this.state[13] = OpCodes.Pack32LE(subkey[24], subkey[25], subkey[26], subkey[27]);
    this.state[14] = OpCodes.Pack32LE(subkey[28], subkey[29], subkey[30], subkey[31]);

    // Last 8 bytes of nonce (64 bits)
    this.state[6] = OpCodes.Pack32LE(this._nonce[16], this._nonce[17], this._nonce[18], this._nonce[19]);
    this.state[7] = OpCodes.Pack32LE(this._nonce[20], this._nonce[21], this._nonce[22], this._nonce[23]);

    // Counter (64 bits)
    this.counter = [0, 0];
    this.state[8] = 0;
    this.state[9] = 0;

    this.keystreamBuffer = [];
    this.bufferIndex = 0;
  }

  _hsalsa20(key, nonce) {
    // HSalsa20: Salsa20 core without final addition
    // Input: 256-bit key + 128-bit nonce
    // Output: 256-bit subkey
    const state = new Array(16);

    // Constants
    state[0] = this.SIGMA[0];
    state[5] = this.SIGMA[1];
    state[10] = this.SIGMA[2];
    state[15] = this.SIGMA[3];

    // Key (256 bits)
    state[1] = OpCodes.Pack32LE(key[0], key[1], key[2], key[3]);
    state[2] = OpCodes.Pack32LE(key[4], key[5], key[6], key[7]);
    state[3] = OpCodes.Pack32LE(key[8], key[9], key[10], key[11]);
    state[4] = OpCodes.Pack32LE(key[12], key[13], key[14], key[15]);
    state[11] = OpCodes.Pack32LE(key[16], key[17], key[18], key[19]);
    state[12] = OpCodes.Pack32LE(key[20], key[21], key[22], key[23]);
    state[13] = OpCodes.Pack32LE(key[24], key[25], key[26], key[27]);
    state[14] = OpCodes.Pack32LE(key[28], key[29], key[30], key[31]);

    // First 16 bytes of nonce (128 bits)
    state[6] = OpCodes.Pack32LE(nonce[0], nonce[1], nonce[2], nonce[3]);
    state[7] = OpCodes.Pack32LE(nonce[4], nonce[5], nonce[6], nonce[7]);
    state[8] = OpCodes.Pack32LE(nonce[8], nonce[9], nonce[10], nonce[11]);
    state[9] = OpCodes.Pack32LE(nonce[12], nonce[13], nonce[14], nonce[15]);

    // Run Salsa20 core (20 rounds)
    const output = this._salsa20Core(state);

    // HSalsa20: Extract subkey without addition (positions 0, 5-9, 10, 15)
    // This differs from regular Salsa20 which adds input to output
    const subkey = new Array(32);
    let subbytes;

    // Extract bytes in order: [0, 5, 10, 15, 6, 7, 8, 9]
    subbytes = OpCodes.Unpack32LE(output[0] - state[0]);
    subkey[0] = subbytes[0]; subkey[1] = subbytes[1]; subkey[2] = subbytes[2]; subkey[3] = subbytes[3];

    subbytes = OpCodes.Unpack32LE(output[5] - state[5]);
    subkey[4] = subbytes[0]; subkey[5] = subbytes[1]; subkey[6] = subbytes[2]; subkey[7] = subbytes[3];

    subbytes = OpCodes.Unpack32LE(output[10] - state[10]);
    subkey[8] = subbytes[0]; subkey[9] = subbytes[1]; subkey[10] = subbytes[2]; subkey[11] = subbytes[3];

    subbytes = OpCodes.Unpack32LE(output[15] - state[15]);
    subkey[12] = subbytes[0]; subkey[13] = subbytes[1]; subkey[14] = subbytes[2]; subkey[15] = subbytes[3];

    subbytes = OpCodes.Unpack32LE(output[6] - state[6]);
    subkey[16] = subbytes[0]; subkey[17] = subbytes[1]; subkey[18] = subbytes[2]; subkey[19] = subbytes[3];

    subbytes = OpCodes.Unpack32LE(output[7] - state[7]);
    subkey[20] = subbytes[0]; subkey[21] = subbytes[1]; subkey[22] = subbytes[2]; subkey[23] = subbytes[3];

    subbytes = OpCodes.Unpack32LE(output[8] - state[8]);
    subkey[24] = subbytes[0]; subkey[25] = subbytes[1]; subkey[26] = subbytes[2]; subkey[27] = subbytes[3];

    subbytes = OpCodes.Unpack32LE(output[9] - state[9]);
    subkey[28] = subbytes[0]; subkey[29] = subbytes[1]; subkey[30] = subbytes[2]; subkey[31] = subbytes[3];

    return subkey;
  }

  _salsa20Core(input) {
    // Salsa20 core: 20 rounds of column and diagonal rounds
    let x0 = input[0], x1 = input[1], x2 = input[2], x3 = input[3];
    let x4 = input[4], x5 = input[5], x6 = input[6], x7 = input[7];
    let x8 = input[8], x9 = input[9], x10 = input[10], x11 = input[11];
    let x12 = input[12], x13 = input[13], x14 = input[14], x15 = input[15];

    // 20 rounds (10 double-rounds)
    for (let i = 0; i < 10; i++) {
      // Column rounds
      x4 ^= OpCodes.RotL32((x0 + x12) | 0, 7);
      x8 ^= OpCodes.RotL32((x4 + x0) | 0, 9);
      x12 ^= OpCodes.RotL32((x8 + x4) | 0, 13);
      x0 ^= OpCodes.RotL32((x12 + x8) | 0, 18);

      x9 ^= OpCodes.RotL32((x5 + x1) | 0, 7);
      x13 ^= OpCodes.RotL32((x9 + x5) | 0, 9);
      x1 ^= OpCodes.RotL32((x13 + x9) | 0, 13);
      x5 ^= OpCodes.RotL32((x1 + x13) | 0, 18);

      x14 ^= OpCodes.RotL32((x10 + x6) | 0, 7);
      x2 ^= OpCodes.RotL32((x14 + x10) | 0, 9);
      x6 ^= OpCodes.RotL32((x2 + x14) | 0, 13);
      x10 ^= OpCodes.RotL32((x6 + x2) | 0, 18);

      x3 ^= OpCodes.RotL32((x15 + x11) | 0, 7);
      x7 ^= OpCodes.RotL32((x3 + x15) | 0, 9);
      x11 ^= OpCodes.RotL32((x7 + x3) | 0, 13);
      x15 ^= OpCodes.RotL32((x11 + x7) | 0, 18);

      // Diagonal rounds
      x1 ^= OpCodes.RotL32((x0 + x3) | 0, 7);
      x2 ^= OpCodes.RotL32((x1 + x0) | 0, 9);
      x3 ^= OpCodes.RotL32((x2 + x1) | 0, 13);
      x0 ^= OpCodes.RotL32((x3 + x2) | 0, 18);

      x6 ^= OpCodes.RotL32((x5 + x4) | 0, 7);
      x7 ^= OpCodes.RotL32((x6 + x5) | 0, 9);
      x4 ^= OpCodes.RotL32((x7 + x6) | 0, 13);
      x5 ^= OpCodes.RotL32((x4 + x7) | 0, 18);

      x11 ^= OpCodes.RotL32((x10 + x9) | 0, 7);
      x8 ^= OpCodes.RotL32((x11 + x10) | 0, 9);
      x9 ^= OpCodes.RotL32((x8 + x11) | 0, 13);
      x10 ^= OpCodes.RotL32((x9 + x8) | 0, 18);

      x12 ^= OpCodes.RotL32((x15 + x14) | 0, 7);
      x13 ^= OpCodes.RotL32((x12 + x15) | 0, 9);
      x14 ^= OpCodes.RotL32((x13 + x12) | 0, 13);
      x15 ^= OpCodes.RotL32((x14 + x13) | 0, 18);
    }

    // Add input to output (final step of Salsa20)
    return [
      (x0 + input[0]) | 0, (x1 + input[1]) | 0, (x2 + input[2]) | 0, (x3 + input[3]) | 0,
      (x4 + input[4]) | 0, (x5 + input[5]) | 0, (x6 + input[6]) | 0, (x7 + input[7]) | 0,
      (x8 + input[8]) | 0, (x9 + input[9]) | 0, (x10 + input[10]) | 0, (x11 + input[11]) | 0,
      (x12 + input[12]) | 0, (x13 + input[13]) | 0, (x14 + input[14]) | 0, (x15 + input[15]) | 0
    ];
  }

  _generateBlock() {
    // Update counter in state
    this.state[8] = this.counter[0];
    this.state[9] = this.counter[1];

    // Generate keystream block
    const output = this._salsa20Core(this.state);

    // Convert to bytes
    const keystream = [];
    for (let i = 0; i < 16; i++) {
      const bytes = OpCodes.Unpack32LE(output[i]);
      keystream.push(bytes[0], bytes[1], bytes[2], bytes[3]);
    }

    // Increment counter
    this.counter[0] = (this.counter[0] + 1) >>> 0;
    if (this.counter[0] === 0) {
      this.counter[1] = (this.counter[1] + 1) >>> 0;
    }

    return keystream;
  }

  _getNextKeystreamByte() {
    if (this.bufferIndex >= this.keystreamBuffer.length) {
      this.keystreamBuffer = this._generateBlock();
      this.bufferIndex = 0;
    }

    return this.keystreamBuffer[this.bufferIndex++];
  }
}

  // ===== REGISTRATION =====

  const algorithmInstance = new XSalsa20();
  if (!AlgorithmFramework.Find(algorithmInstance.name)) {
    RegisterAlgorithm(algorithmInstance);
  }

  // ===== EXPORTS =====

  return { XSalsa20, XSalsa20Instance };
}));
