/*
 * Midori - Low-Energy Block Cipher
 * Professional implementation following ASIACRYPT 2015 specification
 * (c)2006-2025 Hawkynt
 *
 * Midori is a family of lightweight block ciphers optimized for low energy
 * consumption. Midori64 uses 64-bit blocks, Midori128 uses 128-bit blocks,
 * both with 128-bit keys. They use an AES-like structure with 16-20 rounds.
 *
 * Published: ASIACRYPT 2015
 * Authors: Subhadeep Banik, Andrey Bogdanov, Takanori Isobe, Kyoji Shibutani,
 *          Harunaga Hiwatari, Toru Akishita, Francesco Regazzoni
 *
 * Reference: https://eprint.iacr.org/2015/1142
 */

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['../../AlgorithmFramework', '../../OpCodes'], factory);
  } else if (typeof module === 'object' && module.exports) {
    module.exports = factory(
      require('../../AlgorithmFramework'),
      require('../../OpCodes')
    );
  } else {
    factory(root.AlgorithmFramework, root.OpCodes);
  }
}((function() {
  if (typeof globalThis !== 'undefined') return globalThis;
  if (typeof window !== 'undefined') return window;
  if (typeof global !== 'undefined') return global;
  if (typeof self !== 'undefined') return self;
  throw new Error('Unable to locate global object');
})(), function (AlgorithmFramework, OpCodes) {
  'use strict';

  if (!AlgorithmFramework) throw new Error('AlgorithmFramework dependency is required');
  if (!OpCodes) throw new Error('OpCodes dependency is required');

  const { RegisterAlgorithm, CategoryType, SecurityStatus, ComplexityType, CountryCode,
          BlockCipherAlgorithm, IBlockCipherInstance, LinkItem, KeySize } = AlgorithmFramework;

  // S-box Sb0 (4-bit) - used in Midori64
  const SB0 = [0xC, 0xA, 0xD, 0x3, 0xE, 0xB, 0xF, 0x7, 0x8, 0x9, 0x1, 0x5, 0x0, 0x2, 0x4, 0x6];

  // S-box Sb1 (4-bit) - used in Midori128
  const SB1 = [0x1, 0x0, 0x5, 0x3, 0xE, 0x2, 0xF, 0x7, 0xD, 0xA, 0x9, 0xB, 0xC, 0x8, 0x4, 0x6];

  // Inverse S-boxes
  const INV_SB0 = new Array(16);
  const INV_SB1 = new Array(16);
  for (let i = 0; i < 16; ++i) {
    INV_SB0[SB0[i]] = i;
    INV_SB1[SB1[i]] = i;
  }

  // 8-bit S-box construction for Midori128
  // SSbi(x, i) constructs 8-bit S-boxes from 4-bit Sb1 using bit permutations
  function SSbi(x, i) {
    // Extract individual bits (MSB to LSB)
    const x0 = (x >>> 7) & 1;
    const x1 = (x >>> 6) & 1;
    const x2 = (x >>> 5) & 1;
    const x3 = (x >>> 4) & 1;
    const x4 = (x >>> 3) & 1;
    const x5 = (x >>> 2) & 1;
    const x6 = (x >>> 1) & 1;
    const x7 = x & 1;

    let a0, a1, a2, a3;  // First group
    let b0, b1, b2, b3;  // Second group

    // Group bits based on variant i
    if (i === 0) {
      // Groups [x4,x1,x6,x3] and [x0,x5,x2,x7]
      a0 = x4; a1 = x1; a2 = x6; a3 = x3;
      b0 = x0; b1 = x5; b2 = x2; b3 = x7;
    } else if (i === 1) {
      // Groups [x1,x6,x7,x0] and [x5,x2,x3,x4]
      a0 = x1; a1 = x6; a2 = x7; a3 = x0;
      b0 = x5; b1 = x2; b2 = x3; b3 = x4;
    } else if (i === 2) {
      // Groups [x2,x3,x4,x1] and [x6,x7,x0,x5]
      a0 = x2; a1 = x3; a2 = x4; a3 = x1;
      b0 = x6; b1 = x7; b2 = x0; b3 = x5;
    } else {  // i === 3
      // Groups [x7,x4,x1,x2] and [x3,x0,x5,x6]
      a0 = x7; a1 = x4; a2 = x1; a3 = x2;
      b0 = x3; b1 = x0; b2 = x5; b3 = x6;
    }

    // Apply Sb1 to each 4-bit group
    const aVal = (a0 << 3) | (a1 << 2) | (a2 << 1) | a3;
    const bVal = (b0 << 3) | (b1 << 2) | (b2 << 1) | b3;

    const n0 = SB1[bVal];
    const n1 = SB1[aVal];

    // Extract output bits from Sb1 results
    const n0_0 = (n0 >>> 3) & 1;
    const n0_1 = (n0 >>> 2) & 1;
    const n0_2 = (n0 >>> 1) & 1;
    const n0_3 = n0 & 1;

    const n1_0 = (n1 >>> 3) & 1;
    const n1_1 = (n1 >>> 2) & 1;
    const n1_2 = (n1 >>> 1) & 1;
    const n1_3 = n1 & 1;

    let y0, y1, y2, y3, y4, y5, y6, y7;

    // Recombine bits based on variant i
    if (i === 0) {
      // Output: [n1[0],n0[1],n1[2],n0[3],n0[0],n1[1],n0[2],n1[3]]
      y0 = n1_0; y1 = n0_1; y2 = n1_2; y3 = n0_3;
      y4 = n0_0; y5 = n1_1; y6 = n0_2; y7 = n1_3;
    } else if (i === 1) {
      // Output: [n0[3],n0[0],n1[1],n1[2],n1[3],n1[0],n0[1],n0[2]]
      y0 = n0_3; y1 = n0_0; y2 = n1_1; y3 = n1_2;
      y4 = n1_3; y5 = n1_0; y6 = n0_1; y7 = n0_2;
    } else if (i === 2) {
      // Output: [n1[2],n0[3],n0[0],n0[1],n0[2],n1[3],n1[0],n1[1]]
      y0 = n1_2; y1 = n0_3; y2 = n0_0; y3 = n0_1;
      y4 = n0_2; y5 = n1_3; y6 = n1_0; y7 = n1_1;
    } else {  // i === 3
      // Output: [n1[1],n0[2],n0[3],n1[0],n0[1],n1[2],n1[3],n0[0]]
      y0 = n1_1; y1 = n0_2; y2 = n0_3; y3 = n1_0;
      y4 = n0_1; y5 = n1_2; y6 = n1_3; y7 = n0_0;
    }

    // Combine output bits into 8-bit value
    return (y0 << 7) | (y1 << 6) | (y2 << 5) | (y3 << 4) |
           (y4 << 3) | (y5 << 2) | (y6 << 1) | y7;
  }

  // Pre-compute 8-bit S-box lookup tables for Midori128
  const SSB0 = new Array(256);
  const SSB1 = new Array(256);
  const SSB2 = new Array(256);
  const SSB3 = new Array(256);

  for (let i = 0; i < 256; ++i) {
    SSB0[i] = SSbi(i, 0);
    SSB1[i] = SSbi(i, 1);
    SSB2[i] = SSbi(i, 2);
    SSB3[i] = SSbi(i, 3);
  }

  // Inverse 8-bit S-boxes for Midori128 decryption
  const INV_SSB0 = new Array(256);
  const INV_SSB1 = new Array(256);
  const INV_SSB2 = new Array(256);
  const INV_SSB3 = new Array(256);

  for (let i = 0; i < 256; ++i) {
    INV_SSB0[SSB0[i]] = i;
    INV_SSB1[SSB1[i]] = i;
    INV_SSB2[SSB2[i]] = i;
    INV_SSB3[SSB3[i]] = i;
  }

  // MixColumns matrix: Binary matrix with 0s on diagonal, 1s elsewhere
  // Operates in GF(2) (simple XOR)
  function mixColumns(state) {
    const result = [];

    // State is organized as 4×4 matrix of nibbles
    // MixColumns: each column is transformed
    for (let col = 0; col < 4; ++col) {
      const a = state[col];
      const b = state[col + 4];
      const c = state[col + 8];
      const d = state[col + 12];

      // Matrix multiplication in GF(2):
      // [0 1 1 1]   [a]
      // [1 0 1 1] × [b]
      // [1 1 0 1]   [c]
      // [1 1 1 0]   [d]
      result[col] = b ^ c ^ d;
      result[col + 4] = a ^ c ^ d;
      result[col + 8] = a ^ b ^ d;
      result[col + 12] = a ^ b ^ c;
    }

    return result;
  }

  // ShuffleCell permutation
  function shuffleCell(state) {
    // Permutation for cell positions [0..15] → P[i]
    const perm = [0, 10, 5, 15, 14, 4, 11, 1, 9, 3, 12, 6, 7, 13, 2, 8];
    const result = new Array(16);

    for (let i = 0; i < 16; ++i) {
      result[i] = state[perm[i]];
    }

    return result;
  }

  // Inverse ShuffleCell
  function invShuffleCell(state) {
    const perm = [0, 10, 5, 15, 14, 4, 11, 1, 9, 3, 12, 6, 7, 13, 2, 8];
    const invPerm = new Array(16);
    for (let i = 0; i < 16; ++i) {
      invPerm[perm[i]] = i;
    }

    const result = new Array(16);
    for (let i = 0; i < 16; ++i) {
      result[i] = state[invPerm[i]];
    }

    return result;
  }

  // Round constants (4×4 binary matrices) from Midori specification
  // These are the actual beta/alpha constants used in key schedule
  const ROUND_CONSTANTS = [
    [[0,0,1,0],[0,1,0,0],[0,0,1,1],[1,1,1,1]], // C0
    [[0,1,1,0],[1,0,1,0],[1,0,0,0],[1,0,0,0]], // C1
    [[1,0,0,0],[0,1,0,1],[1,0,1,0],[0,0,1,1]], // C2
    [[0,0,0,0],[1,0,0,0],[1,1,0,1],[0,0,1,1]], // C3
    [[0,0,0,1],[0,0,1,1],[0,0,0,1],[1,0,0,1]], // C4
    [[1,0,0,0],[1,0,1,0],[0,0,1,0],[1,1,1,0]], // C5
    [[0,0,0,0],[0,0,1,1],[0,1,1,1],[0,0,0,0]], // C6
    [[0,1,1,1],[0,0,1,1],[0,1,0,0],[0,1,0,0]], // C7
    [[1,0,1,0],[0,1,0,0],[0,0,0,0],[1,0,0,1]], // C8
    [[0,0,1,1],[1,0,0,0],[0,0,1,0],[0,0,1,0]], // C9
    [[0,0,1,0],[1,0,0,1],[1,0,0,1],[1,1,1,1]], // C10
    [[0,0,1,1],[0,0,0,1],[1,1,0,1],[0,0,0,0]], // C11
    [[0,0,0,0],[1,0,0,0],[0,0,1,0],[1,1,1,0]], // C12
    [[1,1,1,1],[1,0,1,0],[1,0,0,1],[1,0,0,0]], // C13
    [[1,1,1,0],[1,1,0,0],[0,1,0,0],[1,1,1,0]], // C14
    [[0,1,1,0],[1,1,0,0],[1,0,0,0],[1,0,0,1]], // C15
    [[0,1,0,0],[0,1,0,1],[0,0,1,0],[1,0,0,0]], // C16
    [[0,0,1,0],[0,0,0,1],[1,1,1,0],[0,1,1,0]], // C17
    [[0,0,1,1],[1,0,0,0],[1,1,0,1],[0,0,0,0]]  // C18
  ];

  // Key schedule for Midori64: uses K₀ for whitening
  function generateRoundKeys64(key, numRounds) {
    const roundKeys = [];

    // Split key into K0 (first 64 bits) and K1 (second 64 bits)
    const k0 = new Array(16);
    const k1 = new Array(16);
    for (let i = 0; i < 8; ++i) {
      k0[2 * i] = (key[i] >>> 4) & 0x0F;
      k0[2 * i + 1] = key[i] & 0x0F;
      k1[2 * i] = (key[i + 8] >>> 4) & 0x0F;
      k1[2 * i + 1] = key[i + 8] & 0x0F;
    }

    // First entry is whitening key (K0 for Midori64)
    roundKeys.push([...k0]);

    // Generate 16 round keys: RKᵢ = K₍ᵢ mod 2₎ ⊕ αᵢ
    for (let r = 0; r < numRounds; ++r) {
      const rk = new Array(16);
      const baseKey = (r % 2 === 0) ? k0 : k1;
      const rConst = ROUND_CONSTANTS[r];

      for (let i = 0; i < 16; ++i) {
        const col = Math.floor(i / 4);
        const row = i % 4;
        const bit = rConst[row][col];
        rk[i] = baseKey[i] ^ bit;
      }
      roundKeys.push(rk);
    }

    return roundKeys;
  }

  // Key schedule for Midori128
  function generateRoundKeys128(key, numRounds) {
    const roundKeys = [];

    // Generate 19 round keys (indices 0-18)
    // Round constants are 4×4 binary matrices
    for (let r = 0; r < numRounds; ++r) {
      const rk = new Array(16);
      const rConst = ROUND_CONSTANTS[r];

      // For each byte position i in the 16-byte key:
      // XOR with corresponding bit from round constant matrix
      for (let i = 0; i < 16; ++i) {
        const col = Math.floor(i / 4);
        const row = i % 4;
        const bit = rConst[row][col];

        // XOR the key byte with the round constant bit
        rk[i] = key[i] ^ bit;
      }
      roundKeys.push(rk);
    }

    return roundKeys;
  }

  // ===== Midori64 Implementation =====

  class Midori64 extends BlockCipherAlgorithm {
    constructor() {
      super();

      this.name = "Midori64";
      this.description = "Lightweight block cipher optimized for low energy consumption. 64-bit block size with 128-bit keys using 16 rounds. Based on AES-like structure with 4×4 nibble state and binary MixColumns operation in GF(2).";
      this.inventor = "Subhadeep Banik, Andrey Bogdanov, Takanori Isobe, et al.";
      this.year = 2015;
      this.category = CategoryType.BLOCK;
      this.subCategory = "Lightweight Block Cipher";
      this.securityStatus = SecurityStatus.EXPERIMENTAL;
      this.complexity = ComplexityType.INTERMEDIATE;
      this.country = CountryCode.JP;

      this.SupportedKeySizes = [new KeySize(16, 16, 1)]; // 128-bit keys only
      this.SupportedBlockSizes = [new KeySize(8, 8, 1)]; // 64-bit blocks only

      this.documentation = [
        new LinkItem("Midori Specification (ePrint Archive)", "https://eprint.iacr.org/2015/1142"),
        new LinkItem("ASIACRYPT 2015 Paper", "https://link.springer.com/chapter/10.1007/978-3-662-48800-3_17")
      ];

      // Test vectors from specification Appendix A
      this.tests = [
        {
          text: "Midori64 Test Vector #1 (ePrint 2015/1142 Appendix A)",
          uri: "https://eprint.iacr.org/2015/1142",
          input: OpCodes.Hex8ToBytes("0000000000000000"),
          key: OpCodes.Hex8ToBytes("00000000000000000000000000000000"),
          expected: OpCodes.Hex8ToBytes("3c9cceda2bbd449a")
        }
      ];
    }

    CreateInstance(isInverse = false) {
      return new Midori64Instance(this, isInverse);
    }
  }

  class Midori64Instance extends IBlockCipherInstance {
    constructor(algorithm, isInverse = false) {
      super(algorithm);
      this.isInverse = isInverse;
      this.inputBuffer = [];
      this._key = null;
      this._roundKeys = null;
    }

    set key(keyBytes) {
      if (!keyBytes) {
        this._key = null;
        this._roundKeys = null;
        return;
      }

      if (keyBytes.length !== 16) {
        throw new Error(`Invalid key size: ${keyBytes.length} bytes (expected 16 bytes)`);
      }

      this._key = [...keyBytes];
      this._roundKeys = generateRoundKeys64(new Uint8Array(this._key), 16);
    }

    get key() {
      return this._key ? [...this._key] : null;
    }

    Feed(data) {
      if (!data || data.length === 0) return;
      if (!this._key) throw new Error("Key not set");
      this.inputBuffer.push(...data);
    }

    Result() {
      if (!this._key) throw new Error("Key not set");
      if (this.inputBuffer.length === 0) throw new Error("No data fed");
      if (this.inputBuffer.length % 8 !== 0) {
        throw new Error(`Invalid input length: ${this.inputBuffer.length} bytes (must be multiple of 8)`);
      }

      const output = [];
      const numBlocks = this.inputBuffer.length / 8;

      for (let b = 0; b < numBlocks; ++b) {
        const block = this.inputBuffer.slice(b * 8, (b + 1) * 8);
        const processed = this.processBlock(block);
        output.push(...processed);
      }

      this.inputBuffer = [];
      return output;
    }

    processBlock(block) {
      // Convert block to 16 nibbles (4×4 state)
      let state = new Array(16);
      for (let i = 0; i < 8; ++i) {
        state[2 * i] = (block[i] >>> 4) & 0x0F;
        state[2 * i + 1] = block[i] & 0x0F;
      }

      // Pre-whitening: XOR with WK (roundKeys[0])
      const wk = this._roundKeys[0];
      for (let i = 0; i < 16; ++i) {
        state[i] ^= wk[i];
      }

      if (this.isInverse) {
        // Decryption: apply SubCell first, then inverse rounds
        for (let i = 0; i < 16; ++i) {
          state[i] = INV_SB0[state[i]];
        }

        // 16 inverse rounds (r = 15 down to 0)
        for (let r = 15; r >= 0; --r) {
          for (let i = 0; i < 16; ++i) {
            state[i] ^= this._roundKeys[r + 1][i];
          }
          state = mixColumns(state);
          state = invShuffleCell(state);
          for (let i = 0; i < 16; ++i) {
            state[i] = INV_SB0[state[i]];
          }
        }
      } else {
        // Encryption: 16 forward rounds
        for (let r = 0; r < 16; ++r) {
          // Round function: KeyAdd → SubCell → ShuffleCell → MixColumn
          // 1. KeyAdd + SubCell (combined)
          for (let i = 0; i < 16; ++i) {
            state[i] = SB0[state[i] ^ this._roundKeys[r + 1][i]];
          }
          // 2. ShuffleCell
          state = shuffleCell(state);
          // 3. MixColumn
          state = mixColumns(state);
        }

        // Final SubCell only (no ShuffleCell or MixColumn after)
        for (let i = 0; i < 16; ++i) {
          state[i] = SB0[state[i]];
        }
      }

      // Post-whitening: XOR with WK (roundKeys[0])
      for (let i = 0; i < 16; ++i) {
        state[i] ^= wk[i];
      }

      // Convert nibbles back to bytes
      const result = new Array(8);
      for (let i = 0; i < 8; ++i) {
        result[i] = ((state[2 * i] & 0x0F) << 4) | (state[2 * i + 1] & 0x0F);
      }

      return result;
    }
  }

  // ===== Midori128 Implementation =====

  class Midori128 extends BlockCipherAlgorithm {
    constructor() {
      super();

      this.name = "Midori128";
      this.description = "Lightweight block cipher optimized for low energy consumption. 128-bit block size with 128-bit keys using 20 rounds. Based on AES-like structure with 4×4 byte state and binary MixColumns operation in GF(2).";
      this.inventor = "Subhadeep Banik, Andrey Bogdanov, Takanori Isobe, et al.";
      this.year = 2015;
      this.category = CategoryType.BLOCK;
      this.subCategory = "Lightweight Block Cipher";
      this.securityStatus = SecurityStatus.EXPERIMENTAL;
      this.complexity = ComplexityType.INTERMEDIATE;
      this.country = CountryCode.JP;

      this.SupportedKeySizes = [new KeySize(16, 16, 1)]; // 128-bit keys only
      this.SupportedBlockSizes = [new KeySize(16, 16, 1)]; // 128-bit blocks only

      this.documentation = [
        new LinkItem("Midori Specification (ePrint Archive)", "https://eprint.iacr.org/2015/1142"),
        new LinkItem("ASIACRYPT 2015 Paper", "https://link.springer.com/chapter/10.1007/978-3-662-48800-3_17")
      ];

      // Test vectors from specification Appendix A
      this.tests = [
        {
          text: "Midori128 Test Vector #1 (ePrint 2015/1142 Appendix A)",
          uri: "https://eprint.iacr.org/2015/1142",
          input: OpCodes.Hex8ToBytes("00000000000000000000000000000000"),
          key: OpCodes.Hex8ToBytes("00000000000000000000000000000000"),
          expected: OpCodes.Hex8ToBytes("c055cbb95996d14902b60574d5e728d6")
        },
        {
          text: "Midori128 Test Vector #2 (ePrint 2015/1142 Appendix A)",
          uri: "https://eprint.iacr.org/2015/1142",
          input: OpCodes.Hex8ToBytes("51084ce6e73a5ca2ec87d7babc297543"),
          key: OpCodes.Hex8ToBytes("687ded3b3c85b3f35b1009863e2a8cbf"),
          expected: OpCodes.Hex8ToBytes("1e0ac4fddff71b4c1801b73ee4afc83d")
        }
      ];
    }

    CreateInstance(isInverse = false) {
      return new Midori128Instance(this, isInverse);
    }
  }

  class Midori128Instance extends IBlockCipherInstance {
    constructor(algorithm, isInverse = false) {
      super(algorithm);
      this.isInverse = isInverse;
      this.inputBuffer = [];
      this._key = null;
      this._roundKeys = null;
    }

    set key(keyBytes) {
      if (!keyBytes) {
        this._key = null;
        this._roundKeys = null;
        return;
      }

      if (keyBytes.length !== 16) {
        throw new Error(`Invalid key size: ${keyBytes.length} bytes (expected 16 bytes)`);
      }

      this._key = [...keyBytes];
      this._roundKeys = generateRoundKeys128(new Uint8Array(this._key), 19);
    }

    get key() {
      return this._key ? [...this._key] : null;
    }

    Feed(data) {
      if (!data || data.length === 0) return;
      if (!this._key) throw new Error("Key not set");
      this.inputBuffer.push(...data);
    }

    Result() {
      if (!this._key) throw new Error("Key not set");
      if (this.inputBuffer.length === 0) throw new Error("No data fed");
      if (this.inputBuffer.length % 16 !== 0) {
        throw new Error(`Invalid input length: ${this.inputBuffer.length} bytes (must be multiple of 16)`);
      }

      const output = [];
      const numBlocks = this.inputBuffer.length / 16;

      for (let b = 0; b < numBlocks; ++b) {
        const block = this.inputBuffer.slice(b * 16, (b + 1) * 16);
        const processed = this.processBlock(block);
        output.push(...processed);
      }

      this.inputBuffer = [];
      return output;
    }

    processBlock(block) {
      // Midori128 works with 16 bytes directly (not nibbles)
      let state = new Array(16);
      for (let i = 0; i < 16; ++i) {
        state[i] = block[i] & 0xFF;
      }

      if (this.isInverse) {
        // Decryption

        // Initial key addition with original key
        for (let i = 0; i < 16; ++i) {
          state[i] ^= this._key[i];
        }

        // Inverse of final round: SubCell only
        for (let i = 0; i < 16; ++i) {
          const sboxIndex = i % 4;
          if (sboxIndex === 0) {
            state[i] = INV_SSB0[state[i]];
          } else if (sboxIndex === 1) {
            state[i] = INV_SSB1[state[i]];
          } else if (sboxIndex === 2) {
            state[i] = INV_SSB2[state[i]];
          } else {  // sboxIndex === 3
            state[i] = INV_SSB3[state[i]];
          }
        }

        // 19 full inverse rounds
        for (let r = 18; r >= 0; --r) {
          // KeyAdd
          for (let i = 0; i < 16; ++i) {
            state[i] ^= this._roundKeys[r][i];
          }

          // Inverse: MixColumn → ShuffleCell → SubCell
          state = mixColumns(state);
          state = invShuffleCell(state);
          for (let i = 0; i < 16; ++i) {
            const sboxIndex = i % 4;
            if (sboxIndex === 0) {
              state[i] = INV_SSB0[state[i]];
            } else if (sboxIndex === 1) {
              state[i] = INV_SSB1[state[i]];
            } else if (sboxIndex === 2) {
              state[i] = INV_SSB2[state[i]];
            } else {  // sboxIndex === 3
              state[i] = INV_SSB3[state[i]];
            }
          }
        }

        // Final key addition with original key
        for (let i = 0; i < 16; ++i) {
          state[i] ^= this._key[i];
        }

      } else {
        // Encryption matching reference implementation

        // Initial key addition with original key
        for (let i = 0; i < 16; ++i) {
          state[i] ^= this._key[i];
        }

        // Try: Initial KeyAdd + 19 rounds (SubCell → ShuffleCell → MixColumn → KeyAdd) = 20 KeyAdds total
        for (let r = 0; r < 19; ++r) {
          // SubCell: Apply 8-bit S-box based on position mod 4
          for (let i = 0; i < 16; ++i) {
            const sboxIndex = i % 4;
            if (sboxIndex === 0) {
              state[i] = SSB0[state[i]];
            } else if (sboxIndex === 1) {
              state[i] = SSB1[state[i]];
            } else if (sboxIndex === 2) {
              state[i] = SSB2[state[i]];
            } else {  // sboxIndex === 3
              state[i] = SSB3[state[i]];
            }
          }

          // ShuffleCell
          state = shuffleCell(state);

          // MixColumn
          state = mixColumns(state);

          // KeyAdd with round key
          for (let i = 0; i < 16; ++i) {
            state[i] ^= this._roundKeys[r][i];
          }
        }

        // SubCell + Final key addition (without ShuffleCell or MixColumn)
        for (let i = 0; i < 16; ++i) {
          const sboxIndex = i % 4;
          if (sboxIndex === 0) {
            state[i] = SSB0[state[i]];
          } else if (sboxIndex === 1) {
            state[i] = SSB1[state[i]];
          } else if (sboxIndex === 2) {
            state[i] = SSB2[state[i]];
          } else {  // sboxIndex === 3
            state[i] = SSB3[state[i]];
          }
        }

        for (let i = 0; i < 16; ++i) {
          state[i] ^= this._key[i];
        }
      }

      return state;
    }
  }

  // Register both algorithms
  RegisterAlgorithm(new Midori64());
  RegisterAlgorithm(new Midori128());

  return { Midori64, Midori128 };
}));
