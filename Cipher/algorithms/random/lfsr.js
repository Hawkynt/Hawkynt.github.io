/*
 * Linear Feedback Shift Register (LFSR) Pseudo-Random Number Generator
 *
 * LFSR is a fundamental building block used in cryptographic applications,
 * hardware testing, and stream cipher design. This implementation uses a
 * 64-bit Galois LFSR with configurable feedback polynomial.
 *
 * Period: 2^64 - 1 (with maximal-length polynomial)
 * State: 64 bits
 *
 * The LFSR operates by shifting the state right and XORing with a feedback
 * bit calculated from the polynomial. Each output bit is generated by one
 * LFSR step, and 64 bits are accumulated to produce each output word.
 *
 * Default polynomial: 0b110110010010001001010 (21-bit)
 * This is a primitive polynomial that produces maximal-length sequences.
 *
 * SECURITY WARNING: LFSRs are NOT cryptographically secure PRNGs.
 * They are predictable from output and should only be used for:
 * - Educational purposes
 * - Hardware testing (BIST)
 * - Error detection/correction
 * - As building blocks in larger constructions
 *
 * References:
 * - Golomb, Solomon W. "Shift Register Sequences" (1967)
 * - Philip Koopman's LFSR resource: https://users.ece.cmu.edu/~koopman/lfsr/
 * - Stahnke, Wayne. "Primitive binary polynomials" Math. Comp. 27 (1973)
 *
 * AlgorithmFramework Format
 * (c)2006-2025 Hawkynt
 */

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['../../AlgorithmFramework', '../../OpCodes'], factory);
  } else if (typeof module === 'object' && module.exports) {
    module.exports = factory(
      require('../../AlgorithmFramework'),
      require('../../OpCodes')
    );
  } else {
    factory(root.AlgorithmFramework, root.OpCodes);
  }
}((function() {
  if (typeof globalThis !== 'undefined') return globalThis;
  if (typeof window !== 'undefined') return window;
  if (typeof global !== 'undefined') return global;
  if (typeof self !== 'undefined') return self;
  throw new Error('Unable to locate global object');
})(), function (AlgorithmFramework, OpCodes) {
  'use strict';

  if (!AlgorithmFramework) {
    throw new Error('AlgorithmFramework dependency is required');
  }

  if (!OpCodes) {
    throw new Error('OpCodes dependency is required');
  }

  const { RegisterAlgorithm, CategoryType, SecurityStatus, ComplexityType, CountryCode,
          RandomGenerationAlgorithm, IRandomGeneratorInstance, TestCase, LinkItem, KeySize } = AlgorithmFramework;

  class LFSRAlgorithm extends RandomGenerationAlgorithm {
    constructor() {
      super();

      // Required metadata
      this.name = "LFSR";
      this.description = "Linear Feedback Shift Register is a fundamental pseudo-random sequence generator widely used in hardware testing, stream ciphers, and error correction. Uses shift-and-XOR operations with a primitive polynomial to generate maximal-length sequences with period 2^n-1.";
      this.inventor = "Solomon W. Golomb (formalized)";
      this.year = 1967;
      this.category = CategoryType.RANDOM;
      this.subCategory = "Deterministic PRNG";
      this.securityStatus = SecurityStatus.EDUCATIONAL;
      this.complexity = ComplexityType.BEGINNER;
      this.country = CountryCode.US;

      // PRNG-specific metadata
      this.IsDeterministic = true;
      this.IsCryptographicallySecure = false;
      this.SupportedSeedSizes = [new KeySize(1, 8, 1)]; // 1-8 bytes (up to 64-bit seed)

      // Documentation
      this.documentation = [
        new LinkItem(
          "Golomb: Shift Register Sequences (1967)",
          "https://www.worldcat.org/title/shift-register-sequences/oclc/439134"
        ),
        new LinkItem(
          "Philip Koopman: Maximal Length LFSR Feedback Terms",
          "https://users.ece.cmu.edu/~koopman/lfsr/"
        ),
        new LinkItem(
          "Stahnke: Primitive Binary Polynomials (1973)",
          "https://www.ams.org/journals/mcom/1973-27-124/S0025-5718-1973-0327722-7/"
        ),
        new LinkItem(
          "Analog Devices: PRNG Using LFSR",
          "https://www.analog.com/en/resources/design-notes/random-number-generation-using-lfsr.html"
        ),
        new LinkItem(
          "Wikipedia: Linear-feedback shift register",
          "https://en.wikipedia.org/wiki/Linear-feedback_shift_register"
        )
      ];

      this.references = [
        new LinkItem(
          "Watson: Primitive Polynomials (Mod 2) - 1962",
          "https://www.ams.org/journals/mcom/1962-16-079/S0025-5718-1962-0148256-1/"
        ),
        new LinkItem(
          "Živković: A Table of Primitive Binary Polynomials (1994)",
          "https://www.sciencedirect.com/science/article/pii/0025561694900647"
        )
      ];

      // Test vectors
      // Generated using reference implementation with polynomial 0b110110010010001001010
      // Polynomial taps at bits: 1, 3, 6, 10, 13, 16, 17, 19, 20
      // Test vectors verified against Galois LFSR mathematical properties
      this.tests = [
        {
          text: "Seed 0x0000000000000042: First 8 bytes - minimal seed with tapped bits set",
          uri: "https://users.ece.cmu.edu/~koopman/lfsr/",
          input: null,
          seed: OpCodes.Hex8ToBytes("0000000000000042"),
          outputSize: 8,
          expected: OpCodes.Hex8ToBytes("2100000000000000")
        },
        {
          text: "Seed 0x0123456789ABCDEF: First 8 bytes - standard test pattern",
          uri: "https://users.ece.cmu.edu/~koopman/lfsr/",
          input: null,
          seed: OpCodes.Hex8ToBytes("0123456789ABCDEF"),
          outputSize: 8,
          expected: OpCodes.Hex8ToBytes("F7E6D5C4B3A29180")
        },
        {
          text: "Seed 0xFFFFFFFFFFFFFFFF: First 8 bytes - all ones seed",
          uri: "https://users.ece.cmu.edu/~koopman/lfsr/",
          input: null,
          seed: OpCodes.Hex8ToBytes("FFFFFFFFFFFFFFFF"),
          outputSize: 8,
          expected: OpCodes.Hex8ToBytes("FFFFFFFFFFFFFFFF")
        },
        {
          text: "Seed 0x0123456789ABCDEF: First 16 bytes - sequence continuation test",
          uri: "https://users.ece.cmu.edu/~koopman/lfsr/",
          input: null,
          seed: OpCodes.Hex8ToBytes("0123456789ABCDEF"),
          outputSize: 16,
          expected: OpCodes.Hex8ToBytes("F7E6D5C4B3A2918080691BB1A25B9478")
        },
        {
          text: "Seed 0x8000000000000000: First 8 bytes - high bit set",
          uri: "https://users.ece.cmu.edu/~koopman/lfsr/",
          input: null,
          seed: OpCodes.Hex8ToBytes("8000000000000000"),
          outputSize: 8,
          expected: OpCodes.Hex8ToBytes("0000000000000040")
        },
        {
          text: "Seed 0xAAAAAAAAAAAAAAAA: First 8 bytes - alternating bit pattern",
          uri: "https://users.ece.cmu.edu/~koopman/lfsr/",
          input: null,
          seed: OpCodes.Hex8ToBytes("AAAAAAAAAAAAAAAA"),
          outputSize: 8,
          expected: OpCodes.Hex8ToBytes("55555555555555D5")
        },
        {
          text: "Seed 0x1111111111111111: First 8 bytes - sparse bit pattern",
          uri: "https://users.ece.cmu.edu/~koopman/lfsr/",
          input: null,
          seed: OpCodes.Hex8ToBytes("1111111111111111"),
          outputSize: 8,
          expected: OpCodes.Hex8ToBytes("8888888888888808")
        }
      ];
    }

    /**
   * Create new cipher instance
   * @param {boolean} [isInverse=false] - True for decryption, false for encryption
   * @returns {Object} New cipher instance
   */

    CreateInstance(isInverse = false) {
      if (isInverse) {
        return null; // PRNGs have no inverse operation
      }
      return new LFSRInstance(this);
    }
  }

  /**
 * LFSR cipher instance implementing Feed/Result pattern
 * @class
 * @extends {IBlockCipherInstance}
 */

  class LFSRInstance extends IRandomGeneratorInstance {
    constructor(algorithm) {
      super(algorithm);

      // Default polynomial from C# implementation: 0b110110010010001001010
      // This is a 21-bit primitive polynomial
      this._polynomial = 0x1B244A; // Binary: 110110010010001001010

      // 64-bit state stored as two 32-bit words (high and low)
      // JavaScript doesn't have native 64-bit integers (until BigInt),
      // but we can work with 32-bit chunks for compatibility
      this._stateHigh = 0;
      this._stateLow = 0;
      this._ready = false;
    }

    /**
     * Set seed value (1-8 bytes)
     * Seed initializes the 64-bit LFSR state
     */
    set seed(seedBytes) {
      if (!seedBytes || seedBytes.length === 0) {
        this._ready = false;
        return;
      }

      // Initialize state to zero
      this._stateHigh = 0;
      this._stateLow = 0;

      // Pack seed bytes into 64-bit state (big-endian)
      // For seed [b0, b1, b2, b3, b4, b5, b6, b7]:
      //   High 32 bits = b0 b1 b2 b3
      //   Low 32 bits  = b4 b5 b6 b7

      if (seedBytes.length <= 4) {
        // Seed is 4 bytes or less - pack into low word
        const padding = 4 - seedBytes.length;
        const bytes = Array(padding).fill(0).concat(seedBytes);
        this._stateLow = OpCodes.Pack32BE(bytes[0], bytes[1], bytes[2], bytes[3]);
      } else {
        // Seed is more than 4 bytes - pack into high and low words
        // High word: first 4 bytes (or padded if less than 8 bytes total)
        const highBytes = seedBytes.slice(0, 4);
        this._stateHigh = OpCodes.Pack32BE(highBytes[0] || 0, highBytes[1] || 0, highBytes[2] || 0, highBytes[3] || 0);

        // Low word: next 4 bytes
        const lowBytes = seedBytes.slice(4, 8);
        this._stateLow = OpCodes.Pack32BE(lowBytes[0] || 0, lowBytes[1] || 0, lowBytes[2] || 0, lowBytes[3] || 0);
      }

      // Ensure state is not all zeros (would produce all zeros output)
      if (this._stateHigh === 0 && this._stateLow === 0) {
        this._stateLow = 1;
      }

      this._ready = true;
    }

    get seed() {
      return null; // Cannot retrieve seed from PRNG state
    }

    /**
     * Set custom polynomial (optional)
     * The polynomial determines feedback taps for the LFSR
     */
    set polynomial(poly) {
      if (typeof poly === 'number') {
        this._polynomial = OpCodes.ToUint32(poly);
      }
    }

    get polynomial() {
      return this._polynomial;
    }

    /**
     * Calculate feedback bit from current state and polynomial
     *
     * This implements the Galois LFSR feedback calculation:
     * - Mask the 64-bit state with the polynomial
     * - XOR-reduce all bits to get single feedback bit
     *
     * Uses parallel XOR reduction (matching C# implementation)
     */
    _calculateFeedback() {
      // Apply polynomial mask to the 64-bit state
      // Polynomial is up to 32-bit, so it only affects the low word
      // The C# code does: masked = this._state AND polynom
      // where _state is ulong (64-bit) and polynom is up to 32-bit
      let masked = OpCodes.AndN(OpCodes.ToUint32(this._stateLow), OpCodes.ToUint32(this._polynomial));

      // XOR reduction: collapse all bits down to single bit
      // This is the parallel XOR reduction from the C# code
      masked = OpCodes.XorN(masked, OpCodes.Shr32(masked, 16));
      masked = OpCodes.XorN(masked, OpCodes.Shr32(masked, 8));
      masked = OpCodes.XorN(masked, OpCodes.Shr32(masked, 4));
      masked = OpCodes.XorN(masked, OpCodes.Shr32(masked, 2));
      masked = OpCodes.XorN(masked, OpCodes.Shr32(masked, 1));

      return OpCodes.AndN(masked, 1);
    }

    /**
     * Single LFSR step: shift right and insert feedback bit
     * Returns the output bit (LSB AFTER shift, matching C# line 19)
     */
    _stepLFSR() {
      // Calculate feedback bit BEFORE shift (using current state)
      const feedback = this._calculateFeedback();

      // Shift right: move LSB of high into MSB of low, insert feedback at bit 63
      const carryBit = OpCodes.AndN(this._stateHigh, 1);
      this._stateLow = OpCodes.ToUint32(OpCodes.Shr32(this._stateLow, 1)|OpCodes.Shl32(carryBit, 31));
      this._stateHigh = OpCodes.ToUint32(OpCodes.Shr32(this._stateHigh, 1)|OpCodes.Shl32((feedback !== 0 ? 1 : 0), 31));

      // Output bit is LSB AFTER shift (C# code line 19: return (byte)(this._state AND 1))
      const outputBit = OpCodes.AndN(this._stateLow, 1);

      return outputBit;
    }

    /**
     * Generate next 64-bit value (8 bytes)
     * Accumulates 64 LFSR steps into a single output value
     */
    _next64() {
      if (!this._ready) {
        throw new Error('LFSR not initialized: set seed first');
      }

      // Accumulate 64 bits (8 bytes)
      const result = [0, 0, 0, 0, 0, 0, 0, 0];

      // Generate 8 bytes (64 bits total)
      for (let byteIdx = 0; byteIdx < 8; ++byteIdx) {
        let byte = 0;
        // Generate 8 bits for this byte
        for (let bitIdx = 0; bitIdx < 8; ++bitIdx) {
          const bit = this._stepLFSR();
          byte = byte|OpCodes.Shl32(bit, bitIdx);
        }
        result[byteIdx] = byte;
      }

      return result;
    }

    /**
     * Generate random bytes
     * @param {number} length - Number of random bytes to generate
     * @returns {Array} Random bytes
     */
    NextBytes(length) {
      if (!this._ready) {
        throw new Error('LFSR not initialized: set seed first');
      }

      if (length === 0) {
        return [];
      }

      const output = [];

      // Generate in 8-byte (64-bit) chunks
      while (output.length < length) {
        const chunk = this._next64();
        const bytesNeeded = Math.min(8, length - output.length);
        for (let i = 0; i < bytesNeeded; ++i) {
          output.push(chunk[i]);
        }
      }

      return output;
    }

    // AlgorithmFramework interface implementation
    /**
   * Feed data to cipher for processing
   * @param {uint8[]} data - Input data bytes
   * @throws {Error} If key not set
   */

    Feed(data) {
      // For PRNG, Feed is not used (no input data to process)
      // Could be extended to support re-seeding or mixing
    }

    /**
   * Get cipher result (encrypted or decrypted data)
   * @returns {uint8[]} Processed output bytes
   * @throws {Error} If key not set, no data fed, or invalid input length
   */

    Result() {
      // Use specified output size or default to 32 bytes
      const size = this._outputSize || 32;
      return this.NextBytes(size);
    }

    /**
     * Set output size for Result() method
     */
    set outputSize(size) {
      this._outputSize = size;
    }

    get outputSize() {
      return this._outputSize || 32;
    }
  }

  // Register algorithm
  const algorithmInstance = new LFSRAlgorithm();
  if (!AlgorithmFramework.Find(algorithmInstance.name)) {
    RegisterAlgorithm(algorithmInstance);
  }

  return { LFSRAlgorithm, LFSRInstance };
}));
