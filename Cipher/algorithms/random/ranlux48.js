/*
 * RANLUX48 (Luxury Random Numbers - 48-bit) Pseudo-Random Number Generator
 * Based on Martin Lüscher's algorithm from "A portable high-quality random number generator for lattice field theory simulations"
 * Computer Physics Communications, 79 (1994) 100-110
 *
 * RANLUX48 is C++ standard library's highest-quality luxury PRNG using 48-bit subtract-with-borrow.
 * - Base engine: ranlux48_base (subtract_with_carry_engine<uint_fast64_t, 48, 5, 12>)
 * - Luxury level: 4 (discard_block_engine<ranlux48_base, 389, 11>)
 * - Takes first 11 values from each block of 389 values generated by ranlux48_base
 * - Default seed: 19780503u (C++ standard library default)
 *
 * The subtract-with-borrow recurrence with 48-bit arithmetic:
 *   Y = X_{i-s} - X_{i-r} - c
 *   X_i = Y mod 2^48
 *   c = (Y < 0) ? 1 : 0
 * where r=12, s=5, modulus=2^48
 *
 * Provides highest statistical quality for Monte Carlo simulations requiring decorrelated sequences.
 * Period: approximately 10^171
 *
 * NOTE: This implementation uses JavaScript BigInt for 48-bit arithmetic.
 * Native bit operations on BigInt (&, >>) are required and cannot be replaced
 * with OpCodes functions which operate on 32-bit integers.
 *
 * AlgorithmFramework Format
 * (c)2006-2025 Hawkynt
 */

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['../../AlgorithmFramework', '../../OpCodes'], factory);
  } else if (typeof module === 'object' && module.exports) {
    module.exports = factory(
      require('../../AlgorithmFramework'),
      require('../../OpCodes')
    );
  } else {
    factory(root.AlgorithmFramework, root.OpCodes);
  }
}((function() {
  if (typeof globalThis !== 'undefined') return globalThis;
  if (typeof window !== 'undefined') return window;
  if (typeof global !== 'undefined') return global;
  if (typeof self !== 'undefined') return self;
  throw new Error('Unable to locate global object');
})(), function (AlgorithmFramework, OpCodes) {
  'use strict';

  if (!AlgorithmFramework) {
    throw new Error('AlgorithmFramework dependency is required');
  }

  if (!OpCodes) {
    throw new Error('OpCodes dependency is required');
  }

  const { RegisterAlgorithm, CategoryType, SecurityStatus, ComplexityType, CountryCode,
          RandomGenerationAlgorithm, IRandomGeneratorInstance, TestCase, LinkItem, KeySize } = AlgorithmFramework;

  // RANLUX48_BASE constants (subtract_with_carry_engine<uint_fast64_t, 48, 5, 12>)
  const WORD_SIZE = 48;               // w: word size in bits
  const SHORT_LAG = 5;                // s: short lag parameter
  const LONG_LAG = 12;                // r: long lag parameter
  const MODULUS_48 = 281474976710656n; // 2^48 as BigInt
  const MASK_48BIT = 0xFFFFFFFFFFFFn;  // 48-bit mask as BigInt
  const DEFAULT_SEED = 19780503;       // C++ standard library default seed

  // RANLUX48 luxury parameters (discard_block_engine<ranlux48_base, 389, 11>)
  const BLOCK_SIZE = 389;             // p: total block size
  const USED_BLOCK = 11;              // r: used values per block (378 discarded)

  class Ranlux48Algorithm extends RandomGenerationAlgorithm {
    constructor() {
      super();

      // Required metadata
      this.name = "RANLUX48";
      this.description = "C++ standard library's highest-quality luxury PRNG using 48-bit subtract-with-borrow with luxury level 4. Designed for Monte Carlo simulations requiring provably decorrelated sequences with superior statistical quality.";
      this.inventor = "Martin Lüscher";
      this.year = 1994;
      this.category = CategoryType.RANDOM;
      this.subCategory = "Pseudo-Random Number Generator";
      this.securityStatus = SecurityStatus.EDUCATIONAL;
      this.complexity = ComplexityType.ADVANCED;
      this.country = CountryCode.CH;

      // PRNG-specific metadata
      this.IsDeterministic = true;
      this.IsCryptographicallySecure = false;
      this.SupportedSeedSizes = [new KeySize(4, 4, 1)]; // 32-bit seed

      // Documentation
      this.documentation = [
        new LinkItem(
          "Original Paper: M. Lüscher (Computer Physics Communications 1994)",
          "https://www.sciencedirect.com/science/article/abs/pii/001046559490232X"
        ),
        new LinkItem(
          "C++ Reference: std::ranlux48",
          "https://en.cppreference.com/w/cpp/numeric/random/discard_block_engine"
        ),
        new LinkItem(
          "C++ Reference: std::subtract_with_carry_engine",
          "https://en.cppreference.com/w/cpp/numeric/random/subtract_with_carry_engine"
        ),
        new LinkItem(
          "Martin Lüscher's RANLUX Page",
          "https://luscher.web.cern.ch/luscher/ranlux/"
        )
      ];

      this.references = [
        new LinkItem(
          "OEIS A221562: ranlux48 Sequence",
          "https://oeis.org/A221562"
        ),
        new LinkItem(
          "OEIS A221560: ranlux48_base Sequence",
          "https://oeis.org/A221560"
        ),
        new LinkItem(
          "LLVM libc++ Test Vector",
          "https://github.com/google/libcxx/blob/master/test/numerics/rand/rand.predef/ranlux48.pass.cpp"
        )
      ];

      // Test vectors from OEIS A221562 (C++ ranlux48 with default seed 19780503)
      // Values are 48-bit unsigned integers output by std::ranlux48
      // Bytes in little-endian format (LSB first)
      this.tests = [
        {
          text: "RANLUX48 with default seed 19780503, first 5 outputs (OEIS A221562)",
          uri: "https://oeis.org/A221562",
          input: null,
          seed: OpCodes.Unpack32LE(DEFAULT_SEED),
          outputSize: 30, // 5 × 6 bytes (48-bit values)
          // First 5 values from OEIS A221562
          expected: [
            // 23459059301164 (0x1555FCE57B2C)
            0x2C, 0x7B, 0xE5, 0xFC, 0x55, 0x15,
            // 28639057539807 (0x1A0C0CD9F2DF)
            0xDF, 0xF2, 0xD9, 0x0C, 0x0C, 0x1A,
            // 276846226770426 (0xFBCA490109FA)
            0xFA, 0x09, 0x01, 0x49, 0xCA, 0xFB,
            // 130971693943559 (0x771E394B0B07)
            0x07, 0x0B, 0x4B, 0x39, 0x1E, 0x77,
            // 84358451161020 (0x4CB93B83E7BC)
            0xBC, 0xE7, 0x83, 0x3B, 0xB9, 0x4C
          ]
        },
        {
          text: "RANLUX48 default seed, outputs 6-10 (OEIS A221562)",
          uri: "https://oeis.org/A221562",
          input: null,
          seed: OpCodes.Unpack32LE(DEFAULT_SEED),
          skipBytes: 30, // Skip first 5 values
          outputSize: 30, // Next 5 values
          expected: [
            // 208150879060961 (0xBD4FE734C3E1)
            0xE1, 0xC3, 0x34, 0xE7, 0x4F, 0xBD,
            // 71914269758754 (0x4167D880D522)
            0x22, 0xD5, 0x80, 0xD8, 0x67, 0x41,
            // 242506792212635 (0xDC8F0334989B)
            0x9B, 0x98, 0x34, 0x03, 0x8F, 0xDC,
            // 257147515259684 (0xE9DFD24D4B24)
            0x24, 0x4B, 0x4D, 0xD2, 0xDF, 0xE9,
            // 55344035667239 (0x3255C9961D27)
            0x27, 0x1D, 0x96, 0xC9, 0x55, 0x32
          ]
        },
        {
          text: "RANLUX48 default seed, 10000th value (LLVM libc++ test)",
          uri: "https://github.com/google/libcxx/blob/master/test/numerics/rand/rand.predef/ranlux48.pass.cpp",
          input: null,
          seed: OpCodes.Unpack32LE(DEFAULT_SEED),
          skipBytes: 59994, // Skip 9999 values (9999 × 6 bytes)
          outputSize: 6,
          // Value after discard(9999): 249142670248501 (0xE2980C5BCA35)
          expected: [
            0x35, 0xCA, 0x5B, 0x0C, 0x98, 0xE2
          ]
        },
        {
          text: "RANLUX48 default seed, values 11-12 (OEIS A221562)",
          uri: "https://oeis.org/A221562",
          input: null,
          seed: OpCodes.Unpack32LE(DEFAULT_SEED),
          skipBytes: 60, // Skip first 10 values
          outputSize: 12, // Values 11-12
          expected: [
            // 280360381592565 (0xFEFC7CF433F5)
            0xF5, 0x33, 0xF4, 0x7C, 0xFC, 0xFE,
            // 269312768919532 (0xF4F043ECC7EC)
            0xEC, 0xC7, 0xEC, 0x43, 0xF0, 0xF4
          ]
        }
      ];
    }

    /**
   * Create new cipher instance
   * @param {boolean} [isInverse=false] - True for decryption, false for encryption
   * @returns {Object} New cipher instance
   */

    CreateInstance(isInverse = false) {
      if (isInverse) {
        return null; // PRNGs have no inverse operation
      }
      return new Ranlux48Instance(this);
    }
  }

  /**
 * Ranlux48 cipher instance implementing Feed/Result pattern
 * @class
 * @extends {IBlockCipherInstance}
 */

  class Ranlux48Instance extends IRandomGeneratorInstance {
    constructor(algorithm) {
      super(algorithm);

      // RANLUX48_BASE state (subtract-with-carry engine)
      this._state = new Array(LONG_LAG);  // r=12 state values (48-bit BigInts)
      this._carry = 0n;                   // Carry bit (0 or 1 as BigInt)
      this._index = 0;                    // Current index in state array
      this._initialized = false;

      // RANLUX48 luxury level state (discard_block_engine)
      this._blockPosition = 0;            // Position within current block (0-388)
      this._usedCount = 0;                // Count of used values in current block (0-10)

      // Output control
      this._outputSize = 32;              // Default output size in bytes
      this._skipBytes = 0;                // Number of bytes to skip before generating output
    }

    /**
     * Initialize the generator with a 32-bit seed
     * Uses linear congruential initialization from C++ standard
     * For w=48 bits, combines TWO 32-bit LCG values per state element
     *
     * @param {Array} seedBytes - 4-byte array containing 32-bit seed
     */
    set seed(seedBytes) {
      if (!seedBytes || seedBytes.length === 0) {
        this._initialized = false;
        return;
      }

      // Convert seed bytes to 32-bit unsigned integer (little-endian)
      let seedValue = 0;
      for (let i = 0; i < Math.min(seedBytes.length, 4); ++i) {
        seedValue |= (seedBytes[i] << (i * 8));
      }
      seedValue = seedValue >>> 0; // Ensure unsigned

      // Initialize state using linear congruential generator
      // C++ uses: linear_congruential_engine<result_type, 40014u, 0u, 2147483563u>
      const LCG_A = 40014n;
      const LCG_M = 2147483563n;

      // Special case: if seed is 0, use default_seed (C++ standard behavior)
      let lcgState = BigInt(seedValue === 0 ? DEFAULT_SEED : seedValue);

      // For w=48, __n = (48 + 31) / 32 = 2
      // Each state element requires 2 LCG values combined as:
      // state[i] = (lcg[0] + lcg[1] * 2^32) mod 2^48
      const n = Math.floor((WORD_SIZE + 31) / 32);

      for (let i = 0; i < LONG_LAG; ++i) {
        let sum = 0n;
        let factor = 1n;

        for (let j = 0; j < n; ++j) {
          // Generate next LCG value
          lcgState = (LCG_A * lcgState) % LCG_M;
          sum += lcgState * factor;
          factor *= 4294967296n; // 2^32
        }

        // Modulo 2^48
        this._state[i] = sum & MASK_48BIT;
      }

      // Initialize carry: 1 if last state element is 0, otherwise 0
      this._carry = (this._state[LONG_LAG - 1] === 0n) ? 1n : 0n;
      this._index = 0;

      // Reset discard_block state
      this._blockPosition = 0;
      this._usedCount = 0;

      this._initialized = true;
    }

    get seed() {
      return null; // Cannot retrieve seed from PRNG state
    }

    /**
     * Generate next 48-bit random value from ranlux48_base
     * Implements subtract-with-carry algorithm from C++ standard library
     *
     * @returns {BigInt} 48-bit unsigned random value
     */
    _nextBase48() {
      if (!this._initialized) {
        throw new Error('RANLUX48 not initialized: set seed first');
      }

      // Calculate short lag index (ps = p - short_lag, wrapping around)
      let ps = this._index - SHORT_LAG;
      if (ps < 0) {
        ps += LONG_LAG;
      }

      // Subtract-with-borrow algorithm
      let xi;
      if (this._state[ps] >= this._state[this._index] + this._carry) {
        // No borrow needed
        xi = this._state[ps] - this._state[this._index] - this._carry;
        this._carry = 0n;
      } else {
        // Borrow from modulus
        xi = MODULUS_48 - this._state[this._index] - this._carry + this._state[ps];
        this._carry = 1n;
      }

      // Update state and get result
      this._state[this._index] = xi & MASK_48BIT;
      const result = this._state[this._index];

      // Advance index (circular)
      this._index = (this._index + 1) % LONG_LAG;

      return result;
    }

    /**
     * Generate next 48-bit random value from ranlux48 (with discarding)
     * Takes first 11 values from each block of 389 base values
     *
     * @returns {BigInt} 48-bit unsigned random value
     */
    _next48() {
      // Check if we've used all allowed values from current block
      if (this._usedCount >= USED_BLOCK) {
        // Discard remaining values in block (378 values)
        const discardCount = BLOCK_SIZE - this._usedCount;
        for (let i = 0; i < discardCount; ++i) {
          this._nextBase48();
        }
        // Reset for next block
        this._usedCount = 0;
        this._blockPosition = 0;
      }

      // Generate and use next value
      const value = this._nextBase48();
      ++this._usedCount;
      ++this._blockPosition;

      return value;
    }

    /**
     * Generate random bytes
     * Outputs bytes in little-endian order (LSB first) from 48-bit values
     *
     * @param {number} length - Number of random bytes to generate
     * @returns {Array} Random bytes
     */
    NextBytes(length) {
      if (!this._initialized) {
        throw new Error('RANLUX48 not initialized: set seed first');
      }

      if (length === 0) {
        return [];
      }

      const output = [];

      // Generate complete 48-bit values (6 bytes each)
      const fullValues = Math.floor(length / 6);
      for (let i = 0; i < fullValues; ++i) {
        const value = this._next48();
        // Output in little-endian format (6 bytes)
        output.push(Number(value & 0xFFn));
        output.push(Number((value >> 8n) & 0xFFn));
        output.push(Number((value >> 16n) & 0xFFn));
        output.push(Number((value >> 24n) & 0xFFn));
        output.push(Number((value >> 32n) & 0xFFn));
        output.push(Number((value >> 40n) & 0xFFn));
      }

      // Handle remaining bytes (if length not multiple of 6)
      const remainingBytes = length % 6;
      if (remainingBytes > 0) {
        const value = this._next48();
        for (let i = 0; i < remainingBytes; ++i) {
          output.push(Number((value >> BigInt(i * 8)) & 0xFFn));
        }
      }

      return output;
    }

    // AlgorithmFramework interface implementation
    /**
   * Feed data to cipher for processing
   * @param {uint8[]} data - Input data bytes
   * @throws {Error} If key not set
   */

    Feed(data) {
      // For PRNG, Feed is not used - algorithm is deterministic based on seed only
    }

    /**
   * Get cipher result (encrypted or decrypted data)
   * @returns {uint8[]} Processed output bytes
   * @throws {Error} If key not set, no data fed, or invalid input length
   */

    Result() {
      // Handle skipBytes parameter for test vectors
      if (this._skipBytes > 0) {
        this.NextBytes(this._skipBytes);
        this._skipBytes = 0;
      }

      // Generate output of specified size
      return this.NextBytes(this._outputSize);
    }

    /**
     * Set output size for Result() method
     */
    set outputSize(size) {
      this._outputSize = size;
    }

    get outputSize() {
      return this._outputSize;
    }

    /**
     * Set number of bytes to skip before generating output
     * Used for testing specific positions in the output stream
     */
    set skipBytes(count) {
      this._skipBytes = count;
    }

    get skipBytes() {
      return this._skipBytes;
    }
  }

  // Register algorithm
  const algorithmInstance = new Ranlux48Algorithm();
  if (!AlgorithmFramework.Find(algorithmInstance.name)) {
    RegisterAlgorithm(algorithmInstance);
  }

  return { Ranlux48Algorithm, Ranlux48Instance };
}));
