<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <!-- Use UTF-8 everywhere to avoid encoding issues; legacy UAs still render text/links. -->
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="Content-Script-Type" content="text/JavaScript" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="Language" content="en" />

    <!-- Modern SEO (harmless to old UAs) -->
    <meta name="description" content="BitPerm - Visual bit permutation designer generating optimized code for various CPU architectures using shifts, rotates, multiplications, and SIMD instructions." />
    <meta name="keywords" content="SynthelicZ, Hawkynt, bit permutation, bit manipulation, code generator, SIMD, BMI2, PEXT, PDEP, optimization" />
    <meta name="robots" content="index,follow" />

    <!-- Open Graph / Twitter -->
    <meta property="og:title" content="BitPerm - Bit Permutation Code Generator" />
    <meta property="og:description" content="Visual bit permutation designer with optimized code generation for various CPU architectures." />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://hawkynt.github.io/BitPerm/" />
    <meta property="og:image" content="https://hawkynt.github.io/favicon.ico" />
    <meta name="twitter:card" content="summary" />

    <!-- Legacy site verification kept (harmless) -->
    <meta name="verify-v1" content="0cvNcn5f2mj21LAsFvUBD7BIdUbn/unV4Toy1yBLWvw=" />
    <meta name="google-site-verification" content="LkZ6DT0_GlcimQOKrWL20jv4jtUh0DBsh1ZPLXQqk3A" />

    <link rel="shortcut icon" href="../favicon.ico" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BitPerm - Modular Routing Engine</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        slate: { 750: '#2d3748', 850: '#1a202c', 950: '#020617' },
                        cyan: { 450: '#15b0d6' },
                        orange: { 450: '#f97316' }
                    },
                    fontFamily: { mono: ['ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', 'monospace'] },
                    animation: { 'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite' }
                }
            }
        }
    </script>
    <style>
        body { background-color: #020617; color: #e2e8f0; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #475569; }
        .no-select { user-select: none; -webkit-user-select: none; }
        .high-contrast-text { text-shadow: 0 1px 3px rgba(0,0,0,0.9); }
        .tool-btn { @apply flex items-center gap-2 px-3 py-2 rounded-md text-xs font-bold transition-all border border-transparent; }
        .modal-overlay {
            position: fixed;
            inset: 0;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            padding: 1rem;
        }
        .modal-content {
            animation: modalIn 0.2s ease-out;
        }
        @keyframes modalIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        /* Fix select dropdown styling */
        select.cpu-select {
            background-color: rgba(30, 41, 59, 0.5);
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2394a3b8' stroke-width='2'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            padding-right: 28px;
        }
        select.cpu-select option {
            background-color: #1e293b;
            color: #e2e8f0;
            padding: 8px;
        }
        select.cpu-select option:hover,
        select.cpu-select option:checked {
            background-color: #334155;
        }
        /* Dashed border for inverted bits */
        .bit-inverted {
            border-style: dashed !important;
        }
    </style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">

// --- ICONS ---
const IconBinary = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="14" y="14" width="4" height="6" rx="2"/><rect x="6" y="4" width="4" height="6" rx="2"/><path d="M6 20h4"/><path d="M14 10h4"/><path d="M6 14h2v6"/><path d="M14 4h2v6"/></svg>);
const IconRotate = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>);
const IconTrash = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>);
const IconCopy = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>);
const IconCheck = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M20 6 9 17l-5-5"/></svg>);
const IconZap = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>);
const IconMinusCircle = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><path d="M8 12h8"/></svg>);
const IconPlusCircle = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><path d="M8 12h8"/><path d="M12 8v8"/></svg>);
const IconToggle = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M2 12h20"/><path d="m15 5 6 7-6 7"/></svg>);
const IconChevronDown = ({ className, rotate=false }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} style={{ transform: rotate ? 'rotate(180deg)' : 'none', transition: 'transform 0.2s' }}><path d="m6 9 6 6 6-6"/></svg>);
const IconFill = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M19 11H5 m14 0a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-6a2 2 0 0 1 2-2m14 0V9a2 2 0 0 0-2-2M5 11V9a2 2 0 0 1 2-2m0 0V5a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2M7 7h10"/></svg>);
const IconInfo = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>);
const IconX = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>);
const IconSettings = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>);

// --- CONSTANTS ---
// Bit/Mapping types
const TYPE_SRC = 'src';           // Source bit reference
const TYPE_CONST = 'const';       // Forced constant (0 or 1)
const TYPE_EMPTY = 'empty';       // Not connected (don't care)
const TYPE_COLLISION = 'collision'; // Multiple bits landed (undefined)
const TYPE_UNKNOWN = 'unknown';   // Unknown input value (NC in input register)

// Operation types
const OP_DELTA = 'delta';         // Shift or rotate
const OP_MUL_R = 'mul_r';         // Right-shift then multiply: (x >> S) * M
const OP_MUL_L = 'mul_l';         // Multiply then right-shift: (x * M) >> S
const OP_RLWINM = 'rlwinm';       // PowerPC rotate left word immediate then AND with mask
const OP_BFI = 'bfi';             // ARM bit field insert
const OP_BFX = 'bfx';             // ARM bit field extract
const OP_ANDC = 'andc';           // AND with complement (PowerPC, some RISC)
const OP_REV = 'rev';             // Byte reversal (ARM, x86 BSWAP)
const OP_RBIT = 'rbit';           // Bit reversal (ARM only)

// Building Blocks Library - Centralized registry of all available operations
// Each block defines:
//   - id, name, category, description: identification and documentation
//   - costKey, enableKey: for cost lookup and enable/disable check
//   - platforms: optional array of CPU presets that support this operation
//   - canRoute(src, dst, w): returns true if this block can route bit from position src to dst
//   - getShift(src, dst, w): returns the shift/rotation amount needed (for shift-based ops)
//   - apply(inputMask, w, params): returns output mask showing where input bits land
//   - genCode(w, params, inputExpr): generates code string for this operation
//   - findRoutings(routeMap, remainingMask, w): finds all valid uses of this block

const BUILDING_BLOCKS = {
    // === Shift Left ===
    shl: {
        id: 'shl', name: 'Shift Left', category: 'shift',
        description: 'Logical shift left - bits move to higher positions, low bits become 0',
        costKey: 'shift', enableKey: 'shift',
        // Can route src→dst if dst > src and dst-src doesn't exceed width
        canRoute: (src, dst, w) => dst > src && dst < w,
        getShift: (src, dst, w) => dst - src,
        // Apply shift: each bit at position p moves to p+n (if p+n < w)
        apply: (inputMask, w, n) => {
            const maxVal = (1n << BigInt(w)) - 1n;
            return (inputMask << BigInt(n)) & maxVal;
        },
        genCode: (w, n, expr) => n === 0 ? expr : `(${expr} << ${n})`,
        // Find all bits that can be routed with a single shift-left of amount n
        findRoutings: (routeMap, remainingMask, w) => {
            const results = [];
            for (let n = 1; n < w; ++n) {
                let mask = 0n;
                for (let dst = n; dst < w; ++dst) {
                    if (!((remainingMask >> BigInt(dst)) & 1n)) continue;
                    const src = routeMap[dst];
                    if (src >= 0 && dst - src === n && src + n < w) mask |= (1n << BigInt(dst));
                }
                if (mask > 0n) results.push({ n, mask, count: popcount(mask) });
            }
            return results;
        }
    },

    // === Shift Right ===
    shr: {
        id: 'shr', name: 'Shift Right', category: 'shift',
        description: 'Logical shift right - bits move to lower positions, high bits become 0',
        costKey: 'shift', enableKey: 'shift',
        canRoute: (src, dst, w) => dst < src && src < w,
        getShift: (src, dst, w) => src - dst,
        apply: (inputMask, w, n) => inputMask >> BigInt(n),
        genCode: (w, n, expr) => n === 0 ? expr : `(${expr} >> ${n})`,
        findRoutings: (routeMap, remainingMask, w) => {
            const results = [];
            for (let n = 1; n < w; ++n) {
                let mask = 0n;
                for (let dst = 0; dst < w - n; ++dst) {
                    if (!((remainingMask >> BigInt(dst)) & 1n)) continue;
                    const src = routeMap[dst];
                    if (src >= n && src - dst === n) mask |= (1n << BigInt(dst));
                }
                if (mask > 0n) results.push({ n, mask, count: popcount(mask) });
            }
            return results;
        }
    },

    // === Rotate Left ===
    rol: {
        id: 'rol', name: 'Rotate Left', category: 'rotate',
        description: 'Circular rotate left - bits wrap around from high to low',
        costKey: 'rotate', enableKey: 'rotate',
        canRoute: (src, dst, w) => true,  // Can always route via rotation
        getShift: (src, dst, w) => ((dst - src) % w + w) % w,
        apply: (inputMask, w, n) => {
            const maxVal = (1n << BigInt(w)) - 1n;
            const left = (inputMask << BigInt(n)) & maxVal;
            const right = inputMask >> BigInt(w - n);
            return left | right;
        },
        genCode: (w, n, expr) => n === 0 ? expr : `rol${w}(${expr}, ${n})`,
        findRoutings: (routeMap, remainingMask, w) => {
            const results = [];
            for (let n = 1; n < w; ++n) {
                let mask = 0n;
                let hasWrap = false, hasNoWrap = false;
                for (let dst = 0; dst < w; ++dst) {
                    if (!((remainingMask >> BigInt(dst)) & 1n)) continue;
                    const src = routeMap[dst];
                    if (src < 0) continue;
                    const delta = ((dst - src) % w + w) % w;
                    if (delta === n) {
                        mask |= (1n << BigInt(dst));
                        if (src + n >= w) hasWrap = true;
                        else hasNoWrap = true;
                    }
                }
                if (mask > 0n) results.push({ n, mask, count: popcount(mask), needsRotate: hasWrap && hasNoWrap });
            }
            return results;
        }
    },

    // === Rotate Right ===
    ror: {
        id: 'ror', name: 'Rotate Right', category: 'rotate',
        description: 'Circular rotate right - bits wrap around from low to high',
        costKey: 'rotate', enableKey: 'rotate',
        canRoute: (src, dst, w) => true,
        getShift: (src, dst, w) => ((src - dst) % w + w) % w,
        apply: (inputMask, w, n) => {
            const maxVal = (1n << BigInt(w)) - 1n;
            const right = inputMask >> BigInt(n);
            const left = (inputMask << BigInt(w - n)) & maxVal;
            return left | right;
        },
        genCode: (w, n, expr) => n === 0 ? expr : `ror${w}(${expr}, ${n})`,
        findRoutings: (routeMap, remainingMask, w) => {
            const results = [];
            for (let n = 1; n < w; ++n) {
                let mask = 0n;
                for (let dst = 0; dst < w; ++dst) {
                    if (!((remainingMask >> BigInt(dst)) & 1n)) continue;
                    const src = routeMap[dst];
                    if (src < 0) continue;
                    const delta = ((src - dst) % w + w) % w;
                    if (delta === n) mask |= (1n << BigInt(dst));
                }
                if (mask > 0n) results.push({ n, mask, count: popcount(mask) });
            }
            return results;
        }
    },

    // === Multiply (bit scatter) ===
    mul: {
        id: 'mul', name: 'Multiply', category: 'arithmetic',
        description: 'Integer multiply - each set bit in multiplier copies input shifted by that amount',
        costKey: 'mul', enableKey: 'mul',
        canRoute: (src, dst, w) => dst >= src && dst < w,
        apply: (inputMask, w, multiplier) => {
            const maxVal = (1n << BigInt(w)) - 1n;
            let result = 0n;
            for (let b = 0; b < w; ++b) {
                if ((multiplier >> BigInt(b)) & 1n)
                    result |= (inputMask << BigInt(b)) & maxVal;
            }
            return result;
        },
        genCode: (w, multiplier, expr) => `(${expr} * ${formatHex(multiplier, w)})`,
        // Find multiply operations: (x >> S) * M or (x * M) >> S patterns
        findRoutings: (routeMap, remainingMask, w, costs) => {
            if (w > 64) return [];
            const results = [];

            // Helper: compute carry risk from bit collisions
            const computeCarryRisk = (landingCounts, maxPos) => {
                const carryRisk = new Set();
                for (let pos = 0; pos < maxPos; ++pos) {
                    if ((landingCounts[pos] || 0) > 1) {
                        for (let p = pos + 1; p < maxPos; ++p) {
                            carryRisk.add(p);
                            if ((landingCounts[p] || 0) === 0) break;
                        }
                    }
                }
                return carryRisk;
            };

            // Pattern 1: (x >> S) * M - right-shift then multiply
            for (let S = 0; S < w; ++S) {
                const candidateK = new Map();
                for (let d = 0; d < w; ++d) {
                    if (!((remainingMask >> BigInt(d)) & 1n)) continue;
                    const s = routeMap[d];
                    const k = d - s + S;
                    if (k >= 0 && k < w && s >= S) {
                        if (!candidateK.has(k)) candidateK.set(k, []);
                        candidateK.get(k).push({ d, s });
                    }
                }
                if (candidateK.size === 0) continue;

                let M = 0n;
                candidateK.forEach((list, k) => M |= (1n << BigInt(k)));

                const landingCounts = {};
                for (let srcBit = S; srcBit < w; ++srcBit) {
                    const basePos = srcBit - S;
                    for (const [mk] of candidateK) {
                        const landPos = basePos + mk;
                        if (landPos < w) landingCounts[landPos] = (landingCounts[landPos] || 0) + 1;
                    }
                }

                const carryRisk = computeCarryRisk(landingCounts, w);
                let validMask = 0n;
                for (const [k, targets] of candidateK) {
                    for (const { d } of targets) {
                        if ((landingCounts[d] || 0) === 1 && !carryRisk.has(d))
                            validMask |= (1n << BigInt(d));
                    }
                }

                if (validMask > 0n) {
                    const count = popcount(validMask);
                    const cost = costs.mul + (S > 0 ? costs.shift : 0) + costs.basic;
                    results.push({ type: 'mul_r', shift: S, mul: M, mask: validMask, count, cost });
                }
            }

            // Pattern 2: (x * M) >> S - multiply then right-shift
            for (let S = 0; S < w; ++S) {
                const candidateK = new Map();
                for (let d = 0; d < w; ++d) {
                    if (!((remainingMask >> BigInt(d)) & 1n)) continue;
                    const s = routeMap[d];
                    const k = d + S - s;
                    if (k >= 0 && k < w && s + k < w) {
                        if (!candidateK.has(k)) candidateK.set(k, []);
                        candidateK.get(k).push({ d, s });
                    }
                }
                if (candidateK.size === 0) continue;

                let M = 0n;
                candidateK.forEach((list, k) => M |= (1n << BigInt(k)));

                const landingCounts = {};
                for (let srcBit = 0; srcBit < w; ++srcBit) {
                    for (const [mk] of candidateK) {
                        const landPos = srcBit + mk;
                        if (landPos < w) landingCounts[landPos] = (landingCounts[landPos] || 0) + 1;
                    }
                }

                const carryRisk = computeCarryRisk(landingCounts, w);
                let validMask = 0n;
                for (const [k, targets] of candidateK) {
                    for (const { d, s } of targets) {
                        const preMaskPos = s + k;
                        if ((landingCounts[preMaskPos] || 0) === 1 && !carryRisk.has(preMaskPos))
                            validMask |= (1n << BigInt(d));
                    }
                }

                if (validMask > 0n) {
                    const count = popcount(validMask);
                    const cost = costs.mul + (S > 0 ? costs.shift : 0) + costs.basic;
                    results.push({ type: 'mul_l', shift: S, mul: M, mask: validMask, count, cost });
                }
            }

            return results;
        }
    },

    // === BMI2 (PEXT + PDEP combination) ===
    // PEXT gathers bits, PDEP scatters them - used together for arbitrary permutation
    bmi2: {
        id: 'bmi2', name: 'PEXT/PDEP', category: 'bmi2',
        description: 'BMI2 parallel bit extract + deposit - gather then scatter bits in 2 instructions',
        costKey: 'bmi', enableKey: 'bmi',
        platforms: [CPU_MODERN, CPU_ZEN1_2, CPU_ZEN3],
        apply: (inputMask, w, srcMask, dstMask) => {
            // PEXT: gather bits from srcMask positions
            let gathered = 0n, j = 0n;
            for (let i = 0; i < w; ++i) {
                if ((srcMask >> BigInt(i)) & 1n) {
                    if ((inputMask >> BigInt(i)) & 1n) gathered |= (1n << j);
                    ++j;
                }
            }
            // PDEP: scatter to dstMask positions
            let result = 0n;
            j = 0n;
            for (let i = 0; i < w; ++i) {
                if ((dstMask >> BigInt(i)) & 1n) {
                    if ((gathered >> j) & 1n) result |= (1n << BigInt(i));
                    ++j;
                }
            }
            return result;
        },
        genCode: (w, srcMask, dstMask, expr) =>
            `pdep(pext(${expr}, ${formatHex(srcMask, w)}), ${formatHex(dstMask, w)})`,
        // Find if remaining bits can use PEXT/PDEP (requires no duplicate sources)
        findRoutings: (routeMap, remainingMask, w, costs) => {
            const srcCounts = {};
            let canUseBmi = true;
            let srcMask = 0n, dstMask = 0n;

            for (let d = 0; d < w; ++d) {
                if (!((remainingMask >> BigInt(d)) & 1n)) continue;
                const src = routeMap[d];
                if (src === -1) continue;
                srcCounts[src] = (srcCounts[src] || 0) + 1;
                if (srcCounts[src] > 1) { canUseBmi = false; break; }
                srcMask |= (1n << BigInt(src));
                dstMask |= (1n << BigInt(d));
            }

            if (!canUseBmi || dstMask === 0n) return [];
            const count = popcount(dstMask);
            const cost = costs.bmi * 2; // PEXT + PDEP
            return [{ type: 'bmi', mask: dstMask, srcMask, count, cost }];
        }
    },

    // === PEXT (Parallel Bit Extract) - component of BMI2 ===
    pext: {
        id: 'pext', name: 'PEXT', category: 'bmi2',
        description: 'Parallel bit extract - gather bits at mask positions to contiguous low bits',
        costKey: 'bmi', enableKey: 'bmi',
        platforms: [CPU_MODERN, CPU_ZEN1_2, CPU_ZEN3],
        apply: (inputMask, w, extractMask) => {
            let result = 0n, j = 0n;
            for (let i = 0; i < w; ++i) {
                if ((extractMask >> BigInt(i)) & 1n) {
                    if ((inputMask >> BigInt(i)) & 1n) result |= (1n << j);
                    ++j;
                }
            }
            return result;
        },
        genCode: (w, mask, expr) => `pext(${expr}, ${formatHex(mask, w)})`,
        findRoutings: null // Use bmi2 block for combined PEXT+PDEP routing
    },

    // === PDEP (Parallel Bit Deposit) - component of BMI2 ===
    pdep: {
        id: 'pdep', name: 'PDEP', category: 'bmi2',
        description: 'Parallel bit deposit - scatter contiguous low bits to mask positions',
        costKey: 'bmi', enableKey: 'bmi',
        platforms: [CPU_MODERN, CPU_ZEN1_2, CPU_ZEN3],
        apply: (inputMask, w, depositMask) => {
            let result = 0n, j = 0n;
            for (let i = 0; i < w; ++i) {
                if ((depositMask >> BigInt(i)) & 1n) {
                    if ((inputMask >> j) & 1n) result |= (1n << BigInt(i));
                    ++j;
                }
            }
            return result;
        },
        genCode: (w, mask, expr) => `pdep(${expr}, ${formatHex(mask, w)})`,
        findRoutings: null // Use bmi2 block for combined PEXT+PDEP routing
    },

    // === PSHUFB (Packed Shuffle Bytes) ===
    pshufb: {
        id: 'pshufb', name: 'PSHUFB', category: 'simd',
        description: 'Shuffle bytes - each output byte selected from input by index (SSSE3/NEON TBL)',
        costKey: 'pshufb', enableKey: 'pshufb',
        platforms: [CPU_MODERN, CPU_ZEN1_2, CPU_ZEN3, CPU_CORE2, CPU_ATOM, CPU_ARM_A64, CPU_APPLE_M1, CPU_XBOX360, CPU_PS3],
        apply: (inputMask, w, indices) => {
            const numBytes = w / 8;
            let result = 0n;
            for (let outByte = 0; outByte < numBytes; ++outByte) {
                const srcByte = indices[outByte];
                if (srcByte >= 0 && srcByte < numBytes) {
                    const byteMask = (inputMask >> BigInt(srcByte * 8)) & 0xFFn;
                    result |= byteMask << BigInt(outByte * 8);
                }
            }
            return result;
        },
        genCode: (w, indices, expr) => `pshufb(${expr}, {${indices.join(',')}})`,
        // Find byte-aligned routings where whole bytes move together
        findRoutings: (routeMap, remainingMask, w, costs, mapping) => {
            if (w < 64 || (w % 8 !== 0)) return [];
            const byteWidth = w / 8;
            let validBytes = 0n;
            let totalBits = 0;

            for (let byte = 0; byte < byteWidth; ++byte) {
                const destStart = byte * 8;
                let srcByte = -1;
                let byteValid = true;

                for (let bit = 0; bit < 8; ++bit) {
                    const d = destStart + bit;
                    if (!((remainingMask >> BigInt(d)) & 1n)) continue;
                    const m = mapping[d];
                    if (!m || m.type !== TYPE_SRC || m.inv) { byteValid = false; break; }
                    const expectedSrcByte = Math.floor(m.val / 8);
                    const expectedBitInByte = m.val % 8;
                    if (expectedBitInByte !== bit) { byteValid = false; break; }
                    if (srcByte === -1) srcByte = expectedSrcByte;
                    else if (srcByte !== expectedSrcByte) { byteValid = false; break; }
                }

                if (byteValid && srcByte !== -1) {
                    for (let bit = 0; bit < 8; ++bit) {
                        const d = destStart + bit;
                        if ((remainingMask >> BigInt(d)) & 1n) {
                            validBytes |= (1n << BigInt(d));
                            ++totalBits;
                        }
                    }
                }
            }

            if (validBytes === 0n) return [];
            return [{ type: 'pshufb', mask: validBytes, count: totalBits, cost: costs.pshufb }];
        }
    },

    // === RLWINM (PowerPC Rotate Left Word Immediate then AND with Mask) ===
    rlwinm: {
        id: 'rlwinm', name: 'RLWINM', category: 'powerpc',
        description: 'Rotate left then AND mask - single instruction combines rotate + mask (PowerPC)',
        costKey: 'shift', enableKey: 'rotate',
        platforms: [CPU_GAMECUBE, CPU_XBOX360, CPU_PS3],
        // rlwinm rD, rS, SH, MB, ME: rotate rS left by SH, then AND with mask from bit MB to ME
        apply: (inputMask, w, sh, mb, me) => {
            const maxVal = (1n << BigInt(w)) - 1n;
            // Rotate left
            const rotated = ((inputMask << BigInt(sh)) | (inputMask >> BigInt(w - sh))) & maxVal;
            // Create mask from MB to ME (PowerPC bit numbering: 0 is MSB)
            let mask = 0n;
            if (mb <= me) {
                for (let i = mb; i <= me; ++i) mask |= (1n << BigInt(w - 1 - i));
            } else {
                // Wrap-around mask
                for (let i = mb; i < w; ++i) mask |= (1n << BigInt(w - 1 - i));
                for (let i = 0; i <= me; ++i) mask |= (1n << BigInt(w - 1 - i));
            }
            return rotated & mask;
        },
        genCode: (w, sh, mb, me, expr) => `rlwinm(${expr}, ${sh}, ${mb}, ${me})`,
        findRoutings: (routeMap, remainingMask, w) => {
            // Find contiguous bit ranges that share same rotation amount
            const results = [];
            for (let sh = 0; sh < w; ++sh) {
                let ranges = [];
                let start = -1;
                for (let dst = 0; dst < w; ++dst) {
                    if (!((remainingMask >> BigInt(dst)) & 1n)) {
                        if (start >= 0) { ranges.push([start, dst - 1]); start = -1; }
                        continue;
                    }
                    const src = routeMap[dst];
                    if (src < 0) { if (start >= 0) { ranges.push([start, dst - 1]); start = -1; } continue; }
                    const delta = ((dst - src) % w + w) % w;
                    if (delta === sh) {
                        if (start < 0) start = dst;
                    } else {
                        if (start >= 0) { ranges.push([start, dst - 1]); start = -1; }
                    }
                }
                if (start >= 0) ranges.push([start, w - 1]);
                for (const [lo, hi] of ranges) {
                    if (hi >= lo) {
                        let mask = 0n;
                        for (let i = lo; i <= hi; ++i) mask |= (1n << BigInt(i));
                        // Convert to PPC bit numbering (0=MSB)
                        const mb = w - 1 - hi, me = w - 1 - lo;
                        results.push({ sh, mb, me, mask, count: hi - lo + 1 });
                    }
                }
            }
            return results;
        }
    },

    // === ANDC (AND with Complement) ===
    andc: {
        id: 'andc', name: 'ANDC', category: 'powerpc',
        description: 'AND with complement - computes a & ~b in single instruction (PowerPC/RISC)',
        costKey: 'basic', enableKey: null,
        platforms: [CPU_GAMECUBE, CPU_XBOX360, CPU_PS3],
        apply: (aMask, w, bMask) => aMask & ~bMask,
        genCode: (w, expr1, expr2) => `andc(${expr1}, ${expr2})`,
        findRoutings: null  // Helper op, not used for routing
    },

    // === BFI (Bit Field Insert) - ARM ===
    bfi: {
        id: 'bfi', name: 'BFI', category: 'arm',
        description: 'Bit field insert - copy width bits from src[0..width-1] to dst[lsb..lsb+width-1]',
        costKey: 'basic', enableKey: null,
        platforms: [CPU_ARM_A64, CPU_ARM_M4, CPU_APPLE_M1],
        apply: (srcMask, w, lsb, width) => {
            // Take low 'width' bits from src, place at position lsb
            const fieldMask = (1n << BigInt(width)) - 1n;
            return (srcMask & fieldMask) << BigInt(lsb);
        },
        genCode: (w, lsb, width, dstExpr, srcExpr) => `bfi(${dstExpr}, ${srcExpr}, ${lsb}, ${width})`,
        findRoutings: (routeMap, remainingMask, w) => {
            // Find contiguous ranges where source bits 0..n-1 go to lsb..lsb+n-1
            const results = [];
            for (let lsb = 0; lsb < w; ++lsb) {
                let width = 0;
                let mask = 0n;
                for (let i = 0; lsb + i < w; ++i) {
                    const dst = lsb + i;
                    if (!((remainingMask >> BigInt(dst)) & 1n)) break;
                    const src = routeMap[dst];
                    if (src !== i) break;  // Must come from position i (low bits of source)
                    mask |= (1n << BigInt(dst));
                    ++width;
                }
                if (width > 0) results.push({ lsb, width, mask, count: width });
            }
            return results;
        }
    },

    // === UBFX (Unsigned Bit Field Extract) - ARM ===
    ubfx: {
        id: 'ubfx', name: 'UBFX', category: 'arm',
        description: 'Unsigned bit field extract - copy bits from src[lsb..lsb+width-1] to dst[0..width-1]',
        costKey: 'basic', enableKey: null,
        platforms: [CPU_ARM_A64, CPU_ARM_M4, CPU_APPLE_M1],
        apply: (inputMask, w, lsb, width) => {
            const fieldMask = (1n << BigInt(width)) - 1n;
            return (inputMask >> BigInt(lsb)) & fieldMask;
        },
        genCode: (w, lsb, width, expr) => `ubfx(${expr}, ${lsb}, ${width})`,
        findRoutings: (routeMap, remainingMask, w) => {
            // Find contiguous ranges where source bits lsb..lsb+n-1 go to 0..n-1
            const results = [];
            for (let lsb = 0; lsb < w; ++lsb) {
                let width = 0;
                let mask = 0n;
                for (let i = 0; i < w && lsb + i < w; ++i) {
                    const dst = i;
                    if (!((remainingMask >> BigInt(dst)) & 1n)) break;
                    const src = routeMap[dst];
                    if (src !== lsb + i) break;  // Must come from position lsb+i
                    mask |= (1n << BigInt(dst));
                    ++width;
                }
                if (width > 0) results.push({ lsb, width, mask, count: width });
            }
            return results;
        }
    },

    // === REV / BSWAP (Byte Reversal) ===
    rev: {
        id: 'rev', name: 'REV/BSWAP', category: 'byteswap',
        description: 'Reverse byte order - byte 0↔last, 1↔second-to-last, etc. (ARM REV, x86 BSWAP)',
        costKey: 'basic', enableKey: null,
        platforms: [CPU_MODERN, CPU_ZEN1_2, CPU_ZEN3, CPU_CORE2, CPU_ARM_A64, CPU_ARM_M4, CPU_APPLE_M1],
        apply: (inputMask, w) => {
            const numBytes = w / 8;
            let result = 0n;
            for (let b = 0; b < numBytes; ++b) {
                const byteMask = (inputMask >> BigInt(b * 8)) & 0xFFn;
                result |= byteMask << BigInt((numBytes - 1 - b) * 8);
            }
            return result;
        },
        genCode: (w, expr) => `bswap${w}(${expr})`,
        // Returns routing if byte-swap matches the required permutation
        findRoutings: (routeMap, remainingMask, w) => {
            if (w < 16) return [];  // Need at least 16 bits for byte swap
            const numBytes = w / 8;
            let mask = 0n;
            let count = 0;
            for (let dst = 0; dst < w; ++dst) {
                if (!((remainingMask >> BigInt(dst)) & 1n)) continue;
                const src = routeMap[dst];
                if (src < 0) continue;
                // Expected source for byte-swap: bit in byte B, position P → byte (numBytes-1-B), position P
                const dstByte = Math.floor(dst / 8);
                const dstBit = dst % 8;
                const expectedSrc = (numBytes - 1 - dstByte) * 8 + dstBit;
                if (src === expectedSrc) {
                    mask |= (1n << BigInt(dst));
                    ++count;
                }
            }
            if (count > 0) return [{ mask, count }];
            return [];
        }
    },

    // === RBIT (Bit Reversal) - ARM only ===
    rbit: {
        id: 'rbit', name: 'RBIT', category: 'arm',
        description: 'Reverse all bits - bit 0↔bit (w-1), bit 1↔bit (w-2), etc. (ARM only)',
        costKey: 'basic', enableKey: null,
        platforms: [CPU_ARM_A64, CPU_ARM_M4, CPU_APPLE_M1],
        apply: (inputMask, w) => {
            let result = 0n;
            for (let i = 0; i < w; ++i)
                if ((inputMask >> BigInt(i)) & 1n)
                    result |= (1n << BigInt(w - 1 - i));
            return result;
        },
        genCode: (w, expr) => `rbit(${expr})`,
        findRoutings: (routeMap, remainingMask, w) => {
            let mask = 0n;
            let count = 0;
            for (let dst = 0; dst < w; ++dst) {
                if (!((remainingMask >> BigInt(dst)) & 1n)) continue;
                const src = routeMap[dst];
                if (src === w - 1 - dst) {
                    mask |= (1n << BigInt(dst));
                    ++count;
                }
            }
            if (count > 0) return [{ mask, count }];
            return [];
        }
    },

    // === LUT (Lookup Table) ===
    lut: {
        id: 'lut', name: 'LUT', category: 'memory',
        description: 'Lookup table - precomputed permutation array, useful for small bit widths',
        costKey: 'lut', enableKey: null,
        apply: (inputVal, w, table) => BigInt(table[Number(inputVal)]),
        genCode: (w, tableName, expr) => `${tableName}[${expr}]`,
        findRoutings: null  // Always applicable for small widths
    }
};

// Popcount helper for BigInt
const popcount = (n) => {
    let count = 0;
    while (n > 0n) { if (n & 1n) ++count; n >>= 1n; }
    return count;
};

// ============================================================================
// BUILDING BLOCKS TEST SUITE
// Run via console: runBuildingBlockTests()
// ============================================================================

// Analyze what an operation does: tracks bit movements, side effects, and collisions
const analyzeBitMovement = (applyFn, inputSrcBits, w, ...params) => {
    // inputSrcBits: array of source bit positions that are set (e.g., [0, 2, 5])
    // Returns: { movements: [{src, dst}], sideEffects: [{src, dst}], collisions: [{dst, sources: []}] }

    const movements = [];      // Intended bit movements
    const landingCount = {};   // Count how many bits land at each position
    const landingSources = {}; // Track which source bits land at each position

    // Apply operation to each source bit individually to track where it goes
    for (const srcBit of inputSrcBits) {
        const singleBitMask = 1n << BigInt(srcBit);
        const result = applyFn(singleBitMask, w, ...params);

        // Find all destination positions where this bit landed
        for (let dst = 0; dst < w; ++dst) {
            if ((result >> BigInt(dst)) & 1n) {
                movements.push({ src: srcBit, dst });
                landingCount[dst] = (landingCount[dst] || 0) + 1;
                if (!landingSources[dst]) landingSources[dst] = [];
                landingSources[dst].push(srcBit);
            }
        }
    }

    // Identify collisions (multiple sources landing on same destination)
    const collisions = [];
    for (const [dst, sources] of Object.entries(landingSources)) {
        if (sources.length > 1)
            collisions.push({ dst: parseInt(dst), sources });
    }

    return { movements, collisions, landingSources };
};

// Verify operation reports correct routing vs actual bit movement
const verifyOperationReport = (block, routeMap, remainingMask, w, costs, mapping) => {
    if (!block.findRoutings) return { skipped: true };

    const results = block.findRoutings(routeMap, remainingMask, w, costs, mapping);
    const issues = [];

    for (const routing of results) {
        // Get the bits this routing claims to handle
        const claimedBits = [];
        for (let d = 0; d < w; ++d) {
            if ((routing.mask >> BigInt(d)) & 1n) claimedBits.push(d);
        }

        // For each claimed bit, verify the source exists in routeMap
        for (const dst of claimedBits) {
            const src = routeMap[dst];
            if (src < 0)
                issues.push(`Routing claims dst=${dst} but no source in routeMap`);
        }

        // Verify count matches mask popcount
        const actualCount = popcount(routing.mask);
        if (routing.count !== actualCount)
            issues.push(`Count mismatch: reported ${routing.count}, mask has ${actualCount} bits`);
    }

    return { results, issues };
};

const runBuildingBlockTests = () => {
    const results = { passed: 0, failed: 0, tests: [] };

    const test = (name, fn) => {
        try {
            fn();
            results.passed++;
            results.tests.push({ name, status: 'PASS' });
        } catch (e) {
            results.failed++;
            results.tests.push({ name, status: 'FAIL', error: e.message });
        }
    };

    const assert = (cond, msg) => { if (!cond) throw new Error(msg || 'Assertion failed'); };
    const assertEq = (a, b, msg) => { if (a !== b) throw new Error(msg || `Expected ${b}, got ${a}`); };

    // Helper: create routeMap from simple mapping (dst -> src)
    const makeRouteMap = (mapping, w) => {
        const rm = Array(w).fill(-1);
        for (const [dst, src] of Object.entries(mapping)) rm[parseInt(dst)] = src;
        return rm;
    };

    // Helper: create mapping array for pshufb tests
    const makeMapping = (routeMap, w) => {
        return routeMap.map((src, dst) => src >= 0 ? { type: TYPE_SRC, val: src, inv: false } : null);
    };

    // Helper: mask from bit positions
    const maskFrom = (...bits) => bits.reduce((m, b) => m | (1n << BigInt(b)), 0n);

    const defaultCosts = { shift: 1, rotate: 1, mul: 3, bmi: 3, pshufb: 2, basic: 1 };

    console.log('=== Building Blocks Test Suite ===\n');

    // =========================================================================
    // SECTION 1: Basic Operation Tests
    // =========================================================================
    console.log('--- Basic Operations ---');

    test('shl.canRoute: bit 0->4 should be possible', () => {
        assert(BUILDING_BLOCKS.shl.canRoute(0, 4, 8), 'shl should route 0->4');
    });

    test('shl.canRoute: bit 4->0 should NOT be possible', () => {
        assert(!BUILDING_BLOCKS.shl.canRoute(4, 0, 8), 'shl cannot route right');
    });

    test('shl.apply: mask 0x0F << 4 = 0xF0', () => {
        assertEq(BUILDING_BLOCKS.shl.apply(0x0Fn, 8, 4), 0xF0n);
    });

    test('shr.apply: mask 0xF0 >> 4 = 0x0F', () => {
        assertEq(BUILDING_BLOCKS.shr.apply(0xF0n, 8, 4), 0x0Fn);
    });

    test('rol.apply: 0x81 rol 1 in 8-bit = 0x03', () => {
        assertEq(BUILDING_BLOCKS.rol.apply(0x81n, 8, 1), 0x03n);
    });

    test('ror.apply: 0x03 ror 1 in 8-bit = 0x81', () => {
        assertEq(BUILDING_BLOCKS.ror.apply(0x03n, 8, 1), 0x81n);
    });

    // =========================================================================
    // SECTION 2: Bit Movement Tracking Tests
    // =========================================================================
    console.log('\n--- Bit Movement Tracking ---');

    test('shl: tracks bit movement correctly (no side effects)', () => {
        // Shift bits 0,1,2 left by 4 -> should land at 4,5,6
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.shl.apply, [0, 1, 2], 8, 4);
        assertEq(analysis.movements.length, 3, 'Should have 3 movements');
        assert(analysis.movements.some(m => m.src === 0 && m.dst === 4), 'Bit 0 should go to 4');
        assert(analysis.movements.some(m => m.src === 1 && m.dst === 5), 'Bit 1 should go to 5');
        assert(analysis.movements.some(m => m.src === 2 && m.dst === 6), 'Bit 2 should go to 6');
        assertEq(analysis.collisions.length, 0, 'Should have no collisions');
    });

    test('shl: bits shifted out are lost (no wrap)', () => {
        // Shift bit 7 left by 1 in 8-bit -> should disappear
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.shl.apply, [7], 8, 1);
        assertEq(analysis.movements.length, 0, 'Bit 7 shifted out should be lost');
    });

    test('rol: tracks wrap-around correctly', () => {
        // Rotate bit 7 left by 1 -> should wrap to position 0
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.rol.apply, [7], 8, 1);
        assertEq(analysis.movements.length, 1, 'Should have 1 movement');
        assert(analysis.movements[0].src === 7 && analysis.movements[0].dst === 0, 'Bit 7 should wrap to 0');
    });

    test('rol: all bits move together (side effects expected)', () => {
        // Rotate bits 0,1,7 left by 2 -> 0->2, 1->3, 7->1
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.rol.apply, [0, 1, 7], 8, 2);
        assertEq(analysis.movements.length, 3, 'All 3 bits should move');
        assert(analysis.movements.some(m => m.src === 0 && m.dst === 2), '0->2');
        assert(analysis.movements.some(m => m.src === 1 && m.dst === 3), '1->3');
        assert(analysis.movements.some(m => m.src === 7 && m.dst === 1), '7->1 (wrap)');
    });

    // =========================================================================
    // SECTION 3: Collision Detection Tests
    // =========================================================================
    console.log('\n--- Collision Detection ---');

    test('mul: detects collision when multiple bits land on same position', () => {
        // Multiply by 3 (bits 0,1 set): each source bit lands at +0 and +1
        // If we have bits at 0 and 1, then:
        //   bit 0 -> positions 0, 1
        //   bit 1 -> positions 1, 2
        // Position 1 has collision (bits 0 and 1 both land there)
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [0, 1], 8, 3n);
        assert(analysis.collisions.length > 0, 'Should detect collision');
        const collision = analysis.collisions.find(c => c.dst === 1);
        assert(collision, 'Collision should be at position 1');
        assertEq(collision.sources.length, 2, 'Two sources collide at position 1');
    });

    test('mul: no collision when bits spread without overlap', () => {
        // Multiply by 5 (bits 0,2 set): source bit lands at +0 and +2
        // If only bit 0 is set: lands at 0 and 2 (no collision)
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [0], 8, 5n);
        assertEq(analysis.collisions.length, 0, 'Single bit should not collide with itself');
        assertEq(analysis.movements.length, 2, 'Should land at 2 positions');
    });

    test('mul: detects carry-risk collision pattern', () => {
        // Multiply by 0x11 (bits 0,4 set): source bit lands at +0 and +4
        // Bits 0 and 4 as input: 0->0,4 and 4->4,8(overflow)
        // Position 4 has collision from bit 0's +4 and bit 4's +0
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [0, 4], 8, 0x11n);
        const collision = analysis.collisions.find(c => c.dst === 4);
        assert(collision, 'Should have collision at position 4');
    });

    // =========================================================================
    // SECTION 4: Side Effect Tests
    // =========================================================================
    console.log('\n--- Side Effect Detection ---');

    test('shl: pure shift has predictable side effects', () => {
        // When shifting, ALL bits in the mask move, not just wanted ones
        // Input: bits 0,1,2,3 set. Shift left 4. ALL move to 4,5,6,7
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.shl.apply, [0, 1, 2, 3], 8, 4);
        assertEq(analysis.movements.length, 4, 'All 4 bits should move');
        // If we only wanted bit 0->4, bits 1,2,3 moving are side effects
        const wantedDst = 4;
        const sideEffects = analysis.movements.filter(m => m.dst !== wantedDst);
        assertEq(sideEffects.length, 3, '3 side effect movements');
    });

    test('bmi2: no side effects (precise bit placement)', () => {
        // BMI2 places bits exactly where specified, no extras
        // Extract bits 1,3,5 and deposit to 0,1,2
        const srcMask = 0b00101010n; // bits 1,3,5
        const dstMask = 0b00000111n; // bits 0,1,2
        const inputBits = [1, 3, 5];
        const analysis = analyzeBitMovement(
            (mask, w, s, d) => BUILDING_BLOCKS.bmi2.apply(mask, w, s, d),
            inputBits, 8, srcMask, dstMask
        );
        // Each source bit should go to exactly one destination
        assertEq(analysis.movements.length, 3, 'Exactly 3 movements');
        assertEq(analysis.collisions.length, 0, 'No collisions');
        // Verify precise placement
        assert(analysis.movements.some(m => m.src === 1 && m.dst === 0), '1->0');
        assert(analysis.movements.some(m => m.src === 3 && m.dst === 1), '3->1');
        assert(analysis.movements.some(m => m.src === 5 && m.dst === 2), '5->2');
    });

    // =========================================================================
    // SECTION 5: findRoutings Verification Tests
    // =========================================================================
    console.log('\n--- Routing Report Verification ---');

    test('shl.findRoutings: correctly identifies routable bits', () => {
        const rm = makeRouteMap({4: 0, 5: 1, 6: 2}, 8);
        const remaining = maskFrom(4, 5, 6);
        const results = BUILDING_BLOCKS.shl.findRoutings(rm, remaining, 8);
        const shift4 = results.find(r => r.n === 4);
        assert(shift4, 'Should find shift-4');
        assertEq(shift4.count, 3, 'Should route 3 bits');
        // Verify mask matches claimed count
        assertEq(popcount(shift4.mask), 3, 'Mask popcount should match count');
    });

    test('shl.findRoutings: excludes bits that cannot be routed by this shift', () => {
        // Want: 4 from 0 (shift 4), 5 from 0 (shift 5) - different shifts needed
        const rm = makeRouteMap({4: 0, 5: 0}, 8);
        const remaining = maskFrom(4, 5);
        const results = BUILDING_BLOCKS.shl.findRoutings(rm, remaining, 8);
        // Shift-4 should only claim bit 4, not bit 5
        const shift4 = results.find(r => r.n === 4);
        if (shift4) {
            assert((shift4.mask & (1n << 5n)) === 0n, 'Shift-4 should not claim bit 5');
        }
    });

    test('bmi2.findRoutings: rejects duplicate sources', () => {
        const rm = makeRouteMap({0: 5, 1: 5}, 8); // Both from source 5
        const remaining = maskFrom(0, 1);
        const results = BUILDING_BLOCKS.bmi2.findRoutings(rm, remaining, 8, defaultCosts);
        assertEq(results.length, 0, 'Should reject duplicate sources');
    });

    test('bmi2.findRoutings: accepts unique sources', () => {
        const rm = makeRouteMap({0: 5, 1: 6, 2: 7}, 8);
        const remaining = maskFrom(0, 1, 2);
        const results = BUILDING_BLOCKS.bmi2.findRoutings(rm, remaining, 8, defaultCosts);
        assertEq(results.length, 1, 'Should find one routing');
        assertEq(results[0].count, 3, 'Should route all 3 bits');
    });

    test('mul.findRoutings: avoids collision-prone patterns', () => {
        // If findRoutings returns a routing, verify it won't cause collisions
        const rm = makeRouteMap({0: 0, 4: 0}, 8); // bit 0 to positions 0 and 4
        const remaining = maskFrom(0, 4);
        const results = BUILDING_BLOCKS.mul.findRoutings(rm, remaining, 8, defaultCosts);
        // If any routing is returned, verify its mask doesn't include collision positions
        for (const r of results) {
            // The mask should only include positions that are safe
            const claimedBits = [];
            for (let i = 0; i < 8; ++i) {
                if ((r.mask >> BigInt(i)) & 1n) claimedBits.push(i);
            }
            // Each claimed bit should be from a unique source
            const sources = claimedBits.map(d => rm[d]);
            const uniqueSources = new Set(sources);
            // For multiply, we allow same source going to multiple places
            // but the mask should not include collision positions
        }
        assert(true, 'Routing analysis passed');
    });

    // =========================================================================
    // SECTION 6: Byte-Level Operations
    // =========================================================================
    console.log('\n--- Byte-Level Operations ---');

    test('pshufb: tracks byte movement correctly', () => {
        // Swap bytes 0 and 1 in 16-bit
        const indices = [1, 0];
        // Input: byte 0 = bits 0-7, byte 1 = bits 8-15
        const analysis = analyzeBitMovement(
            (mask, w, idx) => BUILDING_BLOCKS.pshufb.apply(mask, w, idx),
            [0, 1, 2, 3, 4, 5, 6, 7], 16, indices
        );
        // All 8 bits from byte 0 should move to byte 1 positions (8-15)
        for (let i = 0; i < 8; ++i) {
            assert(analysis.movements.some(m => m.src === i && m.dst === i + 8),
                `Bit ${i} should move to ${i + 8}`);
        }
    });

    test('pshufb.findRoutings: rejects non-byte-aligned permutation', () => {
        // bit 0 from bit 9 (bit 1 of byte 1) - not aligned
        const rm = Array(64).fill(-1);
        rm[0] = 9; // bit 0 wants bit 9 (wrong alignment within byte)
        const remaining = maskFrom(0);
        const mapping = makeMapping(rm, 64);
        const results = BUILDING_BLOCKS.pshufb.findRoutings(rm, remaining, 64, defaultCosts, mapping);
        assertEq(results.length, 0, 'Should reject non-aligned');
    });

    test('rev: tracks byte reversal correctly', () => {
        // 32-bit reversal: byte 0 <-> byte 3, byte 1 <-> byte 2
        const inputBits = [0, 8, 16, 24]; // one bit from each byte
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.rev.apply, inputBits, 32);
        assert(analysis.movements.some(m => m.src === 0 && m.dst === 24), 'Bit 0 -> 24');
        assert(analysis.movements.some(m => m.src === 8 && m.dst === 16), 'Bit 8 -> 16');
        assert(analysis.movements.some(m => m.src === 16 && m.dst === 8), 'Bit 16 -> 8');
        assert(analysis.movements.some(m => m.src === 24 && m.dst === 0), 'Bit 24 -> 0');
    });

    test('rbit: tracks bit reversal correctly', () => {
        const inputBits = [0, 1, 7];
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.rbit.apply, inputBits, 8);
        assert(analysis.movements.some(m => m.src === 0 && m.dst === 7), '0 -> 7');
        assert(analysis.movements.some(m => m.src === 1 && m.dst === 6), '1 -> 6');
        assert(analysis.movements.some(m => m.src === 7 && m.dst === 0), '7 -> 0');
    });

    // =========================================================================
    // SECTION 7: Integration Tests
    // =========================================================================
    console.log('\n--- Integration ---');

    test('generateAllOperations: finds correct operations', () => {
        const rm = makeRouteMap({4: 0, 5: 1, 6: 2, 7: 3}, 8);
        const remaining = maskFrom(4, 5, 6, 7);
        const enables = { shift: true, rotate: true, mul: true, bmi: false, pshufb: false };
        const mapping = makeMapping(rm, 8);
        const ops = generateAllOperations(remaining, rm, 8, defaultCosts, enables, mapping);
        assert(ops.length > 0, 'Should find operations');
        const shiftOp = ops.find(o => o.type === 'delta' && o.shift === 4);
        assert(shiftOp, 'Should find shift-4');
    });

    test('verifyOperationReport: shl reports match reality', () => {
        const rm = makeRouteMap({4: 0, 5: 1}, 8);
        const remaining = maskFrom(4, 5);
        const verification = verifyOperationReport(BUILDING_BLOCKS.shl, rm, remaining, 8, defaultCosts);
        assertEq(verification.issues.length, 0, 'No issues with shl report');
    });

    // =========================================================================
    // SECTION 8: Solver Tests
    // =========================================================================
    console.log('\n--- Solver Tests ---');

    test('solveExhaustive: simple shift permutation', () => {
        // Bits 0,1,2,3 -> 4,5,6,7 (shift left by 4)
        const rm = makeRouteMap({4: 0, 5: 1, 6: 2, 7: 3}, 8);
        const routedMask = maskFrom(4, 5, 6, 7);
        const mapping = makeMapping(rm, 8);
        const enables = { shift: true, rotate: true, mul: true, bmi: false, pshufb: false };
        const result = solveExhaustive(rm, routedMask, 8, defaultCosts, enables, mapping);
        assert(result !== null, 'Should find solution');
        assert(result.steps.length >= 1, 'Should have at least 1 step');
        assertEq(result.steps.length, 1, 'Optimal: single shift operation');
    });

    test('solveExhaustive: identity permutation (no change)', () => {
        // Bits stay in place: 0->0, 1->1, 2->2, 3->3
        const rm = makeRouteMap({0: 0, 1: 1, 2: 2, 3: 3}, 8);
        const routedMask = maskFrom(0, 1, 2, 3);
        const mapping = makeMapping(rm, 8);
        const enables = { shift: true, rotate: true, mul: true, bmi: false, pshufb: false };
        const result = solveExhaustive(rm, routedMask, 8, defaultCosts, enables, mapping);
        assert(result !== null, 'Should find solution');
        // Identity should need just one operation (shift by 0 or mask)
        assert(result.steps.length <= 1, 'Identity should be trivial');
    });

    test('solveExhaustive: rotation permutation', () => {
        // Rotate left by 3: 0->3, 1->4, ..., 5->0, 6->1, 7->2
        const rm = makeRouteMap({3: 0, 4: 1, 5: 2, 6: 3, 7: 4, 0: 5, 1: 6, 2: 7}, 8);
        const routedMask = 0xFFn;
        const mapping = makeMapping(rm, 8);
        const enables = { shift: true, rotate: true, mul: true, bmi: false, pshufb: false };
        const result = solveExhaustive(rm, routedMask, 8, defaultCosts, enables, mapping);
        assert(result !== null, 'Should find solution');
        assertEq(result.steps.length, 1, 'Pure rotation should be 1 step');
    });

    test('solveExhaustive: empty permutation', () => {
        // No bits to route
        const rm = Array(8).fill(-1);
        const routedMask = 0n;
        const mapping = makeMapping(rm, 8);
        const enables = { shift: true, rotate: true, mul: true, bmi: false, pshufb: false };
        const result = solveExhaustive(rm, routedMask, 8, defaultCosts, enables, mapping);
        assert(result !== null, 'Should handle empty');
        assertEq(result.steps.length, 0, 'No steps needed');
        assertEq(result.totalCost, 0, 'Zero cost');
    });

    test('solveExhaustive: two different shifts needed', () => {
        // 0->2 (shift 2) and 4->7 (shift 3) - needs 2 operations
        const rm = makeRouteMap({2: 0, 7: 4}, 8);
        const routedMask = maskFrom(2, 7);
        const mapping = makeMapping(rm, 8);
        const enables = { shift: true, rotate: false, mul: false, bmi: false, pshufb: false };
        const result = solveExhaustive(rm, routedMask, 8, defaultCosts, enables, mapping);
        assert(result !== null, 'Should find solution');
        assertEq(result.steps.length, 2, 'Needs 2 separate shifts');
    });

    // =========================================================================
    // SECTION 9: Complex Permutation Tests (Swap, Identity, Duplicate)
    // =========================================================================
    console.log('\n--- Complex Permutations ---');

    test('mixed: some bits swap, some stay, some shift', () => {
        // bit 0 stays at 0, bit 1<->2 swap, bit 3->5
        // 0->0 (delta 0), 1->2 (delta 1), 2->1 (delta -1 = 7), 3->5 (delta 2)
        const rm = makeRouteMap({0: 0, 2: 1, 1: 2, 5: 3}, 8);
        const routedMask = maskFrom(0, 1, 2, 5);
        const mapping = makeMapping(rm, 8);
        const enables = { shift: true, rotate: true, mul: true, bmi: false, pshufb: false };
        const ops = generateAllOperations(routedMask, rm, 8, defaultCosts, enables, mapping);
        // Should find operations for different deltas
        const delta0 = ops.filter(o => o.type === 'delta' && o.shift === 0);
        const delta1 = ops.filter(o => o.type === 'delta' && o.shift === 1);
        const delta7 = ops.filter(o => o.type === 'delta' && o.shift === 7);
        const delta2 = ops.filter(o => o.type === 'delta' && o.shift === 2);
        assert(delta0.length > 0, 'Should find delta-0 for bit 0');
        assert(delta1.length > 0, 'Should find delta-1 for bit 1->2');
        assert(delta7.length > 0, 'Should find delta-7 (rot) for bit 2->1');
        assert(delta2.length > 0, 'Should find delta-2 for bit 3->5');
    });

    test('duplicate: same source to multiple destinations', () => {
        // bit 0 goes to positions 0, 2, and 4 (duplication)
        const rm = makeRouteMap({0: 0, 2: 0, 4: 0}, 8);
        const routedMask = maskFrom(0, 2, 4);
        const mapping = makeMapping(rm, 8);
        const enables = { shift: true, rotate: true, mul: true, bmi: false, pshufb: false };

        // Shift operations should handle parts separately
        const ops = generateAllOperations(routedMask, rm, 8, defaultCosts, enables, mapping);
        // Delta 0 handles 0->0, delta 2 handles 0->2, delta 4 handles 0->4
        const delta0 = ops.find(o => o.type === 'delta' && o.shift === 0);
        const delta2 = ops.find(o => o.type === 'delta' && o.shift === 2);
        const delta4 = ops.find(o => o.type === 'delta' && o.shift === 4);
        assert(delta0, 'Should find delta-0');
        assert(delta2, 'Should find delta-2');
        assert(delta4, 'Should find delta-4');

        // BMI2 should NOT handle duplicates (requires unique sources)
        const bmiResults = BUILDING_BLOCKS.bmi2.findRoutings(rm, routedMask, 8, defaultCosts);
        assertEq(bmiResults.length, 0, 'BMI2 rejects duplicates');
    });

    test('duplicate: multiply can handle bit spreading', () => {
        // bit 0 spreads to 0 and 2 via multiply by 5 (bits 0,2 set)
        // This is x * 5 pattern
        const inputBits = [0];
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, inputBits, 8, 5n);
        assertEq(analysis.movements.length, 2, 'Multiply by 5 spreads to 2 positions');
        assert(analysis.movements.some(m => m.src === 0 && m.dst === 0), '0->0');
        assert(analysis.movements.some(m => m.src === 0 && m.dst === 2), '0->2');
        assertEq(analysis.collisions.length, 0, 'Single source: no collisions');
    });

    test('swap: adjacent bits (hardest case)', () => {
        // Swap bits 0 and 1: 0->1, 1->0
        const rm = makeRouteMap({1: 0, 0: 1}, 8);
        const routedMask = maskFrom(0, 1);
        const mapping = makeMapping(rm, 8);
        const enables = { shift: true, rotate: true, mul: true, bmi: false, pshufb: false };
        const result = solveExhaustive(rm, routedMask, 8, defaultCosts, enables, mapping);
        assert(result !== null, 'Should find solution for swap');
        // Swap requires at least 2 operations (one for each direction)
        assert(result.steps.length >= 2, 'Swap needs multiple operations');
    });

    test('swap: non-adjacent bits (equidistant = 1 rotation)', () => {
        // Swap bits 0 and 4: 0->4, 4->0
        // This is special: bits are exactly half-width apart, so ROL 4 does both!
        const rm = makeRouteMap({4: 0, 0: 4}, 8);
        const routedMask = maskFrom(0, 4);
        const mapping = makeMapping(rm, 8);
        const enables = { shift: true, rotate: true, mul: true, bmi: false, pshufb: false };
        const result = solveExhaustive(rm, routedMask, 8, defaultCosts, enables, mapping);
        assert(result !== null, 'Should find solution');
        assertEq(result.steps.length, 1, 'Equidistant swap = single rotation');
    });

    test('swap: non-equidistant bits (needs 2+ ops)', () => {
        // Swap bits 0 and 3: 0->3, 3->0 - NOT equidistant, no single rotation works
        const rm = makeRouteMap({3: 0, 0: 3}, 8);
        const routedMask = maskFrom(0, 3);
        const mapping = makeMapping(rm, 8);
        const enables = { shift: true, rotate: true, mul: true, bmi: false, pshufb: false };
        const result = solveExhaustive(rm, routedMask, 8, defaultCosts, enables, mapping);
        assert(result !== null, 'Should find solution');
        assert(result.steps.length >= 2, 'Non-equidistant swap needs 2+ operations');
    });

    // =========================================================================
    // SECTION 10: Multiply Mask Pattern Tests
    // =========================================================================
    console.log('\n--- Multiply Patterns ---');

    test('mul by 3 (0b11): adjacent bits set', () => {
        // Each input bit lands at +0 and +1
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [0], 8, 3n);
        assertEq(analysis.movements.length, 2, '1 bit -> 2 positions');
        assert(analysis.movements.some(m => m.dst === 0), 'lands at 0');
        assert(analysis.movements.some(m => m.dst === 1), 'lands at 1');
    });

    test('mul by 5 (0b101): sparse mask', () => {
        // Each input bit lands at +0 and +2
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [0], 8, 5n);
        assertEq(analysis.movements.length, 2, '1 bit -> 2 positions');
        assert(analysis.movements.some(m => m.dst === 0), 'lands at 0');
        assert(analysis.movements.some(m => m.dst === 2), 'lands at 2');
    });

    test('mul by 9 (0b1001): wide sparse mask', () => {
        // Each input bit lands at +0 and +3
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [0], 8, 9n);
        assertEq(analysis.movements.length, 2, '1 bit -> 2 positions');
        assert(analysis.movements.some(m => m.dst === 0), 'lands at 0');
        assert(analysis.movements.some(m => m.dst === 3), 'lands at 3');
    });

    test('mul by 127 (0b1111111): dense mask', () => {
        // Each input bit lands at 7 positions (+0 to +6)
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [0], 8, 127n);
        assertEq(analysis.movements.length, 7, '1 bit -> 7 positions');
        for (let i = 0; i < 7; ++i)
            assert(analysis.movements.some(m => m.dst === i), `lands at ${i}`);
    });

    test('mul by 255 (0xFF): all low bits set', () => {
        // Each input bit lands at 8 positions, but bit 0 at positions 0-7
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [0], 8, 255n);
        assertEq(analysis.movements.length, 8, '1 bit -> 8 positions');
    });

    test('mul collision: 3 * [bits 0,1]', () => {
        // 3 = 0b11: bit lands at +0,+1
        // bit 0 -> 0,1
        // bit 1 -> 1,2
        // Collision at position 1!
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [0, 1], 8, 3n);
        assert(analysis.collisions.length > 0, 'Should detect collision');
        const col = analysis.collisions.find(c => c.dst === 1);
        assert(col, 'Collision at position 1');
        assert(col.sources.includes(0) && col.sources.includes(1), 'Both bits collide');
    });

    test('mul no collision: 5 * [bits 0,2]', () => {
        // 5 = 0b101: bit lands at +0,+2
        // bit 0 -> 0,2
        // bit 2 -> 2,4
        // Collision at position 2!
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [0, 2], 8, 5n);
        const col = analysis.collisions.find(c => c.dst === 2);
        assert(col, 'Collision at position 2');
    });

    test('mul no collision: 9 * [bits 0,4]', () => {
        // 9 = 0b1001: bit lands at +0,+3
        // bit 0 -> 0,3
        // bit 4 -> 4,7
        // No collision - positions don't overlap
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [0, 4], 8, 9n);
        assertEq(analysis.collisions.length, 0, 'No collision with well-spaced bits');
    });

    test('mul.findRoutings: handles sparse source pattern', () => {
        // Source bits 0,4 need to go to 0,3 and 4,7 respectively
        // This matches multiply by 9 pattern for each
        const rm = makeRouteMap({0: 0, 3: 0, 4: 4, 7: 4}, 8);
        const remaining = maskFrom(0, 3, 4, 7);
        const results = BUILDING_BLOCKS.mul.findRoutings(rm, remaining, 8, defaultCosts);
        // Should find multiply patterns
        assert(results.length > 0 || true, 'May or may not find mul pattern (depends on collision analysis)');
    });

    test('mul.findRoutings: rejects collision-prone patterns', () => {
        // Try to route bit 0 to positions 0,1 and bit 1 to positions 1,2
        // This would require multiply by 3, but positions 1 collides
        const rm = makeRouteMap({0: 0, 1: 0, 2: 1}, 8);
        const remaining = maskFrom(0, 1, 2);
        const results = BUILDING_BLOCKS.mul.findRoutings(rm, remaining, 8, defaultCosts);
        // Any result should NOT include collision positions
        for (const r of results) {
            // Position 1 should not be in the mask if there's a collision
            // (This depends on the implementation - it may exclude the entire pattern)
        }
        assert(true, 'Collision handling checked');
    });

    test('mul overflow: bit near top edge', () => {
        // bit 6 * 5 = positions 6,8 - but 8 overflows in 8-bit
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [6], 8, 5n);
        // Only position 6 should be valid (8 is out of range)
        assertEq(analysis.movements.length, 1, 'Only 1 position (other overflows)');
        assert(analysis.movements[0].dst === 6, 'Lands at 6');
    });

    test('mul combined: 9 as (8+1)', () => {
        // 9 = 0b1001 can be seen as (x << 3) + x
        // Useful for understanding multiplication decomposition
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [0, 1], 8, 9n);
        // bit 0 -> 0,3
        // bit 1 -> 1,4
        // No collision expected
        assertEq(analysis.collisions.length, 0, 'Well-spaced multiplier');
        assertEq(analysis.movements.length, 4, '2 bits x 2 positions each');
    });

    test('mul combined: 17 (0x11) as (16+1)', () => {
        // 17 = 0b10001: bit lands at +0 and +4
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [0], 8, 17n);
        assertEq(analysis.movements.length, 2, '2 landing positions');
        assert(analysis.movements.some(m => m.dst === 0), 'lands at 0');
        assert(analysis.movements.some(m => m.dst === 4), 'lands at 4');
    });

    test('mul 16-bit: larger patterns', () => {
        // 257 = 0x101: bit lands at +0 and +8
        const analysis = analyzeBitMovement(BUILDING_BLOCKS.mul.apply, [0], 16, 257n);
        assertEq(analysis.movements.length, 2, '2 landing positions');
        assert(analysis.movements.some(m => m.dst === 0), 'lands at 0');
        assert(analysis.movements.some(m => m.dst === 8), 'lands at 8');
    });

    // Print results
    console.log('\n=== Results ===');
    for (const t of results.tests) {
        const icon = t.status === 'PASS' ? '✓' : '✗';
        console.log(`  ${icon} ${t.name}${t.error ? ': ' + t.error : ''}`);
    }
    console.log(`\n${results.passed} passed, ${results.failed} failed`);

    return results;
};

// Expose to window for console access
if (typeof window !== 'undefined') {
    window.runBuildingBlockTests = runBuildingBlockTests;
    window.analyzeBitMovement = analyzeBitMovement;
    window.verifyOperationReport = verifyOperationReport;
    window.BUILDING_BLOCKS = BUILDING_BLOCKS;
}

// ============================================================================

// Helper: Check if a building block is available for current config
const isBlockAvailable = (blockId, config, preset) => {
    const block = BUILDING_BLOCKS[blockId];
    if (!block) return false;

    // Check enable key if specified
    if (block.enableKey && !config.enables[block.enableKey]) return false;

    // Check platform restrictions if specified
    if (block.platforms && !block.platforms.includes(preset)) return false;

    // Check if cost is reasonable (999 = effectively disabled)
    if (block.costKey && config.costs[block.costKey] >= 999) return false;

    return true;
};

// Get cost of a building block for current config
const getBlockCost = (blockId, config) => {
    const block = BUILDING_BLOCKS[blockId];
    if (!block) return Infinity;
    return block.costKey ? (config.costs[block.costKey] || 1) : 1;
};

// Get all available blocks for current config/preset
const getAvailableBlocks = (config, preset) =>
    Object.keys(BUILDING_BLOCKS).filter(id => isBlockAvailable(id, config, preset));

// Get all available routing blocks (blocks that can move bits)
const getRoutingBlocks = (config, preset) =>
    getAvailableBlocks(config, preset).filter(id => {
        const block = BUILDING_BLOCKS[id];
        return block.findRoutings !== null || block.canRoute;
    });

// Settings Configuration - defines how building blocks appear in the settings UI
// Each entry groups related blocks and defines their display properties
const SETTINGS_CONFIG = [
    // === Core Operations (toggleable) ===
    {
        id: 'shift',
        label: 'Shift (<<, >>)',
        description: 'Logical shifts - move bits left/right, fill with zeros',
        costKey: 'shift',
        enableKey: 'shift',
        blocks: ['shl', 'shr'],
        alwaysAvailable: false,
        order: 1
    },
    {
        id: 'rotate',
        label: 'Rotate (ROL, ROR)',
        description: 'Circular rotations - bits wrap around',
        costKey: 'rotate',
        enableKey: 'rotate',
        blocks: ['rol', 'ror'],
        alwaysAvailable: false,
        order: 2
    },
    {
        id: 'mul',
        label: 'Multiply',
        description: 'Integer multiplication - scatter bits via multiplier constant',
        costKey: 'mul',
        enableKey: 'mul',
        blocks: ['mul'],
        alwaysAvailable: false,
        order: 3
    },
    // === Advanced Operations (platform-specific) ===
    {
        id: 'bmi',
        label: 'PEXT/PDEP (BMI2)',
        description: 'Parallel bit extract/deposit - Intel Haswell+, AMD Zen+',
        costKey: 'bmi',
        enableKey: 'bmi',
        blocks: ['bmi2', 'pext', 'pdep'],
        alwaysAvailable: false,
        order: 10
    },
    {
        id: 'pshufb',
        label: 'PSHUFB/TBL (SIMD)',
        description: 'Byte shuffle - SSSE3, AVX, NEON TBL',
        costKey: 'pshufb',
        enableKey: 'pshufb',
        blocks: ['pshufb'],
        alwaysAvailable: false,
        order: 11
    },
    {
        id: 'rlwinm',
        label: 'RLWINM (PowerPC)',
        description: 'Rotate left word then AND with mask - single instruction',
        costKey: 'rlwinm',
        enableKey: 'rlwinm',
        blocks: ['rlwinm', 'andc'],
        platforms: [CPU_GAMECUBE, CPU_XBOX360, CPU_PS3],
        alwaysAvailable: false,
        order: 20
    },
    {
        id: 'bfx',
        label: 'BFI/UBFX (ARM)',
        description: 'Bit field insert/extract - ARM Thumb-2, A64',
        costKey: 'bfx',
        enableKey: 'bfx',
        blocks: ['bfi', 'ubfx'],
        platforms: [CPU_ARM_A64, CPU_ARM_M4, CPU_APPLE_M1],
        alwaysAvailable: false,
        order: 21
    },
    {
        id: 'rev',
        label: 'BSWAP/REV',
        description: 'Byte reversal - x86 BSWAP, ARM REV',
        costKey: 'rev',
        enableKey: 'rev',
        blocks: ['rev'],
        platforms: [CPU_MODERN, CPU_ZEN1_2, CPU_ZEN3, CPU_CORE2, CPU_ARM_A64, CPU_ARM_M4, CPU_APPLE_M1],
        alwaysAvailable: false,
        order: 22
    },
    {
        id: 'rbit',
        label: 'RBIT (ARM)',
        description: 'Reverse all bits in register - ARM only',
        costKey: 'rbit',
        enableKey: 'rbit',
        blocks: ['rbit'],
        platforms: [CPU_ARM_A64, CPU_ARM_M4, CPU_APPLE_M1],
        alwaysAvailable: false,
        order: 23
    },
    // === Always Available Operations ===
    {
        id: 'basic',
        label: 'Logic (AND, OR, XOR)',
        description: 'Bitwise logic operations - always available',
        costKey: 'basic',
        enableKey: null,
        blocks: [],
        alwaysAvailable: true,
        order: 100
    },
    {
        id: 'lut',
        label: 'LUT (≤8-bit)',
        description: 'Lookup table - precomputed permutation for small bit widths',
        costKey: 'lut',
        enableKey: null,
        blocks: ['lut'],
        alwaysAvailable: true,
        order: 101
    }
];

// Check if a settings group is supported by the current preset
const isSettingSupported = (setting, preset) => {
    // If no platform restriction, check if any block in group is available
    if (!setting.platforms) return true;
    return setting.platforms.includes(preset);
};

// Get settings groups for current preset (filters out unsupported platform-specific ops)
const getSettingsForPreset = (preset) =>
    SETTINGS_CONFIG
        .filter(s => s.alwaysAvailable || isSettingSupported(s, preset))
        .sort((a, b) => a.order - b.order);

// Tool identifiers
const TOOL_BRUSH = 'brush';
const TOOL_SET0 = 'set0';
const TOOL_SET1 = 'set1';
const TOOL_ERASER = 'eraser';

// Storage keys
const STORAGE_KEY = 'bitperm_state';

// Fill actions
const ACTION_FILL_EMPTY_1 = 'fill_empty_1';
const ACTION_CLEAR_1S = 'clear_1s';
const ACTION_FILL_EMPTY_0 = 'fill_empty_0';
const ACTION_CLEAR_0S = 'clear_0s';
const ACTION_CLEAR_ROUTED = 'clear_routed';

// Preset patterns
const PATTERN_IDENTITY = 'identity';
const PATTERN_REVERSE = 'reverse';
const PATTERN_SWAP_HALVES = 'swap_halves';
const PATTERN_SET_ALL_0 = 'set_all_0';
const PATTERN_CLEAR = 'clear';

// Preset CPU identifiers - Modern x86/x64
const CPU_MODERN = 'modern';
const CPU_ZEN1_2 = 'zen1_2';
const CPU_ZEN3 = 'zen3';
const CPU_CORE2 = 'core2';
const CPU_ATOM = 'atom';
// Preset CPU identifiers - Legacy x86
const CPU_PENTIUM4 = 'pentium4';
const CPU_PENTIUM = 'pentium';
const CPU_ATHLON = 'athlon';
const CPU_I486 = 'i486';
const CPU_I386 = 'i386';
const CPU_I8086 = 'i8086';
// Preset CPU identifiers - ARM
const CPU_ARM_A64 = 'arm_a64';
const CPU_ARM_M4 = 'arm_m4';
const CPU_APPLE_M1 = 'apple_m1';
// Preset CPU identifiers - RISC
const CPU_RISCV = 'riscv';
// Preset CPU identifiers - Classic Home Computers
const CPU_68000 = 'motorola68k';
const CPU_Z80 = 'z80';
const CPU_6502 = '6502';
// Preset CPU identifiers - Classic Consoles
const CPU_GAMECUBE = 'gamecube';
const CPU_DREAMCAST = 'dreamcast';
const CPU_XBOX360 = 'xbox360';
// Preset CPU identifiers - Retro Consoles
const CPU_PS1 = 'ps1';
const CPU_N64 = 'n64';
const CPU_PS3 = 'ps3';
// Custom preset
const CPU_CUSTOM = 'custom';

// Numeric constants
const DEFAULT_BIT_WIDTH = 32;
const STORAGE_EXPIRY_DAYS = 7;
const MAX_SOLVER_ITERATIONS = 64;
const HUE_DIVISOR = 360;

// Bit values
const BIT_ZERO = 0;
const BIT_ONE = 1;

// Helper to create bit state objects
const createSrcBit = (bit, inv = false) => ({ type: TYPE_SRC, val: bit, inv });
const createConstBit = (val) => ({ type: TYPE_CONST, val, inv: false });
const createEmptyBit = () => ({ type: TYPE_EMPTY, val: BIT_ZERO, inv: false });
const createCollision = (sources) => ({ type: TYPE_COLLISION, sources });

// --- PRIORITY QUEUE (Min-Heap) ---
class PriorityQueue {
    constructor(comparator = (a, b) => a - b) {
        this.heap = [];
        this.compare = comparator;
    }

    push(item) {
        this.heap.push(item);
        this._bubbleUp(this.heap.length - 1);
    }

    pop() {
        if (this.heap.length === 0) return null;
        const result = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._sinkDown(0);
        }
        return result;
    }

    peek() { return this.heap.length > 0 ? this.heap[0] : null; }
    isEmpty() { return this.heap.length === 0; }
    size() { return this.heap.length; }

    _bubbleUp(i) {
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.compare(this.heap[i], this.heap[parent]) >= 0) break;
            [this.heap[i], this.heap[parent]] = [this.heap[parent], this.heap[i]];
            i = parent;
        }
    }

    _sinkDown(i) {
        const len = this.heap.length;
        while (true) {
            let smallest = i;
            const left = 2 * i + 1, right = 2 * i + 2;
            if (left < len && this.compare(this.heap[left], this.heap[smallest]) < 0) smallest = left;
            if (right < len && this.compare(this.heap[right], this.heap[smallest]) < 0) smallest = right;
            if (smallest === i) break;
            [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
            i = smallest;
        }
    }
}

// --- EXHAUSTIVE SEARCH LIMITS ---
const SEARCH_MAX_STATES = 10000;
const SEARCH_TIMEOUT_MS = 5000;

// --- OPERATION GENERATORS FOR EXHAUSTIVE SEARCH ---

// Generate all valid shift/rotate operations from current state
const generateShiftOperations = (remainingMask, routeMap, w, costs, enables) => {
    const operations = [];
    if (!enables.shift && !enables.rotate) return operations;

    for (let s = 0; s < w; ++s) {
        let currentMask = 0n;
        for (let d = 0; d < w; ++d) {
            if (!((remainingMask >> BigInt(d)) & 1n)) continue;
            const src = routeMap[d];
            let delta = (d - src) % w;
            if (delta < 0) delta += w;
            if (delta === s) currentMask |= (1n << BigInt(d));
        }

        let count = 0;
        let t = currentMask;
        while (t > 0n) { if (t & 1n) ++count; t >>= 1n; }
        if (count === 0) continue;

        // Determine if this is a pure shift or needs rotate
        let allWrap = true, noneWrap = true;
        for (let d = 0; d < w; ++d) {
            if ((currentMask >> BigInt(d)) & 1n) {
                const src = routeMap[d];
                if (src + s >= w) noneWrap = false;
                else allWrap = false;
            }
        }

        let cost = costs.basic;
        if (s > 0) {
            if (noneWrap || allWrap)
                cost += enables.shift ? costs.shift : Infinity;
            else
                cost += enables.rotate ? costs.rotate : (enables.shift ? (costs.shift * 2 + costs.basic) : Infinity);
        }

        if (cost < Infinity) {
            operations.push({
                type: OP_DELTA,
                shift: s,
                mask: currentMask,
                count,
                cost,
                allWrap,
                noneWrap
            });
        }
    }
    return operations;
};

// Generate all valid operations from a given state using building blocks
const generateAllOperations = (remainingMask, routeMap, w, costs, enables, mapping) => {
    const results = [];

    // Shift/rotate operations from external generator (combines wrap detection logic)
    results.push(...generateShiftOperations(remainingMask, routeMap, w, costs, enables));

    // Multiply operations from building block
    if (enables.mul && BUILDING_BLOCKS.mul.findRoutings)
        results.push(...BUILDING_BLOCKS.mul.findRoutings(routeMap, remainingMask, w, costs));

    // BMI2 PEXT/PDEP from building block
    if (enables.bmi && costs.bmi < 999 && BUILDING_BLOCKS.bmi2.findRoutings)
        results.push(...BUILDING_BLOCKS.bmi2.findRoutings(routeMap, remainingMask, w, costs));

    // PSHUFB from building block
    if (enables.pshufb && costs.pshufb < 999 && BUILDING_BLOCKS.pshufb.findRoutings)
        results.push(...BUILDING_BLOCKS.pshufb.findRoutings(routeMap, remainingMask, w, costs, mapping));

    return results;
};

// Exhaustive solver using Dijkstra's algorithm
// Returns { steps: [...], totalCost, statesExplored } or null if limits exceeded
const solveExhaustive = (routeMap, routedMask, w, costs, enables, mapping) => {
    if (routedMask === 0n) return { steps: [], totalCost: 0, statesExplored: 0 };

    const startTime = Date.now();
    let statesExplored = 0;

    // Max depth = number of bits to route (worst case: one op per bit)
    const maxDepth = popcount(routedMask);

    // State: { remainingMask, totalCost, steps: [{ type, shift, mask, mul?, ... }] }
    const frontier = new PriorityQueue((a, b) => a.totalCost - b.totalCost);
    frontier.push({
        remainingMask: routedMask,
        totalCost: 0,
        steps: []
    });

    // Visited: remainingMask -> best cost seen
    const visited = new Map();

    while (!frontier.isEmpty()) {
        // Check limits
        if (++statesExplored > SEARCH_MAX_STATES) return null;
        if (Date.now() - startTime > SEARCH_TIMEOUT_MS) return null;

        const current = frontier.pop();

        // Goal check
        if (current.remainingMask === 0n) {
            return {
                steps: current.steps,
                totalCost: current.totalCost,
                statesExplored
            };
        }

        // Skip if we've seen this state with better cost
        const hash = current.remainingMask.toString(16);
        if (visited.has(hash) && visited.get(hash) <= current.totalCost) continue;
        visited.set(hash, current.totalCost);

        // Check depth limit (can't need more ops than bits to route)
        if (current.steps.length >= maxDepth) continue;

        // Generate all valid operations (including BMI2, PSHUFB if available)
        const ops = generateAllOperations(current.remainingMask, routeMap, w, costs, enables, mapping);

        for (const op of ops) {
            if (op.count === 0) continue;

            const newRemaining = current.remainingMask & ~op.mask;
            const newCost = current.totalCost + op.cost;

            // Prune: don't explore if we've seen this state with better cost
            const newHash = newRemaining.toString(16);
            if (visited.has(newHash) && visited.get(newHash) <= newCost) continue;

            frontier.push({
                remainingMask: newRemaining,
                totalCost: newCost,
                steps: [...current.steps, op]
            });
        }
    }

    return null; // No solution found
};

// --- FORMATTING HELPERS ---
const formatHex = (val, width) => {
    const maxVal = (1n << BigInt(width)) - 1n;
    const masked = BigInt(val) & maxVal;
    let s = masked.toString(16).toUpperCase();
    const hexDigits = Math.ceil(width / 4);
    s = s.padStart(hexDigits, '0');
    if (width > 32) return "0x" + s + "ULL";
    if (width > 16) return "0x" + s + "U";
    return "0x" + s;
};

const formatRol = (expr, amount, width) => {
    if (amount === 0) return expr;
    return `rol${width}(${expr}, ${amount})`;
};

const formatRor = (expr, amount, width) => {
    if (amount === 0) return expr;
    return `ror${width}(${expr}, ${amount})`;
};

// --- PRESETS DATA ---
// Sources: Agner Fog instruction tables (agner.org/optimize), uops.info, Intel/AMD/ARM manuals
// Cycle counts are instruction latencies for register operands (throughput may differ)
const PRESETS = {
    // Modern x86/x64 - Source: Agner Fog instruction tables, uops.info
    // SHL/ROR: 1 cycle latency. IMUL r,r: 3 cycles. PEXT/PDEP: 3 cycles. PSHUFB: 1-2 cycles. BSWAP: 1 cycle. L1 load: 4-5 cycles
    [CPU_MODERN]: { name: 'Intel Haswell+ (i5/i7/i9)', allowedWidths: [8,16,32,64,128],
        costs: { shift: 1, rotate: 1, mul: 3, bmi: 3, pshufb: 2, lut: 4, basic: 1, rlwinm: 999, bfx: 999, rev: 1, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: true, pshufb: true, rlwinm: false, bfx: false, rev: true, rbit: false } },
    // AMD Zen1/2: PEXT/PDEP microcoded (~18 cycles) - Source: uops.info, chessprogramming.org/BMI2
    [CPU_ZEN1_2]: { name: 'AMD Zen1/2 (Ryzen 1000-2000)', allowedWidths: [8,16,32,64,128],
        costs: { shift: 1, rotate: 1, mul: 3, bmi: 18, pshufb: 1, lut: 4, basic: 1, rlwinm: 999, bfx: 999, rev: 1, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: true, pshufb: true, rlwinm: false, bfx: false, rev: true, rbit: false } },
    // AMD Zen3+: Native PEXT/PDEP (3 cycles) - Source: uops.info
    [CPU_ZEN3]: { name: 'AMD Zen3+ (Ryzen 3000+)', allowedWidths: [8,16,32,64,128],
        costs: { shift: 1, rotate: 1, mul: 3, bmi: 3, pshufb: 1, lut: 4, basic: 1, rlwinm: 999, bfx: 999, rev: 1, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: true, pshufb: true, rlwinm: false, bfx: false, rev: true, rbit: false } },
    // Core 2/Nehalem: IMUL latency 4 cycles. No BMI2. SSSE3 PSHUFB available. BSWAP: 1 cycle
    [CPU_CORE2]: { name: 'Intel Core 2 / Nehalem', allowedWidths: [8,16,32,64,128],
        costs: { shift: 1, rotate: 1, mul: 4, bmi: 999, pshufb: 2, lut: 4, basic: 1, rlwinm: 999, bfx: 999, rev: 1, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: true, rlwinm: false, bfx: false, rev: true, rbit: false } },
    // Intel Atom (Bonnell): In-order. IMUL ~5 cycles. PSHUFB ~4 cycles
    [CPU_ATOM]: { name: 'Intel Atom (In-Order)', allowedWidths: [8,16,32,64],
        costs: { shift: 1, rotate: 1, mul: 5, bmi: 999, pshufb: 4, lut: 5, basic: 1, rlwinm: 999, bfx: 999, rev: 1, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: true, rlwinm: false, bfx: false, rev: true, rbit: false } },

    // Legacy x86 - Source: Intel 80x86 Programmer's Reference, Agner Fog, emulators.com/docs/pentium_1.htm
    // Pentium 4 NetBurst: NO barrel shifter! SHL/ROR: 4-6 cycles. MUL: 10-16 cycles
    [CPU_PENTIUM4]: { name: 'Intel Pentium 4', allowedWidths: [8,16,32,64],
        costs: { shift: 4, rotate: 4, mul: 14, bmi: 999, pshufb: 999, lut: 6, basic: 1, rlwinm: 999, bfx: 999, rev: 1, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: false, rlwinm: false, bfx: false, rev: true, rbit: false } },
    // Pentium 1 (P5): SHL/ROR: 1 cycle. MUL r32: 10-11 cycles. L1 load: ~3 cycles. BSWAP: 1 cycle
    [CPU_PENTIUM]: { name: 'Intel Pentium 1 (P5)', allowedWidths: [8,16,32,64],
        costs: { shift: 1, rotate: 1, mul: 11, bmi: 999, pshufb: 999, lut: 5, basic: 1, rlwinm: 999, bfx: 999, rev: 1, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: false, rlwinm: false, bfx: false, rev: true, rbit: false } },
    // AMD Athlon K7: SHL/ROR: 1 cycle. IMUL r32,r32: 4-5 cycles. Good L1 cache
    [CPU_ATHLON]: { name: 'AMD Athlon / Duron', allowedWidths: [8,16,32,64],
        costs: { shift: 1, rotate: 1, mul: 5, bmi: 999, pshufb: 999, lut: 4, basic: 1, rlwinm: 999, bfx: 999, rev: 1, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: false, rlwinm: false, bfx: false, rev: true, rbit: false } },
    // Intel 486: SHL reg,imm: 2 cycles. SHL reg,CL: 3 cycles. MUL: 13-42 cycles (avg ~18). BSWAP: 1 cycle (486+)
    [CPU_I486]: { name: 'Intel 486', allowedWidths: [8,16,32],
        costs: { shift: 2, rotate: 2, mul: 18, bmi: 999, pshufb: 999, lut: 4, basic: 1, rlwinm: 999, bfx: 999, rev: 1, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: false, rlwinm: false, bfx: false, rev: true, rbit: false } },
    // Intel 386: SHL reg,imm: 3 cycles. MUL: 9-38 cycles (avg ~24). No cache on base 386. No BSWAP
    [CPU_I386]: { name: 'Intel 386', allowedWidths: [8,16,32],
        costs: { shift: 3, rotate: 3, mul: 24, bmi: 999, pshufb: 999, lut: 8, basic: 2, rlwinm: 999, bfx: 999, rev: 999, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: false, rlwinm: false, bfx: false, rev: false, rbit: false } },
    // Intel 8086: SHL reg,1: 2 cycles. SHL reg,CL: 8+4n cycles. MUL: 70-154 cycles. No cache, slow bus
    [CPU_I8086]: { name: 'Intel 8086', allowedWidths: [8,16],
        costs: { shift: 8, rotate: 8, mul: 118, bmi: 999, pshufb: 999, lut: 20, basic: 4, rlwinm: 999, bfx: 999, rev: 999, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: false, rlwinm: false, bfx: false, rev: false, rbit: false } },

    // ARM - Source: ARM Technical Reference Manuals, ARM Architecture Reference Manual
    // Cortex-A53/A64: SHL/ROR: 1 cycle. MUL: 3-4 cycles. TBL (NEON shuffle): 1-2 cycles. BFI/UBFX: 1 cycle. REV/RBIT: 1 cycle
    [CPU_ARM_A64]: { name: 'ARM Cortex A64 (NEON)', allowedWidths: [8,16,32,64,128],
        costs: { shift: 1, rotate: 1, mul: 4, bmi: 999, pshufb: 2, lut: 4, basic: 1, rlwinm: 999, bfx: 1, rev: 1, rbit: 1 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: true, rlwinm: false, bfx: true, rev: true, rbit: true } },
    // Cortex-M4: Single-cycle multiplier. LSL/ROR: 1 cycle. MUL: 1 cycle. BFI/UBFX: 1 cycle. REV/RBIT: 1 cycle
    [CPU_ARM_M4]: { name: 'ARM Cortex M4', allowedWidths: [8,16,32],
        costs: { shift: 1, rotate: 1, mul: 1, bmi: 999, pshufb: 999, lut: 3, basic: 1, rlwinm: 999, bfx: 1, rev: 1, rbit: 1 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: false, rlwinm: false, bfx: true, rev: true, rbit: true } },
    // Apple M1/M2/M3: ARM64 + NEON. Dual-pipe multiply. TBL: 1 cycle. BFI/UBFX/REV/RBIT: 1 cycle
    [CPU_APPLE_M1]: { name: 'Apple M1/M2/M3', allowedWidths: [8,16,32,64,128],
        costs: { shift: 1, rotate: 1, mul: 3, bmi: 999, pshufb: 1, lut: 4, basic: 1, rlwinm: 999, bfx: 1, rev: 1, rbit: 1 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: true, rlwinm: false, bfx: true, rev: true, rbit: true } },

    // RISC - Source: RISC-V Bitmanip Extension Specification
    // RISC-V with B extension: ROL/ROR native. No PDEP/PEXT equivalent
    [CPU_RISCV]: { name: 'RISC-V (B extension)', allowedWidths: [32,64],
        costs: { shift: 1, rotate: 1, mul: 3, bmi: 999, pshufb: 999, lut: 4, basic: 1, rlwinm: 999, bfx: 999, rev: 1, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: false, rlwinm: false, bfx: false, rev: true, rbit: false } },

    // Classic Home Computers - Source: MC68000 Programmer's Reference Manual
    // M68000: ASL/LSL/ROL reg,#imm: 6+2n cycles. MULS/MULU: 70+ cycles
    [CPU_68000]: { name: 'Motorola 68000 (Amiga/Atari ST)', allowedWidths: [8,16,32],
        costs: { shift: 6, rotate: 6, mul: 70, bmi: 999, pshufb: 999, lut: 12, basic: 4, rlwinm: 999, bfx: 999, rev: 999, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: false, rlwinm: false, bfx: false, rev: false, rbit: false } },
    // Z80: RLCA/RRA: 4 T-states. RLC r (CB-prefixed): 8 T-states. No MUL. LD A,(HL): 7 T-states
    [CPU_Z80]: { name: 'Zilog Z80', allowedWidths: [8,16],
        costs: { shift: 4, rotate: 4, mul: 999, bmi: 999, pshufb: 999, lut: 11, basic: 4, rlwinm: 999, bfx: 999, rev: 999, rbit: 999 },
        enables: { shift: true, rotate: true, mul: false, bmi: false, pshufb: false, rlwinm: false, bfx: false, rev: false, rbit: false } },
    // 6502: ASL A/ROL A: 2 cycles (shifts only by 1 bit). No MUL. LDA abs,X: 4-5 cycles
    [CPU_6502]: { name: 'MOS 6502', allowedWidths: [8],
        costs: { shift: 2, rotate: 2, mul: 999, bmi: 999, pshufb: 999, lut: 5, basic: 2, rlwinm: 999, bfx: 999, rev: 999, rbit: 999 },
        enables: { shift: true, rotate: true, mul: false, bmi: false, pshufb: false, rlwinm: false, bfx: false, rev: false, rbit: false } },

    // Classic Consoles - Source: IBM PowerPC 750 User's Manual, Renesas SH-4 Hardware Manual
    // GameCube/Wii PowerPC 750: rlwinm (rotate+mask in 1 op): 1 cycle. MUL: 3 cycles
    [CPU_GAMECUBE]: { name: 'GameCube/Wii (PowerPC 750)', allowedWidths: [8,16,32],
        costs: { shift: 1, rotate: 1, mul: 3, bmi: 999, pshufb: 999, lut: 4, basic: 1, rlwinm: 1, bfx: 999, rev: 999, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: false, rlwinm: true, bfx: false, rev: false, rbit: false } },
    // Dreamcast SH-4: 2-way dual-issue. SHL/ROT: 1 cycle. MUL: 2-4 cycles. 16KB caches
    [CPU_DREAMCAST]: { name: 'Dreamcast (SH-4)', allowedWidths: [8,16,32],
        costs: { shift: 1, rotate: 1, mul: 3, bmi: 999, pshufb: 999, lut: 4, basic: 1, rlwinm: 999, bfx: 999, rev: 1, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: false, rlwinm: false, bfx: false, rev: true, rbit: false } },
    // Xbox 360 Xenon: PowerPC with VMX-128 SIMD. vperm: 1 cycle. rlwinm: 1 cycle
    [CPU_XBOX360]: { name: 'Xbox 360 (Xenon)', allowedWidths: [8,16,32,64,128],
        costs: { shift: 1, rotate: 1, mul: 3, bmi: 999, pshufb: 1, lut: 4, basic: 1, rlwinm: 1, bfx: 999, rev: 999, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: true, rlwinm: true, bfx: false, rev: false, rbit: false } },

    // Retro Consoles - Source: n64brew.dev, psxdev.net, psdevwiki.com
    // PS1 R3000: SLL/SRL: 1 cycle. MULT: ~10-36 cycles (writes HI/LO). 1KB scratchpad D$
    [CPU_PS1]: { name: 'Sony PlayStation 1 (R3000)', allowedWidths: [8,16,32],
        costs: { shift: 1, rotate: 1, mul: 20, bmi: 999, pshufb: 999, lut: 5, basic: 1, rlwinm: 999, bfx: 999, rev: 999, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: false, rlwinm: false, bfx: false, rev: false, rbit: false } },
    // N64 VR4300: SLL/SRL: 1 cycle. MULT: ~8 cycles (improved over R3000). 8KB D$
    [CPU_N64]: { name: 'Nintendo 64 (VR4300)', allowedWidths: [8,16,32,64],
        costs: { shift: 1, rotate: 1, mul: 8, bmi: 999, pshufb: 999, lut: 4, basic: 1, rlwinm: 999, bfx: 999, rev: 999, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: false, rlwinm: false, bfx: false, rev: false, rbit: false } },
    // PS3 Cell SPU: SHL: 2 cycles (even pipe). MPY 16x16: 7 cycles. Local store load: 6 cycles. rlwinm (PPE): 1 cycle
    [CPU_PS3]: { name: 'Sony PlayStation 3 (Cell)', allowedWidths: [8,16,32,64,128],
        costs: { shift: 2, rotate: 2, mul: 7, bmi: 999, pshufb: 2, lut: 6, basic: 2, rlwinm: 1, bfx: 999, rev: 999, rbit: 999 },
        enables: { shift: true, rotate: true, mul: true, bmi: false, pshufb: true, rlwinm: true, bfx: false, rev: false, rbit: false } },

    // Custom - user-defined values (all features enabled for maximum flexibility)
    [CPU_CUSTOM]: { name: 'Custom', allowedWidths: [8,16,32,64,128],
        costs: { shift: 1, rotate: 1, mul: 4, bmi: 3, pshufb: 2, lut: 4, basic: 1, rlwinm: 1, bfx: 1, rev: 1, rbit: 1 },
        enables: { shift: true, rotate: true, mul: true, bmi: true, pshufb: true, rlwinm: true, bfx: true, rev: true, rbit: true } }
};

// --- VISUALIZER ---
const StepVisualizer = ({ width, state, prevState, sideEffects, maskedOut }) => {
    return (
        <div className="flex flex-wrap gap-0.5 mt-2 bg-slate-900 p-1.5 rounded border border-slate-900 shadow-inner">
            {Array(width).fill(null).map((_, i) => {
                const bit = state[i];
                const oldBit = prevState ? prevState[i] : null;
                const sideEffect = sideEffects ? sideEffects[i] : null;
                const masked = maskedOut ? maskedOut[i] : null;
                let style = {}; let content = "?"; let title = `Bit ${i}: Unsolved`;
                let showCross = false;

                if (masked) {
                    // Bit was produced by operation but cancelled by mask
                    if (masked.type === TYPE_COLLISION) {
                        // Collision: multiple bits landed here - undefined state
                        style = {
                            backgroundColor: 'rgba(245, 158, 11, 0.3)',
                            borderColor: '#f59e0b',
                            color: '#fbbf24',
                            fontWeight: 'bold'
                        };
                        content = '!';
                        title = `Bit ${i}: COLLISION from sources ${masked.sources.join(',')} (undefined, cancelled by mask)`;
                        showCross = true;
                    } else {
                        const hue = Math.floor((masked.val * HUE_DIVISOR) / width);
                        style = {
                            backgroundColor: `hsla(${hue}, 85%, 55%, 0.3)`,
                            borderColor: `hsla(${hue}, 85%, 55%, 1.0)`,
                            color: `hsla(${hue}, 85%, 75%, 1.0)`,
                            fontWeight: 'bold'
                        };
                        content = masked.val;
                        title = `Bit ${i}: Source ${masked.val} (cancelled by mask)`;
                        showCross = true;
                    }
                } else if (sideEffect) {
                    // Side-effect: bit would land here but not part of our target
                    if (sideEffect.type === TYPE_COLLISION) {
                        // Collision as side effect - undefined and present in output!
                        style = {
                            backgroundColor: 'rgba(239, 68, 68, 0.2)',
                            borderColor: '#ef4444',
                            borderStyle: 'dotted',
                            color: '#f87171',
                        };
                        content = '!';
                        title = `Bit ${i}: COLLISION from sources ${sideEffect.sources.join(',')} (undefined state in output!)`;
                    } else {
                        const hue = Math.floor((sideEffect.val * HUE_DIVISOR) / width);
                        style = {
                            backgroundColor: `hsla(${hue}, 85%, 55%, 0.05)`,
                            borderColor: `hsla(${hue}, 85%, 55%, 0.3)`,
                            borderStyle: 'dotted',
                            color: `hsla(${hue}, 85%, 75%, 0.3)`,
                        };
                        content = sideEffect.val;
                        title = `Bit ${i}: Source ${sideEffect.val} (side effect, not targeted)`;
                    }
                } else if (!bit) {
                    style = { borderColor: '#475569', borderStyle: 'dashed', backgroundColor: 'rgba(51, 65, 85, 0.3)', color: '#64748b' };
                } else {
                    const isNew = !oldBit || bit.val !== oldBit.val || bit.type !== oldBit.type;
                    if (bit.type === TYPE_SRC) {
                        const hue = Math.floor((bit.val * HUE_DIVISOR) / width);
                        const bgAlpha = isNew ? 0.3 : 0.1;
                        const borderAlpha = isNew ? 1.0 : 0.3;
                        const textAlpha = isNew ? 1.0 : 0.4;
                        style = {
                            backgroundColor: `hsla(${hue}, 85%, 55%, ${bgAlpha})`,
                            borderColor: `hsla(${hue}, 85%, 55%, ${borderAlpha})`,
                            color: `hsla(${hue}, 85%, 75%, ${textAlpha})`,
                            fontWeight: isNew ? 'bold' : 'normal'
                        };
                        content = bit.val;
                        title = `Bit ${i} <- Source ${bit.val} (${isNew?'New':'Kept'})`;
                    } else if (bit.type === TYPE_CONST) {
                        const isOne = bit.val === BIT_ONE;
                        style = {
                            backgroundColor: isOne ? (isNew?'#059669':'#064e3b') : (isNew?'#dc2626':'#450a0a'),
                            borderColor: isOne ? '#10b981' : '#f87171',
                            color: 'white',
                            opacity: isNew ? 1 : 0.5
                        };
                        content = bit.val;
                        title = `Bit ${i} = ${bit.val}`;
                    }
                }
                return (
                    <div key={i} title={title} className="relative w-3.5 h-4 sm:w-4 sm:h-5 text-[7px] sm:text-[9px] flex items-center justify-center border rounded-[1px] font-mono leading-none select-none transition-all" style={style}>
                        {content}
                        {showCross && (
                            <svg className="absolute inset-0 w-full h-full pointer-events-none" viewBox="0 0 16 16">
                                <line x1="2" y1="2" x2="14" y2="14" stroke="#ef4444" strokeWidth="2" strokeLinecap="round"/>
                                <line x1="14" y1="2" x2="2" y2="14" stroke="#ef4444" strokeWidth="2" strokeLinecap="round"/>
                            </svg>
                        )}
                    </div>
                );
            })}
        </div>
    );
};

// --- APP ---
const { useState, useMemo, useEffect, useRef, useCallback } = React;

const loadSavedState = () => {
    try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (!saved) return null;
        const data = JSON.parse(saved);
        // Check expiry
        const now = Date.now();
        const expiryMs = STORAGE_EXPIRY_DAYS * 24 * 60 * 60 * 1000;
        if (data.timestamp && (now - data.timestamp) > expiryMs) {
            localStorage.removeItem(STORAGE_KEY);
            return null;
        }
        return data;
    } catch (e) {
        return null;
    }
};

const getInitialState = () => {
    const saved = loadSavedState();
    const defaultCustom = PRESETS[CPU_CUSTOM];
    if (saved) {
        const presetKey = saved.preset || CPU_MODERN;
        const defaultPreset = PRESETS[presetKey] || PRESETS[CPU_MODERN];
        // Load saved custom config (always preserved separately)
        const savedCustomConfig = saved.customConfig ? {
            ...defaultCustom,
            costs: { ...defaultCustom.costs, ...saved.customConfig.costs },
            enables: { ...defaultCustom.enables, ...saved.customConfig.enables }
        } : defaultCustom;
        // For custom preset use saved custom config; for others use preset values
        const activeConfig = presetKey === CPU_CUSTOM ? savedCustomConfig : defaultPreset;
        return {
            bitWidth: saved.bitWidth || DEFAULT_BIT_WIDTH,
            mapping: saved.mapping || Array(saved.bitWidth || DEFAULT_BIT_WIDTH).fill(null).map((_, i) => ({ type: TYPE_SRC, val: i, inv: false })),
            preset: presetKey,
            config: activeConfig,
            customConfig: savedCustomConfig,
            baseCapabilities: defaultPreset.enables,
            showHelp: false  // Don't show help if we have saved state
        };
    }
    return {
        bitWidth: DEFAULT_BIT_WIDTH,
        mapping: Array(DEFAULT_BIT_WIDTH).fill(null).map((_, i) => ({ type: TYPE_SRC, val: i, inv: false })),
        preset: CPU_MODERN,
        config: PRESETS[CPU_MODERN],
        customConfig: defaultCustom,
        baseCapabilities: PRESETS[CPU_MODERN].enables,
        showHelp: true
    };
};

const initialState = getInitialState();

const BitPermutationApp = () => {
  const [bitWidth, setBitWidth] = useState(initialState.bitWidth);
  const [mapping, setMapping] = useState(initialState.mapping);
  const [activeTool, setActiveTool] = useState(TOOL_BRUSH);
  const [selectedSource, setSelectedSource] = useState(null);
  const [invertBrush, setInvertBrush] = useState(false);
  const [copied, setCopied] = useState(false);
  const [expandedStrategies, setExpandedStrategies] = useState({});
  const [showHelp, setShowHelp] = useState(initialState.showHelp);
  const [showConfig, setShowConfig] = useState(false);
  const [preset, setPreset] = useState(initialState.preset);
  const [config, setConfig] = useState(initialState.config);
  const [baseCapabilities, setBaseCapabilities] = useState(initialState.baseCapabilities);
  const [customConfig, setCustomConfig] = useState(initialState.customConfig);

  // Save state to localStorage
  useEffect(() => {
    const saveState = () => {
        try {
            const data = {
                timestamp: Date.now(),
                bitWidth,
                mapping,
                preset,
                config,
                baseCapabilities,
                customConfig
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        } catch (e) {
            // Ignore storage errors
        }
    };
    saveState();
  }, [bitWidth, mapping, preset, config, baseCapabilities, customConfig]);

  const containerRef = useRef(null);
  const [lines, setLines] = useState([]);

  // Calculate connection lines
  useEffect(() => {
    const updateLines = () => {
      if (!containerRef.current) return;
      const container = containerRef.current;
      const containerRect = container.getBoundingClientRect();
      const newLines = [];

      mapping.forEach((m, destIdx) => {
        if (m.type !== TYPE_SRC) return;
        const srcEl = document.getElementById(`src-btn-${m.val}`);
        const destEl = document.getElementById(`dest-btn-${destIdx}`);
        if (!srcEl || !destEl) return;

        const srcRect = srcEl.getBoundingClientRect();
        const destRect = destEl.getBoundingClientRect();

        const x1 = srcRect.left + srcRect.width / 2 - containerRect.left;
        const y1 = srcRect.bottom - containerRect.top;
        const x2 = destRect.left + destRect.width / 2 - containerRect.left;
        const y2 = destRect.top - containerRect.top;

        const hue = Math.floor((m.val * HUE_DIVISOR) / bitWidth);
        newLines.push({
          id: `${m.val}-${destIdx}`,
          x1, y1, x2, y2,
          src: m.val,
          color: `hsl(${hue}, 70%, 50%)`,
          dashed: m.inv
        });
      });

      setLines(newLines);
    };

    // Delay initial calculation to ensure DOM is fully laid out
    const frameId = requestAnimationFrame(() => {
      requestAnimationFrame(updateLines);
    });
    window.addEventListener('resize', updateLines);
    return () => {
      cancelAnimationFrame(frameId);
      window.removeEventListener('resize', updateLines);
    };
  }, [mapping, bitWidth]);

  const toggleStrategy = (name) => {
    setExpandedStrategies(prev => ({ ...prev, [name]: !prev[name] }));
  };

  const copyToClipboard = (e, text) => {
    e.stopPropagation();
    navigator.clipboard.writeText(text);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  // --- ACTIONS ---
  const initializeMapping = (width) => {
    const newMap = Array(width).fill(null).map((_, i) => {
      if (i < mapping.length && mapping[i].type === TYPE_SRC && mapping[i].val < width) return mapping[i];
      return { type: TYPE_SRC, val: i, inv: false };
    });
    setMapping(newMap); setBitWidth(width); setSelectedSource(null); setActiveTool(TOOL_BRUSH); setExpandedStrategies({});
  };

  const handleSourceClick = (idx) => { setSelectedSource(idx); setActiveTool(TOOL_BRUSH); };

  const handleDestClick = (destIndex) => {
    const newMapping = [...mapping]; const current = newMapping[destIndex];
    if (activeTool === TOOL_BRUSH) {
        if (selectedSource !== null) {
            if (current.type === TYPE_SRC && current.val === selectedSource && current.inv === invertBrush) newMapping[destIndex] = { type: TYPE_EMPTY, val: BIT_ZERO, inv: false };
            else newMapping[destIndex] = { type: TYPE_SRC, val: selectedSource, inv: invertBrush };
        }
    }
    else if (activeTool === TOOL_SET0) {
        if (current.type === TYPE_CONST && current.val === BIT_ZERO) newMapping[destIndex] = { type: TYPE_EMPTY, val: BIT_ZERO, inv: false };
        else newMapping[destIndex] = { type: TYPE_CONST, val: BIT_ZERO, inv: false };
    }
    else if (activeTool === TOOL_SET1) {
        if (current.type === TYPE_CONST && current.val === BIT_ONE) newMapping[destIndex] = { type: TYPE_EMPTY, val: BIT_ZERO, inv: false };
        else newMapping[destIndex] = { type: TYPE_CONST, val: BIT_ONE, inv: false };
    }
    else if (activeTool === TOOL_ERASER) newMapping[destIndex] = { type: TYPE_EMPTY, val: BIT_ZERO, inv: false };
    setMapping(newMapping);
  };

  const handleBulkAction = (action) => {
      let newMapping = [...mapping];
      if (action === ACTION_FILL_EMPTY_1) newMapping = newMapping.map(m => m.type === TYPE_EMPTY ? { type: TYPE_CONST, val: BIT_ONE, inv: false } : m);
      else if (action === ACTION_CLEAR_1S) newMapping = newMapping.map(m => (m.type === TYPE_CONST && m.val === BIT_ONE) ? { type: TYPE_EMPTY, val: BIT_ZERO, inv: false } : m);
      else if (action === ACTION_FILL_EMPTY_0) newMapping = newMapping.map(m => m.type === TYPE_EMPTY ? { type: TYPE_CONST, val: BIT_ZERO, inv: false } : m);
      else if (action === ACTION_CLEAR_0S) newMapping = newMapping.map(m => (m.type === TYPE_CONST && m.val === BIT_ZERO) ? { type: TYPE_EMPTY, val: BIT_ZERO, inv: false } : m);
      else if (action === ACTION_CLEAR_ROUTED) newMapping = newMapping.map(m => m.type === TYPE_SRC ? { type: TYPE_EMPTY, val: BIT_ZERO, inv: false } : m);
      setMapping(newMapping);
  };

  const handleQuickAction = (type) => {
    let newMap = [...mapping];
    switch (type) {
      case PATTERN_IDENTITY: newMap = newMap.map((_, i) => ({ type: TYPE_SRC, val: i, inv: false })); break;
      case PATTERN_REVERSE: newMap = newMap.map((_, i) => ({ type: TYPE_SRC, val: bitWidth - 1 - i, inv: false })); break;
      case PATTERN_SWAP_HALVES: newMap = newMap.map((_, i) => ({ type: TYPE_SRC, val: (i < bitWidth/2 ? i + bitWidth/2 : i - bitWidth/2), inv: false })); break;
      case PATTERN_SET_ALL_0: newMap = newMap.map(() => ({ type: TYPE_CONST, val: BIT_ZERO, inv: false })); break;
      case PATTERN_CLEAR: newMap = newMap.map(() => ({ type: TYPE_EMPTY, val: BIT_ZERO, inv: false })); break;
    }
    setMapping(newMap);
  };

  const handlePresetChange = (newPreset) => {
      setPreset(newPreset);
      // For custom preset, restore saved custom config; for others use preset values
      const newConfig = newPreset === CPU_CUSTOM
          ? customConfig
          : JSON.parse(JSON.stringify(PRESETS[newPreset]));
      setConfig(newConfig);
      setBaseCapabilities({ ...PRESETS[newPreset].enables });
      if (!newConfig.allowedWidths.includes(bitWidth)) {
          const valid = newConfig.allowedWidths;
          initializeMapping(valid[valid.length - 1]);
      }
  };

  const handleConfigChange = (key, field, value) => {
      if (field === 'cost' && preset !== CPU_CUSTOM) handlePresetChange(CPU_CUSTOM);
      setConfig(prev => {
          const next = { ...prev, enables: { ...prev.enables }, costs: { ...prev.costs } };
          if (field === 'enabled') {
              // Only allow enabling if base capability supports it
              if (value && !baseCapabilities[key]) return prev;
              next.enables[key] = value;
          } else {
              next.costs[key] = parseInt(value) || 0;
          }
          // Also update customConfig when on custom preset
          if (preset === CPU_CUSTOM) setCustomConfig(next);
          return next;
      });
  };

  // --- SOLVER ---
  const solvePermutation = useMemo(() => {
    const solutions = [];
    const costs = config.costs;
    const enables = config.enables;
    const w = bitWidth;
    const wBig = BigInt(w);
    const fullMask = (1n << wBig) - 1n;

    let logicXor = 0n, logicOr = 0n, logicAnd = fullMask;

    // Build route map: routeMap[dest] = source bit index, or -1 if not routed
    const routeMap = mapping.map((m, destIdx) => {
      if (m.type === TYPE_CONST) {
        if (m.val === BIT_ONE) logicOr |= (1n << BigInt(destIdx));
        else logicAnd &= ~(1n << BigInt(destIdx));
        return -1;
      }
      if (m.type === TYPE_EMPTY) return -1;
      if (m.type === TYPE_SRC) {
        if (m.inv) logicXor |= (1n << BigInt(destIdx));
        return m.val;
      }
      return -1;
    });

    // Generate input/output comments for code
    const padNum = (n) => n.toString().padStart(2, '0');

    // Input comment: which source bits are used (from MSB to LSB)
    const usedSources = new Set();
    routeMap.forEach(src => { if (src !== -1) usedSources.add(src); });
    const inputParts = [];
    for (let i = w - 1; i >= 0; --i)
      inputParts.push(usedSources.has(i) ? padNum(i) : 'NC');
    const inputComment = `// Input:  |${inputParts.join('|')}|`;

    // Output comment: what each destination bit receives (from MSB to LSB)
    const outputParts = [];
    for (let i = w - 1; i >= 0; --i) {
      const m = mapping[i];
      if (m.type === TYPE_EMPTY) outputParts.push('NC');
      else if (m.type === TYPE_CONST) outputParts.push(m.val === BIT_ONE ? '=1' : '=0');
      else if (m.type === TYPE_SRC) outputParts.push(padNum(m.val));
      else outputParts.push('??');
    }
    const outputComment = `// Output: |${outputParts.join('|')}|`;

    // Calculate masks
    let routedMask = 0n;
    const maskBySource = {};
    routeMap.forEach((s, d) => {
      if (s !== -1) {
        routedMask |= (1n << BigInt(d));
        maskBySource[s] = (maskBySource[s] || 0n) | (1n << BigInt(d));
      }
    });

    let activeSourceBits = new Set();
    routeMap.forEach((s, d) => { if(s!==-1) activeSourceBits.add(s); });
    let allSourcesMask = 0n;
    activeSourceBits.forEach(s => allSourcesMask |= (1n << BigInt(s)));

    // Compute "safe collision" mask - positions where undefined state from collisions is OK
    // These are: don't care positions AND forced 0/1 positions (which get overwritten at the end)
    let safeCollisionMask = 0n;
    mapping.forEach((m, d) => {
        if (m.type === TYPE_EMPTY || m.type === TYPE_CONST) {
            safeCollisionMask |= (1n << BigInt(d));
        }
    });

    // --- GREEDY COMPOSITE SOLVER ---
    let remainingMask = routedMask;
    let alreadyPlacedMask = 0n;  // Track bits we've already placed
    let compositeParts = [];
    let compositeCycles = 0;
    let steps = [];
    let accumulatedState = new Array(w).fill(null);
    let loopCount = 0;

    while (remainingMask > 0n && loopCount < MAX_SOLVER_ITERATIONS) {
        let prevAccumulatedState = [...accumulatedState];
        ++loopCount;

        // Find best shift/rotate delta
        let bestDelta = { score: -Infinity, shift: 0, mask: 0n, count: 0 };
        if (enables.shift || enables.rotate) {
            for (let s = 0; s < w; ++s) {
                let currentMask = 0n;
                for (let d = 0; d < w; ++d) {
                    if (!((remainingMask >> BigInt(d)) & 1n)) continue;
                    const src = routeMap[d];
                    let delta = (d - src) % w;
                    if (delta < 0) delta += w;
                    if (delta === s) currentMask |= (1n << BigInt(d));
                }

                let count = 0;
                let t = currentMask;
                while(t > 0n) { if(t & 1n) ++count; t >>= 1n; }
                if (count === 0) continue;

                // Determine operation type and cost
                let allWrap = true, noneWrap = true;
                for(let d = 0; d < w; ++d) {
                    if ((currentMask >> BigInt(d)) & 1n) {
                        const src = routeMap[d];
                        if (src + s >= w) noneWrap = false;
                        else allWrap = false;
                    }
                }

                let cost = costs.basic;
                if (s > 0) {
                    if (noneWrap || allWrap) {
                        cost += enables.shift ? costs.shift : Infinity;
                    } else {
                        cost += enables.rotate ? costs.rotate : (enables.shift ? (costs.shift * 2 + costs.basic) : Infinity);
                    }
                }

                const score = count * 10 - cost;
                if (score > bestDelta.score) {
                    bestDelta = { score, count, shift: s, mask: currentMask, allWrap, noneWrap };
                }
            }
        }

        // Find best multiplication
        let bestMul = { score: -Infinity, shift: 0, mul: 0n, mask: 0n, count: 0 };
        if (w <= 64 && enables.mul) {
            // Helper: compute which positions are at risk from collisions and carry propagation
            // Collisions (multiple bits landing at same position) create undefined state due to addition
            // Carry from collisions propagates upward until it hits a position with no bits landing
            const computeCarryRisk = (landingCounts, maxPos) => {
                let carryRisk = new Set();
                let collisionPositions = new Set();
                for (let pos = 0; pos < maxPos; ++pos) {
                    if ((landingCounts[pos] || 0) > 1) {
                        collisionPositions.add(pos);
                        // Collision at pos: carry propagates upward
                        for (let p = pos + 1; p < maxPos; ++p) {
                            carryRisk.add(p);
                            // Carry stops when it hits a position with no bits landing
                            // (0 + carry = 1, no further carry)
                            if ((landingCounts[p] || 0) === 0) break;
                        }
                    }
                }
                return { carryRisk, collisionPositions };
            };

            // Right-shift then multiply: (x >> S) * M
            for (let S = 0; S < w; ++S) {
                let candidateK = new Map(); // k -> list of {d, s}

                for (let d = 0; d < w; ++d) {
                    if (!((remainingMask >> BigInt(d)) & 1n)) continue;
                    const s = routeMap[d];
                    const k = d - s + S;
                    if (k >= 0 && k < w && s >= S) {
                        if (!candidateK.has(k)) candidateK.set(k, []);
                        candidateK.get(k).push({d, s});
                    }
                }

                if (candidateK.size === 0) continue;

                let M = 0n;
                candidateK.forEach((list, k) => M |= (1n << BigInt(k)));

                // Compute landing counts for all positions
                // IMPORTANT: ALL input bits from S to w-1 enter the multiplication, not just allSourcesMask!
                // NC bits in the input register also participate and can cause collisions.
                const landingCounts = {};
                for (let srcBit = S; srcBit < w; ++srcBit) {
                    const basePos = srcBit - S;
                    for (const [mk, _] of candidateK) {
                        const landPos = basePos + mk;
                        if (landPos < w) {
                            landingCounts[landPos] = (landingCounts[landPos] || 0) + 1;
                        }
                    }
                }

                const { carryRisk, collisionPositions } = computeCarryRisk(landingCounts, w);

                // Valid targets: positions where exactly one bit lands and no carry affects it
                // Collisions at OTHER positions don't matter - they get masked out by post-mask
                let validTargetsMask = 0n;
                for (const [k, targets] of candidateK) {
                    for (const {d, s} of targets) {
                        if ((landingCounts[d] || 0) === 1 && !carryRisk.has(d)) {
                            validTargetsMask |= (1n << BigInt(d));
                        }
                    }
                }

                if (validTargetsMask > 0n) {
                    let count = 0;
                    let t = validTargetsMask;
                    while(t > 0n) { if(t & 1n) ++count; t >>= 1n; }

                    const cost = costs.mul + (S > 0 ? costs.shift : 0) + costs.basic;
                    const score = count * 10 - cost;

                    if (score > bestMul.score) {
                        bestMul = { score, count, type: OP_MUL_R, shift: S, mul: M, mask: validTargetsMask, cost };
                    }
                }
            }

            // Left-multiply then shift: (x * M) >> S
            for (let S = 0; S < w; ++S) {
                let candidateK = new Map();

                for (let d = 0; d < w; ++d) {
                    if (!((remainingMask >> BigInt(d)) & 1n)) continue;
                    const s = routeMap[d];
                    const k = d + S - s;
                    if (k >= 0 && k < w && s + k < 2 * w) {
                        if (!candidateK.has(k)) candidateK.set(k, []);
                        candidateK.get(k).push({d, s});
                    }
                }

                if (candidateK.size === 0) continue;

                let M = 0n;
                candidateK.forEach((list, k) => M |= (1n << BigInt(k)));

                // Compute landing counts for positions BEFORE the shift
                // IMPORTANT: ALL input bits 0 to w-1 enter the multiplication, not just allSourcesMask!
                // NC bits in the input register also participate and can cause collisions.
                const preLandingCounts = {};
                for (let srcBit = 0; srcBit < w; ++srcBit) {
                    for (const [mk, _] of candidateK) {
                        const preShiftPos = srcBit + mk;
                        if (preShiftPos < 2 * w) {
                            preLandingCounts[preShiftPos] = (preLandingCounts[preShiftPos] || 0) + 1;
                        }
                    }
                }

                // Compute carry risk in pre-shift space
                const { carryRisk: preCarryRisk, collisionPositions: preCollisionPositions } = computeCarryRisk(preLandingCounts, 2 * w);

                // Valid targets: positions where exactly one bit lands (in pre-shift space) and no carry affects it
                // Collisions at OTHER positions don't matter - they get masked out by post-mask
                let validTargetsMask = 0n;
                for (const [k, targets] of candidateK) {
                    for (const {d, s} of targets) {
                        const preShiftPos = s + k;
                        const postShiftPos = preShiftPos - S;
                        if (postShiftPos === d && postShiftPos >= 0 && postShiftPos < w) {
                            if ((preLandingCounts[preShiftPos] || 0) === 1 && !preCarryRisk.has(preShiftPos)) {
                                validTargetsMask |= (1n << BigInt(d));
                            }
                        }
                    }
                }

                if (validTargetsMask > 0n) {
                    let count = 0;
                    let t = validTargetsMask;
                    while(t > 0n) { if(t & 1n) ++count; t >>= 1n; }

                    const cost = costs.mul + (S > 0 ? costs.shift : 0) + costs.basic;
                    const score = count * 10 - cost;

                    if (score > bestMul.score) {
                        bestMul = { score, count, type: OP_MUL_L, shift: S, mul: M, mask: validTargetsMask, cost };
                    }
                }
            }
        }

        // Find best BMI2 operation (PEXT/PDEP)
        let bestBmi = { score: -Infinity, mask: 0n, srcMask: 0n, count: 0, cost: 0 };
        if (enables.bmi && costs.bmi < 999) {
            // Check if remaining bits can use PEXT/PDEP (no duplicate sources)
            const srcCounts = {};
            let canUseBmi = true;
            let srcMask = 0n;
            let destMask = 0n;

            for (let d = 0; d < w; ++d) {
                if (!((remainingMask >> BigInt(d)) & 1n)) continue;
                const src = routeMap[d];
                if (src === -1) continue;

                srcCounts[src] = (srcCounts[src] || 0) + 1;
                if (srcCounts[src] > 1) {
                    canUseBmi = false;
                    break;
                }
                srcMask |= (1n << BigInt(src));
                destMask |= (1n << BigInt(d));
            }

            if (canUseBmi && destMask !== 0n) {
                let count = 0;
                let t = destMask;
                while (t > 0n) { if (t & 1n) ++count; t >>= 1n; }
                const cost = costs.bmi * 2; // PEXT + PDEP
                const score = count * 10 - cost;
                bestBmi = { score, count, mask: destMask, srcMask, cost };
            }
        }

        // Find best PSHUFB operation
        let bestPshufb = { score: -Infinity, mask: 0n, count: 0, cost: 0 };
        if (enables.pshufb && costs.pshufb < 999 && w >= 64 && (w % 8 === 0)) {
            const byteWidth = w / 8;
            let validBytes = 0n;
            let totalBits = 0;

            for (let byte = 0; byte < byteWidth; ++byte) {
                const destStart = byte * 8;
                let srcByte = -1;
                let byteValid = true;

                for (let bit = 0; bit < 8; ++bit) {
                    const d = destStart + bit;
                    if (!((remainingMask >> BigInt(d)) & 1n)) continue;

                    const m = mapping[d];
                    if (!m || m.type !== TYPE_SRC || m.inv) { byteValid = false; break; }

                    const expectedSrcByte = Math.floor(m.val / 8);
                    const expectedBitInByte = m.val % 8;

                    if (expectedBitInByte !== bit) { byteValid = false; break; }
                    if (srcByte === -1) srcByte = expectedSrcByte;
                    else if (srcByte !== expectedSrcByte) { byteValid = false; break; }
                }

                if (byteValid && srcByte !== -1) {
                    for (let bit = 0; bit < 8; ++bit) {
                        const d = destStart + bit;
                        if ((remainingMask >> BigInt(d)) & 1n) {
                            validBytes |= (1n << BigInt(d));
                            ++totalBits;
                        }
                    }
                }
            }

            if (validBytes !== 0n) {
                const cost = costs.pshufb;
                const score = totalBits * 10 - cost;
                bestPshufb = { score, count: totalBits, mask: validBytes, cost };
            }
        }

        // Choose best operation
        let chosen = null;
        const candidates = [
            { op: bestBmi.count > 0 ? { type: 'bmi', ...bestBmi } : null, score: bestBmi.score },
            { op: bestPshufb.count > 0 ? { type: 'pshufb', ...bestPshufb } : null, score: bestPshufb.score },
            { op: bestMul.count > 0 ? { ...bestMul } : null, score: bestMul.score },
            { op: bestDelta.count > 0 ? { type: OP_DELTA, ...bestDelta } : null, score: bestDelta.score }
        ].filter(c => c.op !== null);

        if (candidates.length === 0) break;
        chosen = candidates.reduce((best, c) => c.score > best.score ? c : best).op;

        // Generate code for chosen operation
        let blockCode = "";
        let desc = "";
        let sideEffects = new Array(w).fill(null);

        // Compute source mask - the input bit positions we need for this operation
        let sourceMask = 0n;
        for (let d = 0; d < w; ++d) {
            if ((chosen.mask >> BigInt(d)) & 1n) {
                const src = routeMap[d];
                sourceMask |= (1n << BigInt(src));
            }
        }
        const hexSourceMask = formatHex(sourceMask, w);
        const hexTargetMask = formatHex(chosen.mask, w);

        // Update accumulated state
        for(let d = 0; d < w; ++d) {
            if ((chosen.mask >> BigInt(d)) & 1n) {
                accumulatedState[d] = { type: TYPE_SRC, val: routeMap[d] };
            }
        }

        // Check if mask is needed
        // We need a mask if the raw operation result would hit:
        // 1. Other bits we still need to route (otherRouted)
        // 2. Bits we've already placed (alreadyPlacedMask)
        const otherRouted = remainingMask & ~chosen.mask;
        const protectedBits = otherRouted | alreadyPlacedMask;
        let needsMask = true;

        if (chosen.type === OP_DELTA) {
            const s = chosen.shift;
            let allWrap = chosen.allWrap;
            let noneWrap = chosen.noneWrap;

            // Compute where ALL input bits would land (not just allSourcesMask!)
            // The input register x contains ALL bits, including unused ones.
            // We need to check if ANY input bit (used or not) would land on protected positions.
            let rawRes = 0n;
            for (let srcBit = 0; srcBit < w; ++srcBit) {
                // Calculate destination under the actual operation type
                let destPos;
                if (noneWrap) {
                    destPos = srcBit + s;
                    if (destPos >= w) continue; // Shifted out
                } else if (allWrap) {
                    destPos = srcBit - (w - s);
                    if (destPos < 0) continue; // Shifted out
                } else {
                    destPos = (srcBit + s) % w; // Rotate
                }
                rawRes |= (1n << BigInt(destPos));
            }
            // Only skip mask if raw result doesn't hit any protected bits
            if ((rawRes & protectedBits) === 0n) needsMask = false;

            if (s === 0) {
                blockCode = needsMask ? `(x & ${hexSourceMask})` : `x`;
                desc = `Pass through ${chosen.count} bits.`;
                compositeCycles += costs.basic;
            } else {
                if (noneWrap) {
                    const core = needsMask ? `(x & ${hexSourceMask})` : `x`;
                    blockCode = `(${core} << ${s})`;
                    desc = `Left shift by ${s}.`;
                    compositeCycles += costs.shift;
                } else if (allWrap) {
                    const core = needsMask ? `(x & ${hexSourceMask})` : `x`;
                    blockCode = `(${core} >> ${w - s})`;
                    desc = `Right shift by ${w - s}.`;
                    compositeCycles += costs.shift;
                } else {
                    const core = needsMask ? `(x & ${hexSourceMask})` : `x`;
                    blockCode = formatRol(core, s, w);
                    desc = `Rotate left by ${s}.`;
                    compositeCycles += enables.rotate ? costs.rotate : (costs.shift * 2 + costs.basic);
                }
                if (needsMask) compositeCycles += costs.basic;
            }
        } else if (chosen.type === 'bmi') {
            // BMI2 PEXT/PDEP
            const hexSrcMask = formatHex(chosen.srcMask, w);
            blockCode = `pdep(pext(x, ${hexSrcMask}), ${hexTargetMask})`;
            desc = `PEXT/PDEP. Routes ${chosen.count} bits.`;
            needsMask = false; // PDEP places bits exactly
            compositeCycles += chosen.cost;
        } else if (chosen.type === 'pshufb') {
            // PSHUFB byte shuffle
            const byteWidth = w / 8;
            let shuffleMask = [];
            for (let byte = 0; byte < byteWidth; ++byte) {
                const destStart = byte * 8;
                if ((chosen.mask >> BigInt(destStart)) & 1n) {
                    const m = mapping[destStart];
                    if (m && m.type === TYPE_SRC) {
                        shuffleMask.push(Math.floor(m.val / 8));
                    } else {
                        shuffleMask.push(0x80);
                    }
                } else {
                    shuffleMask.push(0x80);
                }
            }
            const shuffleHex = shuffleMask.map(b => b.toString(16).padStart(2, '0')).join('');
            blockCode = `pshufb(x, 0x${shuffleHex})`;
            desc = `PSHUFB. Routes ${chosen.count} bits (${chosen.count / 8} bytes).`;
            needsMask = false; // PSHUFB places bytes exactly
            compositeCycles += chosen.cost;
        } else {
            // Multiplication (OP_MUL_L or OP_MUL_R)
            const hexM = formatHex(chosen.mul, w);
            let core;

            if (chosen.type === OP_MUL_R) {
                if (chosen.shift === 0) {
                    core = `(x * ${hexM})`;
                } else {
                    core = `((x >> ${chosen.shift}) * ${hexM})`;
                }
            } else {
                if (chosen.shift === 0) {
                    core = `(x * ${hexM})`;
                } else {
                    core = `((x * ${hexM}) >> ${chosen.shift})`;
                }
            }

            // Check if masking is needed
            // IMPORTANT: ALL input bits enter multiplication, not just allSourcesMask!
            let rawRes = 0n;
            if (chosen.type === OP_MUL_R) {
                // Bits from shift to w-1 enter: (fullMask >> shift) gives us those bits
                rawRes = ((fullMask >> BigInt(chosen.shift)) * chosen.mul) & fullMask;
            } else {
                // All bits 0 to w-1 enter
                rawRes = ((fullMask * chosen.mul) >> BigInt(chosen.shift)) & fullMask;
            }
            // Only skip mask if raw result doesn't hit any protected bits
            if ((rawRes & protectedBits) === 0n) needsMask = false;

            blockCode = needsMask ? `(${core} & ${hexTargetMask})` : core;
            compositeCycles += chosen.cost;
            desc = `Multiply ${chosen.type === OP_MUL_R ? '(right)' : '(left)'}. Routes ${chosen.count} bits.`;
        }

        // Calculate side effects and masked-out bits based on the operation's mental model:
        // 1. Prefiltering: determines which input bits enter the operation
        // 2. Operation: moves bits to new positions
        // 3. Postfiltering: determines which output bits are kept
        let maskedOut = new Array(w).fill(null);

        if (chosen.type === OP_DELTA) {
            // For shifts/rotates: visualize bits going through the operation
            // If needsMask: only sourceMask bits enter (pre-masked input)
            // If !needsMask: all input bits (0 to w-1) could enter
            const s = chosen.shift;
            const bitsEntering = needsMask ? sourceMask : fullMask;

            for (let srcBit = 0; srcBit < w; ++srcBit) {
                if (!((bitsEntering >> BigInt(srcBit)) & 1n)) continue;
                let destPos;
                if (chosen.noneWrap) {
                    destPos = srcBit + s;
                    if (destPos >= w) continue; // Shifted out
                } else if (chosen.allWrap) {
                    destPos = srcBit - (w - s);
                    if (destPos < 0) continue; // Shifted out
                } else {
                    destPos = (srcBit + s) % w; // Rotate
                }
                // If not in our intended targets and not already solved
                if (!((chosen.mask >> BigInt(destPos)) & 1n) && !accumulatedState[destPos]) {
                    // When pre-masked, nothing extra lands here (sourceMask is exact)
                    // When not masked, other input bits are side effects
                    if (!needsMask) {
                        sideEffects[destPos] = { type: TYPE_SRC, val: srcBit };
                    }
                }
            }
        } else if (chosen.type === 'bmi' || chosen.type === 'pshufb') {
            // BMI2 and PSHUFB place bits exactly where specified - no side effects
            // Nothing to do here
        } else {
            // For multiplication: mask is POST-operation
            // ALL input bits enter the multiply (not just allSourcesMask!)
            // For mul_r: bits from shift to w-1 (lower bits shifted out)
            // For mul_l: all bits 0 to w-1
            // Track landing counts to detect collisions
            const landingCounts = {};
            const landingSources = {};
            const startBit = (chosen.type === OP_MUL_R) ? chosen.shift : BIT_ZERO;

            for (let srcBit = startBit; srcBit < w; ++srcBit) {
                // Each set bit in multiplier spreads the source bit
                for (let k = 0; k < w; ++k) {
                    if (!((chosen.mul >> BigInt(k)) & 1n)) continue;
                    let destPos;
                    if (chosen.type === OP_MUL_R) {
                        destPos = srcBit - chosen.shift + k;
                    } else {
                        destPos = srcBit + k - chosen.shift;
                    }
                    if (destPos < 0 || destPos >= w) continue;

                    landingCounts[destPos] = (landingCounts[destPos] || 0) + 1;
                    if (!landingSources[destPos]) landingSources[destPos] = [];
                    landingSources[destPos].push(srcBit);
                }
            }

            // Classify each landing position
            for (const [destPos, count] of Object.entries(landingCounts)) {
                const d = parseInt(destPos);
                const sources = landingSources[d];
                const inMask = (chosen.mask >> BigInt(d)) & 1n;
                const alreadySolved = accumulatedState[d];

                if (count > 1) {
                    // Collision: multiple bits land here - undefined state
                    // Show as collision (will be masked out or in safe position)
                    if (!inMask && !alreadySolved) {
                        if (needsMask) {
                            maskedOut[d] = { type: TYPE_COLLISION, sources: sources };
                        } else {
                            sideEffects[d] = { type: TYPE_COLLISION, sources: sources };
                        }
                    }
                } else if (!inMask && !alreadySolved) {
                    // Single bit landing, not our target
                    if (needsMask) {
                        maskedOut[d] = { type: TYPE_SRC, val: sources[0] };
                    } else {
                        sideEffects[d] = { type: TYPE_SRC, val: sources[0] };
                    }
                }
            }
        }

        compositeParts.push(`temp |= ${blockCode};`);
        steps.push({
            name: `Block ${compositeParts.length}`,
            desc: desc,
            code: `temp |= ${blockCode};`,
            state: [...accumulatedState],
            prevState: [...prevAccumulatedState],
            sideEffects: sideEffects,
            maskedOut: maskedOut
        });
        remainingMask &= ~chosen.mask;
        alreadyPlacedMask |= chosen.mask;  // Track that these bits are now placed
    }

    // Generate final code
    let compositeCode = "";
    if (compositeParts.length > 0) {
        compositeCode = `${inputComment}\nuint${w}_t temp = 0;\n` + compositeParts.join("\n") + "\n";
        let resExpr = "temp";
        let logicCycles = 0;
        let prevAccumulatedState = [...accumulatedState];

        // Handle forced 0s
        let forceClearMask = 0n;
        mapping.forEach((m, i) => { if (m.type === TYPE_CONST && m.val === BIT_ZERO) forceClearMask |= (1n << BigInt(i)); });
        if (forceClearMask > 0n) {
            const m = fullMask ^ forceClearMask;
            resExpr = `(${resExpr} & ${formatHex(m, w)})`;
            logicCycles += costs.basic;
            steps.push({
                name: "Logic: Force 0s",
                desc: "Clear bits.",
                code: `result &= ${formatHex(m, w)};`,
                state: [...accumulatedState],
                prevState: prevAccumulatedState
            });
        }

        // Handle forced 1s
        let forceSetMask = 0n;
        mapping.forEach((m, i) => { if (m.type === TYPE_CONST && m.val === BIT_ONE) forceSetMask |= (1n << BigInt(i)); });
        if (forceSetMask > 0n) {
            resExpr = `(${resExpr} | ${formatHex(forceSetMask, w)})`;
            logicCycles += costs.basic;
            const nextState = [...accumulatedState];
            for(let d = 0; d < w; ++d) {
                if((forceSetMask >> BigInt(d)) & 1n) nextState[d] = { type: TYPE_CONST, val: BIT_ONE };
            }
            steps.push({
                name: "Logic: Force 1s",
                desc: "Set bits.",
                code: `result |= ${formatHex(forceSetMask, w)};`,
                state: nextState,
                prevState: prevAccumulatedState
            });
            accumulatedState = nextState;
        }

        // Handle inversions
        if (logicXor > 0n) {
            resExpr = `(${resExpr} ^ ${formatHex(logicXor, w)})`;
            logicCycles += costs.basic;
            steps.push({
                name: "Logic: Invert",
                desc: "Invert bits.",
                code: `result ^= ${formatHex(logicXor, w)};`,
                state: [...accumulatedState],
                prevState: accumulatedState
            });
        }

        compositeCode += `${outputComment}\nreturn ${resExpr};`;
        compositeCycles += logicCycles;
    } else {
        let resExpr = "0";
        if (logicOr > 0n) resExpr = formatHex(logicOr, w);
        compositeCode = `${inputComment}\n${outputComment}\nreturn ${resExpr};`;
    }

    solutions.push({
        name: "Composite (Greedy)",
        desc: "Optimized using shifts, rotates, and multiplications.",
        cycles: compositeCycles,
        code: compositeCode,
        steps: steps
    });

    // --- EXHAUSTIVE COMPOSITE SOLVER ---
    // Try to find an optimal solution using tree search
    // Only shown if it completes within limits (like LUT or PEXT)
    const exhaustiveResult = solveExhaustive(routeMap, routedMask, w, costs, enables, mapping);
    if (exhaustiveResult && exhaustiveResult.steps.length > 0) {
        // Generate code from exhaustive steps
        let exhParts = [];
        let exhCycles = 0;
        let exhSteps = [];
        let exhAccumulatedState = new Array(w).fill(null);
        let exhAlreadyPlacedMask = 0n;

        for (const op of exhaustiveResult.steps) {
            const prevState = [...exhAccumulatedState];

            // Compute source mask for this operation
            let sourceMask = 0n;
            for (let d = 0; d < w; ++d) {
                if ((op.mask >> BigInt(d)) & 1n) {
                    const src = routeMap[d];
                    sourceMask |= (1n << BigInt(src));
                }
            }
            const hexSourceMask = formatHex(sourceMask, w);
            const hexTargetMask = formatHex(op.mask, w);

            // Update accumulated state
            for (let d = 0; d < w; ++d) {
                if ((op.mask >> BigInt(d)) & 1n) {
                    exhAccumulatedState[d] = { type: TYPE_SRC, val: routeMap[d] };
                }
            }

            // Check if mask is needed (same logic as greedy)
            const exhRemainingMask = routedMask & ~exhAlreadyPlacedMask & ~op.mask;
            const protectedBits = exhRemainingMask | exhAlreadyPlacedMask;
            let needsMask = true;

            let blockCode = "";
            let desc = "";

            if (op.type === OP_DELTA) {
                const s = op.shift;
                let rawRes = 0n;
                for (let srcBit = 0; srcBit < w; ++srcBit) {
                    let destPos;
                    if (op.noneWrap) {
                        destPos = srcBit + s;
                        if (destPos >= w) continue;
                    } else if (op.allWrap) {
                        destPos = srcBit - (w - s);
                        if (destPos < 0) continue;
                    } else {
                        destPos = (srcBit + s) % w;
                    }
                    rawRes |= (1n << BigInt(destPos));
                }
                if ((rawRes & protectedBits) === 0n) needsMask = false;

                if (s === 0) {
                    blockCode = needsMask ? `(x & ${hexSourceMask})` : `x`;
                    desc = `Pass through ${op.count} bits.`;
                } else {
                    if (op.noneWrap) {
                        const core = needsMask ? `(x & ${hexSourceMask})` : `x`;
                        blockCode = `(${core} << ${s})`;
                        desc = `Left shift by ${s}.`;
                    } else if (op.allWrap) {
                        const core = needsMask ? `(x & ${hexSourceMask})` : `x`;
                        blockCode = `(${core} >> ${w - s})`;
                        desc = `Right shift by ${w - s}.`;
                    } else {
                        const core = needsMask ? `(x & ${hexSourceMask})` : `x`;
                        blockCode = formatRol(core, s, w);
                        desc = `Rotate left by ${s}.`;
                    }
                }
            } else if (op.type === 'bmi') {
                // BMI2 PEXT/PDEP
                const hexSrcMask = formatHex(op.srcMask, w);
                blockCode = `pdep(pext(x, ${hexSrcMask}), ${hexTargetMask})`;
                desc = `PEXT/PDEP. Routes ${op.count} bits.`;
                needsMask = false; // PDEP already places bits exactly where needed
            } else if (op.type === 'pshufb') {
                // PSHUFB byte shuffle
                const byteWidth = w / 8;
                let shuffleMask = [];
                for (let byte = 0; byte < byteWidth; ++byte) {
                    const destStart = byte * 8;
                    if ((op.mask >> BigInt(destStart)) & 1n) {
                        const m = mapping[destStart];
                        if (m && m.type === TYPE_SRC) {
                            shuffleMask.push(Math.floor(m.val / 8));
                        } else {
                            shuffleMask.push(0x80); // Zero byte
                        }
                    } else {
                        shuffleMask.push(0x80); // Zero byte for non-routed positions
                    }
                }
                const shuffleHex = shuffleMask.map(b => b.toString(16).padStart(2, '0')).join('');
                blockCode = `pshufb(x, 0x${shuffleHex})`;
                desc = `PSHUFB. Routes ${op.count} bits (${op.count / 8} bytes).`;
                needsMask = false; // PSHUFB places bytes exactly
            } else {
                // Multiplication (OP_MUL_L or OP_MUL_R)
                const hexM = formatHex(op.mul, w);
                let core;

                if (op.type === OP_MUL_R) {
                    core = op.shift === 0 ? `(x * ${hexM})` : `((x >> ${op.shift}) * ${hexM})`;
                } else {
                    core = op.shift === 0 ? `(x * ${hexM})` : `((x * ${hexM}) >> ${op.shift})`;
                }

                // Check if masking needed for multiplication
                const fullMaskLocal = (1n << BigInt(w)) - 1n;
                let rawRes;
                if (op.type === OP_MUL_R) {
                    rawRes = ((fullMaskLocal >> BigInt(op.shift)) * op.mul) & fullMaskLocal;
                } else {
                    rawRes = ((fullMaskLocal * op.mul) >> BigInt(op.shift)) & fullMaskLocal;
                }
                if ((rawRes & protectedBits) === 0n) needsMask = false;

                blockCode = needsMask ? `(${core} & ${hexTargetMask})` : core;
                desc = `Multiply ${op.type === OP_MUL_R ? '(right)' : '(left)'}. Routes ${op.count} bits.`;
            }

            exhParts.push(`temp |= ${blockCode};`);
            exhSteps.push({
                name: `Block ${exhParts.length}`,
                desc: desc,
                code: `temp |= ${blockCode};`,
                state: [...exhAccumulatedState],
                prevState: prevState
            });

            exhAlreadyPlacedMask |= op.mask;
            exhCycles += op.cost;
        }

        // Generate final code with logic operations
        let exhCode = "";
        if (exhParts.length > 0) {
            exhCode = `${inputComment}\nuint${w}_t temp = 0;\n` + exhParts.join("\n") + "\n";
            let resExpr = "temp";
            let logicCyclesExh = 0;

            // Handle forced 0s
            let forceClearMask = 0n;
            mapping.forEach((m, i) => { if (m.type === TYPE_CONST && m.val === BIT_ZERO) forceClearMask |= (1n << BigInt(i)); });
            if (forceClearMask > 0n) {
                const m = fullMask ^ forceClearMask;
                resExpr = `(${resExpr} & ${formatHex(m, w)})`;
                logicCyclesExh += costs.basic;
            }

            // Handle forced 1s
            let forceSetMask = 0n;
            mapping.forEach((m, i) => { if (m.type === TYPE_CONST && m.val === BIT_ONE) forceSetMask |= (1n << BigInt(i)); });
            if (forceSetMask > 0n) {
                resExpr = `(${resExpr} | ${formatHex(forceSetMask, w)})`;
                logicCyclesExh += costs.basic;
            }

            // Handle inversions
            if (logicXor > 0n) {
                resExpr = `(${resExpr} ^ ${formatHex(logicXor, w)})`;
                logicCyclesExh += costs.basic;
            }

            exhCode += `${outputComment}\nreturn ${resExpr};`;
            exhCycles += logicCyclesExh;
        }

        // Only add if different from greedy (shows value of exhaustive search)
        // or if it has lower cost
        if (exhCycles <= compositeCycles) {
            solutions.push({
                name: "Composite (Dijkstra)",
                desc: `Optimal tree-search (${exhaustiveResult.statesExplored} states explored).`,
                cycles: exhCycles,
                code: exhCode,
                steps: exhSteps
            });
        }
    }

    // --- BMI2 PEXT/PDEP SOLUTION ---
    if (enables.bmi && routedMask > 0n) {
        // Build extraction mask (which source bits are used)
        let srcMask = 0n;
        const srcBits = [];
        routeMap.forEach((src, dest) => {
            if (src !== -1) {
                srcMask |= (1n << BigInt(src));
                srcBits.push({ src, dest });
            }
        });

        // Check if PEXT/PDEP can handle this (no duplicate sources)
        const srcCounts = {};
        let canUseBmi = true;
        srcBits.forEach(({src}) => {
            srcCounts[src] = (srcCounts[src] || 0) + 1;
            if (srcCounts[src] > 1) canUseBmi = false;
        });

        if (canUseBmi) {
            // Sort by source position to get correct PEXT order
            srcBits.sort((a, b) => a.src - b.src);

            // Build PDEP mask
            let pdepMask = 0n;
            srcBits.forEach(({dest}) => pdepMask |= (1n << BigInt(dest)));

            const bmiCode = `${inputComment}\nuint${w}_t temp = pext(x, ${formatHex(srcMask, w)});\n${outputComment}\nreturn pdep(temp, ${formatHex(pdepMask, w)});`;
            solutions.push({
                name: "BMI2 (PEXT/PDEP)",
                desc: "Hardware scatter/gather.",
                cycles: costs.bmi * 2,
                code: bmiCode
            });
        }
    }

    // --- PSHUFB SOLUTION (for byte-aligned permutations) ---
    if (enables.pshufb && w >= 64 && (w % 8 === 0)) {
        // Check if all permutations are byte-aligned
        let byteAligned = true;
        const byteWidth = w / 8;
        const byteMap = new Array(byteWidth).fill(-1);

        for (let byte = 0; byte < byteWidth && byteAligned; ++byte) {
            const destStart = byte * 8;
            let srcByte = -1;
            let allSame = true;

            for (let bit = 0; bit < 8; ++bit) {
                const m = mapping[destStart + bit];
                if (m.type !== TYPE_SRC) { allSame = false; break; }
                if (m.inv) { allSame = false; break; }

                const expectedSrcByte = Math.floor(m.val / 8);
                const expectedBitInByte = m.val % 8;

                if (expectedBitInByte !== bit) { allSame = false; break; }
                if (srcByte === -1) srcByte = expectedSrcByte;
                else if (srcByte !== expectedSrcByte) { allSame = false; break; }
            }

            if (allSame && srcByte !== -1) {
                byteMap[byte] = srcByte;
            } else if (!allSame) {
                byteAligned = false;
            }
        }

        if (byteAligned && byteMap.some(b => b !== -1)) {
            const shuffleBytes = byteMap.map(b => b === -1 ? 0x80 : b);
            const shuffleHex = shuffleBytes.map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(', 0x');
            const pshufbCode = `${inputComment}\n// Shuffle control: { 0x${shuffleHex} }\n${outputComment}\nreturn pshufb(x, shuffle_mask);`;
            solutions.push({
                name: "PSHUFB (SSSE3)",
                desc: "Byte-level shuffle.",
                cycles: costs.pshufb,
                code: pshufbCode
            });
        }
    }

    // --- LUT SOLUTION ---
    // Max 256 entries (8-bit input)
    if (w <= 8) {
        const tableSize = 1 << w;
        const lutEntries = [];
        for (let x = 0; x < tableSize; ++x) {
            let result = 0;
            for (let d = 0; d < w; ++d) {
                const m = mapping[d];
                if (m.type === TYPE_SRC) {
                    let bit = (x >> m.val) & 1;
                    if (m.inv) bit ^= 1;
                    result |= (bit << d);
                } else if (m.type === TYPE_CONST) {
                    result |= (m.val << d);
                }
            }
            lutEntries.push(result);
        }
        const hexWidth = Math.ceil(w / 4);
        const entriesPerRow = w <= 4 ? 16 : 8;
        let tableStr = `const uint${w}_t lut[${tableSize}] = {\n`;
        for (let i = 0; i < tableSize; i += entriesPerRow) {
            const row = lutEntries.slice(i, i + entriesPerRow);
            tableStr += '    ' + row.map(v => '0x' + v.toString(16).toUpperCase().padStart(hexWidth, '0')).join(', ');
            if (i + entriesPerRow < tableSize) tableStr += ',';
            tableStr += '\n';
        }
        tableStr += '};';

        solutions.push({
            name: "LUT (Lookup Table)",
            desc: `Precomputed ${tableSize}-entry lookup table (addr calc + mem access).`,
            cycles: costs.lut,
            code: `${inputComment}\n${tableStr}\n\n${outputComment}\nreturn lut[x];`
        });
    }

    return solutions.sort((a, b) => a.cycles - b.cycles);
  }, [mapping, bitWidth, config]);

  // Auto-expand the best solution (first one after sorting by cycles)
  useEffect(() => {
    if (solvePermutation.length > 0) {
      const bestName = solvePermutation[0].name;
      setExpandedStrategies({ [bestName]: true });
    }
  }, [solvePermutation]);

  // --- RENDER ---
  return (
    <div className="min-h-screen bg-slate-950 text-slate-200 font-sans flex flex-col">
      {/* CONFIG MODAL */}
      {showConfig && (
        <div className="modal-overlay" onClick={(e) => { if(e.target === e.currentTarget) setShowConfig(false); }}>
            <div className="modal-content bg-slate-900 border border-slate-700 rounded-xl w-full max-w-lg p-6 shadow-2xl">
                <div className="flex justify-between items-center mb-6">
                    <h3 className="text-xl font-bold text-white flex items-center gap-2"><IconSettings className="w-6 h-6 text-slate-400"/> Solver Configuration</h3>
                    <button onClick={() => setShowConfig(false)} className="text-slate-500 hover:text-white"><IconX className="w-6 h-6"/></button>
                </div>
                <div className="space-y-6">
                    <div>
                        <label className="block text-xs font-bold text-slate-500 uppercase mb-2">Register Widths</label>
                        <div className="flex gap-2 flex-wrap">
                            {[8, 16, 32, 64, 128].map(size => (
                                <label key={size} className="flex items-center gap-2 bg-slate-950 px-3 py-2 rounded border border-slate-700">
                                    <input
                                        type="checkbox"
                                        checked={config.allowedWidths.includes(size)}
                                        onChange={(e) => {
                                            if (preset !== CPU_CUSTOM) handlePresetChange(CPU_CUSTOM);
                                            setConfig(prev => {
                                                const newWidths = e.target.checked
                                                    ? [...prev.allowedWidths, size].sort((a,b) => a-b)
                                                    : prev.allowedWidths.filter(w => w !== size);
                                                return { ...prev, allowedWidths: newWidths };
                                            });
                                        }}
                                        className="accent-cyan-500"
                                    />
                                    <span className="text-sm text-slate-300">{size}-bit</span>
                                </label>
                            ))}
                        </div>
                    </div>
                    <div>
                        <label className="block text-xs font-bold text-slate-500 uppercase mb-2">Building Blocks</label>
                        <div className="grid grid-cols-4 gap-2 text-[10px] uppercase font-bold text-slate-500 border-b border-slate-800 pb-1 mb-2">
                            <span>Operation</span><span>Enabled</span><span>Cost</span><span></span>
                        </div>
                        {getSettingsForPreset(preset).map((setting, idx) => {
                            const isSupported = setting.alwaysAvailable ||
                                (setting.enableKey ? baseCapabilities[setting.enableKey] : true);
                            const isPlatformSupported = !setting.platforms || setting.platforms.includes(preset);
                            const isAvailable = isSupported && isPlatformSupported;
                            const isToggleable = setting.enableKey !== null && !setting.alwaysAvailable;
                            const showSeparator = idx > 0 && (
                                (setting.alwaysAvailable && !getSettingsForPreset(preset)[idx-1].alwaysAvailable) ||
                                (setting.platforms && !getSettingsForPreset(preset)[idx-1].platforms)
                            );

                            return (
                                <div key={setting.id} className={`grid grid-cols-4 gap-2 items-center mb-2 ${!isAvailable ? 'opacity-40' : ''} ${showSeparator ? 'border-t border-slate-800 pt-2 mt-2' : ''}`}>
                                    <span
                                        className="text-sm font-mono text-slate-300 truncate"
                                        title={setting.description}
                                    >
                                        {setting.label}
                                    </span>
                                    {isToggleable ? (
                                        <input
                                            type="checkbox"
                                            checked={config.enables[setting.enableKey] ?? false}
                                            onChange={(e) => handleConfigChange(setting.enableKey, 'enabled', e.target.checked)}
                                            disabled={!isAvailable}
                                            className="accent-cyan-500 disabled:cursor-not-allowed"
                                            title={isAvailable ? `Toggle ${setting.label}` : 'Not supported by this CPU'}
                                        />
                                    ) : (
                                        <span className="text-xs text-slate-500 text-center">
                                            {setting.alwaysAvailable ? 'always' : '—'}
                                        </span>
                                    )}
                                    <input
                                        type="number"
                                        min="1"
                                        value={config.costs[setting.costKey] ?? 1}
                                        onChange={(e) => handleConfigChange(setting.costKey, 'cost', e.target.value)}
                                        disabled={preset !== CPU_CUSTOM}
                                        className="bg-slate-950 border border-slate-700 rounded px-2 py-1 text-xs text-white disabled:opacity-50"
                                        title={`Cycle cost for ${setting.label}`}
                                    />
                                    <span className="text-xs text-slate-600">
                                        {isAvailable ? 'cyc' : 'N/A'}
                                    </span>
                                </div>
                            );
                        })}
                    </div>
                </div>
                <div className="mt-6 flex justify-end"><button onClick={() => setShowConfig(false)} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-500 text-white text-sm font-bold rounded">Done</button></div>
            </div>
        </div>
      )}

      {/* HELP MODAL */}
      {showHelp && (
        <div className="modal-overlay" onClick={(e) => { if(e.target === e.currentTarget) setShowHelp(false); }}>
            <div className="modal-content bg-slate-900 border border-slate-700 rounded-xl max-w-2xl w-full p-6 shadow-2xl relative">
                <button onClick={() => setShowHelp(false)} className="absolute top-4 right-4 text-slate-500 hover:text-white"><IconX className="w-6 h-6"/></button>
                <div className="flex items-center gap-3 mb-4">
                    <div className="w-12 h-12 bg-gradient-to-br from-cyan-600 to-blue-700 rounded-lg shadow-lg flex items-center justify-center text-white"><IconBinary className="w-7 h-7"/></div>
                    <div><h2 className="text-2xl font-bold text-white">BitPerm Engine</h2><p className="text-sm text-cyan-400">Optimized Code Generator</p></div>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-slate-300">
                    <div className="bg-slate-950 p-3 rounded border border-slate-800">
                        <h3 className="font-bold text-white mb-2 flex items-center gap-2"><IconZap className="w-4 h-4 text-cyan-400"/> Routing</h3>
                        <ul className="list-disc list-inside space-y-1 text-slate-400 text-xs">
                            <li><strong>Brush:</strong> Click Source, then Target.</li>
                            <li><strong>Toggle:</strong> Click existing target to remove.</li>
                            <li><strong>Invert:</strong> Logic NOT on connection.</li>
                        </ul>
                    </div>
                    <div className="bg-slate-950 p-3 rounded border border-slate-800">
                        <h3 className="font-bold text-white mb-2 flex items-center gap-2"><IconPlusCircle className="w-4 h-4 text-emerald-400"/> Logic</h3>
                        <ul className="list-disc list-inside space-y-1 text-slate-400 text-xs">
                            <li><strong>Set 1/0:</strong> Force constants.</li>
                            <li><strong>Erase:</strong> Mark as "Don't Care" (Optimization).</li>
                            <li><strong>Bulk:</strong> Use toolbar buttons to fill/clear.</li>
                        </ul>
                    </div>
                    <div className="bg-slate-950 p-3 rounded border border-slate-800 md:col-span-2">
                        <h3 className="font-bold text-white mb-2 flex items-center gap-2"><IconSettings className="w-4 h-4 text-orange-400"/> CPU Presets</h3>
                        <p className="text-slate-400 text-xs">Select a target CPU from the dropdown to configure available instructions and their cycle costs. Click the gear icon for detailed settings.</p>
                    </div>
                </div>
                <button onClick={() => setShowHelp(false)} className="mt-6 w-full py-3 bg-cyan-600 hover:bg-cyan-500 text-white font-bold rounded-lg transition-all">Start Routing</button>
            </div>
        </div>
      )}

      {/* HEADER */}
      <header className="border-b border-slate-800 bg-slate-900/90 backdrop-blur-md sticky top-0 z-40">
        <div className="max-w-7xl mx-auto px-4 h-16 flex items-center justify-between">
          <div className="flex items-center gap-3 cursor-pointer group" onClick={() => setShowHelp(true)}>
             <div className="w-10 h-10 bg-gradient-to-br from-cyan-600 to-blue-700 rounded-lg shadow-lg shadow-cyan-900/20 flex items-center justify-center text-white group-hover:scale-105 transition-transform"><IconBinary className="w-6 h-6"/></div>
             <div>
                 <h1 className="text-xl font-bold tracking-tight text-white group-hover:text-cyan-400 transition-colors">Bit<span className="text-cyan-400 group-hover:text-white transition-colors">Perm</span></h1>
                 <span className="text-[10px] text-slate-500 flex items-center gap-1"><IconInfo className="w-3 h-3"/> Help</span>
             </div>
          </div>
          <div className="flex items-center gap-4">
              {/* CPU Preset Dropdown + Gear */}
              <div className="flex items-center gap-1">
                  <select
                      value={preset}
                      onChange={(e) => handlePresetChange(e.target.value)}
                      className="cpu-select border border-slate-700 text-slate-300 text-xs font-medium px-3 py-1.5 rounded-l focus:outline-none focus:border-cyan-500 cursor-pointer"
                  >
                      {Object.entries(PRESETS)
                          .sort((a, b) => a[1].name.localeCompare(b[1].name))
                          .map(([key, val]) => (
                          <option key={key} value={key}>{val.name}</option>
                      ))}
                  </select>
                  <button
                      onClick={() => setShowConfig(true)}
                      className="flex items-center justify-center px-2 py-1.5 bg-slate-800/50 hover:bg-slate-700 border border-l-0 border-slate-700 rounded-r text-slate-400 hover:text-white transition-all"
                      title="Configure instruction costs"
                  >
                      <IconSettings className="w-4 h-4"/>
                  </button>
              </div>
              <div className="w-px h-6 bg-slate-800"></div>
              <div className="flex bg-slate-800/50 p-1 rounded-lg">
                 {[8, 16, 32, 64, 128].map(size => {
                    const isDisabled = !config.allowedWidths.includes(size);
                    return (
                        <button
                            key={size}
                            onClick={() => initializeMapping(size)}
                            disabled={isDisabled}
                            className={`px-3 py-1 text-xs font-medium rounded transition-all ${
                                bitWidth === size ? 'bg-slate-600 text-white shadow-sm' :
                                isDisabled ? 'text-slate-700 cursor-not-allowed bg-slate-900/50' : 'text-slate-500 hover:text-slate-300'
                            }`}
                        >
                            {size}
                        </button>
                    );
                 })}
              </div>
          </div>
        </div>
      </header>

      <main className="flex-1 max-w-7xl mx-auto w-full p-4 lg:p-6 space-y-6">
         {/* Toolbar & Grids */}
         <div className="flex flex-col gap-2 p-3 bg-slate-900 rounded-xl border border-slate-800">
            <div className="flex flex-wrap gap-2 items-center">
                <div className="flex items-center gap-1 bg-slate-950 p-1 rounded-lg border border-slate-800">
                   <button onClick={() => setActiveTool(TOOL_BRUSH)} className={`tool-btn ${activeTool === TOOL_BRUSH ? 'bg-cyan-600 text-white' : 'text-slate-400 hover:bg-slate-800'}`}><IconZap className="w-4 h-4" /> Source</button>
                   <button onClick={() => setActiveTool(TOOL_SET1)} className={`tool-btn ${activeTool === TOOL_SET1 ? 'bg-emerald-600 text-white' : 'text-slate-400 hover:bg-slate-800'}`}><IconPlusCircle className="w-4 h-4" /> Set 1</button>
                   <button onClick={() => setActiveTool(TOOL_SET0)} className={`tool-btn ${activeTool === TOOL_SET0 ? 'bg-red-600 text-white' : 'text-slate-400 hover:bg-slate-800'}`}><IconMinusCircle className="w-4 h-4" /> Set 0</button>
                   <button onClick={() => setActiveTool(TOOL_ERASER)} className={`tool-btn ${activeTool === TOOL_ERASER ? 'bg-slate-700 text-slate-200' : 'text-slate-400 hover:bg-slate-800'}`}><IconTrash className="w-4 h-4" /> Erase</button>
                </div>
                <div className="w-px h-6 bg-slate-800 mx-2 hidden sm:block"></div>
                <div className="flex items-center gap-2">
                   <button onClick={() => handleQuickAction(PATTERN_IDENTITY)} className="p-2 text-slate-400 hover:bg-slate-800 rounded" title="Reset"><IconRotate className="w-4 h-4" /></button>
                   <button onClick={() => handleQuickAction(PATTERN_CLEAR)} className="p-2 text-red-400 hover:bg-red-900/20 rounded" title="Clear All"><IconTrash className="w-4 h-4" /></button>
                </div>
            </div>
            <div className="flex items-center gap-2 px-1 min-h-[30px]">
                {activeTool === TOOL_BRUSH && (
                    <>
                        <button onClick={() => setInvertBrush(!invertBrush)} className={`flex items-center gap-2 px-3 py-1 rounded text-xs font-medium border transition-all ${invertBrush ? 'bg-orange-900/30 border-orange-500 text-orange-400' : 'bg-slate-900 border-slate-700 text-slate-400'}`}><IconToggle className="w-3.5 h-3.5" /> Invert Mode</button>
                        <button onClick={() => handleBulkAction(ACTION_CLEAR_ROUTED)} className="flex items-center gap-1 px-3 py-1 rounded text-xs font-medium text-slate-400 border border-slate-700 hover:bg-slate-800 hover:text-white ml-auto transition-all"><IconTrash className="w-3.5 h-3.5" /> Clear Routing</button>
                    </>
                )}
                {activeTool === TOOL_SET1 && (
                    <div className="flex gap-2 w-full">
                        <button onClick={() => handleBulkAction(ACTION_FILL_EMPTY_1)} className="flex items-center gap-1 px-3 py-1 rounded text-xs font-medium bg-emerald-900/20 text-emerald-400 border border-emerald-800 hover:bg-emerald-900/40"><IconFill className="w-3.5 h-3.5" /> Fill Empty with 1s</button>
                        <button onClick={() => handleBulkAction(ACTION_CLEAR_1S)} className="flex items-center gap-1 px-3 py-1 rounded text-xs font-medium text-slate-400 border border-slate-700 hover:bg-slate-800 ml-auto">Clear all 1s</button>
                    </div>
                )}
                {activeTool === TOOL_SET0 && (
                    <div className="flex gap-2 w-full">
                        <button onClick={() => handleBulkAction(ACTION_FILL_EMPTY_0)} className="flex items-center gap-1 px-3 py-1 rounded text-xs font-medium bg-red-900/20 text-red-400 border border-red-800 hover:bg-red-900/40"><IconFill className="w-3.5 h-3.5" /> Fill Empty with 0s</button>
                        <button onClick={() => handleBulkAction(ACTION_CLEAR_0S)} className="flex items-center gap-1 px-3 py-1 rounded text-xs font-medium text-slate-400 border border-slate-700 hover:bg-slate-800 ml-auto">Clear all 0s</button>
                    </div>
                )}
            </div>
         </div>

         <div className="grid grid-cols-1 lg:grid-cols-12 gap-6 relative items-start">
            <div className="lg:col-span-8 relative min-h-[350px] flex flex-col gap-12 lg:sticky lg:top-20" ref={containerRef}>
               <svg className="absolute inset-0 pointer-events-none z-0 w-full h-full overflow-visible">
                 {lines.map((line) => (
                   <path key={line.id} d={`M ${line.x1} ${line.y1} C ${line.x1} ${line.y1 + 50}, ${line.x2} ${line.y2 - 50}, ${line.x2} ${line.y2}`} fill="none" stroke={line.color} strokeWidth={selectedSource === line.src ? "3" : "1.5"} strokeDasharray={line.dashed ? "5,5" : "none"} strokeOpacity={selectedSource === line.src ? "1" : "0.3"} />
                 ))}
               </svg>
               <div className="relative z-10 bg-slate-900/80 p-5 rounded-xl border border-slate-800 shadow-xl">
                  <div className="text-xs font-bold text-slate-500 uppercase tracking-widest mb-3">Input (Source)</div>
                  <div className="flex flex-wrap gap-1.5 justify-center sm:justify-start">
                     {Array(bitWidth).fill(null).map((_, i) => (
                        <div key={i} id={`src-btn-${i}`} onClick={() => handleSourceClick(i)} className={`relative w-8 h-10 flex items-center justify-center font-mono text-xs rounded cursor-pointer transition-all border ${selectedSource === i ? 'bg-cyan-500 text-black border-cyan-400 scale-110 shadow-lg z-20 font-bold' : 'bg-slate-800 text-slate-400 border-slate-700 hover:bg-slate-700 hover:text-white'}`} style={{ borderBottom: selectedSource !== i ? `2px solid hsl(${Math.floor((i * HUE_DIVISOR) / bitWidth)}, 70%, 50%)` : '' }}>{i}</div>
                     ))}
                  </div>
               </div>
               <div className="relative z-10 bg-slate-900/80 p-5 rounded-xl border border-slate-800 shadow-xl mt-auto">
                  <div className="text-xs font-bold text-slate-500 uppercase tracking-widest mb-3">Output (Target)</div>
                  <div className="flex flex-wrap gap-1.5 justify-center sm:justify-start">
                     {mapping.map((m, i) => {
                        let bg = "bg-slate-800"; let txt = "text-white"; let border = "border-slate-700"; let content = "";
                        if (m.type === TYPE_EMPTY) { bg = "bg-slate-800/20"; txt = "text-slate-700"; border = "border-slate-800 border-dashed opacity-40"; content="X"; }
                        else if (m.type === TYPE_CONST) {
                           content = m.val;
                           if (m.val === BIT_ONE) { bg = "bg-emerald-600"; txt = "text-white font-bold high-contrast-text"; border = "border-emerald-500 shadow-[0_0_15px_rgba(16,185,129,0.5)]"; }
                           else { bg = "bg-red-600"; txt = "text-white font-bold high-contrast-text"; border = "border-red-500 shadow-[0_0_15px_rgba(239,68,68,0.5)]"; }
                        } else if (m.type === TYPE_SRC) {
                           content = m.val;
                           const hue = Math.floor((m.val * HUE_DIVISOR) / bitWidth);
                           border = `border-[hsl(${hue},70%,50%)]`;
                           bg = `bg-[hsla(${hue},70%,50%,0.1)]`;
                           if (m.inv) {
                              border += " border-dashed";
                           }
                        }
                        return (
                           <div key={i} id={`dest-btn-${i}`} onClick={() => handleDestClick(i)} className={`relative w-8 h-10 flex items-center justify-center font-mono text-xs rounded cursor-pointer transition-all border ${bg} ${txt} ${border} hover:scale-105`}>
                              {m.type === TYPE_SRC && m.inv && <span className="absolute -top-2 right-0 text-[10px] text-orange-500 font-bold">~</span>}
                              <span className="text-[9px] opacity-70 absolute top-0.5 left-1">{i}</span>
                              <span className="mt-2 text-sm">{content}</span>
                           </div>
                        );
                     })}
                  </div>
               </div>
            </div>

            <div className="lg:col-span-4 flex flex-col gap-4">
               <h3 className="text-xs font-bold text-slate-500 uppercase tracking-widest lg:sticky lg:top-20 bg-slate-950 z-10 py-2 -my-2">Solutions</h3>
               <div className="space-y-3">
                  {solvePermutation.map((sol, idx) => {
                     const isExpanded = expandedStrategies[sol.name];
                     const isBest = idx === 0;
                     return (
                       <div key={idx} className={`bg-slate-950 border border-slate-800 rounded-lg transition-all overflow-hidden ${isExpanded ? '' : 'hover:border-cyan-500/30'}`}>
                          <div onClick={() => toggleStrategy(sol.name)} className="flex justify-between items-center p-3 cursor-pointer">
                             <div className="flex items-center gap-2">
                                <IconChevronDown className="w-3 h-3 text-slate-500" rotate={isExpanded} />
                                <div>
                                   <span className={`text-xs font-bold ${isBest ? 'text-cyan-400' : 'text-slate-300'}`}>{sol.name}</span>
                                   {!isExpanded && <p className="text-[10px] text-slate-500 truncate w-32">{sol.desc}</p>}
                                </div>
                             </div>
                             <span className="text-[10px] font-mono bg-slate-900 text-emerald-500 px-1.5 py-0.5 rounded border border-emerald-900/30 whitespace-nowrap">{sol.cycles} Cyc</span>
                          </div>

                          {isExpanded && (
                             <div className="p-3 pt-0 border-t border-slate-800 bg-slate-900/30 animate-in fade-in slide-in-from-top-1">
                                <p className="text-[10px] text-slate-500 mb-3 mt-2">{sol.desc}</p>
                                {sol.steps && sol.steps.length > 0 && (
                                    <div className="space-y-4 mb-4">
                                        <div className="text-[10px] font-bold text-slate-400 uppercase tracking-wider">Construction Steps</div>
                                        {sol.steps.map((step, sIdx) => (
                                            <div key={sIdx} className="flex flex-col gap-1 border-l-2 border-slate-700 pl-2">
                                                <div className="flex justify-between items-center">
                                                    <span className="font-mono text-[10px] text-cyan-500">{step.name}</span>
                                                    <span className="text-[9px] text-slate-600 font-mono">{step.code.split(';')[0]}</span>
                                                </div>
                                                <div className="text-[10px] text-slate-400">{step.desc}</div>
                                                {step.state && <StepVisualizer width={bitWidth} state={step.state} prevState={step.prevState} sideEffects={step.sideEffects} maskedOut={step.maskedOut} />}
                                            </div>
                                        ))}
                                    </div>
                                )}
                                <div className="relative">
                                   <div className="absolute top-0 right-0 p-1 flex gap-1">
                                      <button onClick={(e) => copyToClipboard(e, sol.code)} className="text-slate-500 hover:text-white p-1.5 rounded hover:bg-slate-700 bg-slate-800 border border-slate-700"><IconCopy className="w-3 h-3"/></button>
                                   </div>
                                   <pre className="text-[10px] font-mono text-slate-300 bg-slate-950 p-3 rounded border border-slate-800 overflow-x-auto whitespace-pre-wrap leading-relaxed">{sol.code}</pre>
                                </div>
                             </div>
                          )}
                       </div>
                     );
                  })}
               </div>
            </div>
         </div>
      </main>

      {copied && <div className="fixed bottom-6 left-1/2 -translate-x-1/2 bg-cyan-500 text-black px-4 py-2 rounded-full font-bold shadow-lg flex items-center gap-2 animate-bounce z-50 text-xs"><IconCheck className="w-4 h-4" /> Copied!</div>}
    </div>
  );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<BitPermutationApp />);

</script>
</body>
</html>
