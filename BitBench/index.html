<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="Content-Script-Type" content="text/JavaScript" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="Language" content="en" />

    <meta name="description" content="BitBench - Binary/Bitwise Workbench for base conversions, bitfield editing, bit manipulation operations, and code generation." />
    <meta name="keywords" content="SynthelicZ, Hawkynt, binary, hex, decimal, bitfield, bit manipulation, endianness, popcount, CLZ, CTZ, float16, bfloat16, IEEE754" />
    <meta name="robots" content="index,follow" />

    <meta property="og:title" content="BitBench - Binary/Bitwise Workbench" />
    <meta property="og:description" content="Interactive tool for binary/hex/decimal conversions, bitfield editing, and bit manipulation operations." />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://hawkynt.github.io/BitBench/" />
    <meta property="og:image" content="https://hawkynt.github.io/favicon.ico" />
    <meta name="twitter:card" content="summary" />

    <meta name="verify-v1" content="0cvNcn5f2mj21LAsFvUBD7BIdUbn/unV4Toy1yBLWvw=" />
    <meta name="google-site-verification" content="LkZ6DT0_GlcimQOKrWL20jv4jtUh0DBsh1ZPLXQqk3A" />

    <link rel="shortcut icon" href="../favicon.ico" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BitBench - Binary/Bitwise Workbench</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        slate: { 750: '#2d3748', 850: '#1a202c', 950: '#020617' },
                        cyan: { 450: '#15b0d6' },
                        orange: { 450: '#f97316' }
                    },
                    fontFamily: { mono: ['ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', 'monospace'] }
                }
            }
        }
    </script>
    <style>
        body { background-color: #020617; color: #e2e8f0; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #475569; }
        .no-select { user-select: none; -webkit-user-select: none; }
        .modal-overlay {
            position: fixed; inset: 0; z-index: 50;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            padding: 1rem;
        }
        .modal-content { animation: modalIn 0.2s ease-out; }
        @keyframes modalIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .bit-cell { transition: all 0.1s ease; }
        .bit-cell:hover { transform: scale(1.1); }
        .field-highlight { animation: fieldPulse 0.3s ease-out; }
        @keyframes fieldPulse {
            0% { box-shadow: 0 0 0 0 rgba(34, 211, 238, 0.4); }
            100% { box-shadow: 0 0 0 4px rgba(34, 211, 238, 0); }
        }
        .format-row:hover { background: rgba(30, 41, 59, 0.5); }
        .category-header { border-left: 3px solid; padding-left: 8px; }
    </style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">

// --- ICONS ---
const IconBinary = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="14" y="14" width="4" height="6" rx="2"/><rect x="6" y="4" width="4" height="6" rx="2"/><path d="M6 20h4"/><path d="M14 10h4"/><path d="M6 14h2v6"/><path d="M14 4h2v6"/></svg>);
const IconCopy = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>);
const IconCheck = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M20 6 9 17l-5-5"/></svg>);
const IconRotate = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>);
const IconTrash = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>);
const IconInfo = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>);
const IconX = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>);
const IconChevronDown = ({ className, rotate=false }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} style={{ transform: rotate ? 'rotate(180deg)' : 'none', transition: 'transform 0.2s' }}><path d="m6 9 6 6 6-6"/></svg>);
const IconPlus = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M5 12h14"/><path d="M12 5v14"/></svg>);
const IconArrowLeft = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>);
const IconArrowRight = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>);
const IconCode = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>);
const IconRefresh = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></svg>);
const IconDice = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5" fill="currentColor"/><circle cx="15.5" cy="8.5" r="1.5" fill="currentColor"/><circle cx="8.5" cy="15.5" r="1.5" fill="currentColor"/><circle cx="15.5" cy="15.5" r="1.5" fill="currentColor"/><circle cx="12" cy="12" r="1.5" fill="currentColor"/></svg>);

// --- CONSTANTS ---
const BIT_WIDTHS = [8, 16, 32, 64];

// BigInt-safe power function (Babel converts ** to Math.pow which fails with BigInt)
const bigPow = (base, exp) => {
    let result = 1n;
    base = BigInt(base);
    exp = Number(exp);
    for (let i = 0; i < exp; ++i) result *= base;
    return result;
};

// --- DECIMAL STRING PARSING (BigInt-based for precision) ---
// Parses decimal strings with comma/period, signs, and exponent notation
// Returns { mantissa: BigInt, exponent: number, sign: 1|-1 } or null on error
// Also handles special values: inf, -inf, nan, infinity
const parseDecimalString = (str) => {
    str = str.trim().replace(/,/g, '.').replace(/_/g, '');
    if (!str || str === '-' || str === '+' || str === '.') return null;

    // Handle special float values
    const lower = str.toLowerCase();
    if (lower === 'nan') return { special: NaN };
    if (lower === 'inf' || lower === '+inf' || lower === 'infinity' || lower === '+infinity') return { special: Infinity };
    if (lower === '-inf' || lower === '-infinity') return { special: -Infinity };

    // Match: optional sign, integer part, optional decimal part, optional exponent
    const match = str.match(/^([+-])?(\d*)(?:\.(\d*))?(?:[eE]([+-]?\d+))?$/);
    if (!match) return null;

    const sign = match[1] === '-' ? -1 : 1;
    const intPart = match[2] || '0';
    const fracPart = match[3] || '';
    const expPart = match[4] ? parseInt(match[4], 10) : 0;

    // Combine integer and fractional parts into a single BigInt mantissa
    const combined = intPart + fracPart;
    if (!/^\d+$/.test(combined) || combined.length === 0) return null;

    const mantissa = BigInt(combined.replace(/^0+/, '') || '0');
    const exponent = expPart - fracPart.length;

    return { mantissa, exponent, sign };
};

// Convert parsed decimal to JavaScript Number (IEEE 754 double)
const parsedDecimalToNumber = (parsed) => {
    if (!parsed) return NaN;
    if ('special' in parsed) return parsed.special;
    const { mantissa, exponent, sign } = parsed;
    if (mantissa === 0n) return sign === -1 ? -0 : 0;

    // For reasonable exponents, compute directly
    if (exponent >= 0 && exponent <= 308) {
        return sign * Number(mantissa) * Math.pow(10, exponent);
    } else if (exponent < 0 && exponent >= -308) {
        return sign * Number(mantissa) / Math.pow(10, -exponent);
    }

    // Fallback for extreme exponents
    return sign * Number(mantissa + 'e' + exponent);
};

// Parse decimal string directly to Number
const parseDecimalToNumber = (str) => parsedDecimalToNumber(parseDecimalString(str));

// Convert Number to bits for the given width (assumes IEEE 754 floats)
const numberToFloatBits = (num, width) => {
    if (width === 64) return numberToFloat64(num);
    if (width === 32) return numberToFloat32(num);
    if (width === 16) return BigInt(numberToFloat16(num));
    if (width === 8) return BigInt(numberToMinifloat8(num));
    // For other widths, just use the 64-bit representation masked
    return numberToFloat64(num) & ((1n << BigInt(width)) - 1n);
};

// Convert bits to Number for display
const floatBitsToNumber = (bits, width) => {
    if (width === 64) return float64ToNumber(bits);
    if (width === 32) return float32ToNumber(Number(bits));
    if (width === 16) return float16ToNumber(Number(bits));
    if (width === 8) return minifloat8ToNumber(Number(bits));
    return float64ToNumber(bits);
};

// --- MATH EXPRESSION EVALUATOR ---
// Function dictionary with descriptions for autocomplete
const MATH_FUNCTIONS = {
    // Trigonometric (radians)
    sin:   { fn: Math.sin,   desc: 'sin(x) - Sine of x (radians)' },
    cos:   { fn: Math.cos,   desc: 'cos(x) - Cosine of x (radians)' },
    tan:   { fn: Math.tan,   desc: 'tan(x) - Tangent of x (radians)' },
    cot:   { fn: x => 1/Math.tan(x), desc: 'cot(x) - Cotangent of x (radians)' },
    sec:   { fn: x => 1/Math.cos(x), desc: 'sec(x) - Secant of x (radians)' },
    csc:   { fn: x => 1/Math.sin(x), desc: 'csc(x) - Cosecant of x (radians)' },
    // Inverse trigonometric
    asin:  { fn: Math.asin,  desc: 'asin(x) - Arc sine, returns radians' },
    acos:  { fn: Math.acos,  desc: 'acos(x) - Arc cosine, returns radians' },
    atan:  { fn: Math.atan,  desc: 'atan(x) - Arc tangent, returns radians' },
    acot:  { fn: x => Math.atan(1/x), desc: 'acot(x) - Arc cotangent, returns radians' },
    asec:  { fn: x => Math.acos(1/x), desc: 'asec(x) - Arc secant, returns radians' },
    acsc:  { fn: x => Math.asin(1/x), desc: 'acsc(x) - Arc cosecant, returns radians' },
    atan2: { fn: Math.atan2, desc: 'atan2(y,x) - Arc tangent of y/x, returns radians', args: 2 },
    // Hyperbolic
    sinh:  { fn: Math.sinh,  desc: 'sinh(x) - Hyperbolic sine' },
    cosh:  { fn: Math.cosh,  desc: 'cosh(x) - Hyperbolic cosine' },
    tanh:  { fn: Math.tanh,  desc: 'tanh(x) - Hyperbolic tangent' },
    coth:  { fn: x => 1/Math.tanh(x), desc: 'coth(x) - Hyperbolic cotangent' },
    sech:  { fn: x => 1/Math.cosh(x), desc: 'sech(x) - Hyperbolic secant' },
    csch:  { fn: x => 1/Math.sinh(x), desc: 'csch(x) - Hyperbolic cosecant' },
    // Inverse hyperbolic (area functions)
    asinh: { fn: Math.asinh, desc: 'asinh(x) - Inverse hyperbolic sine' },
    acosh: { fn: Math.acosh, desc: 'acosh(x) - Inverse hyperbolic cosine' },
    atanh: { fn: Math.atanh, desc: 'atanh(x) - Inverse hyperbolic tangent' },
    acoth: { fn: x => Math.atanh(1/x), desc: 'acoth(x) - Inverse hyperbolic cotangent' },
    asech: { fn: x => Math.acosh(1/x), desc: 'asech(x) - Inverse hyperbolic secant' },
    acsch: { fn: x => Math.asinh(1/x), desc: 'acsch(x) - Inverse hyperbolic cosecant' },
    // Area function aliases
    arsinh: { fn: Math.asinh, desc: 'arsinh(x) - Area hyperbolic sine' },
    arcosh: { fn: Math.acosh, desc: 'arcosh(x) - Area hyperbolic cosine' },
    artanh: { fn: Math.atanh, desc: 'artanh(x) - Area hyperbolic tangent' },
    // Logarithmic
    log:   { fn: Math.log,   desc: 'log(x) - Natural logarithm (base e)' },
    ln:    { fn: Math.log,   desc: 'ln(x) - Natural logarithm (base e)' },
    log10: { fn: Math.log10, desc: 'log10(x) - Base 10 logarithm' },
    log2:  { fn: Math.log2,  desc: 'log2(x) - Base 2 logarithm' },
    // Exponential
    exp:   { fn: Math.exp,   desc: 'exp(x) - e raised to power x' },
    pow:   { fn: Math.pow,   desc: 'pow(x,y) - x raised to power y', args: 2 },
    sqrt:  { fn: Math.sqrt,  desc: 'sqrt(x) - Square root' },
    cbrt:  { fn: Math.cbrt,  desc: 'cbrt(x) - Cube root' },
    // Rounding
    abs:   { fn: Math.abs,   desc: 'abs(x) - Absolute value' },
    ceil:  { fn: Math.ceil,  desc: 'ceil(x) - Round up to integer' },
    floor: { fn: Math.floor, desc: 'floor(x) - Round down to integer' },
    round: { fn: Math.round, desc: 'round(x) - Round to nearest integer' },
    trunc: { fn: Math.trunc, desc: 'trunc(x) - Truncate to integer' },
    sign:  { fn: Math.sign,  desc: 'sign(x) - Sign of x (-1, 0, or 1)' },
    // Other
    min:   { fn: Math.min,   desc: 'min(a,b,...) - Minimum of values', args: -1 },
    max:   { fn: Math.max,   desc: 'max(a,b,...) - Maximum of values', args: -1 },
    hypot: { fn: Math.hypot, desc: 'hypot(a,b,...) - Euclidean distance', args: -1 },
    frac:  { fn: x => x - Math.floor(x), desc: 'frac(x) - Fractional part' },
    deg:   { fn: x => x * 180 / Math.PI, desc: 'deg(x) - Radians to degrees' },
    rad:   { fn: x => x * Math.PI / 180, desc: 'rad(x) - Degrees to radians' },
};

// Constants for math expressions
const MATH_CONSTANTS = {
    pi: Math.PI,
    e: Math.E,
    tau: Math.PI * 2,
    phi: (1 + Math.sqrt(5)) / 2,
    inf: Infinity,
    nan: NaN,
};

// Tokenize math expression
const tokenizeMathExpr = (expr) => {
    const tokens = [];
    let i = 0;
    while (i < expr.length) {
        const ch = expr[i];
        if (/\s/.test(ch)) { ++i; continue; }
        if (/[0-9.]/.test(ch)) {
            let num = '';
            while (i < expr.length && /[0-9.eE+-]/.test(expr[i])) {
                if ((expr[i] === 'e' || expr[i] === 'E') && num.length > 0) {
                    num += expr[i++];
                    if (i < expr.length && /[+-]/.test(expr[i])) num += expr[i++];
                } else if ((expr[i] === '+' || expr[i] === '-') && !/[eE]/.test(num.slice(-1))) break;
                else num += expr[i++];
            }
            tokens.push({ type: 'number', value: parseFloat(num) });
        } else if (/[a-zA-Z_]/.test(ch)) {
            let name = '';
            while (i < expr.length && /[a-zA-Z0-9_]/.test(expr[i])) name += expr[i++];
            tokens.push({ type: 'name', value: name.toLowerCase() });
        } else if (ch === '*' && expr[i + 1] === '*') {
            // Handle ** as power operator (convert to ^)
            tokens.push({ type: 'op', value: '^' });
            i += 2;
        } else if ('+-*/^(),'.includes(ch)) {
            tokens.push({ type: 'op', value: ch });
            ++i;
        } else ++i;
    }
    return tokens;
};

// Parse and evaluate math expression
const evalMathExpr = (expr) => {
    const tokens = tokenizeMathExpr(expr);
    let pos = 0;

    const peek = () => tokens[pos];
    const consume = () => tokens[pos++];

    const parseExpr = () => parseAddSub();

    const parseAddSub = () => {
        let left = parseMulDiv();
        while (peek() && peek().type === 'op' && (peek().value === '+' || peek().value === '-')) {
            const op = consume().value;
            const right = parseMulDiv();
            left = op === '+' ? left + right : left - right;
        }
        return left;
    };

    const parseMulDiv = () => {
        let left = parsePower();
        while (peek() && peek().type === 'op' && (peek().value === '*' || peek().value === '/')) {
            const op = consume().value;
            const right = parsePower();
            left = op === '*' ? left * right : left / right;
        }
        return left;
    };

    const parsePower = () => {
        let left = parseUnary();
        while (peek() && peek().type === 'op' && peek().value === '^') {
            consume();
            const right = parseUnary();
            left = Math.pow(left, right);
        }
        return left;
    };

    const parseUnary = () => {
        if (peek() && peek().type === 'op' && (peek().value === '+' || peek().value === '-')) {
            const op = consume().value;
            return op === '-' ? -parseUnary() : parseUnary();
        }
        return parseAtom();
    };

    const parseAtom = () => {
        const tok = peek();
        if (!tok) return 0;

        if (tok.type === 'number') {
            consume();
            return tok.value;
        }

        if (tok.type === 'name') {
            consume();
            const name = tok.value;
            // Check for function call
            if (peek() && peek().type === 'op' && peek().value === '(') {
                consume(); // consume '('
                const args = [];
                if (!(peek() && peek().type === 'op' && peek().value === ')')) {
                    args.push(parseExpr());
                    while (peek() && peek().type === 'op' && peek().value === ',') {
                        consume();
                        args.push(parseExpr());
                    }
                }
                if (peek() && peek().type === 'op' && peek().value === ')') consume();
                const func = MATH_FUNCTIONS[name];
                if (func) return func.fn(...args);
                return NaN;
            }
            // Check for constant
            if (MATH_CONSTANTS.hasOwnProperty(name)) return MATH_CONSTANTS[name];
            return NaN;
        }

        if (tok.type === 'op' && tok.value === '(') {
            consume();
            const val = parseExpr();
            if (peek() && peek().type === 'op' && peek().value === ')') consume();
            return val;
        }

        return 0;
    };

    try {
        return parseExpr();
    } catch (e) {
        return NaN;
    }
};

// Get function name at cursor for autocomplete
const getFunctionPrefixAtCursor = (text, cursorPos) => {
    let start = cursorPos;
    while (start > 0 && /[a-zA-Z0-9_]/.test(text[start - 1])) --start;
    const prefix = text.slice(start, cursorPos).toLowerCase();
    return { prefix, start, end: cursorPos };
};

// Get autocomplete suggestions (sorted alphabetically)
const getMathSuggestions = (prefix) => {
    if (!prefix) return [];
    const names = Object.keys(MATH_FUNCTIONS);
    const matches = names.filter(n => n.startsWith(prefix) && n !== prefix).sort();
    return matches.map(name => ({ name, desc: MATH_FUNCTIONS[name].desc }));
};

// Math Autocomplete Input Component
const MathAutocompleteInput = ({ value, onChange, onEvaluate, onFocusChange, className }) => {
    const [suggestions, setSuggestions] = React.useState([]);
    const [selectedIndex, setSelectedIndex] = React.useState(0);
    const [showDropdown, setShowDropdown] = React.useState(false);
    const [cursorInfo, setCursorInfo] = React.useState(null);
    const inputRef = React.useRef(null);
    const dropdownRef = React.useRef(null);

    // Scroll selected item into view when selection changes
    React.useEffect(() => {
        if (showDropdown && dropdownRef.current) {
            const selectedItem = dropdownRef.current.querySelector(`[data-index="${selectedIndex}"]`);
            if (selectedItem) {
                selectedItem.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
        }
    }, [selectedIndex, showDropdown]);

    const updateSuggestions = (text, cursorPos) => {
        const info = getFunctionPrefixAtCursor(text, cursorPos);
        setCursorInfo(info);
        const matches = getMathSuggestions(info.prefix);
        setSuggestions(matches);
        setSelectedIndex(0);
        setShowDropdown(matches.length > 0);
    };

    const handleChange = (e) => {
        const newText = e.target.value;
        const cursorPos = e.target.selectionStart;
        onChange(newText);
        updateSuggestions(newText, cursorPos);
    };

    const handleSelect = (cursorPos) => {
        if (inputRef.current) {
            updateSuggestions(value, cursorPos);
        }
    };

    const completeSuggestion = (suggestion) => {
        if (!cursorInfo || !suggestion) return;
        const before = value.slice(0, cursorInfo.start);
        const after = value.slice(cursorInfo.end);
        const newText = before + suggestion.name + '(' + after;
        onChange(newText);
        setShowDropdown(false);
        // Set cursor after the opening paren
        setTimeout(() => {
            if (inputRef.current) {
                const newPos = cursorInfo.start + suggestion.name.length + 1;
                inputRef.current.setSelectionRange(newPos, newPos);
                inputRef.current.focus();
            }
        }, 0);
    };

    const handleKeyDown = (e) => {
        if (showDropdown && suggestions.length > 0) {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                setSelectedIndex(prev => (prev + 1) % suggestions.length);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                setSelectedIndex(prev => (prev - 1 + suggestions.length) % suggestions.length);
            } else if (e.key === 'Tab' || e.key === 'Enter') {
                if (suggestions[selectedIndex]) {
                    e.preventDefault();
                    completeSuggestion(suggestions[selectedIndex]);
                }
            } else if (e.key === 'Escape') {
                e.preventDefault();
                setShowDropdown(false);
            }
        } else if (e.key === 'Enter') {
            e.preventDefault();
            onEvaluate(value);
        }
    };

    const handleFocus = () => {
        onFocusChange?.(true);
    };

    const handleBlur = (e) => {
        // Delay hiding to allow click on dropdown item
        setTimeout(() => {
            if (!dropdownRef.current?.contains(document.activeElement)) {
                setShowDropdown(false);
                onFocusChange?.(false);
            }
        }, 150);
    };

    return (
        <div className="relative flex-1">
            <input
                ref={inputRef}
                type="text"
                value={value}
                onChange={handleChange}
                onKeyDown={handleKeyDown}
                onSelect={(e) => handleSelect(e.target.selectionStart)}
                onFocus={handleFocus}
                onBlur={handleBlur}
                className={className}
                spellCheck={false}
            />
            {showDropdown && suggestions.length > 0 && (
                <div
                    ref={dropdownRef}
                    className="absolute left-0 right-0 top-full mt-1 bg-slate-900 border border-slate-700 rounded shadow-lg z-50 max-h-48 overflow-y-auto"
                >
                    {suggestions.map((s, idx) => (
                        <div
                            key={s.name}
                            data-index={idx}
                            onClick={() => completeSuggestion(s)}
                            className={`px-3 py-2 cursor-pointer text-sm font-mono border-b border-slate-800 last:border-b-0 ${
                                idx === selectedIndex
                                    ? 'bg-emerald-700 text-white'
                                    : 'text-slate-300 hover:bg-slate-800'
                            }`}
                        >
                            <span className="font-bold text-cyan-400">{s.name}</span>
                            <span className="text-slate-400 ml-2 text-xs">{s.desc.split(' - ')[1] || s.desc}</span>
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
};

// BigInt-based precise decimal string conversion for IEEE 754 floats
// Avoids JavaScript Number rounding artifacts by computing decimal representation directly
const floatBitsToDecimalString = (bits, signBits, expBits, mantBits, expBias) => {
    bits = BigInt(bits);
    const totalBits = signBits + expBits + mantBits;
    const mantMask = (1n << BigInt(mantBits)) - 1n;
    const expMask = (1n << BigInt(expBits)) - 1n;

    const sign = Number((bits >> BigInt(totalBits - 1)) & 1n);
    const exp = Number((bits >> BigInt(mantBits)) & expMask);
    const mant = bits & mantMask;

    // Handle special cases
    const expMax = (1 << expBits) - 1;
    if (exp === expMax) {
        if (mant === 0n) return sign ? '-Infinity' : 'Infinity';
        return 'NaN';
    }
    if (exp === 0 && mant === 0n) return sign ? '-0' : '0';

    // Calculate actual value using BigInt arithmetic
    // value = (-1)^sign * mantissa * 2^(exp - bias - mantBits)
    // For normalized: mantissa = (1 << mantBits) + mant
    // For denormalized: mantissa = mant, exp = 1
    let mantissa, exponent;
    if (exp === 0) {
        // Denormalized
        mantissa = mant;
        exponent = 1 - expBias - mantBits;
    } else {
        // Normalized
        mantissa = (1n << BigInt(mantBits)) + mant;
        exponent = exp - expBias - mantBits;
    }

    if (mantissa === 0n) return sign ? '-0' : '0';

    // Convert to decimal: multiply by appropriate power of 10 for precision
    // then divide and format
    const precision = Math.max(20, mantBits + 10); // Extra precision for accurate rounding
    const scale = bigPow(10n, precision);

    let numerator, denominator;
    if (exponent >= 0) {
        numerator = mantissa * (1n << BigInt(exponent)) * scale;
        denominator = 1n;
    } else {
        numerator = mantissa * scale;
        denominator = 1n << BigInt(-exponent);
    }

    // Perform the division
    let integerPart = numerator / denominator;

    // Convert to string and insert decimal point
    let str = integerPart.toString();

    // Insert decimal point at the right position
    if (str.length <= precision) {
        str = '0'.repeat(precision - str.length + 1) + str;
    }
    const decimalPos = str.length - precision;
    let intPart = str.slice(0, decimalPos);
    let fracPart = str.slice(decimalPos);

    // Trim trailing zeros from fraction
    fracPart = fracPart.replace(/0+$/, '');

    // Format result
    let result;
    if (fracPart.length === 0) {
        result = intPart;
    } else {
        result = intPart + '.' + fracPart;
    }

    // Use scientific notation for very large or very small numbers
    if (intPart.length > 15 || (intPart === '0' && fracPart.match(/^0{6,}/))) {
        // Generate scientific notation from BigInt computation
        const fullStr = intPart + fracPart;
        const firstNonZero = fullStr.search(/[1-9]/);
        if (firstNonZero >= 0) {
            const significand = fullStr.slice(firstNonZero, firstNonZero + 15).replace(/0+$/, '');
            let expVal;
            if (intPart !== '0' && intPart !== '') {
                expVal = intPart.length - 1;
            } else {
                expVal = -(fracPart.search(/[1-9]/) + 1);
            }
            result = significand[0] + (significand.length > 1 ? '.' + significand.slice(1) : '') + 'e' + (expVal >= 0 ? '+' : '') + expVal;
        }
    }

    return sign ? '-' + result : result;
};

// Format float for display, avoiding unnecessary precision loss display
const formatFloatInput = (bits, width) => {
    // Use precise BigInt-based conversion for standard IEEE 754 formats
    if (width === 64) return floatBitsToDecimalString(bits, 1, 11, 52, 1023);
    if (width === 32) return floatBitsToDecimalString(bits, 1, 8, 23, 127);
    if (width === 16) return floatBitsToDecimalString(bits, 1, 5, 10, 15);
    if (width === 8) return floatBitsToDecimalString(bits, 1, 4, 3, 7);
    // Fallback for non-standard widths
    const num = floatBitsToNumber(bits, width);
    if (!isFinite(num)) return num.toString();
    if (Object.is(num, -0)) return '-0';
    return num.toPrecision(15).replace(/\.?0+$/, '');
};

// Precise BigInt-based formatters for common float formats (for use in display functions)
const formatFloat64Bits = (bits) => floatBitsToDecimalString(bits, 1, 11, 52, 1023);
const formatFloat32Bits = (bits) => floatBitsToDecimalString(bits, 1, 8, 23, 127);
const formatFloat16Bits = (bits) => floatBitsToDecimalString(bits, 1, 5, 10, 15);
const formatMinifloat8Bits = (bits) => floatBitsToDecimalString(bits, 1, 4, 3, 7);
const formatBFloat16Bits = (bits) => floatBitsToDecimalString(bits, 1, 8, 7, 127);
const formatBFloat8Bits = (bits) => floatBitsToDecimalString(bits, 1, 4, 3, 7);
const formatTF32Bits = (bits) => floatBitsToDecimalString(bits, 1, 8, 10, 127);
const formatFP8E4M3Bits = (bits) => {
    // FP8-E4M3 has no infinity, all-ones exp means NaN
    const b = BigInt(bits);
    const sign = Number((b >> 7n) & 1n);
    const exp = Number((b >> 3n) & 0xFn);
    const mant = b & 0x7n;
    if (exp === 15) return 'NaN';
    if (exp === 0 && mant === 0n) return sign ? '-0' : '0';
    return floatBitsToDecimalString(bits, 1, 4, 3, 7);
};
const formatFP8E5M2Bits = (bits) => floatBitsToDecimalString(bits, 1, 5, 2, 15);
const formatBFloat64Bits = (bits) => floatBitsToDecimalString(bits, 1, 8, 55, 127);

// --- FIXED POINT PRECISE FORMATTING ---
const formatFixedPointBits = (bits, intBits, fracBits, signed) => {
    bits = BigInt(bits);
    const totalBits = intBits + fracBits;
    if (fracBits === 0) return bits.toString(); // No fractional part

    const signBit = 1n << BigInt(totalBits - 1);
    let isNeg = false;
    if (signed && bits >= signBit) {
        isNeg = true;
        bits = (1n << BigInt(totalBits)) - bits;
    }
    if (bits === 0n) return isNeg ? '-0' : '0';

    // Split into integer and fractional parts
    const fracMask = (1n << BigInt(fracBits)) - 1n;
    const intPart = bits >> BigInt(fracBits);
    const fracPart = bits & fracMask;

    if (fracPart === 0n) return (isNeg ? '-' : '') + intPart.toString();

    // Convert fractional part exactly: fracPart / 2^fracBits
    // Use enough decimal digits to represent any binary fraction exactly
    // For n binary digits, need ceil(n * log10(2)) + 1 decimal digits
    const precision = Math.ceil(fracBits * 0.30103) + 3;
    const divisor = 1n << BigInt(fracBits);
    const scale = bigPow(10n, precision);

    // Compute with rounding: (fracPart * scale + divisor/2) / divisor
    const fracValue = (fracPart * scale * 2n + divisor) / (divisor * 2n);
    let fracStr = fracValue.toString().padStart(precision, '0');

    // Trim trailing zeros but keep at least one decimal place for clarity
    fracStr = fracStr.replace(/0+$/, '');
    if (fracStr === '') return (isNeg ? '-' : '') + intPart.toString();

    return (isNeg ? '-' : '') + intPart.toString() + '.' + fracStr;
};

// --- DECIMAL FLOAT PRECISE FORMATTING ---
const formatDecimal8Bits = (bits) => {
    bits = Number(bits);
    const sign = (bits >> 7) & 1;
    const exp = (bits >> 4) & 0x7;
    const coeff = bits & 0xF;
    if (exp === 7 && coeff >= 14) return coeff === 14 ? (sign ? '-Infinity' : 'Infinity') : 'NaN';
    if (coeff === 0) return sign ? '-0' : '0';
    const expVal = exp - 4;
    return formatDecimalCoeff(BigInt(coeff), expVal, sign);
};

const formatDecimal16Bits = (bits) => {
    bits = Number(bits);
    const sign = (bits >> 15) & 1;
    const exp = (bits >> 10) & 0x1F;
    const coeff = bits & 0x3FF;
    if (exp === 31 && coeff >= 1022) return coeff === 1022 ? (sign ? '-Infinity' : 'Infinity') : 'NaN';
    if (coeff === 0) return sign ? '-0' : '0';
    const expVal = exp - 16;
    return formatDecimalCoeff(BigInt(coeff), expVal, sign);
};

const formatDecimal32Bits = (bits) => {
    bits = Number(bits);
    const sign = (bits >> 31) & 1;
    const combo = (bits >> 23) & 0xFF;
    const trailing = bits & 0x7FFFFF;

    if ((combo >> 6) === 3) {
        if ((combo >> 5) === 0x1E) return sign ? '-Infinity' : 'Infinity';
        if ((combo >> 5) === 0x1F) return 'NaN';
        const exp = ((combo & 0x3) << 6) | ((bits >> 21) & 0x3F);
        const coeff = (8 + ((combo >> 2) & 1)) * 1000000 + (trailing & 0x1FFFFF);
        return formatDecimalCoeff(BigInt(coeff), exp - 101, sign);
    }

    const exp = ((combo >> 1) & 0x3F) | ((combo & 0x80) >> 1);
    const coeff = ((combo & 1) << 23) | trailing;
    if (coeff === 0) return sign ? '-0' : '0';
    return formatDecimalCoeff(BigInt(coeff), exp - 101, sign);
};

const formatDecimal64Bits = (bits) => {
    bits = BigInt(bits);
    const sign = Number((bits >> 63n) & 1n);
    const combo = Number((bits >> 53n) & 0x3FFn);
    const trailing = bits & 0x1FFFFFFFFFFFFFn;

    if ((combo >> 8) === 3) {
        if ((combo >> 7) === 0x1E) return sign ? '-Infinity' : 'Infinity';
        if ((combo >> 7) === 0x1F) return 'NaN';
        const exp = ((combo & 0x3) << 8) | Number((bits >> 51n) & 0xFFn);
        const leadDigit = 8 + ((combo >> 2) & 1);
        const coeff = BigInt(leadDigit) * 10000000000000000n + (trailing & 0x7FFFFFFFFFFFFn);
        return formatDecimalCoeff(coeff, exp - 398, sign);
    }

    const exp = ((combo >> 2) & 0xFF) | ((combo & 0x300) >> 1);
    const coeff = (BigInt(combo & 3) << 53n) | trailing;
    if (coeff === 0n) return sign ? '-0' : '0';
    return formatDecimalCoeff(coeff, exp - 398, sign);
};

const formatDecimalCoeff = (coeff, exp, sign) => {
    if (coeff === 0n) return sign ? '-0' : '0';
    let str = coeff.toString();
    const decPos = str.length + exp;

    if (exp >= 0) {
        str = str + '0'.repeat(exp);
    } else if (decPos <= 0) {
        str = '0.' + '0'.repeat(-decPos) + str;
    } else {
        str = str.slice(0, decPos) + '.' + str.slice(decPos);
    }
    str = str.replace(/\.?0+$/, '').replace(/^0+(?=\d)/, '');
    if (str === '' || str === '.') str = '0';
    return (sign ? '-' : '') + str;
};

// --- EXOTIC FLOAT PRECISE FORMATTING ---
const formatIBMFloat32Bits = (bits) => {
    bits = BigInt(bits);
    const sign = Number((bits >> 31n) & 1n);
    const exp = Number((bits >> 24n) & 0x7Fn);
    const mant = bits & 0xFFFFFFn;
    if (mant === 0n && exp === 0) return sign ? '-0' : '0';

    // IBM HFP: value = mant/2^24 * 16^(exp-64) = mant * 16^(exp-64) / 2^24
    // = mant * 2^(4*(exp-64)) / 2^24 = mant * 2^(4*exp - 256 - 24) = mant * 2^(4*exp - 280)
    const binExp = 4 * exp - 280;
    return formatMantissaWithBinExp(mant, binExp, sign);
};

const formatVAXFBits = (bits) => {
    bits = BigInt(bits);
    // VAX byte order swap
    const swapped = ((bits & 0xFFFFn) << 16n) | ((bits >> 16n) & 0xFFFFn);
    const sign = Number((swapped >> 15n) & 1n);
    const exp = Number((swapped >> 7n) & 0xFFn);
    const mant = ((swapped & 0x7Fn) << 16n) | ((bits >> 16n) & 0xFFFFn);
    if (exp === 0) return '0';

    // VAX F: value = (0.5 + mant/2^24) * 2^(exp-128) with hidden bit
    // = (2^23 + mant) / 2^24 * 2^(exp-128) = (2^23 + mant) * 2^(exp-152)
    const fullMant = (1n << 23n) + mant;
    return formatMantissaWithBinExp(fullMant, exp - 152, sign);
};

const formatMBF32Bits = (bits) => {
    bits = BigInt(bits);
    const exp = Number((bits >> 24n) & 0xFFn);
    if (exp === 0) return '0';
    const sign = Number((bits >> 23n) & 1n);
    const mant = bits & 0x7FFFFFn;

    // MBF32: value = (0.5 + mant/2^24) * 2^(exp-128) = (2^23 + mant) * 2^(exp-152)
    const fullMant = (1n << 23n) + mant;
    return formatMantissaWithBinExp(fullMant, exp - 152, sign);
};

const formatMBF64Bits = (bits) => {
    bits = BigInt(bits);
    const exp = Number((bits >> 56n) & 0xFFn);
    if (exp === 0) return '0';
    const sign = Number((bits >> 55n) & 1n);
    const mant = bits & 0x7FFFFFFFFFFFFFn;

    // MBF64: value = (0.5 + mant/2^56) * 2^(exp-128) = (2^55 + mant) * 2^(exp-184)
    const fullMant = (1n << 55n) + mant;
    return formatMantissaWithBinExp(fullMant, exp - 184, sign);
};

const formatMantissaWithBinExp = (mant, binExp, sign) => {
    if (mant === 0n) return sign ? '-0' : '0';

    // Convert mant * 2^binExp to decimal string
    let value;
    if (binExp >= 0) {
        value = mant << BigInt(binExp);
        return (sign ? '-' : '') + value.toString();
    } else {
        const negExp = -binExp;
        const divisor = 1n << BigInt(negExp);
        const intPart = mant / divisor;
        const fracPart = mant % divisor;

        if (fracPart === 0n) return (sign ? '-' : '') + intPart.toString();

        // Calculate decimal digits for fractional part
        const precision = Math.ceil(negExp * 0.30103) + 2;
        const scale = bigPow(10n, precision);
        const fracValue = (fracPart * scale) / divisor;
        let fracStr = fracValue.toString().padStart(precision, '0').replace(/0+$/, '');

        if (fracStr === '') return (sign ? '-' : '') + intPart.toString();
        return (sign ? '-' : '') + intPart.toString() + '.' + fracStr;
    }
};

// --- POSIT PRECISE FORMATTING ---
const formatPositBits = (bits, nbits, es) => {
    bits = BigInt(bits);
    const mask = (1n << BigInt(nbits)) - 1n;
    bits = bits & mask;

    if (bits === 0n) return '0';
    if (bits === (1n << BigInt(nbits - 1))) return 'NaR';

    const sign = Number((bits >> BigInt(nbits - 1)) & 1n);
    let p = sign ? ((1n << BigInt(nbits)) - bits) : bits;

    // Count regime bits
    let regimeBit = Number((p >> BigInt(nbits - 2)) & 1n);
    let regimeLen = 1;
    for (let i = nbits - 3; i >= 0; --i) {
        if (Number((p >> BigInt(i)) & 1n) === regimeBit) ++regimeLen;
        else break;
    }

    const k = regimeBit ? regimeLen - 1 : -regimeLen;
    const remainingBits = nbits - 1 - regimeLen - 1;

    let exp = 0;
    let fracBits = 0;
    let frac = 0n;

    if (remainingBits > 0) {
        if (es > 0 && remainingBits >= es) {
            exp = Number((p >> BigInt(remainingBits - es)) & ((1n << BigInt(es)) - 1n));
            fracBits = remainingBits - es;
        } else if (es > 0) {
            exp = Number((p & ((1n << BigInt(remainingBits)) - 1n)) << BigInt(es - remainingBits));
            fracBits = 0;
        } else {
            fracBits = remainingBits;
        }
        if (fracBits > 0) frac = p & ((1n << BigInt(fracBits)) - 1n);
    }

    // useed = 2^(2^es), scale = useed^k * 2^exp = 2^(k*2^es + exp)
    const useedExp = 1 << es;
    const totalExp = k * useedExp + exp;

    // value = (1 + frac/2^fracBits) * 2^totalExp
    const fullMant = fracBits > 0 ? (1n << BigInt(fracBits)) + frac : 1n;
    const effectiveExp = totalExp - fracBits;

    return formatMantissaWithBinExp(fullMant, effectiveExp, sign);
};

// --- BYTE ORDER UTILITIES ---
const swapBytes = (val, width) => {
    const bytes = width / 8;
    let result = 0n;
    for (let i = 0; i < bytes; ++i) {
        const byte = (val >> BigInt(i * 8)) & 0xFFn;
        result |= byte << BigInt((bytes - 1 - i) * 8);
    }
    return result;
};

// Extract bytes as array (LE order)
const toBytes = (val, width) => {
    const bytes = [];
    for (let i = 0; i < width / 8; ++i)
        bytes.push(Number((val >> BigInt(i * 8)) & 0xFFn));
    return bytes;
};

// Build value from bytes (LE order)
const fromBytes = (bytes) => {
    let val = 0n;
    for (let i = 0; i < bytes.length; ++i)
        val |= BigInt(bytes[i]) << BigInt(i * 8);
    return val;
};

// --- BIT UTILITIES ---
const popcount = (n) => {
    let count = 0, val = BigInt(n);
    while (val > 0n) { if (val & 1n) ++count; val >>= 1n; }
    return count;
};

const parity = (n) => popcount(n) % 2;

const clz = (n, width) => {
    if (n === 0n) return width;
    let count = 0;
    for (let i = width - 1; i >= 0; --i) {
        if ((n >> BigInt(i)) & 1n) break;
        ++count;
    }
    return count;
};

const ctz = (n, width) => {
    if (n === 0n) return width;
    let count = 0;
    for (let i = 0; i < width; ++i) {
        if ((n >> BigInt(i)) & 1n) break;
        ++count;
    }
    return count;
};

// Count Leading Ones
const clo = (n, width) => {
    const mask = (1n << BigInt(width)) - 1n;
    return clz(~n & mask, width);
};

// Count Trailing Ones
const cto = (n, width) => {
    const mask = (1n << BigInt(width)) - 1n;
    return ctz(~n & mask, width);
};

// Bit width needed to represent value (log2 + 1, or 0 for zero)
const bitWidth = (n) => {
    if (n === 0n) return 0;
    let width = 0;
    while (n > 0n) { ++width; n >>= 1n; }
    return width;
};

const rotateLeft = (val, amount, width) => {
    const mask = (1n << BigInt(width)) - 1n;
    amount = amount % width;
    return ((val << BigInt(amount)) | (val >> BigInt(width - amount))) & mask;
};

const rotateRight = (val, amount, width) => {
    const mask = (1n << BigInt(width)) - 1n;
    amount = amount % width;
    return ((val >> BigInt(amount)) | (val << BigInt(width - amount))) & mask;
};

// Arithmetic shift right (preserves sign bit)
const arithmeticShiftRight = (val, amount, width) => {
    const mask = (1n << BigInt(width)) - 1n;
    const signBit = (val >> BigInt(width - 1)) & 1n;
    const shifted = val >> BigInt(amount);
    if (signBit === 1n) {
        // Fill vacated high bits with 1s
        const fillMask = (((1n << BigInt(amount)) - 1n) << BigInt(width - amount)) & mask;
        return (shifted | fillMask) & mask;
    }
    return shifted & mask;
};

// Sign-preserving left shift (keeps sign bit, shifts magnitude)
const signPreservingShiftLeft = (val, amount, width) => {
    const signBit = (val >> BigInt(width - 1)) & 1n;
    const magnitudeMask = (1n << BigInt(width - 1)) - 1n;
    const magnitude = val & magnitudeMask;
    const shiftedMagnitude = (magnitude << BigInt(amount)) & magnitudeMask;
    return (signBit << BigInt(width - 1)) | shiftedMagnitude;
};

// --- INTEGER CONVERSIONS ---
const toSigned = (val, width) => {
    const signBit = 1n << BigInt(width - 1);
    return val >= signBit ? val - (1n << BigInt(width)) : val;
};

const fromSigned = (val, width) => {
    return val < 0n ? val + (1n << BigInt(width)) : val;
};

const formatHex = (val, width) => {
    const hexDigits = Math.ceil(width / 4);
    return '0x' + val.toString(16).toUpperCase().padStart(hexDigits, '0');
};

// Extract array of unsigned values from a larger value (LE order)
const extractUnsignedArray = (val, elementBits, totalBits) => {
    const count = totalBits / elementBits;
    const mask = (1n << BigInt(elementBits)) - 1n;
    const result = [];
    for (let i = 0; i < count; ++i)
        result.push((val >> BigInt(i * elementBits)) & mask);
    return result;
};

// Extract array of signed values from a larger value (LE order)
const extractSignedArray = (val, elementBits, totalBits) => {
    const count = totalBits / elementBits;
    const mask = (1n << BigInt(elementBits)) - 1n;
    const result = [];
    for (let i = 0; i < count; ++i)
        result.push(toSigned((val >> BigInt(i * elementBits)) & mask, elementBits));
    return result;
};

// Format array for display
const formatArray = (arr) => '[ ' + arr.join(', ') + ' ]';

// Generic array extractor and formatter for any type
const extractAndFormat = (val, typeBits, totalBits, convertFn, formatFn) => {
    if (totalBits > typeBits) {
        const arr = extractUnsignedArray(val, typeBits, totalBits);
        return formatArray(arr.map(x => formatFn(convertFn(x))));
    }
    return formatFn(convertFn(val));
};

// Bits-based extractor and formatter (for precise BigInt-based float formatting)
const extractAndFormatBits = (val, typeBits, totalBits, formatBitsFn) => {
    if (totalBits > typeBits) {
        const arr = extractUnsignedArray(val, typeBits, totalBits);
        return formatArray(arr.map(x => formatBitsFn(x)));
    }
    return formatBitsFn(val);
};

// Extract BCD array
const extractBcdArray = (val, typeBits, totalBits) => {
    if (totalBits > typeBits) {
        const arr = extractUnsignedArray(val, typeBits, totalBits);
        return formatArray(arr.map(x => {
            const n = bcdToNumber(x, typeBits);
            return n.valid ? n.value.toString() : '?';
        }));
    }
    const n = bcdToNumber(val, typeBits);
    return n.valid ? n.value.toString() : 'Invalid BCD';
};

const formatBinary = (val, width) => '0b' + val.toString(2).padStart(width, '0');

const formatOctal = (val) => '0o' + val.toString(8);

// --- FLOAT CONVERSION UTILITIES ---

// IEEE 754 Binary16 (Half precision): 1 sign, 5 exp, 10 mantissa, bias=15
const float16ToNumber = (bits) => {
    const sign = (bits >> 15) & 1;
    const exp = (bits >> 10) & 0x1F;
    const mant = bits & 0x3FF;
    if (exp === 0) {
        if (mant === 0) return sign ? -0 : 0;
        return (sign ? -1 : 1) * mant / 1024 * Math.pow(2, -14); // Subnormal
    }
    if (exp === 31) return mant === 0 ? (sign ? -Infinity : Infinity) : NaN;
    return (sign ? -1 : 1) * (1 + mant / 1024) * Math.pow(2, exp - 15);
};

const numberToFloat16 = (num) => {
    if (isNaN(num)) return 0x7E00;
    if (!isFinite(num)) return num > 0 ? 0x7C00 : 0xFC00;
    if (num === 0) return Object.is(num, -0) ? 0x8000 : 0;
    const sign = num < 0 ? 1 : 0;
    const abs = Math.abs(num);
    if (abs < Math.pow(2, -24)) return sign << 15; // Too small
    if (abs >= 65504) return (sign << 15) | 0x7C00; // Overflow to inf
    let exp = Math.floor(Math.log2(abs));
    let mant = abs / Math.pow(2, exp) - 1;
    exp += 15;
    if (exp <= 0) { mant = abs / Math.pow(2, -14); return (sign << 15) | Math.round(mant * 1024); }
    return (sign << 15) | (exp << 10) | Math.round(mant * 1024);
};

// BFloat16 (Brain Float): 1 sign, 8 exp, 7 mantissa (truncated float32)
const bfloat16ToNumber = (bits) => {
    // BFloat16 is just top 16 bits of float32, pad with zeros
    const f32bits = bits << 16;
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    view.setUint32(0, f32bits, false);
    return view.getFloat32(0, false);
};

const numberToBFloat16 = (num) => {
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    view.setFloat32(0, num, false);
    return view.getUint32(0, false) >>> 16;
};

// BFloat8 (custom): 1 sign, 4 exp, 3 mantissa (truncated bfloat16, bias=7)
const bfloat8ToNumber = (bits) => {
    const sign = (bits >> 7) & 1;
    const exp = (bits >> 3) & 0xF;
    const mant = bits & 0x7;
    if (exp === 0) {
        if (mant === 0) return sign ? -0 : 0;
        return (sign ? -1 : 1) * mant / 8 * Math.pow(2, -6); // Subnormal
    }
    if (exp === 15) return mant === 0 ? (sign ? -Infinity : Infinity) : NaN;
    return (sign ? -1 : 1) * (1 + mant / 8) * Math.pow(2, exp - 7);
};

// BFloat64 (custom): 1 sign, 8 exp, 55 mantissa (extended bfloat with float32 exponent range)
const bfloat64ToNumber = (bits) => {
    const sign = Number((bits >> 63n) & 1n);
    const exp = Number((bits >> 55n) & 0xFFn);
    const mant = bits & 0x7FFFFFFFFFFFFFn;
    if (exp === 0) {
        if (mant === 0n) return sign ? -0 : 0;
        return (sign ? -1 : 1) * Number(mant) / 0x80000000000000 * Math.pow(2, -126); // Subnormal
    }
    if (exp === 255) return mant === 0n ? (sign ? -Infinity : Infinity) : NaN;
    return (sign ? -1 : 1) * (1 + Number(mant) / 0x80000000000000) * Math.pow(2, exp - 127);
};

// IEEE 754 Binary32 (Single precision) using DataView
const float32ToNumber = (bits) => {
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    view.setUint32(0, Number(bits), false);
    return view.getFloat32(0, false);
};

const numberToFloat32 = (num) => {
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    view.setFloat32(0, num, false);
    return BigInt(view.getUint32(0, false));
};

// IEEE 754 Binary64 (Double precision) using DataView
const float64ToNumber = (bits) => {
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    view.setBigUint64(0, bits, false);
    return view.getFloat64(0, false);
};

const numberToFloat64 = (num) => {
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    view.setFloat64(0, num, false);
    return view.getBigUint64(0, false);
};

// Minifloat 8-bit (1 sign, 4 exp, 3 mantissa, bias=7) - common variant
const minifloat8ToNumber = (bits) => {
    const sign = (bits >> 7) & 1;
    const exp = (bits >> 3) & 0xF;
    const mant = bits & 0x7;
    if (exp === 0) {
        if (mant === 0) return sign ? -0 : 0;
        return (sign ? -1 : 1) * mant / 8 * Math.pow(2, -6);
    }
    if (exp === 15) return mant === 0 ? (sign ? -Infinity : Infinity) : NaN;
    return (sign ? -1 : 1) * (1 + mant / 8) * Math.pow(2, exp - 7);
};

const numberToMinifloat8 = (num) => {
    if (isNaN(num)) return 0x7C; // NaN: exp=15, mant!=0
    if (!isFinite(num)) return num > 0 ? 0x78 : 0xF8; // Inf: exp=15, mant=0
    if (num === 0) return Object.is(num, -0) ? 0x80 : 0;
    const sign = num < 0 ? 1 : 0;
    const abs = Math.abs(num);
    if (abs < Math.pow(2, -9)) return sign << 7; // Too small, underflow to zero
    if (abs >= 240) return (sign << 7) | 0x78; // Overflow to infinity
    // Subnormal range
    if (abs < Math.pow(2, -6)) {
        const mant = Math.round(abs / Math.pow(2, -6) * 8);
        return (sign << 7) | (mant & 0x7);
    }
    // Normal range
    let exp = Math.floor(Math.log2(abs));
    let mant = abs / Math.pow(2, exp) - 1;
    exp += 7;
    if (exp <= 0) { exp = 0; mant = abs / Math.pow(2, -6); }
    if (exp >= 15) return (sign << 7) | 0x78; // Overflow
    return (sign << 7) | ((exp & 0xF) << 3) | (Math.round(mant * 8) & 0x7);
};

// IBM Hexadecimal Floating Point (32-bit): 1 sign, 7 exp (base 16), 24 mantissa
const ibmFloat32ToNumber = (bits) => {
    const sign = (bits >> 31) & 1;
    const exp = (bits >> 24) & 0x7F;
    const mant = bits & 0xFFFFFF;
    if (mant === 0 && exp === 0) return sign ? -0 : 0;
    const value = (mant / 0x1000000) * Math.pow(16, exp - 64);
    return sign ? -value : value;
};

// VAX F_floating (32-bit): 1 sign, 8 exp (bias 128), 23 mantissa, hidden bit
const vaxFToNumber = (bits) => {
    // VAX has different byte order: swap 16-bit words
    const swapped = ((bits & 0xFFFF) << 16) | ((bits >> 16) & 0xFFFF);
    const sign = (swapped >> 15) & 1;
    const exp = (swapped >> 7) & 0xFF;
    const mant = ((swapped & 0x7F) << 16) | ((bits >> 16) & 0xFFFF);
    if (exp === 0) return 0;
    const value = (0.5 + mant / 0x1000000) * Math.pow(2, exp - 128);
    return sign ? -value : value;
};

// Microsoft Binary Format (MBF) 32-bit: 8 exp, 1 sign, 23 mantissa
const mbf32ToNumber = (bits) => {
    const exp = (bits >> 24) & 0xFF;
    if (exp === 0) return 0;
    const sign = (bits >> 23) & 1;
    const mant = bits & 0x7FFFFF;
    const value = (0.5 + mant / 0x1000000) * Math.pow(2, exp - 128);
    return sign ? -value : value;
};

// Microsoft Binary Format (MBF) 64-bit
const mbf64ToNumber = (bits) => {
    const exp = Number((bits >> 56n) & 0xFFn);
    if (exp === 0) return 0;
    const sign = Number((bits >> 55n) & 1n);
    const mant = bits & 0x7FFFFFFFFFFFFFn;
    const value = (0.5 + Number(mant) / 0x80000000000000) * Math.pow(2, exp - 128);
    return sign ? -value : value;
};

// Custom Decimal8 (custom BID-like): 1 sign, 3 exp (bias=4), 4 coefficient
const decimal8ToNumber = (bits) => {
    const sign = (bits >> 7) & 1;
    const exp = (bits >> 4) & 0x7;
    const coeff = bits & 0xF;
    if (exp === 7 && coeff >= 14) return coeff === 14 ? (sign ? -Infinity : Infinity) : NaN;
    if (coeff === 0 && exp === 0) return sign ? -0 : 0;
    const value = coeff * Math.pow(10, exp - 4);
    return sign ? -value : value;
};

// Custom Decimal16 (custom BID-like): 1 sign, 5 exp (bias=16), 10 coefficient
const decimal16ToNumber = (bits) => {
    const sign = (bits >> 15) & 1;
    const exp = (bits >> 10) & 0x1F;
    const coeff = bits & 0x3FF;
    if (exp === 31 && coeff >= 1022) return coeff === 1022 ? (sign ? -Infinity : Infinity) : NaN;
    if (coeff === 0 && exp === 0) return sign ? -0 : 0;
    const value = coeff * Math.pow(10, exp - 16);
    return sign ? -value : value;
};

// IEEE 754 Decimal32 (BID encoding - Binary Integer Decimal)
const decimal32ToNumber = (bits) => {
    const sign = (bits >> 31) & 1;
    const combo = (bits >> 23) & 0xFF;
    const trailing = bits & 0x7FFFFF;

    // Check for special values (combo field starts with 11)
    if ((combo >> 6) === 3) {
        if ((combo >> 5) === 0x1E) return sign ? -Infinity : Infinity;
        if ((combo >> 5) === 0x1F) return NaN;
        // Large coefficient encoding
        const exp = ((combo & 0x3) << 6) | ((bits >> 21) & 0x3F);
        const coeff = (8 + ((combo >> 2) & 1)) * 1000000 + (trailing & 0x1FFFFF);
        const value = coeff * Math.pow(10, exp - 101);
        return sign ? -value : value;
    }

    // Standard encoding
    const exp = (combo >> 1) & 0x7F;
    const leadDigit = (combo >> 3) & 0x7;
    const coeff = leadDigit * 10000000 + trailing;
    if (coeff === 0) return sign ? -0 : 0;
    const value = coeff * Math.pow(10, exp - 101);
    return sign ? -value : value;
};

// IEEE 754 Decimal64 (BID encoding)
const decimal64ToNumber = (bits) => {
    const sign = Number((bits >> 63n) & 1n);
    const combo = Number((bits >> 53n) & 0x3FFn);
    const trailing = bits & 0x1FFFFFFFFFFFFFn;

    // Check for special values
    if ((combo >> 8) === 3) {
        if ((combo >> 7) === 0x1E) return sign ? -Infinity : Infinity;
        if ((combo >> 7) === 0x1F) return NaN;
        // Large coefficient encoding
        const exp = ((combo & 0x3) << 8) | Number((bits >> 51n) & 0xFFn);
        const leadDigit = 8 + ((combo >> 2) & 1);
        const coeff = BigInt(leadDigit) * 10000000000000000n + (trailing & 0x7FFFFFFFFFFFFn);
        const value = Number(coeff) * Math.pow(10, exp - 398);
        return sign ? -value : value;
    }

    // Standard encoding
    const exp = (combo >> 2) & 0xFF;
    const leadDigit = combo & 0x7;
    const coeff = BigInt(leadDigit) * 10000000000000000n + trailing;
    if (coeff === 0n) return sign ? -0 : 0;
    const value = Number(coeff) * Math.pow(10, exp - 398);
    return sign ? -value : value;
};

// Posit format decoder (parameterized by nbits and es)
const positToNumber = (bits, nbits, es) => {
    const mask = (1n << BigInt(nbits)) - 1n;
    bits = bits & mask;

    // Special cases
    if (bits === 0n) return 0;
    if (bits === (1n << BigInt(nbits - 1))) return NaN; // NaR (Not a Real)

    const sign = Number((bits >> BigInt(nbits - 1)) & 1n);
    let p = sign ? ((1n << BigInt(nbits)) - bits) : bits;

    // Count regime bits (leading 0s or 1s after sign)
    let regimeBit = Number((p >> BigInt(nbits - 2)) & 1n);
    let regimeLen = 1;
    for (let i = nbits - 3; i >= 0; --i) {
        if (Number((p >> BigInt(i)) & 1n) === regimeBit)
            ++regimeLen;
        else
            break;
    }

    // Regime value
    const k = regimeBit ? regimeLen - 1 : -regimeLen;

    // Extract exponent (es bits after regime terminator)
    let expBits = 0;
    let bitsRemaining = nbits - 1 - regimeLen - 1; // -1 for sign, -1 for terminator
    if (bitsRemaining > 0) {
        const expWidth = Math.min(es, bitsRemaining);
        expBits = Number((p >> BigInt(bitsRemaining - expWidth)) & ((1n << BigInt(expWidth)) - 1n));
        expBits <<= (es - expWidth); // Left-align if truncated
        bitsRemaining -= expWidth;
    }

    // Remaining bits are fraction
    let frac = 1.0;
    if (bitsRemaining > 0) {
        const fracBits = Number(p & ((1n << BigInt(bitsRemaining)) - 1n));
        frac = 1 + fracBits / Math.pow(2, bitsRemaining);
    }

    // useed = 2^(2^es)
    const useed = Math.pow(2, Math.pow(2, es));
    const value = Math.pow(useed, k) * Math.pow(2, expBits) * frac;
    return sign ? -value : value;
};

// TensorFloat-32 (TF32): 1 sign, 8 exponent, 10 mantissa (19 bits used, stored in 32)
const tf32ToNumber = (bits) => {
    // TF32 uses upper 19 bits of a 32-bit container
    const sign = (bits >> 31) & 1;
    const exp = (bits >> 23) & 0xFF;
    const mant = (bits >> 13) & 0x3FF; // 10-bit mantissa

    if (exp === 0) {
        // Denormalized
        if (mant === 0) return sign ? -0 : 0;
        const value = mant / 1024 * Math.pow(2, -126);
        return sign ? -value : value;
    }
    if (exp === 255) {
        if (mant !== 0) return NaN;
        return sign ? -Infinity : Infinity;
    }

    // Normalized
    const value = (1 + mant / 1024) * Math.pow(2, exp - 127);
    return sign ? -value : value;
};

// --- FIXED POINT / DECIMAL CONVERSIONS ---

// Q format fixed point (e.g., Q15.16 for 32-bit)
const fixedPointToNumber = (bits, intBits, fracBits, signed) => {
    let val = bits;
    if (signed) {
        const signBit = 1n << BigInt(intBits + fracBits - 1);
        if (val >= signBit) val = val - (1n << BigInt(intBits + fracBits));
    }
    return Number(val) / Math.pow(2, fracBits);
};

// BCD (Binary Coded Decimal) - packed, 2 digits per byte
// Returns { valid: boolean, value: BigInt }
const bcdToNumber = (bits, width) => {
    let result = 0n;
    let multiplier = 1n;
    const bytes = width / 8;
    for (let i = 0; i < bytes; ++i) {
        const byte = Number((bits >> BigInt(i * 8)) & 0xFFn);
        const lo = byte & 0xF;
        const hi = (byte >> 4) & 0xF;
        if (lo > 9 || hi > 9) return { valid: false, value: 0n };
        result += BigInt(lo) * multiplier;
        multiplier *= 10n;
        result += BigInt(hi) * multiplier;
        multiplier *= 10n;
    }
    return { valid: true, value: result };
};

const numberToBcd = (num, width) => {
    if (num < 0n) return 0n;
    let result = 0n;
    const bytes = width / 8;
    for (let i = 0; i < bytes; ++i) {
        const lo = num % 10n;
        num = num / 10n;
        const hi = num % 10n;
        num = num / 10n;
        result |= ((hi << 4n) | lo) << BigInt(i * 8);
    }
    return result;
};

// Unpacked BCD: one digit per byte (in lower nibble, upper nibble typically 0 or 0x3 for ASCII)
const unpackedBcdToNumber = (bits, width) => {
    let result = 0n;
    let multiplier = 1n;
    const bytes = width / 8;
    for (let i = 0; i < bytes; ++i) {
        const byte = Number((bits >> BigInt(i * 8)) & 0xFFn);
        const digit = byte & 0xF;
        if (digit > 9) return { valid: false, value: 0n };
        result += BigInt(digit) * multiplier;
        multiplier *= 10n;
    }
    return { valid: true, value: result };
};

const extractUnpackedBcdArray = (val, typeBits, totalBits) => {
    if (totalBits <= typeBits) {
        const n = unpackedBcdToNumber(val, typeBits);
        return n.valid ? n.value.toString() : 'Invalid BCD';
    }
    return formatArray(extractUnsignedArray(val, typeBits, totalBits).map(x => {
        const n = unpackedBcdToNumber(x, typeBits);
        return n.valid ? n.value.toString() : '?';
    }));
};

// .NET Decimal (128-bit): 96-bit integer + 1 sign bit + 5 scale bits (0-28)
// Format: [lo32][mid32][hi32][flags] where flags = sign(bit31) + scale(bits16-20)
const dotnetDecimalToNumber = (bits) => {
    const lo = bits & 0xFFFFFFFFn;
    const mid = (bits >> 32n) & 0xFFFFFFFFn;
    const hi = (bits >> 64n) & 0xFFFFFFFFn;
    const flags = (bits >> 96n) & 0xFFFFFFFFn;
    const sign = (flags >> 31n) & 1n;
    const scale = Number((flags >> 16n) & 0x1Fn);
    const mantissa = (hi << 64n) | (mid << 32n) | lo;
    const value = Number(mantissa) / Math.pow(10, scale);
    return sign ? -value : value;
};

// OLE Currency (64-bit scaled integer, /10000)
const currencyToNumber = (bits) => {
    const signed = toSigned(bits, 64);
    return Number(signed) / 10000;
};

const formatCurrencyBits = (bits) => {
    const signed = toSigned(bits, 64);
    const isNeg = signed < 0n;
    const abs = isNeg ? -signed : signed;
    const intPart = abs / 10000n;
    const fracPart = abs % 10000n;
    const fracStr = fracPart.toString().padStart(4, '0').replace(/0+$/, '') || '0';
    return '$' + (isNeg ? '-' : '') + intPart.toString() + '.' + fracStr;
};

// --- GRAY CODE CONVERSION ---
const grayToBinary = (gray) => {
    let binary = gray;
    let mask = gray >> 1n;
    while (mask > 0n) {
        binary ^= mask;
        mask >>= 1n;
    }
    return binary;
};

// --- ASCII CONTROL CHARACTER NAMES ---
const ASCII_CONTROL = [
    'NUL', 'SOH', 'STX', 'ETX', 'EOT', 'ENQ', 'ACK', 'BEL',
    'BS', 'HT', 'LF', 'VT', 'FF', 'CR', 'SO', 'SI',
    'DLE', 'DC1', 'DC2', 'DC3', 'DC4', 'NAK', 'SYN', 'ETB',
    'CAN', 'EM', 'SUB', 'ESC', 'FS', 'GS', 'RS', 'US'
];

const formatAsciiChar = (c) => {
    if (c < 32) return ASCII_CONTROL[c];
    if (c === 32) return 'SP';
    if (c === 127) return 'DEL';
    if (c > 127) return `\\x${c.toString(16).padStart(2, '0')}`;
    return String.fromCharCode(c);
};

// --- EBCDIC TO ASCII CONVERSION TABLE ---
const EBCDIC_TO_ASCII = [
    0x00,0x01,0x02,0x03,0x9C,0x09,0x86,0x7F,0x97,0x8D,0x8E,0x0B,0x0C,0x0D,0x0E,0x0F,
    0x10,0x11,0x12,0x13,0x9D,0x85,0x08,0x87,0x18,0x19,0x92,0x8F,0x1C,0x1D,0x1E,0x1F,
    0x80,0x81,0x82,0x83,0x84,0x0A,0x17,0x1B,0x88,0x89,0x8A,0x8B,0x8C,0x05,0x06,0x07,
    0x90,0x91,0x16,0x93,0x94,0x95,0x96,0x04,0x98,0x99,0x9A,0x9B,0x14,0x15,0x9E,0x1A,
    0x20,0xA0,0xE2,0xE4,0xE0,0xE1,0xE3,0xE5,0xE7,0xF1,0xA2,0x2E,0x3C,0x28,0x2B,0x7C,
    0x26,0xE9,0xEA,0xEB,0xE8,0xED,0xEE,0xEF,0xEC,0xDF,0x21,0x24,0x2A,0x29,0x3B,0xAC,
    0x2D,0x2F,0xC2,0xC4,0xC0,0xC1,0xC3,0xC5,0xC7,0xD1,0xA6,0x2C,0x25,0x5F,0x3E,0x3F,
    0xF8,0xC9,0xCA,0xCB,0xC8,0xCD,0xCE,0xCF,0xCC,0x60,0x3A,0x23,0x40,0x27,0x3D,0x22,
    0xD8,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0xAB,0xBB,0xF0,0xFD,0xFE,0xB1,
    0xB0,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,0x70,0x71,0x72,0xAA,0xBA,0xE6,0xB8,0xC6,0xA4,
    0xB5,0x7E,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0xA1,0xBF,0xD0,0xDD,0xDE,0xAE,
    0x5E,0xA3,0xA5,0xB7,0xA9,0xA7,0xB6,0xBC,0xBD,0xBE,0x5B,0x5D,0xAF,0xA8,0xB4,0xD7,
    0x7B,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0xAD,0xF4,0xF6,0xF2,0xF3,0xF5,
    0x7D,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x50,0x51,0x52,0xB9,0xFB,0xFC,0xF9,0xFA,0xFF,
    0x5C,0xF7,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0xB2,0xD4,0xD6,0xD2,0xD3,0xD5,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0xB3,0xDB,0xDC,0xD9,0xDA,0x9F
];

const ebcdicToAscii = (ebcdic) => EBCDIC_TO_ASCII[ebcdic & 0xFF];

// --- FP8 CONVERSION FUNCTIONS ---
// FP8 E4M3 (1 sign, 4 exp, 3 mant, bias=7) - ML inference format
const fp8E4M3ToNumber = (bits) => {
    const sign = (bits >> 7) & 1;
    const exp = (bits >> 3) & 0xF;
    const mant = bits & 0x7;
    if (exp === 0) {
        if (mant === 0) return sign ? -0 : 0;
        return (sign ? -1 : 1) * mant / 8 * Math.pow(2, -6); // Subnormal
    }
    if (exp === 15) return NaN; // E4M3 uses all-ones exp for NaN (no infinity)
    return (sign ? -1 : 1) * (1 + mant / 8) * Math.pow(2, exp - 7);
};

// FP8 E5M2 (1 sign, 5 exp, 2 mant, bias=15) - ML training format
const fp8E5M2ToNumber = (bits) => {
    const sign = (bits >> 7) & 1;
    const exp = (bits >> 2) & 0x1F;
    const mant = bits & 0x3;
    if (exp === 0) {
        if (mant === 0) return sign ? -0 : 0;
        return (sign ? -1 : 1) * mant / 4 * Math.pow(2, -14); // Subnormal
    }
    if (exp === 31) return mant === 0 ? (sign ? -Infinity : Infinity) : NaN;
    return (sign ? -1 : 1) * (1 + mant / 4) * Math.pow(2, exp - 15);
};

// --- ZIGZAG ENCODING (Protocol Buffers) ---
const zigzagDecode = (val, width) => {
    const n = val;
    return (n >> 1n) ^ -(n & 1n);
};

// --- HSV COLOR CONVERSION ---
const rgbToHsv = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    const d = max - min;
    let h = 0, s = max === 0 ? 0 : d / max, v = max;
    if (d !== 0) {
        if (max === r) h = ((g - b) / d + 6) % 6;
        else if (max === g) h = (b - r) / d + 2;
        else h = (r - g) / d + 4;
        h /= 6;
    }
    return { h: Math.round(h * 360), s: Math.round(s * 100), v: Math.round(v * 100) };
};

const hsvToRgb = (h, s, v) => {
    h /= 360; s /= 100; v /= 100;
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);
    let r, g, b;
    switch (i % 6) {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        case 5: r = v; g = p; b = q; break;
    }
    return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
};

// -law to linear PCM (ITU-T G.711)
const mulawToLinear = (mulaw) => {
    mulaw = ~mulaw & 0xFF;
    const sign = mulaw & 0x80;
    const exponent = (mulaw >> 4) & 0x07;
    const mantissa = mulaw & 0x0F;
    let sample = ((mantissa << 3) + 0x84) << exponent;
    sample -= 0x84;
    return sign ? -sample : sample;
};

// A-law to linear PCM (ITU-T G.711)
const alawToLinear = (alaw) => {
    alaw ^= 0x55;
    const sign = alaw & 0x80;
    const exponent = (alaw >> 4) & 0x07;
    const mantissa = alaw & 0x0F;
    let sample = exponent === 0 ? (mantissa << 4) + 8 : ((mantissa << 4) + 0x108) << (exponent - 1);
    return sign ? -sample : sample;
};

// MIDI note names
const MIDI_NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
const midiToNoteName = (note) => {
    if (note < 0 || note > 127) return 'Invalid';
    const octave = Math.floor(note / 12) - 1;
    return `${MIDI_NOTES[note % 12]}${octave}`;
};

// --- FORMAT DEFINITIONS ---
const FORMAT_CATEGORIES = {
    integers: { name: 'Integers', color: 'cyan' },
    floats: { name: 'IEEE 754 Floats', color: 'emerald' },
    ai_floats: { name: 'AI/ML Floats', color: 'purple' },
    exotic_floats: { name: 'Exotic Floats', color: 'amber' },
    fixed: { name: 'Fixed Point', color: 'violet' },
    decimal: { name: 'Decimal/BCD', color: 'pink' },
    colors: { name: 'Colors', color: 'rose' },
    datetime: { name: 'Date/Time', color: 'sky' },
    audio: { name: 'Audio', color: 'fuchsia' },
    special: { name: 'Special', color: 'orange' },
    characters: { name: 'Characters', color: 'lime' }
};

const FORMATS = [
    // === INTEGERS ===
    // Each type automatically displays as array when bit width > type size
    { id: 'uint8', category: 'integers', bits: 8, names: ['Byte', 'UInt8', 'byte', 'u8', 'unsigned char', 'BYTE'],
      components: [
        { name: 'High Nibble', start: 4, width: 4 },
        { name: 'Low Nibble', start: 0, width: 4 }
      ],
      convert: (v, w) => w > 8 ? extractUnsignedArray(v, 8, w) : v,
      display: (v, w) => w > 8 ? formatArray(extractUnsignedArray(v, 8, w)) : v.toString() },
    { id: 'int8', category: 'integers', bits: 8, names: ['SByte', 'Int8', 'sbyte', 'i8', 'signed char', 'char'],
      components: [
        { name: 'Sign [B0]', start: 7, width: 1, color: '#ef4444' },
        { name: 'Mag [B0]', start: 0, width: 7, color: '#22c55e' }
      ],
      convert: (v, w) => w > 8 ? extractSignedArray(v, 8, w) : toSigned(v, 8),
      display: (v, w) => w > 8 ? formatArray(extractSignedArray(v, 8, w)) : toSigned(v, 8).toString() },

    { id: 'uint16_le', category: 'integers', bits: 16, names: ['Word', 'UInt16', 'ushort', 'u16', 'word', 'WORD', 'unsigned short'],
      endian: 'LE',
      components: [
        { name: 'Byte 1', start: 8, width: 8, color: '#22c55e' },
        { name: 'Byte 0', start: 0, width: 8, color: '#3b82f6' }
      ],
      convert: (v, w) => w > 16 ? extractUnsignedArray(v, 16, w) : v,
      display: (v, w) => w > 16 ? formatArray(extractUnsignedArray(v, 16, w)) : v.toString() },
    { id: 'uint16_be', category: 'integers', bits: 16, names: ['Word BE', 'UInt16 BE', 'u16be'],
      endian: 'BE',
      components: [
        { name: 'Byte 0', start: 8, width: 8, color: '#3b82f6' },
        { name: 'Byte 1', start: 0, width: 8, color: '#22c55e' }
      ],
      convert: (v, w) => w > 16 ? extractUnsignedArray(v, 16, w).map(x => swapBytes(x, 16)) : swapBytes(v, 16),
      display: (v, w) => w > 16 ? formatArray(extractUnsignedArray(v, 16, w).map(x => swapBytes(x, 16))) : swapBytes(v, 16).toString() },
    { id: 'int16_le', category: 'integers', bits: 16, names: ['Short', 'Int16', 'short', 'i16', 'signed short'],
      endian: 'LE',
      components: [
        { name: 'Sign [B1]', start: 15, width: 1, color: '#ef4444' },
        { name: 'Mag Hi [B1]', start: 8, width: 7, color: '#15803d' },
        { name: 'Mag Lo [B0]', start: 0, width: 8, color: '#86efac' }
      ],
      convert: (v, w) => w > 16 ? extractSignedArray(v, 16, w) : toSigned(v, 16),
      display: (v, w) => w > 16 ? formatArray(extractSignedArray(v, 16, w)) : toSigned(v, 16).toString() },
    { id: 'int16_be', category: 'integers', bits: 16, names: ['Short BE', 'Int16 BE', 'i16be'],
      endian: 'BE',
      components: [
        { name: 'Mag Lo [B0]', start: 8, width: 8, color: '#86efac' },
        { name: 'Sign [B1]', start: 7, width: 1, color: '#ef4444' },
        { name: 'Mag Hi [B1]', start: 0, width: 7, color: '#15803d' }
      ],
      convert: (v, w) => w > 16 ? extractSignedArray(v, 16, w).map(x => toSigned(swapBytes(fromSigned(x, 16), 16), 16)) : toSigned(swapBytes(v, 16), 16),
      display: (v, w) => w > 16 ? formatArray(extractUnsignedArray(v, 16, w).map(x => toSigned(swapBytes(x, 16), 16))) : toSigned(swapBytes(v, 16), 16).toString() },

    { id: 'uint32_le', category: 'integers', bits: 32, names: ['DWord', 'UInt32', 'uint', 'u32', 'dword', 'DWORD', 'unsigned int', 'unsigned long'],
      endian: 'LE',
      components: [
        { name: 'Byte 3', start: 24, width: 8, color: '#ef4444' },
        { name: 'Byte 2', start: 16, width: 8, color: '#eab308' },
        { name: 'Byte 1', start: 8, width: 8, color: '#22c55e' },
        { name: 'Byte 0', start: 0, width: 8, color: '#3b82f6' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w) : v,
      display: (v, w) => w > 32 ? formatArray(extractUnsignedArray(v, 32, w)) : v.toString() },
    { id: 'uint32_be', category: 'integers', bits: 32, names: ['DWord BE', 'UInt32 BE', 'u32be'],
      endian: 'BE',
      components: [
        { name: 'Byte 0', start: 24, width: 8, color: '#3b82f6' },
        { name: 'Byte 1', start: 16, width: 8, color: '#22c55e' },
        { name: 'Byte 2', start: 8, width: 8, color: '#eab308' },
        { name: 'Byte 3', start: 0, width: 8, color: '#ef4444' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w).map(x => swapBytes(x, 32)) : swapBytes(v, 32),
      display: (v, w) => w > 32 ? formatArray(extractUnsignedArray(v, 32, w).map(x => swapBytes(x, 32))) : swapBytes(v, 32).toString() },
    { id: 'int32_le', category: 'integers', bits: 32, names: ['Int', 'Int32', 'int', 'i32', 'signed int', 'long'],
      endian: 'LE',
      components: [
        { name: 'Sign [B3]', start: 31, width: 1, color: '#ef4444' },
        { name: 'Mag Hi [B3]', start: 24, width: 7, color: '#15803d' },
        { name: 'Mag [B2]', start: 16, width: 8, color: '#22c55e' },
        { name: 'Mag [B1]', start: 8, width: 8, color: '#4ade80' },
        { name: 'Mag Lo [B0]', start: 0, width: 8, color: '#86efac' }
      ],
      convert: (v, w) => w > 32 ? extractSignedArray(v, 32, w) : toSigned(v, 32),
      display: (v, w) => w > 32 ? formatArray(extractSignedArray(v, 32, w)) : toSigned(v, 32).toString() },
    { id: 'int32_be', category: 'integers', bits: 32, names: ['Int BE', 'Int32 BE', 'i32be'],
      endian: 'BE',
      components: [
        { name: 'Mag Lo [B0]', start: 24, width: 8, color: '#86efac' },
        { name: 'Mag [B1]', start: 16, width: 8, color: '#4ade80' },
        { name: 'Mag [B2]', start: 8, width: 8, color: '#22c55e' },
        { name: 'Sign [B3]', start: 7, width: 1, color: '#ef4444' },
        { name: 'Mag Hi [B3]', start: 0, width: 7, color: '#15803d' }
      ],
      convert: (v, w) => w > 32 ? extractSignedArray(v, 32, w).map(x => toSigned(swapBytes(fromSigned(x, 32), 32), 32)) : toSigned(swapBytes(v, 32), 32),
      display: (v, w) => w > 32 ? formatArray(extractUnsignedArray(v, 32, w).map(x => toSigned(swapBytes(x, 32), 32))) : toSigned(swapBytes(v, 32), 32).toString() },

    { id: 'uint64_le', category: 'integers', bits: 64, names: ['QWord', 'UInt64', 'ulong', 'u64', 'qword', 'QWORD', 'unsigned long long'],
      endian: 'LE',
      components: [
        { name: 'Byte 7', start: 56, width: 8, color: '#f97316' },
        { name: 'Byte 6', start: 48, width: 8, color: '#06b6d4' },
        { name: 'Byte 5', start: 40, width: 8, color: '#ec4899' },
        { name: 'Byte 4', start: 32, width: 8, color: '#a855f7' },
        { name: 'Byte 3', start: 24, width: 8, color: '#ef4444' },
        { name: 'Byte 2', start: 16, width: 8, color: '#eab308' },
        { name: 'Byte 1', start: 8, width: 8, color: '#22c55e' },
        { name: 'Byte 0', start: 0, width: 8, color: '#3b82f6' }
      ],
      convert: (v) => v, display: (v) => v.toString() },
    { id: 'uint64_be', category: 'integers', bits: 64, names: ['QWord BE', 'UInt64 BE', 'u64be'],
      endian: 'BE',
      components: [
        { name: 'Byte 0', start: 56, width: 8, color: '#3b82f6' },
        { name: 'Byte 1', start: 48, width: 8, color: '#22c55e' },
        { name: 'Byte 2', start: 40, width: 8, color: '#eab308' },
        { name: 'Byte 3', start: 32, width: 8, color: '#ef4444' },
        { name: 'Byte 4', start: 24, width: 8, color: '#a855f7' },
        { name: 'Byte 5', start: 16, width: 8, color: '#ec4899' },
        { name: 'Byte 6', start: 8, width: 8, color: '#06b6d4' },
        { name: 'Byte 7', start: 0, width: 8, color: '#f97316' }
      ],
      convert: (v) => swapBytes(v, 64), display: (v) => swapBytes(v, 64).toString() },
    { id: 'int64_le', category: 'integers', bits: 64, names: ['Long', 'Int64', 'long long', 'i64', 'signed long long'],
      endian: 'LE',
      components: [
        { name: 'Sign [B7]', start: 63, width: 1, color: '#ef4444' },
        { name: 'Mag Hi [B7]', start: 56, width: 7, color: '#14532d' },
        { name: 'Mag [B6]', start: 48, width: 8, color: '#15803d' },
        { name: 'Mag [B5]', start: 40, width: 8, color: '#16a34a' },
        { name: 'Mag [B4]', start: 32, width: 8, color: '#22c55e' },
        { name: 'Mag [B3]', start: 24, width: 8, color: '#4ade80' },
        { name: 'Mag [B2]', start: 16, width: 8, color: '#86efac' },
        { name: 'Mag [B1]', start: 8, width: 8, color: '#bbf7d0' },
        { name: 'Mag Lo [B0]', start: 0, width: 8, color: '#dcfce7' }
      ],
      convert: (v) => toSigned(v, 64), display: (v) => toSigned(v, 64).toString() },
    { id: 'int64_be', category: 'integers', bits: 64, names: ['Long BE', 'Int64 BE', 'i64be'],
      endian: 'BE',
      components: [
        { name: 'Mag Lo [B0]', start: 56, width: 8, color: '#dcfce7' },
        { name: 'Mag [B1]', start: 48, width: 8, color: '#bbf7d0' },
        { name: 'Mag [B2]', start: 40, width: 8, color: '#86efac' },
        { name: 'Mag [B3]', start: 32, width: 8, color: '#4ade80' },
        { name: 'Mag [B4]', start: 24, width: 8, color: '#22c55e' },
        { name: 'Mag [B5]', start: 16, width: 8, color: '#16a34a' },
        { name: 'Mag [B6]', start: 8, width: 8, color: '#15803d' },
        { name: 'Sign [B7]', start: 7, width: 1, color: '#ef4444' },
        { name: 'Mag Hi [B7]', start: 0, width: 7, color: '#14532d' }
      ],
      convert: (v) => toSigned(swapBytes(v, 64), 64), display: (v) => toSigned(swapBytes(v, 64), 64).toString() },

    // === IEEE 754 FLOATS ===
    { id: 'float16_le', category: 'floats', bits: 16, names: ['Float16', 'half', 'f16', 'binary16', '__fp16'],
      endian: 'LE',
      components: [
        { name: 'Sign [B1]', start: 15, width: 1, color: '#ef4444' },
        { name: 'Exp [B1]', start: 10, width: 5, color: '#f97316' },
        { name: 'Mant Hi [B1]', start: 8, width: 2, color: '#1d4ed8' },
        { name: 'Mant Lo [B0]', start: 0, width: 8, color: '#93c5fd' }
      ],
      convert: (v, w) => w > 16 ? extractUnsignedArray(v, 16, w).map(x => float16ToNumber(Number(x))) : float16ToNumber(Number(v)),
      display: (v, w) => extractAndFormatBits(v, 16, w, formatFloat16Bits) },
    { id: 'float16_be', category: 'floats', bits: 16, names: ['Float16 BE', 'f16be'],
      endian: 'BE',
      components: [
        { name: 'Mant Lo [B0]', start: 8, width: 8, color: '#93c5fd' },
        { name: 'Sign [B1]', start: 7, width: 1, color: '#ef4444' },
        { name: 'Exp [B1]', start: 2, width: 5, color: '#f97316' },
        { name: 'Mant Hi [B1]', start: 0, width: 2, color: '#1d4ed8' }
      ],
      convert: (v, w) => w > 16 ? extractUnsignedArray(v, 16, w).map(x => float16ToNumber(Number(swapBytes(x, 16)))) : float16ToNumber(Number(swapBytes(v, 16))),
      display: (v, w) => extractAndFormatBits(v, 16, w, x => formatFloat16Bits(swapBytes(x, 16))) },

    { id: 'float32_le', category: 'floats', bits: 32, names: ['Float32', 'float', 'f32', 'single', 'binary32', 'Single'],
      endian: 'LE',
      components: [
        { name: 'Sign [B3]', start: 31, width: 1, color: '#ef4444' },
        { name: 'Exp Hi [B3]', start: 24, width: 7, color: '#f97316' },
        { name: 'Exp Lo [B2]', start: 23, width: 1, color: '#fdba74' },
        { name: 'Mant Hi [B2]', start: 16, width: 7, color: '#1d4ed8' },
        { name: 'Mant Mid [B1]', start: 8, width: 8, color: '#3b82f6' },
        { name: 'Mant Lo [B0]', start: 0, width: 8, color: '#93c5fd' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w).map(x => float32ToNumber(x)) : float32ToNumber(v),
      display: (v, w) => extractAndFormatBits(v, 32, w, formatFloat32Bits) },
    { id: 'float32_be', category: 'floats', bits: 32, names: ['Float32 BE', 'f32be'],
      endian: 'BE',
      components: [
        { name: 'Mant Lo [B0]', start: 24, width: 8, color: '#93c5fd' },
        { name: 'Mant Mid [B1]', start: 16, width: 8, color: '#3b82f6' },
        { name: 'Exp Lo [B2]', start: 15, width: 1, color: '#fdba74' },
        { name: 'Mant Hi [B2]', start: 8, width: 7, color: '#1d4ed8' },
        { name: 'Sign [B3]', start: 7, width: 1, color: '#ef4444' },
        { name: 'Exp Hi [B3]', start: 0, width: 7, color: '#f97316' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w).map(x => float32ToNumber(swapBytes(x, 32))) : float32ToNumber(swapBytes(v, 32)),
      display: (v, w) => extractAndFormatBits(v, 32, w, x => formatFloat32Bits(swapBytes(x, 32))) },

    { id: 'float64_le', category: 'floats', bits: 64, names: ['Float64', 'double', 'f64', 'binary64', 'Double'],
      endian: 'LE',
      components: [
        { name: 'Sign [B7]', start: 63, width: 1, color: '#ef4444' },
        { name: 'Exp Hi [B7]', start: 56, width: 7, color: '#f97316' },
        { name: 'Exp Lo [B6]', start: 52, width: 4, color: '#fdba74' },
        { name: 'Mant Hi [B6]', start: 48, width: 4, color: '#1d4ed8' },
        { name: 'Mant [B5]', start: 40, width: 8, color: '#2563eb' },
        { name: 'Mant [B4]', start: 32, width: 8, color: '#3b82f6' },
        { name: 'Mant [B3]', start: 24, width: 8, color: '#60a5fa' },
        { name: 'Mant [B2]', start: 16, width: 8, color: '#7dd3fc' },
        { name: 'Mant [B1]', start: 8, width: 8, color: '#93c5fd' },
        { name: 'Mant Lo [B0]', start: 0, width: 8, color: '#bfdbfe' }
      ],
      convert: (v) => float64ToNumber(v), display: (v) => formatFloat64Bits(v) },
    { id: 'float64_be', category: 'floats', bits: 64, names: ['Float64 BE', 'f64be'],
      endian: 'BE',
      components: [
        { name: 'Mant Lo [B0]', start: 56, width: 8, color: '#bfdbfe' },
        { name: 'Mant [B1]', start: 48, width: 8, color: '#93c5fd' },
        { name: 'Mant [B2]', start: 40, width: 8, color: '#7dd3fc' },
        { name: 'Mant [B3]', start: 32, width: 8, color: '#60a5fa' },
        { name: 'Mant [B4]', start: 24, width: 8, color: '#3b82f6' },
        { name: 'Mant [B5]', start: 16, width: 8, color: '#2563eb' },
        { name: 'Exp Lo [B6]', start: 12, width: 4, color: '#fdba74' },
        { name: 'Mant Hi [B6]', start: 8, width: 4, color: '#1d4ed8' },
        { name: 'Sign [B7]', start: 7, width: 1, color: '#ef4444' },
        { name: 'Exp Hi [B7]', start: 0, width: 7, color: '#f97316' }
      ],
      convert: (v) => float64ToNumber(swapBytes(v, 64)), display: (v) => formatFloat64Bits(swapBytes(v, 64)) },

    // === EXOTIC FLOATS ===
    { id: 'bfloat8', category: 'ai_floats', bits: 8, names: ['BFloat8', 'bf8', 'brain float 8'],
      components: [
        { name: 'Sign', start: 7, width: 1, color: '#ef4444' },
        { name: 'Exponent', start: 3, width: 4, color: '#f97316' },
        { name: 'Mantissa', start: 0, width: 3, color: '#3b82f6' }
      ],
      convert: (v, w) => w > 8 ? extractUnsignedArray(v, 8, w).map(x => bfloat8ToNumber(Number(x))) : bfloat8ToNumber(Number(v)),
      display: (v, w) => extractAndFormatBits(v, 8, w, formatBFloat8Bits) },

    { id: 'bfloat16_le', category: 'ai_floats', bits: 16, names: ['BFloat16', 'bf16', 'brain float'],
      endian: 'LE',
      components: [
        { name: 'Sign [B1]', start: 15, width: 1, color: '#ef4444' },
        { name: 'Exp Hi [B1]', start: 8, width: 7, color: '#f97316' },
        { name: 'Exp Lo [B0]', start: 7, width: 1, color: '#fdba74' },
        { name: 'Mant [B0]', start: 0, width: 7, color: '#3b82f6' }
      ],
      convert: (v, w) => w > 16 ? extractUnsignedArray(v, 16, w).map(x => bfloat16ToNumber(Number(x))) : bfloat16ToNumber(Number(v)),
      display: (v, w) => extractAndFormatBits(v, 16, w, formatBFloat16Bits) },
    { id: 'bfloat16_be', category: 'ai_floats', bits: 16, names: ['BFloat16 BE', 'bf16be'],
      endian: 'BE',
      components: [
        { name: 'Exp Lo [B0]', start: 15, width: 1, color: '#fdba74' },
        { name: 'Mant [B0]', start: 8, width: 7, color: '#3b82f6' },
        { name: 'Sign [B1]', start: 7, width: 1, color: '#ef4444' },
        { name: 'Exp Hi [B1]', start: 0, width: 7, color: '#f97316' }
      ],
      convert: (v, w) => w > 16 ? extractUnsignedArray(v, 16, w).map(x => bfloat16ToNumber(Number(swapBytes(x, 16)))) : bfloat16ToNumber(Number(swapBytes(v, 16))),
      display: (v, w) => extractAndFormatBits(v, 16, w, x => formatBFloat16Bits(swapBytes(x, 16))) },

    { id: 'bfloat32_le', category: 'ai_floats', bits: 32, names: ['BFloat32', 'bf32', 'brain float 32'],
      endian: 'LE',
      components: [
        { name: 'Sign [B3]', start: 31, width: 1, color: '#ef4444' },
        { name: 'Exponent [B2-3]', start: 23, width: 8, color: '#f97316' },
        { name: 'Mantissa [B0-2]', start: 0, width: 23, color: '#3b82f6' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w).map(x => float32ToNumber(Number(x))) : float32ToNumber(Number(v)),
      display: (v, w) => extractAndFormatBits(v, 32, w, formatFloat32Bits) },
    { id: 'bfloat32_be', category: 'ai_floats', bits: 32, names: ['BFloat32 BE', 'bf32be'],
      endian: 'BE',
      components: [
        { name: 'Mantissa Lo [B0]', start: 24, width: 8, color: '#2563eb' },
        { name: 'Mantissa Mid [B1]', start: 16, width: 8, color: '#3b82f6' },
        { name: 'Mantissa Hi [B2]', start: 8, width: 7, color: '#60a5fa' },
        { name: 'Exp Lo [B2]', start: 15, width: 1, color: '#fdba74' },
        { name: 'Sign [B3]', start: 7, width: 1, color: '#ef4444' },
        { name: 'Exp Hi [B3]', start: 0, width: 7, color: '#f97316' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w).map(x => float32ToNumber(Number(swapBytes(x, 32)))) : float32ToNumber(Number(swapBytes(v, 32))),
      display: (v, w) => extractAndFormatBits(v, 32, w, x => formatFloat32Bits(swapBytes(x, 32))) },

    { id: 'bfloat64_le', category: 'ai_floats', bits: 64, names: ['BFloat64', 'bf64', 'brain float 64'],
      endian: 'LE',
      components: [
        { name: 'Sign [B7]', start: 63, width: 1, color: '#ef4444' },
        { name: 'Exponent [B6-7]', start: 55, width: 8, color: '#f97316' },
        { name: 'Mantissa [B0-6]', start: 0, width: 55, color: '#3b82f6' }
      ],
      convert: (v) => bfloat64ToNumber(v),
      display: (v) => formatBFloat64Bits(v) },
    { id: 'bfloat64_be', category: 'ai_floats', bits: 64, names: ['BFloat64 BE', 'bf64be'],
      endian: 'BE',
      components: [
        { name: 'Mantissa Lo [B0-5]', start: 8, width: 48, color: '#3b82f6' },
        { name: 'Mantissa Hi [B6]', start: 56, width: 7, color: '#60a5fa' },
        { name: 'Exp Lo [B6]', start: 63, width: 1, color: '#fdba74' },
        { name: 'Sign [B7]', start: 7, width: 1, color: '#ef4444' },
        { name: 'Exp Hi [B7]', start: 0, width: 7, color: '#f97316' }
      ],
      convert: (v) => bfloat64ToNumber(swapBytes(v, 64)),
      display: (v) => formatBFloat64Bits(swapBytes(v, 64)) },

    { id: 'minifloat8', category: 'floats', bits: 8, names: ['Minifloat8', 'fp8', 'float8'],
      components: [
        { name: 'Sign', start: 7, width: 1, color: '#ef4444' },
        { name: 'Exponent', start: 3, width: 4, color: '#f97316' },
        { name: 'Mantissa', start: 0, width: 3, color: '#3b82f6' }
      ],
      convert: (v, w) => w > 8 ? extractUnsignedArray(v, 8, w).map(x => minifloat8ToNumber(Number(x))) : minifloat8ToNumber(Number(v)),
      display: (v, w) => extractAndFormatBits(v, 8, w, formatMinifloat8Bits) },

    { id: 'ibm_float32', category: 'exotic_floats', bits: 32, names: ['IBM Float', 'IBM HFP', 'hex float'],
      components: [
        { name: 'Sign', start: 31, width: 1, color: '#ef4444' },
        { name: 'Exponent', start: 24, width: 7, color: '#f97316' },
        { name: 'Mantissa', start: 0, width: 24, color: '#3b82f6' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w).map(x => ibmFloat32ToNumber(Number(x))) : ibmFloat32ToNumber(Number(v)),
      display: (v, w) => extractAndFormatBits(v, 32, w, formatIBMFloat32Bits) },

    { id: 'vax_f', category: 'exotic_floats', bits: 32, names: ['VAX F', 'F_floating', 'VAX float'],
      components: [
        { name: 'Sign', start: 15, width: 1, color: '#ef4444' },
        { name: 'Exponent', start: 7, width: 8, color: '#f97316' },
        { name: 'Mantissa Hi', start: 0, width: 7, color: '#3b82f6' },
        { name: 'Mantissa Lo', start: 16, width: 16, color: '#60a5fa' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w).map(x => vaxFToNumber(Number(x))) : vaxFToNumber(Number(v)),
      display: (v, w) => extractAndFormatBits(v, 32, w, formatVAXFBits) },

    { id: 'mbf32', category: 'exotic_floats', bits: 32, names: ['MBF32', 'MS Binary', 'BASIC float'],
      components: [
        { name: 'Exponent', start: 24, width: 8, color: '#f97316' },
        { name: 'Sign', start: 23, width: 1, color: '#ef4444' },
        { name: 'Mantissa', start: 0, width: 23, color: '#3b82f6' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w).map(x => mbf32ToNumber(Number(x))) : mbf32ToNumber(Number(v)),
      display: (v, w) => extractAndFormatBits(v, 32, w, formatMBF32Bits) },

    { id: 'mbf64', category: 'exotic_floats', bits: 64, names: ['MBF64', 'MS Binary 64', 'BASIC double'],
      components: [
        { name: 'Exponent', start: 56, width: 8, color: '#f97316' },
        { name: 'Sign', start: 55, width: 1, color: '#ef4444' },
        { name: 'Mantissa', start: 0, width: 55, color: '#3b82f6' }
      ],
      convert: (v) => mbf64ToNumber(v), display: (v) => formatMBF64Bits(v) },

    // Decimal Floating Point (custom BID-like for 8/16-bit, IEEE 754 BID for 32/64-bit)
    { id: 'decimal8', category: 'exotic_floats', bits: 8, names: ['Decimal8', 'decimal8'],
      components: [
        { name: 'Sign', start: 7, width: 1, color: '#ef4444' },
        { name: 'Exponent', start: 4, width: 3, color: '#f97316' },
        { name: 'Coefficient', start: 0, width: 4, color: '#3b82f6' }
      ],
      convert: (v, w) => w > 8 ? extractUnsignedArray(v, 8, w).map(x => decimal8ToNumber(Number(x))) : decimal8ToNumber(Number(v)),
      display: (v, w) => extractAndFormatBits(v, 8, w, formatDecimal8Bits) },

    { id: 'decimal16_le', category: 'exotic_floats', bits: 16, names: ['Decimal16', 'decimal16'],
      endian: 'LE',
      components: [
        { name: 'Sign [B1]', start: 15, width: 1, color: '#ef4444' },
        { name: 'Exponent [B1]', start: 10, width: 5, color: '#f97316' },
        { name: 'Coeff Hi [B1]', start: 8, width: 2, color: '#60a5fa' },
        { name: 'Coeff Lo [B0]', start: 0, width: 8, color: '#3b82f6' }
      ],
      convert: (v, w) => w > 16 ? extractUnsignedArray(v, 16, w).map(x => decimal16ToNumber(Number(x))) : decimal16ToNumber(Number(v)),
      display: (v, w) => extractAndFormatBits(v, 16, w, formatDecimal16Bits) },
    { id: 'decimal16_be', category: 'exotic_floats', bits: 16, names: ['Decimal16 BE', 'decimal16be'],
      endian: 'BE',
      components: [
        { name: 'Coeff Lo [B0]', start: 8, width: 8, color: '#3b82f6' },
        { name: 'Sign [B1]', start: 7, width: 1, color: '#ef4444' },
        { name: 'Exponent [B1]', start: 2, width: 5, color: '#f97316' },
        { name: 'Coeff Hi [B1]', start: 0, width: 2, color: '#60a5fa' }
      ],
      convert: (v, w) => w > 16 ? extractUnsignedArray(v, 16, w).map(x => decimal16ToNumber(Number(swapBytes(x, 16)))) : decimal16ToNumber(Number(swapBytes(v, 16))),
      display: (v, w) => extractAndFormatBits(v, 16, w, x => formatDecimal16Bits(swapBytes(x, 16))) },

    { id: 'decimal32', category: 'exotic_floats', bits: 32, names: ['Decimal32', 'decimal32', '_Decimal32'],
      components: [
        { name: 'Sign', start: 31, width: 1, color: '#ef4444' },
        { name: 'Combination', start: 23, width: 8, color: '#f97316' },
        { name: 'Trailing Sig.', start: 0, width: 23, color: '#3b82f6' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w).map(x => decimal32ToNumber(Number(x))) : decimal32ToNumber(Number(v)),
      display: (v, w) => extractAndFormatBits(v, 32, w, formatDecimal32Bits) },

    { id: 'decimal64', category: 'exotic_floats', bits: 64, names: ['Decimal64', 'decimal64', '_Decimal64'],
      components: [
        { name: 'Sign', start: 63, width: 1, color: '#ef4444' },
        { name: 'Combination', start: 53, width: 10, color: '#f97316' },
        { name: 'Trailing Sig.', start: 0, width: 53, color: '#3b82f6' }
      ],
      convert: (v) => decimal64ToNumber(v), display: (v) => formatDecimal64Bits(v) },

    // Posit format (unum type III)
    { id: 'posit8', category: 'exotic_floats', bits: 8, names: ['Posit8', 'posit<8,0>'],
      components: [
        { name: 'Sign', start: 7, width: 1, color: '#ef4444' },
        { name: 'Regime+Exp+Frac', start: 0, width: 7, color: '#3b82f6' }
      ],
      convert: (v, w) => {
          if (w > 8) return extractUnsignedArray(v, 8, w).map(x => positToNumber(x, 8, 0));
          return positToNumber(v, 8, 0);
      },
      display: (v, w) => extractAndFormatBits(v, 8, w, x => formatPositBits(x, 8, 0)) },

    { id: 'posit16', category: 'exotic_floats', bits: 16, names: ['Posit16', 'posit<16,1>'],
      components: [
        { name: 'Sign', start: 15, width: 1, color: '#ef4444' },
        { name: 'Regime+Exp+Frac', start: 0, width: 15, color: '#3b82f6' }
      ],
      convert: (v, w) => {
          if (w > 16) return extractUnsignedArray(v, 16, w).map(x => positToNumber(x, 16, 1));
          return positToNumber(v, 16, 1);
      },
      display: (v, w) => extractAndFormatBits(v, 16, w, x => formatPositBits(x, 16, 1)) },

    { id: 'posit32', category: 'exotic_floats', bits: 32, names: ['Posit32', 'posit<32,2>'],
      components: [
        { name: 'Sign', start: 31, width: 1, color: '#ef4444' },
        { name: 'Regime+Exp+Frac', start: 0, width: 31, color: '#3b82f6' }
      ],
      convert: (v, w) => {
          if (w > 32) return extractUnsignedArray(v, 32, w).map(x => positToNumber(x, 32, 2));
          return positToNumber(v, 32, 2);
      },
      display: (v, w) => extractAndFormatBits(v, 32, w, x => formatPositBits(x, 32, 2)) },

    // TensorFloat-32 (NVIDIA tensor core format)
    { id: 'tf32', category: 'ai_floats', bits: 32, names: ['TF32', 'TensorFloat-32', 'TensorFloat32'],
      components: [
        { name: 'Sign', start: 31, width: 1, color: '#ef4444' },
        { name: 'Exponent', start: 23, width: 8, color: '#f97316' },
        { name: 'Mantissa', start: 13, width: 10, color: '#3b82f6' },
        { name: 'Unused', start: 0, width: 13, color: '#6b7280' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w).map(x => tf32ToNumber(Number(x))) : tf32ToNumber(Number(v)),
      display: (v, w) => extractAndFormatBits(v, 32, w, formatTF32Bits) },

    // === FIXED POINT ===
    { id: 'q7_8', category: 'fixed', bits: 16, names: ['Q7.8', 'fixed8.8'],
      components: [
        { name: 'Integer', start: 8, width: 8, color: '#22c55e' },
        { name: 'Fraction', start: 0, width: 8, color: '#a855f7' }
      ],
      convert: (v, w) => w > 16 ? extractUnsignedArray(v, 16, w).map(x => fixedPointToNumber(x, 8, 8, true)) : fixedPointToNumber(v, 8, 8, true),
      display: (v, w) => extractAndFormatBits(v, 16, w, x => formatFixedPointBits(x, 8, 8, true)) },

    { id: 'q15_16', category: 'fixed', bits: 32, names: ['Q15.16', 'fixed16.16'],
      components: [
        { name: 'Integer', start: 16, width: 16, color: '#22c55e' },
        { name: 'Fraction', start: 0, width: 16, color: '#a855f7' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w).map(x => fixedPointToNumber(x, 16, 16, true)) : fixedPointToNumber(v, 16, 16, true),
      display: (v, w) => extractAndFormatBits(v, 32, w, x => formatFixedPointBits(x, 16, 16, true)) },

    { id: 'q31_32', category: 'fixed', bits: 64, names: ['Q31.32', 'fixed32.32'],
      components: [
        { name: 'Integer', start: 32, width: 32, color: '#22c55e' },
        { name: 'Fraction', start: 0, width: 32, color: '#a855f7' }
      ],
      convert: (v) => fixedPointToNumber(v, 32, 32, true), display: (v) => formatFixedPointBits(v, 32, 32, true) },

    { id: 'uq8_8', category: 'fixed', bits: 16, names: ['UQ8.8', 'ufixed8.8'],
      components: [
        { name: 'Integer', start: 8, width: 8, color: '#22c55e' },
        { name: 'Fraction', start: 0, width: 8, color: '#a855f7' }
      ],
      convert: (v, w) => w > 16 ? extractUnsignedArray(v, 16, w).map(x => fixedPointToNumber(x, 8, 8, false)) : fixedPointToNumber(v, 8, 8, false),
      display: (v, w) => extractAndFormatBits(v, 16, w, x => formatFixedPointBits(x, 8, 8, false)) },

    { id: 'uq16_16', category: 'fixed', bits: 32, names: ['UQ16.16', 'ufixed16.16'],
      components: [
        { name: 'Integer', start: 16, width: 16, color: '#22c55e' },
        { name: 'Fraction', start: 0, width: 16, color: '#a855f7' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w).map(x => fixedPointToNumber(x, 16, 16, false)) : fixedPointToNumber(v, 16, 16, false),
      display: (v, w) => extractAndFormatBits(v, 32, w, x => formatFixedPointBits(x, 16, 16, false)) },

    { id: 'uq32_32', category: 'fixed', bits: 64, names: ['UQ32.32', 'ufixed32.32'],
      components: [
        { name: 'Integer', start: 32, width: 32, color: '#22c55e' },
        { name: 'Fraction', start: 0, width: 32, color: '#a855f7' }
      ],
      convert: (v) => fixedPointToNumber(v, 32, 32, false),
      display: (v) => formatFixedPointBits(v, 32, 32, false) },

    // === DECIMAL / BCD ===
    { id: 'bcd8', category: 'decimal', bits: 8, names: ['BCD8', 'packed BCD 8'],
      components: [
        { name: 'Digit 1', start: 4, width: 4 },
        { name: 'Digit 0', start: 0, width: 4 }
      ],
      convert: (v) => bcdToNumber(v, 8).value,
      display: (v, w) => extractBcdArray(v, 8, w) },

    { id: 'bcd16', category: 'decimal', bits: 16, names: ['BCD16', 'packed BCD 16'],
      components: [
        { name: 'Digit 3', start: 12, width: 4 },
        { name: 'Digit 2', start: 8, width: 4 },
        { name: 'Digit 1', start: 4, width: 4 },
        { name: 'Digit 0', start: 0, width: 4 }
      ],
      convert: (v) => bcdToNumber(v, 16).value,
      display: (v, w) => extractBcdArray(v, 16, w) },

    { id: 'bcd32', category: 'decimal', bits: 32, names: ['BCD32', 'packed BCD 32'],
      components: [
        { name: 'Digit 7', start: 28, width: 4 },
        { name: 'Digit 6', start: 24, width: 4 },
        { name: 'Digit 5', start: 20, width: 4 },
        { name: 'Digit 4', start: 16, width: 4 },
        { name: 'Digit 3', start: 12, width: 4 },
        { name: 'Digit 2', start: 8, width: 4 },
        { name: 'Digit 1', start: 4, width: 4 },
        { name: 'Digit 0', start: 0, width: 4 }
      ],
      convert: (v) => bcdToNumber(v, 32).value,
      display: (v, w) => extractBcdArray(v, 32, w) },

    { id: 'bcd64', category: 'decimal', bits: 64, names: ['BCD64', 'packed BCD 64'],
      components: [
        { name: 'Digit 15', start: 60, width: 4 },
        { name: 'Digit 14', start: 56, width: 4 },
        { name: 'Digit 13', start: 52, width: 4 },
        { name: 'Digit 12', start: 48, width: 4 },
        { name: 'Digit 11', start: 44, width: 4 },
        { name: 'Digit 10', start: 40, width: 4 },
        { name: 'Digit 9', start: 36, width: 4 },
        { name: 'Digit 8', start: 32, width: 4 },
        { name: 'Digit 7', start: 28, width: 4 },
        { name: 'Digit 6', start: 24, width: 4 },
        { name: 'Digit 5', start: 20, width: 4 },
        { name: 'Digit 4', start: 16, width: 4 },
        { name: 'Digit 3', start: 12, width: 4 },
        { name: 'Digit 2', start: 8, width: 4 },
        { name: 'Digit 1', start: 4, width: 4 },
        { name: 'Digit 0', start: 0, width: 4 }
      ],
      convert: (v) => bcdToNumber(v, 64).value, display: (v) => { const n = bcdToNumber(v, 64); return n.valid ? n.value.toString() : 'Invalid BCD'; } },

    // Unpacked BCD (one digit per byte, lower nibble only - use array syntax for multiple digits)
    { id: 'ubcd', category: 'decimal', bits: 8, names: ['Unpacked BCD', 'UBCD', 'zoned decimal'],
      components: [
        { name: 'Zone', start: 4, width: 4, color: '#6b7280' },
        { name: 'Digit', start: 0, width: 4, color: '#3b82f6' }
      ],
      convert: (v) => unpackedBcdToNumber(v, 8).value,
      display: (v, w) => extractUnpackedBcdArray(v, 8, w) },

    // === SPECIAL ===
    { id: 'currency64', category: 'special', bits: 64, names: ['Currency', 'OLE Currency', 'money', 'CY', 'CURRENCY'],
      components: [
        { name: 'Value', start: 0, width: 64, color: '#22c55e' }
      ],
      convert: (v) => currencyToNumber(v), display: (v) => formatCurrencyBits(v) },

    { id: 'filetime', category: 'datetime', bits: 64, names: ['FILETIME', 'Windows FILETIME'],
      components: [
        { name: '100ns Ticks', start: 0, width: 64, color: '#a855f7' }
      ],
      convert: (v) => new Date(Number(v / 10000n) - 11644473600000), display: (v) => {
          const d = new Date(Number(v / 10000n) - 11644473600000);
          return isNaN(d.getTime()) ? 'Invalid' : d.toISOString();
      }},

    { id: 'unix32', category: 'datetime', bits: 32, names: ['Unix32', 'time_t', 'Unix timestamp'],
      components: [
        { name: 'Seconds', start: 0, width: 32, color: '#a855f7' }
      ],
      convert: (v) => new Date(Number(v) * 1000), display: (v, w) => {
          if (w > 32) {
              const arr = extractUnsignedArray(v, 32, w);
              return formatArray(arr.map(x => {
                  const d = new Date(Number(x) * 1000);
                  return isNaN(d.getTime()) ? 'Invalid' : d.toISOString();
              }));
          }
          const d = new Date(Number(v) * 1000);
          return isNaN(d.getTime()) ? 'Invalid' : d.toISOString();
      }},

    { id: 'unix64', category: 'datetime', bits: 64, names: ['Unix64', 'time64_t'],
      components: [
        { name: 'Seconds', start: 0, width: 64, color: '#a855f7' }
      ],
      convert: (v) => new Date(Number(v) * 1000), display: (v) => {
          const d = new Date(Number(v) * 1000);
          return isNaN(d.getTime()) ? 'Invalid' : d.toISOString();
      }},

    { id: 'dosdate', category: 'datetime', bits: 32, names: ['DOS DateTime', 'FAT timestamp'],
      components: [
        { name: 'Year-1980', start: 25, width: 7, color: '#ef4444' },
        { name: 'Month', start: 21, width: 4, color: '#f97316' },
        { name: 'Day', start: 16, width: 5, color: '#eab308' },
        { name: 'Hour', start: 11, width: 5, color: '#22c55e' },
        { name: 'Minute', start: 5, width: 6, color: '#3b82f6' },
        { name: 'Second/2', start: 0, width: 5, color: '#a855f7' }
      ],
      convert: (v) => {
          const time = Number(v & 0xFFFFn);
          const date = Number((v >> 16n) & 0xFFFFn);
          const sec = (time & 0x1F) * 2;
          const min = (time >> 5) & 0x3F;
          const hour = (time >> 11) & 0x1F;
          const day = date & 0x1F;
          const month = ((date >> 5) & 0xF) - 1;
          const year = ((date >> 9) & 0x7F) + 1980;
          return new Date(year, month, day, hour, min, sec);
      },
      display: (v, w) => {
          const formatDos = (x) => {
              const time = Number(x & 0xFFFFn);
              const date = Number((x >> 16n) & 0xFFFFn);
              const sec = (time & 0x1F) * 2;
              const min = (time >> 5) & 0x3F;
              const hour = (time >> 11) & 0x1F;
              const day = date & 0x1F;
              const month = ((date >> 5) & 0xF);
              const year = ((date >> 9) & 0x7F) + 1980;
              return `${year}-${String(month).padStart(2,'0')}-${String(day).padStart(2,'0')} ${String(hour).padStart(2,'0')}:${String(min).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
          };
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(formatDos));
          return formatDos(v);
      }},

    { id: 'rgb24', category: 'colors', bits: 32, names: ['RGB', 'RGB24', 'color'],
      components: [
        { name: 'Unused', start: 24, width: 8, color: '#64748b' },
        { name: 'Red', start: 16, width: 8, color: '#ef4444' },
        { name: 'Green', start: 8, width: 8, color: '#22c55e' },
        { name: 'Blue', start: 0, width: 8, color: '#3b82f6' }
      ],
      convert: (v) => ({ r: Number((v >> 16n) & 0xFFn), g: Number((v >> 8n) & 0xFFn), b: Number(v & 0xFFn) }),
      display: (v, w) => {
          const formatRgb = (x) => {
              const r = Number((x >> 16n) & 0xFFn);
              const g = Number((x >> 8n) & 0xFFn);
              const b = Number(x & 0xFFn);
              return `rgb(${r},${g},${b})`;
          };
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(formatRgb));
          return formatRgb(v);
      }},

    { id: 'rgba32', category: 'colors', bits: 32, names: ['RGBA', 'RGBA32', 'ARGB'],
      components: [
        { name: 'Alpha', start: 24, width: 8, color: '#94a3b8' },
        { name: 'Red', start: 16, width: 8, color: '#ef4444' },
        { name: 'Green', start: 8, width: 8, color: '#22c55e' },
        { name: 'Blue', start: 0, width: 8, color: '#3b82f6' }
      ],
      convert: (v) => ({ a: Number((v >> 24n) & 0xFFn), r: Number((v >> 16n) & 0xFFn), g: Number((v >> 8n) & 0xFFn), b: Number(v & 0xFFn) }),
      display: (v, w) => {
          const formatRgba = (x) => {
              const a = Number((x >> 24n) & 0xFFn);
              const r = Number((x >> 16n) & 0xFFn);
              const g = Number((x >> 8n) & 0xFFn);
              const b = Number(x & 0xFFn);
              return `rgba(${r},${g},${b},${(a/255).toFixed(2)})`;
          };
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(formatRgba));
          return formatRgba(v);
      }},

    { id: 'fourcc', category: 'special', bits: 32, names: ['FourCC', 'FOURCC', 'magic'],
      components: [
        { name: 'Char 4', start: 24, width: 8, color: '#ef4444' },
        { name: 'Char 3', start: 16, width: 8, color: '#eab308' },
        { name: 'Char 2', start: 8, width: 8, color: '#22c55e' },
        { name: 'Char 1', start: 0, width: 8, color: '#3b82f6' }
      ],
      convert: (v) => String.fromCharCode(Number(v & 0xFFn), Number((v >> 8n) & 0xFFn), Number((v >> 16n) & 0xFFn), Number((v >> 24n) & 0xFFn)),
      display: (v, w) => {
          const formatFcc = (x) => {
              const chars = [x & 0xFFn, (x >> 8n) & 0xFFn, (x >> 16n) & 0xFFn, (x >> 24n) & 0xFFn];
              return '"' + chars.map(c => {
                  const n = Number(c);
                  return (n >= 32 && n < 127) ? String.fromCharCode(n) : '.';
              }).join('') + '"';
          };
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(formatFcc));
          return formatFcc(v);
      }},

    // === CHARACTERS ===
    { id: 'ascii8', category: 'characters', bits: 8, names: ['ASCII', 'Char', 'char'],
      convert: (v, w) => w > 8 ? extractUnsignedArray(v, 8, w).map(x => Number(x)) : Number(v & 0xFFn),
      display: (v, w) => {
          const fmt = (c) => {
              const n = Number(c);
              if (n < 32) return `'${ASCII_CONTROL[n]}'`;
              if (n === 32) return "'SP'";
              if (n === 127) return "'DEL'";
              if (n > 127) return `'\\x${n.toString(16).padStart(2, '0')}'`;
              return `'${String.fromCharCode(n)}'`;
          };
          if (w > 8) return formatArray(extractUnsignedArray(v, 8, w).map(fmt));
          return fmt(v);
      }},
    { id: 'ascii16', category: 'characters', bits: 16, names: ['ASCII16', 'Chars16'],
      convert: (v) => {
          const chars = [v & 0xFFn, (v >> 8n) & 0xFFn].map(c => Number(c));
          return chars.map(c => c >= 32 && c < 127 ? String.fromCharCode(c) : '.').join('');
      },
      display: (v, w) => {
          const fmt = (x) => {
              const chars = [x & 0xFFn, (x >> 8n) & 0xFFn].map(c => Number(c));
              return '"' + chars.map(c => c >= 32 && c < 127 ? String.fromCharCode(c) : '.').join('') + '"';
          };
          if (w > 16) return formatArray(extractUnsignedArray(v, 16, w).map(fmt));
          return fmt(v);
      }},
    { id: 'ascii32', category: 'characters', bits: 32, names: ['ASCII32', 'Chars32'],
      convert: (v) => {
          const chars = [v & 0xFFn, (v >> 8n) & 0xFFn, (v >> 16n) & 0xFFn, (v >> 24n) & 0xFFn].map(c => Number(c));
          return chars.map(c => c >= 32 && c < 127 ? String.fromCharCode(c) : '.').join('');
      },
      display: (v, w) => {
          const fmt = (x) => {
              const chars = [x & 0xFFn, (x >> 8n) & 0xFFn, (x >> 16n) & 0xFFn, (x >> 24n) & 0xFFn].map(c => Number(c));
              return '"' + chars.map(c => c >= 32 && c < 127 ? String.fromCharCode(c) : '.').join('') + '"';
          };
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(fmt));
          return fmt(v);
      }},
    { id: 'ascii64', category: 'characters', bits: 64, names: ['ASCII64', 'Chars64'],
      convert: (v) => {
          const chars = [];
          for (let i = 0; i < 8; ++i) chars.push(Number((v >> BigInt(i * 8)) & 0xFFn));
          return chars.map(c => c >= 32 && c < 127 ? String.fromCharCode(c) : '.').join('');
      },
      display: (v) => {
          const chars = [];
          for (let i = 0; i < 8; ++i) chars.push(Number((v >> BigInt(i * 8)) & 0xFFn));
          return '"' + chars.map(c => c >= 32 && c < 127 ? String.fromCharCode(c) : '.').join('') + '"';
      }},
    { id: 'ebcdic8', category: 'characters', bits: 8, names: ['EBCDIC'],
      convert: (v, w) => w > 8 ? extractUnsignedArray(v, 8, w).map(x => ebcdicToAscii(Number(x))) : ebcdicToAscii(Number(v)),
      display: (v, w) => {
          const fmt = (c) => {
              const ascii = ebcdicToAscii(Number(c));
              if (ascii >= 32 && ascii < 127) return `'${String.fromCharCode(ascii)}'`;
              return `'\\x${Number(c).toString(16).padStart(2, '0')}'`;
          };
          if (w > 8) return formatArray(extractUnsignedArray(v, 8, w).map(fmt));
          return fmt(v);
      }},
    { id: 'utf8', category: 'characters', bits: 8, names: ['UTF-8'],
      convert: (v, w) => w > 8 ? extractUnsignedArray(v, 8, w).map(x => Number(x)) : Number(v & 0xFFn),
      display: (v, w) => {
          const fmt = (c) => {
              const n = Number(c);
              if (n < 0x80) {
                  if (n < 32) return `'${ASCII_CONTROL[n]}'`;
                  if (n === 127) return "'DEL'";
                  return `'${String.fromCharCode(n)}'`;
              }
              if (n < 0xC0) return `(cont)`;
              if (n < 0xE0) return `(2-byte lead)`;
              if (n < 0xF0) return `(3-byte lead)`;
              if (n < 0xF8) return `(4-byte lead)`;
              return `(invalid)`;
          };
          if (w > 8) return formatArray(extractUnsignedArray(v, 8, w).map(fmt));
          return fmt(v);
      }},
    { id: 'utf16', category: 'characters', bits: 16, names: ['UTF-16', 'wchar_t', 'WCHAR'],
      convert: (v, w) => {
          if (w > 16) return extractUnsignedArray(v, 16, w).map(x => Number(x));
          const n = Number(v & 0xFFFFn);
          if (n >= 0xD800 && n <= 0xDFFF) return n;
          try { return String.fromCharCode(n); } catch { return n; }
      },
      display: (v, w) => {
          const fmt = (x) => {
              const n = Number(x & 0xFFFFn);
              if (n >= 0xD800 && n <= 0xDBFF) return `U+${n.toString(16).toUpperCase()} (high surrogate)`;
              if (n >= 0xDC00 && n <= 0xDFFF) return `U+${n.toString(16).toUpperCase()} (low surrogate)`;
              try {
                  const ch = String.fromCharCode(n);
                  if (n < 32) return `U+${n.toString(16).toUpperCase().padStart(4, '0')} '${ASCII_CONTROL[n]}'`;
                  return `U+${n.toString(16).toUpperCase().padStart(4, '0')} '${ch}'`;
              } catch { return `U+${n.toString(16).toUpperCase().padStart(4, '0')} (invalid)`; }
          };
          if (w > 16) return formatArray(extractUnsignedArray(v, 16, w).map(fmt));
          return fmt(v);
      }},
    { id: 'utf32', category: 'characters', bits: 32, names: ['UTF-32', 'Unicode', 'UCS-4'],
      components: [
        { name: 'Plane', start: 16, width: 5, color: '#ef4444' },
        { name: 'Code Point', start: 0, width: 16, color: '#3b82f6' }
      ],
      convert: (v) => {
          const cp = Number(v & 0x1FFFFFn);
          try { return String.fromCodePoint(cp); } catch { return '?'; }
      },
      display: (v, w) => {
          const fmt = (x) => {
              const cp = Number(x & 0x1FFFFFn);
              try {
                  const ch = String.fromCodePoint(cp);
                  return `U+${cp.toString(16).toUpperCase().padStart(4, '0')} '${ch}'`;
              } catch { return `U+${cp.toString(16).toUpperCase().padStart(4, '0')} (invalid)`; }
          };
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(fmt));
          return fmt(v);
      }},

    // === NETWORK ===
    { id: 'ipv4', category: 'special', bits: 32, names: ['IPv4', 'IP Address', 'ipaddr', 'in_addr'],
      components: [
        { name: 'Octet 1', start: 24, width: 8, color: '#ef4444' },
        { name: 'Octet 2', start: 16, width: 8, color: '#f97316' },
        { name: 'Octet 3', start: 8, width: 8, color: '#22c55e' },
        { name: 'Octet 4', start: 0, width: 8, color: '#3b82f6' }
      ],
      convert: (v) => Number(v & 0xFFFFFFFFn),
      display: (v, w) => {
          const fmt = (x) => {
              const n = Number(x & 0xFFFFFFFFn);
              return `${(n >>> 24) & 0xFF}.${(n >>> 16) & 0xFF}.${(n >>> 8) & 0xFF}.${n & 0xFF}`;
          };
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(fmt));
          return fmt(v);
      }},
    { id: 'mac48', category: 'special', bits: 64, names: ['MAC', 'MAC-48', 'EUI-48'],
      components: [
        { name: 'Unused', start: 48, width: 16, color: '#6b7280' },
        { name: 'OUI-1', start: 40, width: 8, color: '#ef4444' },
        { name: 'OUI-2', start: 32, width: 8, color: '#f97316' },
        { name: 'OUI-3', start: 24, width: 8, color: '#eab308' },
        { name: 'NIC-1', start: 16, width: 8, color: '#22c55e' },
        { name: 'NIC-2', start: 8, width: 8, color: '#06b6d4' },
        { name: 'NIC-3', start: 0, width: 8, color: '#3b82f6' }
      ],
      convert: (v) => v & 0xFFFFFFFFFFFFn,
      display: (v) => {
          const bytes = [];
          for (let i = 5; i >= 0; --i) bytes.push(Number((v >> BigInt(i * 8)) & 0xFFn).toString(16).padStart(2, '0').toUpperCase());
          return bytes.join(':');
      }},
    { id: 'ipv6low', category: 'special', bits: 64, names: ['IPv6 (low)', 'IPv6-L'],
      components: [
        { name: 'Group 4', start: 48, width: 16, color: '#3b82f6' },
        { name: 'Group 5', start: 32, width: 16, color: '#22c55e' },
        { name: 'Group 6', start: 16, width: 16, color: '#eab308' },
        { name: 'Group 7', start: 0, width: 16, color: '#ef4444' }
      ],
      convert: (v) => v,
      display: (v) => {
          const g4 = ((v >> 48n) & 0xFFFFn).toString(16);
          const g5 = ((v >> 32n) & 0xFFFFn).toString(16);
          const g6 = ((v >> 16n) & 0xFFFFn).toString(16);
          const g7 = (v & 0xFFFFn).toString(16);
          return `::${g4}:${g5}:${g6}:${g7}`;
      }},
    { id: 'port16', category: 'special', bits: 16, names: ['Port', 'TCP Port', 'UDP Port'],
      components: [
        { name: 'Port', start: 0, width: 16, color: '#3b82f6' }
      ],
      convert: (v, w) => w > 16 ? extractUnsignedArray(v, 16, w).map(x => Number(x & 0xFFFFn)) : Number(v & 0xFFFFn),
      display: (v, w) => {
          const wellKnown = { 20: 'FTP-data', 21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP', 53: 'DNS',
              80: 'HTTP', 110: 'POP3', 143: 'IMAP', 443: 'HTTPS', 993: 'IMAPS', 995: 'POP3S',
              3306: 'MySQL', 5432: 'PostgreSQL', 6379: 'Redis', 8080: 'HTTP-alt', 3389: 'RDP',
              27017: 'MongoDB', 11211: 'Memcached', 6443: 'K8s API' };
          const fmt = (x) => {
              const port = Number(x & 0xFFFFn);
              return wellKnown[port] ? `${port} (${wellKnown[port]})` : `${port}`;
          };
          if (w > 16) return formatArray(extractUnsignedArray(v, 16, w).map(fmt));
          return fmt(v);
      }},

    // === ADDITIONAL COLORS ===
    { id: 'rgb565', category: 'colors', bits: 16, names: ['RGB565', '16-bit Color', 'rgb16'],
      components: [
        { name: 'Red', start: 11, width: 5, color: '#ef4444' },
        { name: 'Green', start: 5, width: 6, color: '#22c55e' },
        { name: 'Blue', start: 0, width: 5, color: '#3b82f6' }
      ],
      convert: (v) => {
          const n = Number(v & 0xFFFFn);
          return {
              r: ((n >> 11) & 0x1F) * 255 / 31 | 0,
              g: ((n >> 5) & 0x3F) * 255 / 63 | 0,
              b: (n & 0x1F) * 255 / 31 | 0
          };
      },
      display: (v, w) => {
          const fmt = (x) => {
              const n = Number(x & 0xFFFFn);
              const r = ((n >> 11) & 0x1F) * 255 / 31 | 0;
              const g = ((n >> 5) & 0x3F) * 255 / 63 | 0;
              const b = (n & 0x1F) * 255 / 31 | 0;
              return `rgb(${r},${g},${b})`;
          };
          if (w > 16) return formatArray(extractUnsignedArray(v, 16, w).map(fmt));
          return fmt(v);
      }},
    { id: 'rgb555', category: 'colors', bits: 16, names: ['RGB555', '15-bit Color', 'rgb15'],
      components: [
        { name: 'X', start: 15, width: 1, color: '#6b7280' },
        { name: 'Red', start: 10, width: 5, color: '#ef4444' },
        { name: 'Green', start: 5, width: 5, color: '#22c55e' },
        { name: 'Blue', start: 0, width: 5, color: '#3b82f6' }
      ],
      convert: (v) => {
          const n = Number(v & 0x7FFFn);
          return {
              r: ((n >> 10) & 0x1F) * 255 / 31 | 0,
              g: ((n >> 5) & 0x1F) * 255 / 31 | 0,
              b: (n & 0x1F) * 255 / 31 | 0
          };
      },
      display: (v, w) => {
          const fmt = (x) => {
              const n = Number(x & 0x7FFFn);
              const r = ((n >> 10) & 0x1F) * 255 / 31 | 0;
              const g = ((n >> 5) & 0x1F) * 255 / 31 | 0;
              const b = (n & 0x1F) * 255 / 31 | 0;
              return `rgb(${r},${g},${b})`;
          };
          if (w > 16) return formatArray(extractUnsignedArray(v, 16, w).map(fmt));
          return fmt(v);
      }},
    { id: 'argb1555', category: 'colors', bits: 16, names: ['ARGB1555', '16-bit ARGB'],
      components: [
        { name: 'Alpha', start: 15, width: 1, color: '#a855f7' },
        { name: 'Red', start: 10, width: 5, color: '#ef4444' },
        { name: 'Green', start: 5, width: 5, color: '#22c55e' },
        { name: 'Blue', start: 0, width: 5, color: '#3b82f6' }
      ],
      convert: (v) => {
          const n = Number(v & 0xFFFFn);
          return {
              a: (n >> 15) & 1 ? 255 : 0,
              r: ((n >> 10) & 0x1F) * 255 / 31 | 0,
              g: ((n >> 5) & 0x1F) * 255 / 31 | 0,
              b: (n & 0x1F) * 255 / 31 | 0
          };
      },
      display: (v, w) => {
          const fmt = (x) => {
              const n = Number(x & 0xFFFFn);
              const a = (n >> 15) & 1 ? 1 : 0;
              const r = ((n >> 10) & 0x1F) * 255 / 31 | 0;
              const g = ((n >> 5) & 0x1F) * 255 / 31 | 0;
              const b = (n & 0x1F) * 255 / 31 | 0;
              return `rgba(${r},${g},${b},${a})`;
          };
          if (w > 16) return formatArray(extractUnsignedArray(v, 16, w).map(fmt));
          return fmt(v);
      }},
    { id: 'argb4444', category: 'colors', bits: 16, names: ['ARGB4444', '16-bit ARGB4444', '4444'],
      components: [
        { name: 'Alpha', start: 12, width: 4, color: '#a855f7' },
        { name: 'Red', start: 8, width: 4, color: '#ef4444' },
        { name: 'Green', start: 4, width: 4, color: '#22c55e' },
        { name: 'Blue', start: 0, width: 4, color: '#3b82f6' }
      ],
      convert: (v) => {
          const n = Number(v & 0xFFFFn);
          return {
              a: ((n >> 12) & 0xF) * 17,
              r: ((n >> 8) & 0xF) * 17,
              g: ((n >> 4) & 0xF) * 17,
              b: (n & 0xF) * 17
          };
      },
      display: (v, w) => {
          const fmt = (x) => {
              const n = Number(x & 0xFFFFn);
              const a = ((n >> 12) & 0xF) / 15;
              const r = ((n >> 8) & 0xF) * 17;
              const g = ((n >> 4) & 0xF) * 17;
              const b = (n & 0xF) * 17;
              return `rgba(${r},${g},${b},${a.toFixed(2)})`;
          };
          if (w > 16) return formatArray(extractUnsignedArray(v, 16, w).map(fmt));
          return fmt(v);
      }},
    { id: 'bgr24', category: 'colors', bits: 32, names: ['BGR24', 'BGR', 'COLORREF'],
      components: [
        { name: 'Unused', start: 24, width: 8, color: '#6b7280' },
        { name: 'Blue', start: 16, width: 8, color: '#3b82f6' },
        { name: 'Green', start: 8, width: 8, color: '#22c55e' },
        { name: 'Red', start: 0, width: 8, color: '#ef4444' }
      ],
      convert: (v) => {
          const n = Number(v & 0xFFFFFFn);
          return { b: (n >> 16) & 0xFF, g: (n >> 8) & 0xFF, r: n & 0xFF };
      },
      display: (v, w) => {
          const fmt = (x) => {
              const n = Number(x & 0xFFFFFFn);
              const b = (n >> 16) & 0xFF, g = (n >> 8) & 0xFF, r = n & 0xFF;
              return `rgb(${r},${g},${b})`;
          };
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(fmt));
          return fmt(v);
      }},
    { id: 'bgra32', category: 'colors', bits: 32, names: ['BGRA32', 'BGRA'],
      components: [
        { name: 'Alpha', start: 24, width: 8, color: '#a855f7' },
        { name: 'Blue', start: 16, width: 8, color: '#3b82f6' },
        { name: 'Green', start: 8, width: 8, color: '#22c55e' },
        { name: 'Red', start: 0, width: 8, color: '#ef4444' }
      ],
      convert: (v) => {
          const n = Number(v & 0xFFFFFFFFn);
          return { a: (n >> 24) & 0xFF, b: (n >> 16) & 0xFF, g: (n >> 8) & 0xFF, r: n & 0xFF };
      },
      display: (v, w) => {
          const fmt = (x) => {
              const n = Number(x & 0xFFFFFFFFn);
              const a = (n >> 24) & 0xFF, b = (n >> 16) & 0xFF, g = (n >> 8) & 0xFF, r = n & 0xFF;
              return `rgba(${r},${g},${b},${(a/255).toFixed(2)})`;
          };
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(fmt));
          return fmt(v);
      }},
    { id: 'abgr32', category: 'colors', bits: 32, names: ['ABGR32', 'ABGR'],
      components: [
        { name: 'Alpha', start: 24, width: 8, color: '#a855f7' },
        { name: 'Blue', start: 16, width: 8, color: '#3b82f6' },
        { name: 'Green', start: 8, width: 8, color: '#22c55e' },
        { name: 'Red', start: 0, width: 8, color: '#ef4444' }
      ],
      convert: (v) => {
          const n = Number(v & 0xFFFFFFFFn);
          return { a: (n >> 24) & 0xFF, b: (n >> 16) & 0xFF, g: (n >> 8) & 0xFF, r: n & 0xFF };
      },
      display: (v, w) => {
          const fmt = (x) => {
              const n = Number(x & 0xFFFFFFFFn);
              const a = (n >> 24) & 0xFF, b = (n >> 16) & 0xFF, g = (n >> 8) & 0xFF, r = n & 0xFF;
              return `rgba(${r},${g},${b},${(a/255).toFixed(2)})`;
          };
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(fmt));
          return fmt(v);
      }},
    { id: 'hsv24', category: 'colors', bits: 32, names: ['HSV', 'HSB'],
      components: [
        { name: 'Unused', start: 24, width: 8, color: '#6b7280' },
        { name: 'Hue', start: 16, width: 8, color: '#ef4444' },
        { name: 'Saturation', start: 8, width: 8, color: '#22c55e' },
        { name: 'Value', start: 0, width: 8, color: '#3b82f6' }
      ],
      convert: (v) => {
          const n = Number(v & 0xFFFFFFn);
          const h = ((n >> 16) & 0xFF) * 360 / 255 | 0;
          const s = ((n >> 8) & 0xFF) * 100 / 255 | 0;
          const vv = (n & 0xFF) * 100 / 255 | 0;
          return { h, s, v: vv };
      },
      display: (v, w) => {
          const fmt = (x) => {
              const n = Number(x & 0xFFFFFFn);
              const h = ((n >> 16) & 0xFF) * 360 / 255 | 0;
              const s = ((n >> 8) & 0xFF) * 100 / 255 | 0;
              const vv = (n & 0xFF) * 100 / 255 | 0;
              const rgb = hsvToRgb(h, s, vv);
              return `rgb(${rgb.r},${rgb.g},${rgb.b})`;
          };
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(fmt));
          return fmt(v);
      }},

    // === AI/ML FLOATS ===
    { id: 'fp8e4m3', category: 'ai_floats', bits: 8, names: ['FP8-E4M3', 'E4M3'],
      components: [
        { name: 'Sign', start: 7, width: 1, color: '#ef4444' },
        { name: 'Exponent', start: 3, width: 4, color: '#f97316' },
        { name: 'Mantissa', start: 0, width: 3, color: '#3b82f6' }
      ],
      convert: (v, w) => w > 8 ? extractUnsignedArray(v, 8, w).map(x => fp8E4M3ToNumber(Number(x))) : fp8E4M3ToNumber(Number(v)),
      display: (v, w) => extractAndFormatBits(v, 8, w, formatFP8E4M3Bits) },
    { id: 'fp8e5m2', category: 'ai_floats', bits: 8, names: ['FP8-E5M2', 'E5M2'],
      components: [
        { name: 'Sign', start: 7, width: 1, color: '#ef4444' },
        { name: 'Exponent', start: 2, width: 5, color: '#f97316' },
        { name: 'Mantissa', start: 0, width: 2, color: '#3b82f6' }
      ],
      convert: (v, w) => w > 8 ? extractUnsignedArray(v, 8, w).map(x => fp8E5M2ToNumber(Number(x))) : fp8E5M2ToNumber(Number(v)),
      display: (v, w) => extractAndFormatBits(v, 8, w, formatFP8E5M2Bits) },

    // === ADDITIONAL DATE/TIME ===
    { id: 'ntp64', category: 'datetime', bits: 64, names: ['NTP', 'NTP Timestamp'],
      components: [
        { name: 'Seconds', start: 32, width: 32, color: '#3b82f6' },
        { name: 'Fraction', start: 0, width: 32, color: '#22c55e' }
      ],
      convert: (v) => {
          const secs = Number(v >> 32n);
          const frac = Number(v & 0xFFFFFFFFn) / 0x100000000;
          return new Date((secs - 2208988800 + frac) * 1000);
      },
      display: (v) => {
          const secs = Number(v >> 32n);
          const frac = Number(v & 0xFFFFFFFFn) / 0x100000000;
          const ms = (secs - 2208988800 + frac) * 1000;
          if (secs === 0 && frac === 0) return 'Era 0 start';
          try { return new Date(ms).toISOString(); } catch { return 'Invalid'; }
      }},
    { id: 'oledate', category: 'datetime', bits: 64, names: ['OLE Date', 'Automation Date', 'DATE'],
      components: [
        { name: 'Days (double)', start: 0, width: 64, color: '#3b82f6' }
      ],
      convert: (v) => {
          const buf = new ArrayBuffer(8);
          new DataView(buf).setBigUint64(0, v, true);
          const days = new DataView(buf).getFloat64(0, true);
          return new Date((days - 25569) * 86400000);
      },
      display: (v) => {
          const buf = new ArrayBuffer(8);
          new DataView(buf).setBigUint64(0, v, true);
          const days = new DataView(buf).getFloat64(0, true);
          if (!isFinite(days)) return 'Invalid';
          try { return new Date((days - 25569) * 86400000).toISOString(); } catch { return 'Invalid'; }
      }},
    { id: 'hfsplus', category: 'datetime', bits: 32, names: ['HFS+', 'Mac Time', 'HFSPlusDate'],
      components: [
        { name: 'Seconds', start: 0, width: 32, color: '#3b82f6' }
      ],
      convert: (v, w) => {
          const secs = Number(v & 0xFFFFFFFFn);
          return new Date((secs - 2082844800) * 1000);
      },
      display: (v, w) => {
          const fmt = (x) => {
              const secs = Number(x & 0xFFFFFFFFn);
              if (secs === 0) return '1904-01-01 (epoch)';
              try { return new Date((secs - 2082844800) * 1000).toISOString(); } catch { return 'Invalid'; }
          };
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(fmt));
          return fmt(v);
      }},
    { id: 'gpstime', category: 'datetime', bits: 32, names: ['GPS Time', 'GPS'],
      components: [
        { name: 'Seconds', start: 0, width: 32, color: '#3b82f6' }
      ],
      convert: (v) => {
          const secs = Number(v & 0xFFFFFFFFn);
          return new Date((secs + 315964800) * 1000);
      },
      display: (v, w) => {
          const fmt = (x) => {
              const secs = Number(x & 0xFFFFFFFFn);
              if (secs === 0) return '1980-01-06 (epoch)';
              try { return new Date((secs + 315964800) * 1000).toISOString(); } catch { return 'Invalid'; }
          };
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(fmt));
          return fmt(v);
      }},
    { id: 'webkit', category: 'datetime', bits: 64, names: ['WebKit', 'Chrome Time'],
      components: [
        { name: 'Microseconds', start: 0, width: 64, color: '#3b82f6' }
      ],
      convert: (v) => {
          const us = v - 11644473600000000n;
          return new Date(Number(us / 1000n));
      },
      display: (v) => {
          const us = v - 11644473600000000n;
          if (v === 0n) return '1601-01-01 (epoch)';
          try { return new Date(Number(us / 1000n)).toISOString(); } catch { return 'Invalid'; }
      }},
    { id: 'dotnet', category: 'datetime', bits: 64, names: ['.NET Ticks', 'DateTime.Ticks'],
      components: [
        { name: 'Kind', start: 62, width: 2, color: '#ef4444' },
        { name: 'Ticks', start: 0, width: 62, color: '#3b82f6' }
      ],
      convert: (v) => {
          const ticks = v & 0x3FFFFFFFFFFFFFFFn;
          const ms = Number(ticks / 10000n) - 62135596800000;
          return new Date(ms);
      },
      display: (v) => {
          const ticks = v & 0x3FFFFFFFFFFFFFFFn;
          const ms = Number(ticks / 10000n) - 62135596800000;
          if (ticks === 0n) return '0001-01-01 (epoch)';
          try { return new Date(ms).toISOString(); } catch { return 'Invalid'; }
      }},

    // === ALTERNATIVE INTEGERS ===
    { id: 'gray8', category: 'integers', bits: 8, names: ['Gray8', 'Gray Code 8'],
      components: [
        { name: 'Gray Code', start: 0, width: 8, color: '#6b7280' }
      ],
      convert: (v, w) => w > 8 ? extractUnsignedArray(v, 8, w).map(x => grayToBinary(x)) : grayToBinary(v),
      display: (v, w) => {
          if (w > 8) return formatArray(extractUnsignedArray(v, 8, w).map(x => grayToBinary(x).toString()));
          return `${grayToBinary(v)} (from Gray ${v})`;
      }},
    { id: 'gray16', category: 'integers', bits: 16, names: ['Gray16', 'Gray Code 16'],
      components: [
        { name: 'Gray Code', start: 0, width: 16, color: '#6b7280' }
      ],
      convert: (v, w) => w > 16 ? extractUnsignedArray(v, 16, w).map(x => grayToBinary(x)) : grayToBinary(v),
      display: (v, w) => {
          if (w > 16) return formatArray(extractUnsignedArray(v, 16, w).map(x => grayToBinary(x).toString()));
          return `${grayToBinary(v)} (from Gray ${v})`;
      }},
    { id: 'gray32', category: 'integers', bits: 32, names: ['Gray32', 'Gray Code 32'],
      components: [
        { name: 'Gray Code', start: 0, width: 32, color: '#6b7280' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w).map(x => grayToBinary(x)) : grayToBinary(v),
      display: (v, w) => {
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(x => grayToBinary(x).toString()));
          return `${grayToBinary(v)} (from Gray ${v})`;
      }},
    { id: 'gray64', category: 'integers', bits: 64, names: ['Gray64', 'Gray Code 64'],
      components: [
        { name: 'Gray Code', start: 0, width: 64, color: '#6b7280' }
      ],
      convert: (v) => grayToBinary(v),
      display: (v) => `${grayToBinary(v)} (from Gray ${v})` },
    { id: 'zigzag8', category: 'integers', bits: 8, names: ['Zigzag8', 'sint8'],
      components: [
        { name: 'Zigzag Encoded', start: 0, width: 8, color: '#a855f7' }
      ],
      convert: (v, w) => w > 8 ? extractUnsignedArray(v, 8, w).map(x => zigzagDecode(x)) : zigzagDecode(v),
      display: (v, w) => {
          if (w > 8) return formatArray(extractUnsignedArray(v, 8, w).map(x => zigzagDecode(x).toString()));
          return zigzagDecode(v).toString();
      }},
    { id: 'zigzag16', category: 'integers', bits: 16, names: ['Zigzag16', 'sint16'],
      components: [
        { name: 'Zigzag Encoded', start: 0, width: 16, color: '#a855f7' }
      ],
      convert: (v, w) => w > 16 ? extractUnsignedArray(v, 16, w).map(x => zigzagDecode(x)) : zigzagDecode(v),
      display: (v, w) => {
          if (w > 16) return formatArray(extractUnsignedArray(v, 16, w).map(x => zigzagDecode(x).toString()));
          return zigzagDecode(v).toString();
      }},
    { id: 'zigzag32', category: 'integers', bits: 32, names: ['Zigzag32', 'Varint32', 'sint32'],
      components: [
        { name: 'Zigzag Encoded', start: 0, width: 32, color: '#a855f7' }
      ],
      convert: (v, w) => w > 32 ? extractUnsignedArray(v, 32, w).map(x => zigzagDecode(x)) : zigzagDecode(v),
      display: (v, w) => {
          if (w > 32) return formatArray(extractUnsignedArray(v, 32, w).map(x => zigzagDecode(x).toString()));
          return zigzagDecode(v).toString();
      }},
    { id: 'zigzag64', category: 'integers', bits: 64, names: ['Zigzag64', 'Varint64', 'sint64'],
      components: [
        { name: 'Zigzag Encoded', start: 0, width: 64, color: '#a855f7' }
      ],
      convert: (v) => zigzagDecode(v),
      display: (v) => zigzagDecode(v).toString() },

    // === AUDIO ===
    { id: 'mulaw8', category: 'audio', bits: 8, names: ['-law', 'mu-law', 'ulaw', 'G.711'],
      components: [
        { name: 'Sign', start: 7, width: 1, color: '#ef4444' },
        { name: 'Chord', start: 4, width: 3, color: '#3b82f6' },
        { name: 'Step', start: 0, width: 4, color: '#22c55e' }
      ],
      convert: (v, w) => w > 8 ? extractUnsignedArray(v, 8, w).map(x => mulawToLinear(Number(x))) : mulawToLinear(Number(v)),
      display: (v, w) => {
          if (w > 8) return formatArray(extractUnsignedArray(v, 8, w).map(x => `PCM: ${mulawToLinear(Number(x))}`));
          return `PCM: ${mulawToLinear(Number(v))}`;
      }},
    { id: 'alaw8', category: 'audio', bits: 8, names: ['A-law', 'alaw', 'G.711A'],
      components: [
        { name: 'Sign', start: 7, width: 1, color: '#ef4444' },
        { name: 'Chord', start: 4, width: 3, color: '#3b82f6' },
        { name: 'Step', start: 0, width: 4, color: '#22c55e' }
      ],
      convert: (v, w) => w > 8 ? extractUnsignedArray(v, 8, w).map(x => alawToLinear(Number(x))) : alawToLinear(Number(v)),
      display: (v, w) => {
          if (w > 8) return formatArray(extractUnsignedArray(v, 8, w).map(x => `PCM: ${alawToLinear(Number(x))}`));
          return `PCM: ${alawToLinear(Number(v))}`;
      }},
    { id: 'midi8', category: 'audio', bits: 8, names: ['MIDI Note', 'MIDI', 'note'],
      components: [
        { name: 'Note', start: 0, width: 7, color: '#a855f7' },
        { name: 'Unused', start: 7, width: 1, color: '#6b7280' }
      ],
      convert: (v, w) => w > 8 ? extractUnsignedArray(v, 8, w).map(x => Number(x & 0x7Fn)) : Number(v & 0x7Fn),
      display: (v, w) => {
          if (w > 8) return formatArray(extractUnsignedArray(v, 8, w).map(x => {
              const note = Number(x & 0x7Fn);
              return `${midiToNoteName(note)} (${note})`;
          }));
          const note = Number(v & 0x7Fn);
          return `${midiToNoteName(note)} (${note})`;
      }},
];

// Helper to format float values
const formatFloat = (v) => {
    if (isNaN(v)) return 'NaN';
    if (!isFinite(v)) return v > 0 ? '+Inf' : '-Inf';
    if (Object.is(v, -0)) return '-0';
    // Use exponential for very large/small values
    const abs = Math.abs(v);
    if (abs !== 0 && (abs >= 1e10 || abs < 1e-6)) return v.toExponential(6);
    // Otherwise use fixed precision
    const str = v.toPrecision(10);
    // Remove trailing zeros after decimal point
    return str.replace(/\.?0+$/, '').replace(/(\.\d*?)0+$/, '$1');
};

// Get formats applicable to current bit width
// For array formats, minBits specifies the minimum width needed (e.g., Byte[] needs at least 16 bits for 2 elements)
const getFormatsForWidth = (width) => FORMATS.filter(f => f.bits <= width && (!f.minBits || width >= f.minBits));

// --- CODE GENERATION ---
const generateCCode = (fields, width) => {
    if (fields.length === 0) return '// No fields defined';
    const typeName = width <= 8 ? 'uint8_t' : width <= 16 ? 'uint16_t' : width <= 32 ? 'uint32_t' : 'uint64_t';
    const suffix = width <= 32 ? 'U' : 'ULL';
    let code = `// Bit field definitions for ${width}-bit value\n\n`;
    code += '// Field masks\n';
    fields.forEach(f => {
        const mask = ((1n << BigInt(f.width)) - 1n) << BigInt(f.start);
        code += `#define ${f.name.toUpperCase()}_MASK ${formatHex(mask, width)}${suffix}\n`;
    });
    code += '\n// Field positions\n';
    fields.forEach(f => code += `#define ${f.name.toUpperCase()}_POS  ${f.start}\n`);
    code += '\n// Field widths\n';
    fields.forEach(f => code += `#define ${f.name.toUpperCase()}_BITS ${f.width}\n`);
    code += '\n// Accessor macros\n';
    fields.forEach(f => {
        const mask = ((1n << BigInt(f.width)) - 1n);
        code += `#define GET_${f.name.toUpperCase()}(v) (((v) >> ${f.name.toUpperCase()}_POS) & ${formatHex(mask, f.width)}${suffix})\n`;
        code += `#define SET_${f.name.toUpperCase()}(v, x) (((v) & ~${f.name.toUpperCase()}_MASK) | (((x) & ${formatHex(mask, f.width)}${suffix}) << ${f.name.toUpperCase()}_POS))\n`;
    });
    return code;
};

const generateCSharpCode = (fields, width) => {
    if (fields.length === 0) return '// No fields defined';
    const typeName = width <= 8 ? 'byte' : width <= 16 ? 'ushort' : width <= 32 ? 'uint' : 'ulong';
    let code = `// Bit field definitions for ${width}-bit value\n\npublic static class BitFields\n{\n`;
    code += '    // Field masks\n';
    fields.forEach(f => {
        const mask = ((1n << BigInt(f.width)) - 1n) << BigInt(f.start);
        code += `    public const ${typeName} ${f.name}Mask = ${formatHex(mask, width)};\n`;
    });
    code += '\n    // Field positions\n';
    fields.forEach(f => code += `    public const int ${f.name}Pos = ${f.start};\n`);
    code += '\n    // Accessor methods\n';
    fields.forEach(f => {
        const mask = ((1n << BigInt(f.width)) - 1n);
        code += `    public static ${typeName} Get${f.name}(${typeName} v) => (${typeName})((v >> ${f.name}Pos) & ${formatHex(mask, f.width)});\n`;
        code += `    public static ${typeName} Set${f.name}(${typeName} v, ${typeName} x) => (${typeName})((v & ~${f.name}Mask) | ((x & ${formatHex(mask, f.width)}) << ${f.name}Pos));\n`;
    });
    code += '}\n';
    return code;
};

const generateCppCode = (fields, width) => {
    if (fields.length === 0) return '// No fields defined';
    const typeName = width <= 8 ? 'uint8_t' : width <= 16 ? 'uint16_t' : width <= 32 ? 'uint32_t' : 'uint64_t';
    const suffix = width <= 32 ? 'U' : 'ULL';
    let code = `// Bit field definitions for ${width}-bit value\n\n#include <cstdint>\n\nnamespace BitFields {\n\n`;
    code += '// Field masks\n';
    fields.forEach(f => {
        const mask = ((1n << BigInt(f.width)) - 1n) << BigInt(f.start);
        code += `constexpr ${typeName} ${f.name}_mask = ${formatHex(mask, width)}${suffix};\n`;
    });
    code += '\n// Field positions\n';
    fields.forEach(f => code += `constexpr int ${f.name}_pos = ${f.start};\n`);
    code += '\n// Accessor functions\n';
    fields.forEach(f => {
        const mask = ((1n << BigInt(f.width)) - 1n);
        code += `constexpr ${typeName} get_${f.name}(${typeName} v) { return (v >> ${f.name}_pos) & ${formatHex(mask, f.width)}${suffix}; }\n`;
        code += `constexpr ${typeName} set_${f.name}(${typeName} v, ${typeName} x) { return (v & ~${f.name}_mask) | ((x & ${formatHex(mask, f.width)}${suffix}) << ${f.name}_pos); }\n`;
    });
    code += '\n} // namespace BitFields\n';
    return code;
};

// --- COMPONENTS ---

// Bit Grid Component - responsive layout, prefers 16 bits per row when space allows
const BitGrid = ({ value, width, onToggleBit, fields, highlightField }) => {
    const containerRef = React.useRef(null);
    const [bitsPerRow, setBitsPerRow] = React.useState(8);
    const [isReady, setIsReady] = React.useState(false);

    // Use ResizeObserver for reliable dimension detection on initial render and resize
    React.useEffect(() => {
        if (!containerRef.current) return;

        const updateBitsPerRow = (containerWidth) => {
            if (containerWidth < 10) return; // Skip if container not yet sized
            const bitCellWidth = 32; // ~28px cell + gap + nibble spacer averaged
            const availableBits = Math.floor(containerWidth / bitCellWidth);
            // Prefer 64, then 32, then 16, then 8
            if (availableBits >= 64 && width >= 64) setBitsPerRow(64);
            else if (availableBits >= 32 && width >= 32) setBitsPerRow(32);
            else if (availableBits >= 16 && width >= 16) setBitsPerRow(16);
            else setBitsPerRow(8);
            setIsReady(true);
        };

        const resizeObserver = new ResizeObserver((entries) => {
            for (const entry of entries) {
                const containerWidth = entry.contentRect.width;
                updateBitsPerRow(containerWidth);
            }
        });

        resizeObserver.observe(containerRef.current);
        return () => resizeObserver.disconnect();
    }, [width]);

    const rows = width / bitsPerRow;

    const getFieldForBit = (bitIndex) => fields.find(f => bitIndex >= f.start && bitIndex < f.start + f.width);
    const getFieldColor = (field) => {
        if (!field) return null;
        // Use custom color if specified, otherwise generate from colorIndex
        if (field.color) {
            // Parse hex color and create background/border variants
            const hex = field.color;
            return { bg: `${hex}26`, border: hex }; // 26 = ~15% alpha in hex
        }
        const hue = (field.colorIndex * 60) % 360;
        return { bg: `hsla(${hue}, 70%, 50%, 0.15)`, border: `hsl(${hue}, 70%, 50%)` };
    };

    return (
        <div ref={containerRef} className="space-y-1" style={{ minHeight: isReady ? 'auto' : `${Math.ceil(width / 8) * 40}px` }}>
            {isReady && Array.from({ length: rows }).map((_, rowIdx) => {
                const startBit = (rows - 1 - rowIdx) * bitsPerRow;
                return (
                    <div key={rowIdx} className="flex gap-0.5 justify-center">
                        {Array.from({ length: bitsPerRow }).map((_, colIdx) => {
                            const bitIndex = startBit + (bitsPerRow - 1 - colIdx);
                            const bitVal = (value >> BigInt(bitIndex)) & 1n;
                            const field = getFieldForBit(bitIndex);
                            const fieldColor = getFieldColor(field);
                            const isHighlighted = highlightField && field && field.name === highlightField;
                            // Add visual separator every 8 bits (byte boundary)
                            const isByteBoundary = colIdx > 0 && colIdx % 8 === 0;
                            return (
                                <React.Fragment key={bitIndex}>
                                    {isByteBoundary && <div className="w-2 border-l border-slate-700" />}
                                    <div onClick={() => onToggleBit(bitIndex)}
                                        className={`bit-cell flex-1 min-w-[28px] h-9 flex flex-col items-center justify-center font-mono text-xs rounded cursor-pointer transition-all border ${isHighlighted ? 'field-highlight' : ''}`}
                                        style={{
                                            backgroundColor: fieldColor?.bg || (bitVal ? 'rgba(34, 211, 238, 0.2)' : 'rgba(30, 41, 59, 0.5)'),
                                            borderColor: fieldColor?.border || (bitVal ? 'rgb(34, 211, 238)' : 'rgb(51, 65, 85)'),
                                            borderWidth: field ? '2px' : '1px'
                                        }}>
                                        <span className="text-[8px] text-slate-500">{bitIndex}</span>
                                        <span className={`text-sm font-bold ${bitVal ? 'text-cyan-400' : 'text-slate-500'}`}>{bitVal.toString()}</span>
                                    </div>
                                </React.Fragment>
                            );
                        })}
                    </div>
                );
            })}
        </div>
    );
};

// Format Value Row Component
const FormatRow = ({ format, value, width, onCopy, onLoadComponents }) => {
    const displayValue = format.display(value, width);
    const endianLabel = format.endian ? ` (${format.endian})` : '';
    const isColor = format.category === 'colors';
    const hasComponents = format.components && format.components.length > 0;

    // Extract color values for swatches (handles both single and array formats)
    const colorSwatches = isColor ? displayValue.match(/rgba?\([^)]+\)/g) || [] : [];

    const handleClick = () => {
        if (hasComponents && onLoadComponents)
            onLoadComponents(format);
    };

    return (
        <div className="format-row flex items-center gap-2 py-1 px-2 rounded transition-colors">
            <span
                className={`text-[10px] text-slate-500 w-24 truncate ${hasComponents ? 'cursor-pointer hover:text-cyan-400' : ''}`}
                title={hasComponents ? `${format.names.join(', ')} - Click to load components` : format.names.join(', ')}
                onClick={handleClick}>
                {format.names[0]}{endianLabel}
            </span>
            {colorSwatches.length > 0 && (
                <div className="flex gap-0.5">
                    {colorSwatches.map((color, i) => (
                        <div key={i} className="w-4 h-4 rounded border border-slate-600"
                             style={{ backgroundColor: color }} title={color} />
                    ))}
                </div>
            )}
            <code className="flex-1 font-mono text-xs text-slate-200 truncate" title={displayValue}>
                {displayValue}
            </code>
            <button onClick={() => onCopy(displayValue)} className="text-slate-600 hover:text-cyan-400 p-0.5 opacity-0 group-hover:opacity-100 transition-opacity">
                <IconCopy className="w-3 h-3" />
            </button>
        </div>
    );
};

// Format Category Component
const FormatCategory = ({ category, formats, value, width, onCopy, onLoadComponents, expanded, onToggle }) => {
    const catInfo = FORMAT_CATEGORIES[category];
    const applicableFormats = formats.filter(f => f.bits <= width);

    if (applicableFormats.length === 0) return null;

    return (
        <div className="mb-2">
            <button onClick={onToggle}
                className={`category-header w-full flex items-center gap-2 py-1 text-left hover:bg-slate-800/30 rounded transition-colors`}
                style={{ borderColor: `var(--tw-${catInfo.color}-500, #06b6d4)` }}>
                <IconChevronDown className="w-3 h-3 text-slate-500" rotate={expanded} />
                <span className={`text-xs font-bold uppercase tracking-wider text-${catInfo.color}-400`}>{catInfo.name}</span>
                <span className="text-[10px] text-slate-600">({applicableFormats.length})</span>
            </button>
            {expanded && (
                <div className="mt-1 ml-2 space-y-0.5 group">
                    {applicableFormats.map(f => (
                        <FormatRow key={f.id} format={f} value={value} width={width} onCopy={onCopy} onLoadComponents={onLoadComponents} />
                    ))}
                </div>
            )}
        </div>
    );
};

// Conversions Panel Component
const ConversionsPanel = ({ value, width, onCopy, onLoadComponents }) => {
    const [expandedCategories, setExpandedCategories] = React.useState({
        integers: true, floats: true, ai_floats: false, exotic_floats: false, fixed: false, decimal: false,
        colors: false, datetime: false, audio: false, special: false, characters: false
    });

    const toggleCategory = (cat) => setExpandedCategories(prev => ({ ...prev, [cat]: !prev[cat] }));

    const formatsByCategory = {};
    FORMATS.forEach(f => {
        if (!formatsByCategory[f.category]) formatsByCategory[f.category] = [];
        formatsByCategory[f.category].push(f);
    });

    return (
        <div className="space-y-1">
            <div className="flex items-center justify-between mb-2">
                <div className="text-xs font-bold text-slate-500 uppercase tracking-widest">Type Interpretations</div>
                <div className="flex gap-1">
                    <button onClick={() => setExpandedCategories(Object.fromEntries(Object.keys(FORMAT_CATEGORIES).map(k => [k, true])))}
                        className="text-[10px] text-slate-600 hover:text-white">All</button>
                    <button onClick={() => setExpandedCategories(Object.fromEntries(Object.keys(FORMAT_CATEGORIES).map(k => [k, false])))}
                        className="text-[10px] text-slate-600 hover:text-white">None</button>
                </div>
            </div>
            {Object.keys(FORMAT_CATEGORIES).map(cat => (
                <FormatCategory key={cat} category={cat} formats={formatsByCategory[cat] || []}
                    value={value} width={width} onCopy={onCopy} onLoadComponents={onLoadComponents}
                    expanded={expandedCategories[cat]} onToggle={() => toggleCategory(cat)} />
            ))}
        </div>
    );
};

// Input Panel Component
const InputPanel = ({ value, width, onValueChange, onCopy }) => {
    const [inputMode, setInputMode] = React.useState('hex');
    const [textInput, setTextInput] = React.useState('0');
    const [isFloatFocused, setIsFloatFocused] = React.useState(false);

    const mask = (1n << BigInt(width)) - 1n;

    React.useEffect(() => {
        // Don't overwrite float input while user is typing a formula
        if (inputMode === 'float' && isFloatFocused) return;

        if (inputMode === 'hex') setTextInput(formatHex(value, width));
        else if (inputMode === 'dec') setTextInput(value.toString());
        else if (inputMode === 'sdec') setTextInput(toSigned(value, width).toString());
        else if (inputMode === 'bin') setTextInput(formatBinary(value, width));
        else if (inputMode === 'oct') setTextInput(formatOctal(value));
        else if (inputMode === 'float') setTextInput(formatFloatInput(value, width));
    }, [value, width, inputMode, isFloatFocused]);

    const handleTextInputChange = (newText) => {
        setTextInput(newText);
        try {
            let newVal = 0n;
            if (inputMode === 'hex') {
                const cleaned = newText.replace(/^0x/i, '').replace(/[^0-9a-fA-F]/g, '');
                if (cleaned) newVal = BigInt('0x' + cleaned);
            } else if (inputMode === 'dec') {
                const cleaned = newText.replace(/[^0-9]/g, '');
                if (cleaned) newVal = BigInt(cleaned);
            } else if (inputMode === 'sdec') {
                const cleaned = newText.replace(/[^0-9-]/g, '');
                if (cleaned && cleaned !== '-') newVal = fromSigned(BigInt(cleaned), width);
            } else if (inputMode === 'bin') {
                const cleaned = newText.replace(/^0b/i, '').replace(/[^01]/g, '');
                if (cleaned) newVal = BigInt('0b' + cleaned);
            } else if (inputMode === 'oct') {
                const cleaned = newText.replace(/^0o/i, '').replace(/[^0-7]/g, '');
                if (cleaned) newVal = BigInt('0o' + cleaned);
            } else if (inputMode === 'float') {
                // Parse math expressions (e.g., "1/3", "sin(pi)", "2^10")
                // Falls back to simple decimal parsing if no operators
                let num = evalMathExpr(newText);
                if (isNaN(num)) num = parseDecimalToNumber(newText);
                if (!isNaN(num)) newVal = numberToFloatBits(num, width);
            }
            onValueChange(newVal & mask);
        } catch (e) { /* Invalid input, ignore */ }
    };

    const modes = [
        { id: 'hex', label: 'Hex' },
        { id: 'dec', label: 'Dec' },
        { id: 'sdec', label: 'Signed' },
        { id: 'float', label: 'Float' },
        { id: 'bin', label: 'Bin' },
        { id: 'oct', label: 'Oct' }
    ];

    return (
        <div className="space-y-3">
            <div className="text-xs font-bold text-slate-500 uppercase tracking-widest">Input</div>
            <div className="flex gap-1 flex-wrap">
                {modes.map((mode) => (
                    <button key={mode.id} onClick={() => setInputMode(mode.id)}
                        className={`px-2 py-1 rounded text-xs font-bold transition-all ${inputMode === mode.id ? 'bg-emerald-600 text-white' : 'bg-slate-800 text-slate-400 hover:text-white'}`}>
                        {mode.label}
                    </button>
                ))}
            </div>
            <div className="flex gap-2">
                {inputMode === 'float' ? (
                    <MathAutocompleteInput
                        value={textInput}
                        onChange={handleTextInputChange}
                        onEvaluate={handleTextInputChange}
                        onFocusChange={setIsFloatFocused}
                        className="flex-1 bg-slate-950 border border-slate-700 rounded px-3 py-2 font-mono text-sm text-white focus:outline-none focus:border-emerald-500"
                    />
                ) : (
                    <input type="text" value={textInput} onChange={(e) => handleTextInputChange(e.target.value)}
                        className="flex-1 bg-slate-950 border border-slate-700 rounded px-3 py-2 font-mono text-sm text-white focus:outline-none focus:border-emerald-500" />
                )}
                <button onClick={() => {
                    // Generate random value using crypto API for better randomness
                    const bytes = new Uint8Array(width / 8);
                    crypto.getRandomValues(bytes);
                    let rnd = 0n;
                    for (let i = 0; i < bytes.length; ++i) rnd |= BigInt(bytes[i]) << BigInt(i * 8);
                    onValueChange(rnd);
                }} className="text-slate-500 hover:text-amber-400 p-2" title="Random value">
                    <IconDice className="w-4 h-4" />
                </button>
                <button onClick={() => onCopy(textInput)} className="text-slate-500 hover:text-cyan-400 p-2" title="Copy">
                    <IconCopy className="w-4 h-4" />
                </button>
            </div>

            {/* Quick reference displays */}
            <div className="grid grid-cols-2 gap-2 text-[10px]">
                <div className="bg-slate-900/50 rounded p-2">
                    <span className="text-slate-500">Hex:</span>
                    <code className="ml-1 text-emerald-400">{formatHex(value, width)}</code>
                </div>
                <div className="bg-slate-900/50 rounded p-2">
                    <span className="text-slate-500">Dec:</span>
                    <code className="ml-1 text-emerald-400">{value.toString()}</code>
                </div>
            </div>
        </div>
    );
};

// Field Editor Component
const FieldEditor = ({ fields, onAddField, onRemoveField, width }) => {
    const [newField, setNewField] = React.useState({ name: '', start: 0, width: 1 });

    const handleAdd = () => {
        if (newField.name && newField.width > 0 && newField.start + newField.width <= width) {
            onAddField({ ...newField, colorIndex: fields.length });
            setNewField({ name: '', start: 0, width: 1 });
        }
    };

    return (
        <div className="space-y-3">
            <div className="text-xs font-bold text-slate-500 uppercase tracking-widest">Named Fields</div>
            {fields.map((field, idx) => (
                <div key={idx} className="flex items-center gap-2 bg-slate-900/50 p-2 rounded border border-slate-800">
                    <div className="w-3 h-3 rounded-full" style={{ backgroundColor: field.color || `hsl(${(field.colorIndex * 60) % 360}, 70%, 50%)` }} />
                    <span className="text-sm font-mono text-slate-300 flex-1">{field.name}</span>
                    <span className="text-xs text-slate-500">[{field.start}:{field.start + field.width - 1}]</span>
                    <button onClick={() => onRemoveField(idx)} className="text-slate-500 hover:text-red-400">
                        <IconTrash className="w-4 h-4" />
                    </button>
                </div>
            ))}
            <div className="flex flex-wrap items-center gap-2">
                <input type="text" placeholder="Name" value={newField.name}
                    onChange={(e) => setNewField({ ...newField, name: e.target.value })}
                    className="flex-1 min-w-[80px] bg-slate-950 border border-slate-700 rounded px-2 py-1 text-sm text-white focus:outline-none focus:border-cyan-500" />
                <div className="flex items-center gap-1">
                    <input type="number" min="0" max={width - 1} value={newField.start}
                        onChange={(e) => setNewField({ ...newField, start: parseInt(e.target.value) || 0 })}
                        className="w-12 bg-slate-950 border border-slate-700 rounded px-1 py-1 text-sm text-white text-center focus:outline-none focus:border-cyan-500" title="Start bit" />
                    <span className="text-slate-600 text-xs">:</span>
                    <input type="number" min="1" max={width} value={newField.width}
                        onChange={(e) => setNewField({ ...newField, width: parseInt(e.target.value) || 1 })}
                        className="w-12 bg-slate-950 border border-slate-700 rounded px-1 py-1 text-sm text-white text-center focus:outline-none focus:border-cyan-500" title="Width in bits" />
                    <button onClick={handleAdd} className="bg-cyan-600 hover:bg-cyan-500 text-white px-2 py-1 rounded text-sm font-bold flex-shrink-0">
                        <IconPlus className="w-4 h-4" />
                    </button>
                </div>
            </div>
        </div>
    );
};

// Operations Panel Component
const OperationsPanel = ({ value, width, onChange }) => {
    const [shiftAmount, setShiftAmount] = React.useState(1);
    const mask = (1n << BigInt(width)) - 1n;

    const ops = [
        { label: 'SHL', icon: <IconArrowLeft className="w-4 h-4" />, title: 'Shift Left (logical, zero-fill)', action: () => onChange((value << BigInt(shiftAmount)) & mask) },
        { label: 'SAL', icon: <IconArrowLeft className="w-4 h-4" />, title: 'Shift Arithmetic Left (preserves sign bit)', action: () => onChange(signPreservingShiftLeft(value, shiftAmount, width)) },
        { label: 'SAR', icon: <IconArrowRight className="w-4 h-4" />, title: 'Shift Arithmetic Right (sign-extend)', action: () => onChange(arithmeticShiftRight(value, shiftAmount, width)) },
        { label: 'SHR', icon: <IconArrowRight className="w-4 h-4" />, title: 'Shift Right (logical, zero-fill)', action: () => onChange(value >> BigInt(shiftAmount)) },
        { label: 'ROL', icon: <IconRotate className="w-4 h-4" />, title: 'Rotate Left', action: () => onChange(rotateLeft(value, shiftAmount, width)) },
        { label: 'ROR', icon: <IconRotate className="w-4 h-4 transform scale-x-[-1]" />, title: 'Rotate Right', action: () => onChange(rotateRight(value, shiftAmount, width)) },
        { label: 'NOT', icon: '~', title: 'Bitwise NOT (complement)', action: () => onChange(mask ^ value) },
        { label: 'BSWAP', icon: <IconRefresh className="w-4 h-4" />, title: 'Byte Swap (reverse endianness)', action: () => onChange(swapBytes(value, width)) },
    ];

    return (
        <div className="space-y-3">
            <div className="text-xs font-bold text-slate-500 uppercase tracking-widest">Operations</div>
            <div className="flex items-center gap-2 mb-3">
                <span className="text-xs text-slate-500">Amount:</span>
                <input type="number" min="1" max={width - 1} value={shiftAmount}
                    onChange={(e) => setShiftAmount(parseInt(e.target.value) || 1)}
                    className="w-14 bg-slate-950 border border-slate-700 rounded px-2 py-1 text-sm text-white text-center focus:outline-none focus:border-cyan-500" />
            </div>
            <div className="grid grid-cols-4 gap-2">
                {ops.map((op, idx) => (
                    <button key={idx} onClick={op.action} title={op.title}
                        className="flex items-center justify-center gap-1 bg-slate-800 hover:bg-slate-700 border border-slate-700 hover:border-cyan-500 text-slate-300 hover:text-white px-2 py-2 rounded text-xs font-bold transition-all">
                        {typeof op.icon === 'string' ? <span className="text-base">{op.icon}</span> : op.icon}
                        <span>{op.label}</span>
                    </button>
                ))}
            </div>
            <div className="flex gap-2">
                <button onClick={() => onChange(0n)} className="flex-1 bg-slate-800 hover:bg-slate-700 border border-slate-700 text-slate-300 hover:text-white px-3 py-2 rounded text-xs font-bold transition-all">Clear</button>
                <button onClick={() => onChange(mask)} className="flex-1 bg-slate-800 hover:bg-slate-700 border border-slate-700 text-slate-300 hover:text-white px-3 py-2 rounded text-xs font-bold transition-all">Set All</button>
            </div>
        </div>
    );
};

// Statistics Panel Component
const StatsPanel = ({ value, width }) => {
    const pc = popcount(value);
    const stats = [
        { label: 'Popcount', value: pc, tooltip: 'Population Count: Number of bits set to 1' },
        { label: 'Zerocount', value: width - pc, tooltip: 'Zero Count: Number of bits set to 0' },
        { label: 'Parity', value: parity(value) === 0 ? 'Even' : 'Odd', tooltip: 'Parity: Even if popcount is even, Odd if popcount is odd (used for error detection)' },
        { label: 'Bit Width', value: bitWidth(value), tooltip: 'Minimum bits needed to represent this value (floor(log2(n))+1)' },
        { label: 'CLZ', value: clz(value, width), tooltip: 'Count Leading Zeros: Consecutive 0 bits from MSB' },
        { label: 'CLO', value: clo(value, width), tooltip: 'Count Leading Ones: Consecutive 1 bits from MSB' },
        { label: 'CTZ', value: ctz(value, width), tooltip: 'Count Trailing Zeros: Consecutive 0 bits from LSB' },
        { label: 'CTO', value: cto(value, width), tooltip: 'Count Trailing Ones: Consecutive 1 bits from LSB' },
        { label: 'MSB', value: value === 0n ? '-' : (width - 1 - clz(value, width)), tooltip: 'Most Significant Bit: Position of highest set bit (0-indexed)' },
        { label: 'LSB', value: value === 0n ? '-' : ctz(value, width), tooltip: 'Least Significant Bit: Position of lowest set bit (0-indexed)' },
    ];

    return (
        <div className="space-y-3">
            <div className="text-xs font-bold text-slate-500 uppercase tracking-widest">Statistics</div>
            <div className="grid grid-cols-5 gap-1">
                {stats.map((stat, idx) => (
                    <div key={idx} className="bg-slate-900/50 border border-slate-800 rounded p-1.5 text-center cursor-help" title={stat.tooltip}>
                        <div className="text-[9px] text-slate-500 uppercase truncate">{stat.label}</div>
                        <div className="text-sm font-mono text-cyan-400">{stat.value}</div>
                    </div>
                ))}
            </div>
        </div>
    );
};

// Code Export Component
const CodeExport = ({ fields, width, onCopy }) => {
    const [lang, setLang] = React.useState('c');
    const [expanded, setExpanded] = React.useState(false);
    const codeGenerators = { c: generateCCode, csharp: generateCSharpCode, cpp: generateCppCode };
    const code = codeGenerators[lang](fields, width);

    return (
        <div className="space-y-3">
            <div className="flex items-center justify-between">
                <div className="text-xs font-bold text-slate-500 uppercase tracking-widest flex items-center gap-2">
                    <IconCode className="w-4 h-4" />Code Export
                </div>
                <button onClick={() => setExpanded(!expanded)} className="text-slate-500 hover:text-white">
                    <IconChevronDown className="w-4 h-4" rotate={expanded} />
                </button>
            </div>
            {expanded && (
                <div className="space-y-2">
                    <div className="flex gap-2">
                        {['c', 'cpp', 'csharp'].map((l) => (
                            <button key={l} onClick={() => setLang(l)}
                                className={`px-3 py-1 rounded text-xs font-bold transition-all ${lang === l ? 'bg-cyan-600 text-white' : 'bg-slate-800 text-slate-400 hover:text-white'}`}>
                                {l === 'csharp' ? 'C#' : l.toUpperCase()}
                            </button>
                        ))}
                    </div>
                    <div className="relative">
                        <button onClick={() => onCopy(code)}
                            className="absolute top-2 right-2 text-slate-500 hover:text-white p-1.5 rounded hover:bg-slate-700 bg-slate-800 border border-slate-700">
                            <IconCopy className="w-3 h-3" />
                        </button>
                        <pre className="text-[10px] font-mono text-slate-300 bg-slate-950 p-3 rounded border border-slate-800 overflow-x-auto whitespace-pre-wrap leading-relaxed max-h-64 overflow-y-auto">
                            {code}
                        </pre>
                    </div>
                </div>
            )}
        </div>
    );
};

// --- MAIN APP ---
const BitBenchApp = () => {
    const [bitWidth, setBitWidth] = React.useState(32);
    const [value, setValue] = React.useState(0n);
    const [fields, setFields] = React.useState([]);
    const [highlightField, setHighlightField] = React.useState(null);
    const [showHelp, setShowHelp] = React.useState(false);
    const [copied, setCopied] = React.useState(false);

    const mask = (1n << BigInt(bitWidth)) - 1n;

    const handleToggleBit = (bitIndex) => setValue(prev => prev ^ (1n << BigInt(bitIndex)));

    const handleWidthChange = (newWidth) => {
        setBitWidth(newWidth);
        const newMask = (1n << BigInt(newWidth)) - 1n;
        setValue(prev => prev & newMask);
        setFields(prev => prev.filter(f => f.start + f.width <= newWidth));
    };

    const copyToClipboard = (text) => {
        navigator.clipboard.writeText(String(text));
        setCopied(true);
        setTimeout(() => setCopied(false), 1500);
    };

    // Load format components as named fields (double-click on format name)
    const handleLoadComponents = (format) => {
        if (!format.components || format.components.length === 0) return;
        // Clear existing fields and replace with format components
        const newFields = format.components.map((comp, idx) => ({
            name: comp.name,
            start: comp.start,
            width: comp.width,
            color: comp.color || null,  // Preserve custom color if specified
            colorIndex: idx             // Fallback for auto-generated colors
        }));
        setFields(newFields);
    };

    return (
        <div className="min-h-screen bg-slate-950 text-slate-200 font-sans flex flex-col">
            {/* HELP MODAL */}
            {showHelp && (
                <div className="modal-overlay" onClick={(e) => { if (e.target === e.currentTarget) setShowHelp(false); }}>
                    <div className="modal-content bg-slate-900 border border-slate-700 rounded-xl max-w-2xl w-full p-6 shadow-2xl relative max-h-[90vh] overflow-y-auto">
                        <button onClick={() => setShowHelp(false)} className="absolute top-4 right-4 text-slate-500 hover:text-white">
                            <IconX className="w-6 h-6" />
                        </button>
                        <div className="flex items-center gap-3 mb-4">
                            <div className="w-12 h-12 bg-gradient-to-br from-emerald-600 to-cyan-700 rounded-lg shadow-lg flex items-center justify-center text-white">
                                <IconBinary className="w-7 h-7" />
                            </div>
                            <div>
                                <h2 className="text-2xl font-bold text-white">BitBench</h2>
                                <p className="text-sm text-emerald-400">Binary/Bitwise Workbench</p>
                            </div>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-slate-300">
                            <div className="bg-slate-950 p-3 rounded border border-slate-800">
                                <h3 className="font-bold text-white mb-2">Type Interpretations</h3>
                                <ul className="list-disc list-inside space-y-1 text-slate-400 text-xs">
                                    <li>Integers: UInt8/16/32/64, Int8/16/32/64</li>
                                    <li>IEEE 754: Float16, Float32, Float64</li>
                                    <li>Exotic: BFloat16, MBF, IBM HFP, VAX</li>
                                    <li>Fixed: Q7.8, Q15.16, Q31.32</li>
                                    <li>BCD, Currency, Timestamps, Colors</li>
                                    <li>Both LE and BE byte orders</li>
                                </ul>
                            </div>
                            <div className="bg-slate-950 p-3 rounded border border-slate-800">
                                <h3 className="font-bold text-white mb-2">Type Aliases</h3>
                                <ul className="list-disc list-inside space-y-1 text-slate-400 text-xs">
                                    <li>UInt32 = uint = u32 = dword = DWORD</li>
                                    <li>Float32 = float = single = f32</li>
                                    <li>Int64 = long long = i64 = qword</li>
                                    <li>Currency = OLE Currency = money</li>
                                </ul>
                            </div>
                            <div className="bg-slate-950 p-3 rounded border border-slate-800">
                                <h3 className="font-bold text-white mb-2">Bit Operations</h3>
                                <ul className="list-disc list-inside space-y-1 text-slate-400 text-xs">
                                    <li>SHL: Shift left logical (zero-fill)</li>
                                    <li>SAL: Shift left arithmetic (preserves sign)</li>
                                    <li>SHR: Shift right logical (zero-fill)</li>
                                    <li>SAR: Shift right arithmetic (sign-extend)</li>
                                    <li>ROL/ROR: Rotate left/right (bits wrap)</li>
                                    <li>NOT: Bitwise complement</li>
                                    <li>BSWAP: Byte-swap (endianness)</li>
                                </ul>
                            </div>
                            <div className="bg-slate-950 p-3 rounded border border-slate-800">
                                <h3 className="font-bold text-white mb-2">Code Export</h3>
                                <ul className="list-disc list-inside space-y-1 text-slate-400 text-xs">
                                    <li>Define named bit fields</li>
                                    <li>Generate C/C++/C# code</li>
                                    <li>Masks, positions, accessors</li>
                                </ul>
                            </div>
                        </div>
                        <button onClick={() => setShowHelp(false)} className="mt-6 w-full py-3 bg-emerald-600 hover:bg-emerald-500 text-white font-bold rounded-lg transition-all">
                            Get Started
                        </button>
                    </div>
                </div>
            )}

            {/* HEADER */}
            <header className="border-b border-slate-800 bg-slate-900/90 backdrop-blur-md sticky top-0 z-40">
                <div className="mx-auto px-6 h-14 flex items-center justify-between">
                    <div className="flex items-center gap-3 cursor-pointer group" onClick={() => setShowHelp(true)}>
                        <div className="w-9 h-9 bg-gradient-to-br from-emerald-600 to-cyan-700 rounded-lg shadow-lg shadow-emerald-900/20 flex items-center justify-center text-white group-hover:scale-105 transition-transform">
                            <IconBinary className="w-5 h-5" />
                        </div>
                        <div>
                            <h1 className="text-lg font-bold tracking-tight text-white group-hover:text-emerald-400 transition-colors">
                                Bit<span className="text-emerald-400 group-hover:text-white transition-colors">Bench</span>
                            </h1>
                            <span className="text-[9px] text-slate-500 flex items-center gap-1"><IconInfo className="w-2.5 h-2.5" /> Help</span>
                        </div>
                    </div>
                    <div className="flex items-center gap-4">
                        <div className="flex bg-slate-800/50 p-1 rounded-lg">
                            {BIT_WIDTHS.map(size => (
                                <button key={size} onClick={() => handleWidthChange(size)}
                                    className={`px-3 py-1 rounded text-xs font-bold transition-all ${bitWidth === size ? 'bg-emerald-600 text-white shadow' : 'text-slate-400 hover:text-white'}`}>
                                    {size}
                                </button>
                            ))}
                        </div>
                    </div>
                </div>
            </header>

            {/* MAIN CONTENT */}
            <main className="flex-1 mx-auto px-6 py-4 w-full">
                <div className="grid grid-cols-1 lg:grid-cols-12 gap-4">
                    {/* LEFT PANEL - Input & Conversions */}
                    <div className="lg:col-span-4 space-y-4">
                        <div className="bg-slate-900/50 border border-slate-800 rounded-xl p-4">
                            <InputPanel value={value} width={bitWidth} onValueChange={setValue} onCopy={copyToClipboard} />
                        </div>
                        <div className="bg-slate-900/50 border border-slate-800 rounded-xl p-4 max-h-[60vh] overflow-y-auto">
                            <ConversionsPanel value={value} width={bitWidth} onCopy={copyToClipboard} onLoadComponents={handleLoadComponents} />
                        </div>
                    </div>

                    {/* CENTER PANEL - Bit Grid & Operations */}
                    <div className="lg:col-span-5 space-y-4">
                        <div className="bg-slate-900/50 border border-slate-800 rounded-xl p-4">
                            <div className="text-xs font-bold text-slate-500 uppercase tracking-widest mb-3">Bit Editor</div>
                            <BitGrid value={value} width={bitWidth} onToggleBit={handleToggleBit} fields={fields} highlightField={highlightField} />
                        </div>
                        <div className="bg-slate-900/50 border border-slate-800 rounded-xl p-4">
                            <OperationsPanel value={value} width={bitWidth} onChange={setValue} />
                        </div>
                        <div className="bg-slate-900/50 border border-slate-800 rounded-xl p-4">
                            <StatsPanel value={value} width={bitWidth} />
                        </div>
                    </div>

                    {/* RIGHT PANEL - Fields & Export */}
                    <div className="lg:col-span-3 space-y-4">
                        <div className="bg-slate-900/50 border border-slate-800 rounded-xl p-4">
                            <FieldEditor fields={fields} width={bitWidth}
                                onAddField={(f) => setFields([...fields, f])}
                                onRemoveField={(idx) => setFields(fields.filter((_, i) => i !== idx))} />
                        </div>
                        {fields.length > 0 && (
                            <div className="bg-slate-900/50 border border-slate-800 rounded-xl p-4 space-y-2">
                                <div className="text-xs font-bold text-slate-500 uppercase tracking-widest">Field Values</div>
                                {fields.map((field, idx) => {
                                    const fieldMask = ((1n << BigInt(field.width)) - 1n);
                                    const fieldValue = (value >> BigInt(field.start)) & fieldMask;
                                    return (
                                        <div key={idx}
                                            className="flex items-center gap-2 p-2 rounded border border-slate-700 hover:border-slate-600 cursor-pointer transition-all"
                                            onMouseEnter={() => setHighlightField(field.name)}
                                            onMouseLeave={() => setHighlightField(null)}>
                                            <div className="w-3 h-3 rounded-full flex-shrink-0" style={{ backgroundColor: field.color || `hsl(${(field.colorIndex * 60) % 360}, 70%, 50%)` }} />
                                            <span className="text-sm font-mono text-slate-300 flex-1 truncate">{field.name}</span>
                                            <span className="text-xs font-mono text-slate-500">{fieldValue.toString()}</span>
                                            <span className="text-sm font-mono text-emerald-400">{formatHex(fieldValue, field.width)}</span>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                        <div className="bg-slate-900/50 border border-slate-800 rounded-xl p-4">
                            <CodeExport fields={fields} width={bitWidth} onCopy={copyToClipboard} />
                        </div>
                    </div>
                </div>
            </main>

            {/* COPY NOTIFICATION */}
            {copied && (
                <div className="fixed bottom-6 left-1/2 -translate-x-1/2 bg-emerald-500 text-black px-4 py-2 rounded-full font-bold shadow-lg flex items-center gap-2 animate-bounce z-50 text-xs">
                    <IconCheck className="w-4 h-4" /> Copied!
                </div>
            )}
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<BitBenchApp />);

</script>
</body>
</html>
