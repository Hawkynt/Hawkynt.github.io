<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <!-- Use UTF-8 everywhere to avoid encoding issues; legacy UAs still render text/links. -->
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="Content-Script-Type" content="text/JavaScript" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="Language" content="en" />

    <!-- Modern SEO (harmless to old UAs) -->
    <meta name="description" content="MeetBurn - Free real-time meeting cost calculator. Track burn rate, visualize expenses, and optimize meeting ROI with live cost projections based on attendee hourly rates." />
    <meta name="keywords" content="meeting cost calculator, burn rate tracker, meeting ROI, productivity tool, time tracking, meeting timer, cost visualization, team meeting expenses, SynthelicZ, Hawkynt" />
    <meta name="robots" content="index,follow" />

    <!-- Open Graph / Twitter -->
    <meta property="og:title" content="MeetBurn - Real-Time Meeting Cost Calculator" />
    <meta property="og:description" content="Track your meeting costs in real-time. Visualize burn rate, project expenses, and make data-driven decisions about meeting ROI." />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://hawkynt.github.io/MeetBurn/" />
    <meta property="og:image" content="https://hawkynt.github.io/favicon.ico" />
    <meta name="twitter:card" content="summary" />

    <!-- Legacy site verification kept (harmless) -->
    <meta name="verify-v1" content="0cvNcn5f2mj21LAsFvUBD7BIdUbn/unV4Toy1yBLWvw=" />
    <meta name="google-site-verification" content="LkZ6DT0_GlcimQOKrWL20jv4jtUh0DBsh1ZPLXQqk3A" />

    <link rel="shortcut icon" href="../favicon.ico" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Meeting Cost Calculator</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        .touch-none { touch-action: none; }

        /* High Contrast overrides */
        .high-contrast { filter: contrast(1.5); }

        /* Disable scroll in presentation mode */
        body.presentation-active { overflow: hidden; }

        /* Desktop layout - sidebar scrolling */
        @media (min-width: 1024px) {
            .settings-sidebar {
                max-height: 100%;
                overflow-y: auto;
            }
            .main-layout {
                overflow: hidden !important;
            }
            .content-area, .settings-sidebar {
                min-height: 0;
                overflow-y: auto;
            }
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-900 transition-colors duration-200">
    <div id="root" class="h-screen w-screen flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- Icon Wrapper for Lucide ---
        const Icon = ({ name, size = 24, className }) => {
            useEffect(() => {
                if (window.lucide) window.lucide.createIcons();
            });
            // Convert camelCase to kebab-case for data-lucide attribute
            const iconName = name.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
            return <i data-lucide={iconName} className={className} style={{ width: size, height: size, display: 'inline-block', pointerEvents: 'none' }}></i>;
        };

        // --- Color Utility Functions ---
        const colorUtils = {
            hexToRgb: (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            },
            rgbToHex: (r, g, b) => {
                const toHex = (c) => {
                    const hex = Math.max(0, Math.min(255, Math.round(c))).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            },
            normalizedToRgb: (nr, ng, nb) => ({
                r: Math.round(nr * 255),
                g: Math.round(ng * 255),
                b: Math.round(nb * 255)
            }),
            rgbToNormalized: (r, g, b) => ({
                nr: (r / 255).toFixed(3),
                ng: (g / 255).toFixed(3),
                nb: (b / 255).toFixed(3)
            }),
            isValidHex: (hex) => /^#?([a-f\d]{6})$/i.test(hex),
            parseColorInput: (value, mode) => {
                if (mode === 'hex') {
                    const hex = value.startsWith('#') ? value : `#${value}`;
                    return colorUtils.isValidHex(hex) ? hex : null;
                }
                if (mode === 'rgb') {
                    const parts = value.split(/[,\s]+/).map(Number);
                    if (parts.length === 3 && parts.every(n => !isNaN(n) && n >= 0 && n <= 255))
                        return colorUtils.rgbToHex(parts[0], parts[1], parts[2]);
                    return null;
                }
                if (mode === 'normalized') {
                    const parts = value.split(/[,\s]+/).map(Number);
                    if (parts.length === 3 && parts.every(n => !isNaN(n) && n >= 0 && n <= 1)) {
                        const rgb = colorUtils.normalizedToRgb(parts[0], parts[1], parts[2]);
                        return colorUtils.rgbToHex(rgb.r, rgb.g, rgb.b);
                    }
                    return null;
                }
                return null;
            }
        };

        // --- ColorPicker Component ---
        const ColorPicker = ({ color, onChange, label, isDark, t }) => {
            const [inputMode, setInputMode] = useState('hex');
            const [textValue, setTextValue] = useState(color);
            const [isOpen, setIsOpen] = useState(false);
            const pickerRef = useRef(null);

            useEffect(() => {
                const rgb = colorUtils.hexToRgb(color);
                if (inputMode === 'hex')
                    setTextValue(color);
                else if (inputMode === 'rgb')
                    setTextValue(`${rgb.r}, ${rgb.g}, ${rgb.b}`);
                else {
                    const norm = colorUtils.rgbToNormalized(rgb.r, rgb.g, rgb.b);
                    setTextValue(`${norm.nr}, ${norm.ng}, ${norm.nb}`);
                }
            }, [color, inputMode]);

            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (pickerRef.current && !pickerRef.current.contains(e.target))
                        setIsOpen(false);
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            const handleTextChange = (value) => {
                setTextValue(value);
                const parsed = colorUtils.parseColorInput(value, inputMode);
                if (parsed) onChange(parsed);
            };

            const modes = [
                { key: 'hex', label: t('hexInput') },
                { key: 'rgb', label: t('rgbInput') },
                { key: 'normalized', label: t('normalizedInput') }
            ];

            return (
                <div className="relative" ref={pickerRef}>
                    <div className="flex items-center gap-2">
                        <button
                            onClick={() => setIsOpen(!isOpen)}
                            className="w-8 h-8 rounded border-2 shadow-sm cursor-pointer flex-shrink-0"
                            style={{ backgroundColor: color, borderColor: isDark ? '#475569' : '#cbd5e1' }}
                            title={label}
                        />
                        <span className={`text-xs flex-grow ${isDark ? 'text-slate-300' : 'text-slate-600'}`}>{label}</span>
                    </div>
                    {isOpen && (
                        <div className={`absolute z-50 mt-2 p-3 rounded-lg shadow-xl border ${isDark ? 'bg-slate-800 border-slate-600' : 'bg-white border-slate-200'}`} style={{ left: 0, minWidth: '220px' }}>
                            <input
                                type="color"
                                value={color}
                                onChange={(e) => onChange(e.target.value)}
                                className="w-full h-24 cursor-pointer rounded border-0 mb-3"
                                style={{ padding: 0 }}
                            />
                            <div className="flex gap-1 mb-2">
                                {modes.map(m => (
                                    <button
                                        key={m.key}
                                        onClick={() => setInputMode(m.key)}
                                        className={`flex-1 px-2 py-1 text-xs rounded transition-colors ${inputMode === m.key
                                            ? (isDark ? 'bg-blue-600 text-white' : 'bg-blue-500 text-white')
                                            : (isDark ? 'bg-slate-700 text-slate-300 hover:bg-slate-600' : 'bg-slate-100 text-slate-600 hover:bg-slate-200')
                                        }`}
                                    >
                                        {m.label}
                                    </button>
                                ))}
                            </div>
                            <input
                                type="text"
                                value={textValue}
                                onChange={(e) => handleTextChange(e.target.value)}
                                className={`w-full px-2 py-1 text-sm rounded border font-mono ${isDark ? 'bg-slate-700 border-slate-600 text-slate-200' : 'bg-white border-slate-300 text-slate-800'}`}
                                placeholder={inputMode === 'hex' ? '#ffffff' : inputMode === 'rgb' ? '255, 255, 255' : '1.0, 1.0, 1.0'}
                            />
                        </div>
                    )}
                </div>
            );
        };


        // =========================================================================
        // CONSTANTS
        // =========================================================================

        const TIME = {
            MS_PER_SECOND: 1000,
            MS_PER_MINUTE: 60000,
            MS_PER_HOUR: 3600000,
            SECONDS_PER_MINUTE: 60,
            SECONDS_PER_HOUR: 3600,
            QUARTER_HOUR_MINUTES: 15,
            FUTURE_MARKS_COUNT: 4,
        };

        const UI = {
            ICON_SIZE_DEFAULT: 24,
            TICKER_INTERVAL_MS: 100,
            COPY_SUCCESS_DURATION_MS: 2000,
            RATE_CHANGE_DEBOUNCE_MS: 500,
            SESSION_RESTORE_MINUTES: 15,
            CHART_PADDING: { top: 30, bottom: 30, left: 50, right: 30 },
            BURN_CHART_PADDING: { top: 10, bottom: 10, left: 20, right: 20 },
            TOOLTIP_PROXIMITY: 0.05,
            CHART_SCALE_PADDING: 1.1,
            BURN_CHART_SCALE_PADDING: 1.2,
            Y_AXIS_STEPS: 4,
            MIN_LABEL_SPACING: 40,
            MARKER_RADIUS: 3,
            LINE_DASH_PATTERN: [5, 5],
            MIN_DURATION_MS: 60000,
        };

        const DEFAULTS = {
            TITLE: 'Strategy Meeting',
            CURRENCY: 'USD',
            LOCALE: 'en',
            OVERHEAD: 1.3,
            ATTENDEE_COUNT: 6,
            HOURLY_RATE: 100,
            MANAGER_RATE: 150,
            ENGINEER_RATE: 100,
            MANAGER_COUNT: 1,
            ENGINEER_COUNT: 3,
            OVERHEAD_OPTIONS: [1.0, 1.3, 1.5, 2.0],
        };

        const INPUT_MODES = {
            SIMPLE: 'simple',
            DETAILED: 'detailed',
        };

        const SEGMENT_TYPES = {
            ACTIVE: 'active',
            PAUSED: 'paused',
        };

        const CURRENCIES = ['USD', 'EUR', 'GBP'];

        // Default color palettes for each mode (light, lightContrast, dark, darkContrast)
        const DEFAULT_PALETTES = {
            light: {
                background: '#f8fafc',
                surface: '#ffffff',
                text: '#0f172a',
                textMuted: '#64748b',
                accent: '#2563eb',
                border: '#e2e8f0',
                success: '#16a34a',
                warning: '#d97706',
            },
            lightContrast: {
                background: '#ffffff',
                surface: '#f8fafc',
                text: '#000000',
                textMuted: '#374151',
                accent: '#1d4ed8',
                border: '#9ca3af',
                success: '#15803d',
                warning: '#b45309',
            },
            dark: {
                background: '#0f172a',
                surface: '#1e293b',
                text: '#f1f5f9',
                textMuted: '#94a3b8',
                accent: '#3b82f6',
                border: '#334155',
                success: '#22c55e',
                warning: '#f59e0b',
            },
            darkContrast: {
                background: '#000000',
                surface: '#111827',
                text: '#ffffff',
                textMuted: '#d1d5db',
                accent: '#60a5fa',
                border: '#4b5563',
                success: '#4ade80',
                warning: '#fbbf24',
            },
        };

        const PALETTE_KEYS = ['background', 'surface', 'text', 'textMuted', 'accent', 'border', 'success', 'warning'];
        const PALETTE_ORDER = ['light', 'lightContrast', 'dark', 'darkContrast'];

        // Compact palette encoding: [[hex6,...],[hex6,...],[hex6,...],[hex6,...]]
        const encodePalettes = (palettes) => {
            const arr = PALETTE_ORDER.map(key =>
                PALETTE_KEYS.map(ck => palettes[key][ck].replace('#', ''))
            );
            return JSON.stringify(arr);
        };

        const decodePalettes = (str) => {
            try {
                const arr = JSON.parse(str);
                const result = {};
                PALETTE_ORDER.forEach((key, i) => {
                    result[key] = {};
                    PALETTE_KEYS.forEach((ck, j) => {
                        result[key][ck] = '#' + arr[i][j];
                    });
                });
                return result;
            } catch (e) { return null; }
        };

        // =========================================================================
        // LOCALIZATION
        // =========================================================================

        const TRANSLATIONS = {
            en: {
                // Headers and Titles
                currentMeetingCost: 'Current Meeting Cost',
                billableTime: 'Billable Time',
                burnRatePerHour: 'Burn Rate / Hr',
                costHistoryProjection: 'Cost History & Projection',
                burnRateHistory: 'Burn Rate History',
                agendaRoiCheck: 'Agenda ROI Check',
                quickEdit: 'Quick Edit',
                presentationMode: 'Presentation Mode',

                // Buttons
                start: 'Start',
                pause: 'Pause',
                resume: 'Resume',
                reset: 'Reset',
                copySnapshot: 'Copy Snapshot',
                copied: 'Copied!',
                shareLink: 'Share Link',
                shareLinkMinimal: 'Quick (attendees only)',
                shareLinkReadable: 'Full (readable)',
                linkCopied: 'Link copied!',
                addRole: '+ Add Role',

                // Labels
                participants: 'Participants',
                running: 'Running',
                paused: 'Paused',
                clickToToggle: '(Click to toggle)',
                simple: 'Simple',
                detailed: 'Detailed',
                overhead: 'Overhead',
                avgHourlyRate: 'Avg Hourly Rate',
                attendeeCount: 'Attendee Count',
                role: 'Role',
                perHour: '/hr',
                activeRate: 'Active Rate',
                estimatedAt: 'Est. @',
                newRole: 'New Role',

                // Agenda items
                goalDefined: 'Goal defined?',
                decisionRequired: 'Decision required?',
                alternativesConsidered: 'Alternatives considered?',

                // Tooltips
                toggleTheme: 'Toggle Theme',
                exitPresentation: 'Exit Presentation',
                highContrast: 'High Contrast',
                themeToggle: 'Theme Toggle',

                // Copy snapshot template
                meeting: 'Meeting',
                date: 'Date',
                duration: 'Duration',
                cost: 'Cost',
                burnRate: 'Burn Rate',
                attendees: 'Attendees',

                // Chart tooltips
                attendeesLabel: 'Attendees',
                rateLabel: 'Rate',

                // Currencies
                currencyUSD: 'USD ($)',
                currencyEUR: 'EUR (€)',
                currencyGBP: 'GBP (£)',

                // Roles
                manager: 'Manager',
                engineer: 'Engineer',

                // Corporate Design
                corporateDesign: 'Corporate Design',
                colorPalettes: 'Color Palettes',
                logoUrl: 'Logo URL',
                wordmarkUrl: 'Wordmark URL',
                paletteLight: 'Light',
                paletteLightContrast: 'Light (High Contrast)',
                paletteDark: 'Dark',
                paletteDarkContrast: 'Dark (High Contrast)',
                colorBackground: 'Background',
                colorSurface: 'Surface',
                colorText: 'Text',
                colorTextMuted: 'Muted Text',
                colorAccent: 'Accent',
                colorBorder: 'Border',
                colorSuccess: 'Success',
                colorWarning: 'Warning',
                resetPalette: 'Reset to Default',
                hexInput: 'Hex',
                rgbInput: 'RGB',
                normalizedInput: 'Normalized',
            },
            de: {
                // Headers and Titles
                currentMeetingCost: 'Aktuelle Meeting-Kosten',
                billableTime: 'Abrechenbare Zeit',
                burnRatePerHour: 'Kosten / Std',
                costHistoryProjection: 'Kostenverlauf & Prognose',
                burnRateHistory: 'Kostenrate-Verlauf',
                agendaRoiCheck: 'Agenda ROI-Check',
                quickEdit: 'Schnellbearbeitung',
                presentationMode: 'Präsentationsmodus',

                // Buttons
                start: 'Starten',
                pause: 'Pause',
                resume: 'Fortsetzen',
                reset: 'Zurücksetzen',
                copySnapshot: 'Kopieren',
                copied: 'Kopiert!',
                shareLink: 'Link teilen',
                shareLinkMinimal: 'Kurz (nur Teilnehmer)',
                shareLinkReadable: 'Voll (lesbar)',
                linkCopied: 'Link kopiert!',
                addRole: '+ Rolle hinzufügen',

                // Labels
                participants: 'Teilnehmer',
                running: 'Läuft',
                paused: 'Pausiert',
                clickToToggle: '(Klicken zum Umschalten)',
                simple: 'Einfach',
                detailed: 'Detailliert',
                overhead: 'Gemeinkosten',
                avgHourlyRate: 'Durchschn. Stundensatz',
                attendeeCount: 'Teilnehmeranzahl',
                role: 'Rolle',
                perHour: '/Std',
                activeRate: 'Aktive Rate',
                estimatedAt: 'Prognose @',
                newRole: 'Neue Rolle',

                // Agenda items
                goalDefined: 'Ziel definiert?',
                decisionRequired: 'Entscheidung nötig?',
                alternativesConsidered: 'Alternativen erwogen?',

                // Tooltips
                toggleTheme: 'Design wechseln',
                exitPresentation: 'Präsentation beenden',
                highContrast: 'Hoher Kontrast',
                themeToggle: 'Design wechseln',

                // Copy snapshot template
                meeting: 'Meeting',
                date: 'Datum',
                duration: 'Dauer',
                cost: 'Kosten',
                burnRate: 'Kosten/Std',
                attendees: 'Teilnehmer',

                // Chart tooltips
                attendeesLabel: 'Teilnehmer',
                rateLabel: 'Rate',

                // Currencies
                currencyUSD: 'USD ($)',
                currencyEUR: 'EUR (€)',
                currencyGBP: 'GBP (£)',

                // Roles
                manager: 'Manager',
                engineer: 'Entwickler',

                // Corporate Design
                corporateDesign: 'Corporate Design',
                colorPalettes: 'Farbpaletten',
                logoUrl: 'Logo URL',
                wordmarkUrl: 'Schriftzug URL',
                paletteLight: 'Hell',
                paletteLightContrast: 'Hell (Hoher Kontrast)',
                paletteDark: 'Dunkel',
                paletteDarkContrast: 'Dunkel (Hoher Kontrast)',
                colorBackground: 'Hintergrund',
                colorSurface: 'Oberfläche',
                colorText: 'Text',
                colorTextMuted: 'Gedämpfter Text',
                colorAccent: 'Akzent',
                colorBorder: 'Rahmen',
                colorSuccess: 'Erfolg',
                colorWarning: 'Warnung',
                resetPalette: 'Zurücksetzen',
                hexInput: 'Hex',
                rgbInput: 'RGB',
                normalizedInput: 'Normalisiert',
            }
        };

        const detectLocale = () => {
            const lang = (navigator.language || navigator.userLanguage || 'en').slice(0, 2).toLowerCase();
            return TRANSLATIONS[lang] ? lang : DEFAULTS.LOCALE;
        };

        const getDefaultCurrency = (locale) => {
            const currencyMap = { de: 'EUR', en: 'USD' };
            return currencyMap[locale] || DEFAULTS.CURRENCY;
        };

        // --- Utils ---
        const formatMoney = (amount, currency) => {
            return new Intl.NumberFormat('en-US', { style: 'currency', currency: currency }).format(amount);
        };

        const formatMoneyRounded = (amount, currency) => {
            return new Intl.NumberFormat('en-US', { 
                style: 'currency', 
                currency: currency,
                maximumFractionDigits: 0,
                minimumFractionDigits: 0
            }).format(amount);
        };

        const formatTime = (ms) => {
            const totalSeconds = Math.floor(ms / TIME.MS_PER_SECOND);
            const hours = Math.floor(totalSeconds / TIME.SECONDS_PER_HOUR);
            const minutes = Math.floor((totalSeconds % TIME.SECONDS_PER_HOUR) / TIME.SECONDS_PER_MINUTE);
            const seconds = totalSeconds % 60;
            const pad = (n) => n.toString().padStart(2, '0');
            return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
        };

        const formatClockTime = (date) => {
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        };

        const getBurnRatePerHour = (mode, simpleInputs, detailedRows, overhead) => {
            let hourlySum = 0;
            if (mode === 'simple') {
                hourlySum = simpleInputs.rate * simpleInputs.count;
            } else {
                hourlySum = detailedRows.reduce((acc, row) => acc + (row.rate * row.count), 0);
            }
            return hourlySum * overhead;
        };

        const getNextQuarterMarks = (nowTime) => {
            const d = new Date(nowTime);
            const m = d.getMinutes();
            const currentQuarter = Math.floor(m / TIME.QUARTER_HOUR_MINUTES);
            
            const marks = [];
            for (let i = 1; i <= TIME.FUTURE_MARKS_COUNT; i++) {
                const nextD = new Date(nowTime);
                const nextMin = (currentQuarter + i) * TIME.QUARTER_HOUR_MINUTES;
                nextD.setMinutes(nextMin);
                nextD.setSeconds(0);
                nextD.setMilliseconds(0);
                marks.push(nextD.getTime());
            }
            return marks;
        };

        const copyToClipboard = (text) => {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).catch(() => fallbackCopy(text));
            } else {
                fallbackCopy(text);
            }
        };

        const fallbackCopy = (text) => {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.left = "-9999px";
            textArea.style.top = "0";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try { document.execCommand('copy'); } catch (err) { console.error('Fallback copy failed', err); }
            document.body.removeChild(textArea);
        };

        // --- Session Persistence ---
        const STORAGE_KEY = 'meetburn_session';
        const RESTORE_TIMEOUT_MS = UI.SESSION_RESTORE_MINUTES * TIME.MS_PER_MINUTE;

        const saveSession = (state) => {
            try {
                const data = { ...state, savedAt: Date.now() };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            } catch (e) { console.warn('Failed to save session:', e); }
        };

        const loadSession = () => {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) return null;
                const data = JSON.parse(raw);
                const age = Date.now() - (data.savedAt || 0);
                // Meeting state expires after timeout, but UI preferences persist
                if (age > RESTORE_TIMEOUT_MS) {
                    // Clear meeting-specific state but keep UI preferences
                    delete data.startTime;
                    delete data.segments;
                    delete data.timerRunning;
                }
                return data;
            } catch (e) {
                console.warn('Failed to load session:', e);
                return null;
            }
        };

        const clearSession = () => {
            try { localStorage.removeItem(STORAGE_KEY); } catch (e) {}
        };

        // --- URL Parameter Utilities ---

        const parseUrlParams = () => {
            const params = new URLSearchParams(window.location.search);
            const config = {};

            // Simple params
            if (params.has('att')) config.attendees = parseInt(params.get('att'), 10);
            if (params.has('rate')) config.rate = parseFloat(params.get('rate'));
            if (params.has('overhead')) config.overhead = parseFloat(params.get('overhead'));
            if (params.has('currency')) config.currency = params.get('currency').toUpperCase();
            if (params.has('title')) config.title = params.get('title');
            if (params.has('mode')) config.inputMode = params.get('mode');
            if (params.has('dark')) config.isDark = params.get('dark') === '1';
            if (params.has('contrast')) config.highContrast = params.get('contrast') === '1';
            if (params.has('logo')) config.logoUri = params.get('logo');
            if (params.has('wordmark')) config.schriftzugUri = params.get('wordmark');
            if (params.has('lang')) config.locale = params.get('lang');

            // Roles param: "Manager:150:2,Engineer:100:4"
            if (params.has('roles')) {
                config.inputMode = INPUT_MODES.DETAILED;
                config.detailedRows = params.get('roles').split(',').map((role, idx) => {
                    const [label, rate, count] = role.split(':');
                    return { id: idx + 1, label: decodeURIComponent(label), rate: parseFloat(rate), count: parseInt(count, 10) };
                });
            }

            // Colors param: compact palette format [[hex6,...],...]
            if (params.has('colors')) {
                try {
                    const decoded = decodePalettes(atob(params.get('colors')));
                    if (decoded) config.customPalettes = decoded;
                } catch (e) { console.warn('Invalid colors param'); }
            }

            return Object.keys(config).length > 0 ? config : null;
        };

        const generateShareUrl = (state, options = {}) => {
            const base = window.location.origin + window.location.pathname;
            const params = new URLSearchParams();

            if (options.minimal) {
                // Just attendee count for quick share
                const count = state.inputMode === INPUT_MODES.SIMPLE
                    ? state.simpleInputs.count
                    : state.detailedRows.reduce((sum, r) => sum + r.count, 0);
                params.set('att', count);
            } else {
                // Human-readable params
                if (state.title !== DEFAULTS.TITLE) params.set('title', state.title);
                if (state.currency !== 'USD') params.set('currency', state.currency);
                if (state.overhead !== DEFAULTS.OVERHEAD) params.set('overhead', state.overhead);
                if (state.isDark) params.set('dark', '1');
                if (state.highContrast) params.set('contrast', '1');
                if (state.logoUri) params.set('logo', state.logoUri);
                if (state.schriftzugUri) params.set('wordmark', state.schriftzugUri);
                if (state.locale !== 'en') params.set('lang', state.locale);

                // Include custom color palettes if modified from defaults (compact format)
                const palettesModified = JSON.stringify(state.customPalettes) !== JSON.stringify(DEFAULT_PALETTES);
                if (palettesModified) {
                    params.set('colors', btoa(encodePalettes(state.customPalettes)));
                }

                if (state.inputMode === INPUT_MODES.DETAILED) {
                    const rolesStr = state.detailedRows
                        .map(r => `${encodeURIComponent(r.label)}:${r.rate}:${r.count}`)
                        .join(',');
                    params.set('roles', rolesStr);
                } else {
                    params.set('att', state.simpleInputs.count);
                    if (state.simpleInputs.rate !== DEFAULTS.HOURLY_RATE) {
                        params.set('rate', state.simpleInputs.rate);
                    }
                }
            }

            const queryStr = params.toString();
            return queryStr ? `${base}?${queryStr}` : base;
        };

        // --- Charts ---

        const CostHistoryChart = ({ segments, currentCost, currentBurnRate, currency, chartColors, startTime, timerRunning }) => {
            const canvasRef = useRef(null);
            const [tooltip, setTooltip] = useState(null);

            const draw = useCallback((ctx, width, height) => {
                ctx.clearRect(0, 0, width, height);

                const now = Date.now();
                const effectiveStart = startTime || now;
                
                // Future Marks
                const futureMarks = getNextQuarterMarks(now);
                const projectionEnd = futureMarks[futureMarks.length - 1]; 
                
                // Domain
                const timeDomainStart = effectiveStart;
                const timeDomainEnd = projectionEnd;
                const totalDuration = Math.max(timeDomainEnd - timeDomainStart, UI.MIN_DURATION_MS);

                // History Points
                const historyPoints = [];

                // Always add start point (0,0)
                historyPoints.push({ xTime: effectiveStart, cost: 0, type: 'start' });

                if (segments.length > 0) {
                    segments.forEach((seg) => {
                        // Avoid duplicate start point if segment aligns perfectly
                        if (Math.abs(seg.timestamp - effectiveStart) > 100) {
                            historyPoints.push({
                                xTime: seg.timestamp,
                                cost: seg.costAtStart,
                                type: 'event'
                            });
                        }
                    });
                }

                // Now Point
                historyPoints.push({ xTime: now, cost: currentCost, type: 'now' });

                // Projection Points
                const projectionPoints = [];
                const ratePerMs = timerRunning ? (currentBurnRate / TIME.MS_PER_HOUR) : 0; 

                futureMarks.forEach(markTime => {
                    const timeDiff = markTime - now;
                    const projectedCost = currentCost + (ratePerMs * timeDiff);
                    projectionPoints.push({
                        xTime: markTime,
                        cost: projectedCost,
                        label: formatClockTime(new Date(markTime))
                    });
                });

                // Scales
                const maxProjectedCost = projectionPoints.length > 0 ? projectionPoints[projectionPoints.length - 1].cost : currentCost;
                const maxCost = Math.max(currentCost * 1.1, maxProjectedCost * 1.1, 100); 

                const padding = { top: 30, bottom: 30, left: 60, right: 30 };
                const graphWidth = width - padding.left - padding.right;
                const graphHeight = height - padding.top - padding.bottom;

                const getX = (t) => padding.left + ((t - timeDomainStart) / totalDuration) * graphWidth;
                const getY = (c) => (height - padding.bottom) - (c / maxCost) * graphHeight;

                // Axes
                ctx.strokeStyle = chartColors.grid;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(padding.left, padding.top);
                ctx.lineTo(padding.left, height - padding.bottom);
                ctx.lineTo(width - padding.right, height - padding.bottom);
                ctx.stroke();

                // Y-Axis Labels
                ctx.fillStyle = chartColors.text;
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.font = '10px sans-serif';
                
                const ySteps = 4;
                for (let i = 0; i <= ySteps; i++) {
                    const val = (maxCost / ySteps) * i;
                    const yPos = getY(val);
                    ctx.fillText(formatMoneyRounded(val, currency), padding.left - 8, yPos);
                    
                    if (i > 0) {
                        ctx.beginPath();
                        ctx.strokeStyle = chartColors.gridLight;
                        ctx.moveTo(padding.left, yPos);
                        ctx.lineTo(width - padding.right, yPos);
                        ctx.stroke();
                    }
                }

                // X-Axis Labels
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                
                // Explicitly draw Start Time
                const startX = getX(timeDomainStart);
                ctx.fillStyle = chartColors.text;
                ctx.fillText(formatClockTime(new Date(timeDomainStart)), startX, height - padding.bottom + 8);

                // Draw Future Marks labels
                futureMarks.forEach(t => {
                    const xPos = getX(t);
                    if (xPos > startX + 40 && xPos < width) { 
                        ctx.fillText(formatClockTime(new Date(t)), xPos, height - padding.bottom + 8);
                    }
                });

                // History Line
                ctx.strokeStyle = chartColors.accent;
                ctx.lineWidth = 3;
                ctx.lineJoin = 'round';
                ctx.beginPath();
                
                historyPoints.forEach((p, i) => {
                    const x = getX(p.xTime);
                    const y = getY(p.cost);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Projection Line
                ctx.beginPath();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = chartColors.projection;
                
                ctx.moveTo(getX(now), getY(currentCost));
                projectionPoints.forEach(p => {
                    ctx.lineTo(getX(p.xTime), getY(p.cost));
                });
                ctx.stroke();
                ctx.setLineDash([]); 

                // Event markers
                historyPoints.forEach((p) => {
                    if (p.type === 'start') return; 
                    const x = getX(p.xTime);
                    const y = getY(p.cost);
                    ctx.beginPath();
                    ctx.strokeStyle = chartColors.projectionLight;
                    ctx.lineWidth = 1;
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, height - padding.bottom);
                    ctx.stroke();
                    ctx.fillStyle = chartColors.accent;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Projection Dots & Values
                projectionPoints.forEach(p => {
                    const x = getX(p.xTime);
                    const y = getY(p.cost);
                    ctx.fillStyle = chartColors.text;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.font = 'bold 11px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = chartColors.textStrong; 
                    ctx.fillText(formatMoneyRounded(p.cost, currency), x, y - 10);
                });

            }, [segments, currentCost, currentBurnRate, chartColors, startTime, currency, timerRunning]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                const parent = canvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                
                const resize = () => {
                    const w = parent.clientWidth;
                    const h = parent.clientHeight;
                    canvas.width = w * dpr;
                    canvas.height = h * dpr;
                    canvas.style.width = w + 'px';
                    canvas.style.height = h + 'px';
                    ctx.scale(dpr, dpr);
                    draw(ctx, w, h);
                };
                
                resize();
                window.addEventListener('resize', resize);
                return () => window.removeEventListener('resize', resize);
            }, [draw]);

            // Re-draw on data change
            useEffect(() => {
                const canvas = canvasRef.current;
                if(canvas) {
                    const ctx = canvas.getContext('2d');
                    const parent = canvas.parentElement;
                    if (parent) {
                        const w = parent.clientWidth;
                        const h = parent.clientHeight;
                        draw(ctx, w, h);
                    }
                }
            }, [draw, currentCost]);

            const handleMouseMove = (e) => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                
                const now = Date.now();
                const effectiveStart = startTime || now;
                const futureMarks = getNextQuarterMarks(now);
                const projectionEnd = futureMarks[futureMarks.length - 1];
                const totalDuration = Math.max(projectionEnd - effectiveStart, UI.MIN_DURATION_MS);
                
                const width = canvas.offsetWidth;
                const padding = { left: 60, right: 30 };
                const graphWidth = width - padding.left - padding.right;
                
                const timeAtCursor = effectiveStart + ((mouseX - padding.left) / graphWidth) * totalDuration;
                
                let closestSeg = null;
                let minDist = Infinity;

                segments.forEach(seg => {
                    const dist = Math.abs(seg.timestamp - timeAtCursor);
                    if (dist < minDist) {
                        minDist = dist;
                        closestSeg = seg;
                    }
                });

                const thresholdTime = totalDuration * 0.05; 
                
                if (closestSeg && minDist < thresholdTime) {
                    const timeStr = formatClockTime(new Date(closestSeg.timestamp));
                    const status = closestSeg.type === 'paused' ? 'Paused' : `${closestSeg.attendeeCount} Attendees`;
                    const rate = closestSeg.type === 'paused' ? 'Rate: $0/hr' : `${formatMoney(closestSeg.burnRate, currency)}/hr`;
                    
                    setTooltip({
                        x: mouseX,
                        y: 30,
                        text: [timeStr, status, rate]
                    });
                } else {
                    setTooltip(null);
                }
            };

            return (
                <div className="w-full h-full relative group">
                    <canvas 
                        ref={canvasRef} 
                        className="w-full h-full cursor-crosshair touch-none"
                        onMouseMove={handleMouseMove}
                        onMouseLeave={() => setTooltip(null)}
                    />
                    {tooltip && (
                        <div 
                            className="absolute z-10 p-2 rounded shadow-lg text-xs pointer-events-none bg-slate-800 text-white border border-slate-600 whitespace-nowrap"
                            style={{ left: Math.min(tooltip.x + 10, 400), top: tooltip.y }}
                        >
                            {tooltip.text.map((line, i) => <div key={i}>{line}</div>)}
                        </div>
                    )}
                </div>
            );
        };

        const BurnRateChart = ({ segments, currentBurnRate, currency, chartColors, startTime, timerRunning, label }) => {
            const canvasRef = useRef(null);
            const [tooltip, setTooltip] = useState(null);

            const draw = useCallback((ctx, width, height) => {
                ctx.clearRect(0, 0, width, height);

                const now = Date.now();
                if (!startTime) return;

                const totalDuration = Math.max(now - startTime, UI.MIN_DURATION_MS);
                const maxRate = Math.max(...segments.map((s) => s.burnRate), currentBurnRate, 100) * 1.2;

                const padding = { left: 55, right: 20, top: 25, bottom: 30 };
                const graphWidth = width - padding.left - padding.right;
                const graphHeight = height - padding.top - padding.bottom;

                const getX = (t) => padding.left + ((t - startTime) / totalDuration) * graphWidth;
                const getY = (r) => (height - padding.bottom) - (r / maxRate) * graphHeight;

                // Axes
                ctx.strokeStyle = chartColors.grid;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(padding.left, padding.top);
                ctx.lineTo(padding.left, height - padding.bottom);
                ctx.lineTo(width - padding.right, height - padding.bottom);
                ctx.stroke();

                // Y-Axis grid lines and labels
                ctx.fillStyle = chartColors.text;
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.font = '10px sans-serif';

                const ySteps = 3;
                for (let i = 0; i <= ySteps; ++i) {
                    const val = (maxRate / ySteps) * i;
                    const yPos = getY(val);
                    ctx.fillText(formatMoneyRounded(val, currency), padding.left - 8, yPos);

                    if (i > 0) {
                        ctx.beginPath();
                        ctx.strokeStyle = chartColors.gridLight;
                        ctx.moveTo(padding.left, yPos);
                        ctx.lineTo(width - padding.right, yPos);
                        ctx.stroke();
                    }
                }

                // X-Axis Labels (start time and now)
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillStyle = chartColors.text;

                const startX = getX(startTime);
                ctx.fillText(formatClockTime(new Date(startTime)), startX, height - padding.bottom + 8);

                const nowX = getX(now);
                if (nowX > startX + 50) {
                    ctx.fillText(formatClockTime(new Date(now)), nowX, height - padding.bottom + 8);
                }

                // Draw step line for burn rate
                ctx.strokeStyle = chartColors.burnLine;
                ctx.lineWidth = 2;
                ctx.beginPath();

                segments.forEach((seg, i) => {
                    const nextSeg = segments[i + 1];
                    const segEndTime = nextSeg ? nextSeg.timestamp : now;

                    const xStart = getX(seg.timestamp);
                    const xEnd = getX(segEndTime);
                    const y = getY(seg.burnRate);

                    if (i === 0) ctx.moveTo(xStart, y);
                    else ctx.lineTo(xStart, y);

                    ctx.lineTo(xEnd, y);
                });

                ctx.stroke();

                // Fill under the line
                ctx.lineTo(getX(now), height - padding.bottom);
                ctx.lineTo(padding.left, height - padding.bottom);
                ctx.closePath();
                ctx.fillStyle = chartColors.burnFill;
                ctx.fill();

                // Event markers (vertical lines at segment changes)
                segments.forEach((seg, i) => {
                    if (i === 0) return; // Skip first segment
                    const x = getX(seg.timestamp);
                    const y = getY(seg.burnRate);

                    // Vertical dashed line
                    ctx.beginPath();
                    ctx.setLineDash([3, 3]);
                    ctx.strokeStyle = chartColors.projectionLight;
                    ctx.lineWidth = 1;
                    ctx.moveTo(x, padding.top);
                    ctx.lineTo(x, height - padding.bottom);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Marker dot
                    ctx.fillStyle = chartColors.burnLine;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Current position marker
                if (timerRunning) {
                    const currentY = getY(currentBurnRate);
                    ctx.fillStyle = chartColors.burnLine;
                    ctx.beginPath();
                    ctx.arc(getX(now), currentY, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

            }, [segments, currentBurnRate, currency, chartColors, startTime, timerRunning]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                const parent = canvas.parentElement;
                const dpr = window.devicePixelRatio || 1;

                const resize = () => {
                    const w = parent.clientWidth;
                    const h = parent.clientHeight;
                    canvas.width = w * dpr;
                    canvas.height = h * dpr;
                    canvas.style.width = w + 'px';
                    canvas.style.height = h + 'px';
                    ctx.scale(dpr, dpr);
                    draw(ctx, w, h);
                };

                resize();
                window.addEventListener('resize', resize);
                return () => window.removeEventListener('resize', resize);
            }, [draw]);

            // Re-draw on data change
            useEffect(() => {
                const canvas = canvasRef.current;
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    const parent = canvas.parentElement;
                    if (parent) {
                        const w = parent.clientWidth;
                        const h = parent.clientHeight;
                        draw(ctx, w, h);
                    }
                }
            }, [draw, currentBurnRate]);

            const handleMouseMove = (e) => {
                const canvas = canvasRef.current;
                if (!canvas || !startTime) return;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;

                const now = Date.now();
                const totalDuration = Math.max(now - startTime, UI.MIN_DURATION_MS);

                const width = canvas.offsetWidth;
                const padding = { left: 55, right: 20 };
                const graphWidth = width - padding.left - padding.right;

                const timeAtCursor = startTime + ((mouseX - padding.left) / graphWidth) * totalDuration;

                let closestSeg = null;
                let minDist = Infinity;

                segments.forEach(seg => {
                    const dist = Math.abs(seg.timestamp - timeAtCursor);
                    if (dist < minDist) {
                        minDist = dist;
                        closestSeg = seg;
                    }
                });

                const thresholdTime = totalDuration * 0.08;

                if (closestSeg && minDist < thresholdTime) {
                    const timeStr = formatClockTime(new Date(closestSeg.timestamp));
                    const status = closestSeg.type === 'paused' ? 'Paused' : `${closestSeg.attendeeCount} Attendees`;
                    const rate = closestSeg.type === 'paused' ? 'Rate: $0/hr' : `${formatMoney(closestSeg.burnRate, currency)}/hr`;

                    setTooltip({
                        x: mouseX,
                        y: 20,
                        text: [timeStr, status, rate]
                    });
                } else {
                    setTooltip(null);
                }
            };

            return (
                <div className="w-full h-full relative group">
                    <div className="absolute top-0 left-2 text-[10px] uppercase font-semibold opacity-50 z-10">{label}</div>
                    <canvas
                        ref={canvasRef}
                        className="w-full h-full cursor-crosshair touch-none"
                        onMouseMove={handleMouseMove}
                        onMouseLeave={() => setTooltip(null)}
                    />
                    {tooltip && (
                        <div
                            className="absolute z-20 p-2 rounded shadow-lg text-xs pointer-events-none bg-slate-800 text-white border border-slate-600 whitespace-nowrap"
                            style={{ left: Math.min(tooltip.x + 10, 300), top: tooltip.y }}
                        >
                            {tooltip.text.map((line, i) => <div key={i}>{line}</div>)}
                        </div>
                    )}
                </div>
            );
        };

        // --- Main App ---
        const App = () => {
            const [timerRunning, setTimerRunning] = useState(false);
            const [startTime, setStartTime] = useState(null);
            const [segments, setSegments] = useState([]); 
            
            const [title, setTitle] = useState(DEFAULTS.TITLE);
            const [currency, setCurrency] = useState(() => getDefaultCurrency(detectLocale()));
            const [presentationMode, setPresentationMode] = useState(false);
            const [isDark, setIsDark] = useState(false);
            const [highContrast, setHighContrast] = useState(false);
                        const [showAgenda, setShowAgenda] = useState(false);
            const [copySuccess, setCopySuccess] = useState(false);
            const [shareMenuOpen, setShareMenuOpen] = useState(false);
            const [shareSuccess, setShareSuccess] = useState(false);
            const [ticker, setTicker] = useState(0);

            // Localization
            const [locale, setLocale] = useState(detectLocale);
            const t = (key) => TRANSLATIONS[locale]?.[key] || TRANSLATIONS.en[key] || key; 

            const [inputMode, setInputMode] = useState(INPUT_MODES.SIMPLE); 
            const [overhead, setOverhead] = useState(DEFAULTS.OVERHEAD);
            const [simpleInputs, setSimpleInputs] = useState({ count: DEFAULTS.ATTENDEE_COUNT, rate: DEFAULTS.HOURLY_RATE });
            const [detailedRows, setDetailedRows] = useState([
                { id: 1, label: TRANSLATIONS[detectLocale()].manager, rate: DEFAULTS.MANAGER_RATE, count: DEFAULTS.MANAGER_COUNT },
                { id: 2, label: TRANSLATIONS[detectLocale()].engineer, rate: DEFAULTS.ENGINEER_RATE, count: DEFAULTS.ENGINEER_COUNT },
            ]);

            // Corporate Design
            const [customPalettes, setCustomPalettes] = useState(() => JSON.parse(JSON.stringify(DEFAULT_PALETTES)));
            const [logoUri, setLogoUri] = useState('');
            const [schriftzugUri, setSchriftzugUri] = useState('');

            // Get current palette based on theme mode
            const getCurrentPaletteKey = () => {
                if (isDark && highContrast) return 'darkContrast';
                if (isDark) return 'dark';
                if (highContrast) return 'lightContrast';
                return 'light';
            };

            const updatePaletteColor = (paletteKey, colorKey, value) => {
                setCustomPalettes(prev => ({
                    ...prev,
                    [paletteKey]: { ...prev[paletteKey], [colorKey]: value }
                }));
            };

            const resetPalette = (paletteKey) => {
                setCustomPalettes(prev => ({
                    ...prev,
                    [paletteKey]: { ...DEFAULT_PALETTES[paletteKey] }
                }));
            };

            // Session restoration ref
            const sessionRestored = useRef(false);

            // Restore session on mount (URL params override localStorage)
            useEffect(() => {
                if (sessionRestored.current) return;
                sessionRestored.current = true;

                const urlConfig = parseUrlParams();
                const saved = loadSession() || {};

                // Merge: URL params take priority over saved session
                const config = { ...saved, ...urlConfig };

                // Restore meeting state (only from saved, not URL)
                if (saved.startTime) {
                    setTimerRunning(saved.timerRunning || false);
                    setStartTime(saved.startTime);
                    setSegments(saved.segments || []);
                }

                // Restore configuration (merged)
                if (config.title) setTitle(config.title);
                if (config.currency) setCurrency(config.currency);
                if (config.inputMode) setInputMode(config.inputMode);
                if (config.overhead !== undefined) setOverhead(config.overhead);
                if (config.simpleInputs) setSimpleInputs(config.simpleInputs);
                if (config.detailedRows) setDetailedRows(config.detailedRows);

                // Handle URL-specific simple mode overrides
                if (urlConfig?.attendees !== undefined) {
                    setSimpleInputs(prev => ({ ...prev, count: urlConfig.attendees }));
                    if (!urlConfig.inputMode) setInputMode(INPUT_MODES.SIMPLE);
                }
                if (urlConfig?.rate !== undefined) {
                    setSimpleInputs(prev => ({ ...prev, rate: urlConfig.rate }));
                }

                // Restore UI state (merged)
                if (config.presentationMode !== undefined) setPresentationMode(config.presentationMode);
                if (config.isDark !== undefined) setIsDark(config.isDark);
                if (config.highContrast !== undefined) setHighContrast(config.highContrast);
                                if (config.showAgenda !== undefined) setShowAgenda(config.showAgenda);
                if (config.locale) setLocale(config.locale);

                // Restore corporate design (merged)
                if (config.customPalettes) setCustomPalettes(prev => ({ ...prev, ...config.customPalettes }));
                if (config.logoUri !== undefined) setLogoUri(config.logoUri);
                if (config.schriftzugUri !== undefined) setSchriftzugUri(config.schriftzugUri);
            }, []);

            // Save session state
            useEffect(() => {
                saveSession({
                    timerRunning, startTime, segments, title, currency,
                    inputMode, overhead, simpleInputs, detailedRows,
                    presentationMode, isDark, highContrast, showAgenda, locale,
                    customPalettes, logoUri, schriftzugUri
                });
            }, [timerRunning, startTime, segments, title, currency, inputMode, overhead, simpleInputs, detailedRows, presentationMode, isDark, highContrast, showAgenda, locale, customPalettes, logoUri, schriftzugUri]);

            const totalAttendees = inputMode === 'simple' ? simpleInputs.count : detailedRows.reduce((a,b)=>a+b.count,0);
            
            const calculatedBurnRate = useMemo(() => 
                getBurnRatePerHour(inputMode, simpleInputs, detailedRows, overhead), 
            [inputMode, simpleInputs, detailedRows, overhead]);

            const currentCost = useMemo(() => {
                if (!startTime || segments.length === 0) return 0;
                const now = Date.now();
                let total = 0;
                for (let i = 0; i < segments.length; i++) {
                    const seg = segments[i];
                    const nextSeg = segments[i + 1];
                    const segEndTime = nextSeg ? nextSeg.timestamp : now;
                    if (seg.type === 'active') {
                        const durationHrs = (segEndTime - seg.timestamp) / TIME.MS_PER_HOUR;
                        total += durationHrs * seg.burnRate;
                    }
                }
                return total;
            }, [segments, startTime, ticker]);

            const billableDuration = useMemo(() => {
                if (!startTime || segments.length === 0) return 0;
                const now = Date.now();
                let totalMs = 0;
                for (let i = 0; i < segments.length; i++) {
                    const seg = segments[i];
                    const nextSeg = segments[i + 1];
                    const segEndTime = nextSeg ? nextSeg.timestamp : now;
                    if (seg.type === 'active') {
                        totalMs += (segEndTime - seg.timestamp);
                    }
                }
                return totalMs;
            }, [segments, startTime, ticker]);

            useEffect(() => {
                let interval;
                if (startTime) {
                    interval = setInterval(() => {
                        setTicker(Date.now());
                    }, UI.TICKER_INTERVAL_MS);
                }
                return () => clearInterval(interval);
            }, [startTime]);

            const pushSegment = (type, rate) => {
                const now = Date.now();
                let costUpToNow = 0;
                if (segments.length > 0) {
                    const lastSeg = segments[segments.length - 1];
                    costUpToNow = lastSeg.costAtStart; 
                    if (lastSeg.type === 'active') {
                        costUpToNow += ((now - lastSeg.timestamp) / TIME.MS_PER_HOUR) * lastSeg.burnRate;
                    }
                }
                setSegments(prev => [
                    ...prev,
                    { 
                        timestamp: now, 
                        burnRate: rate, 
                        type: type, 
                        attendeeCount: totalAttendees,
                        costAtStart: costUpToNow
                    }
                ]);
            };

            const toggleTimer = () => {
                const now = Date.now();
                if (timerRunning) {
                    setTimerRunning(false);
                    pushSegment('paused', 0);
                } else {
                    if (!startTime) setStartTime(now);
                    setTimerRunning(true);
                    pushSegment('active', calculatedBurnRate);
                }
            };

            const resetMeeting = () => {
                setTimerRunning(false);
                setStartTime(null);
                setSegments([]);
                clearSession();
            };

            const lastCommittedRate = useRef(calculatedBurnRate);
            const lastCommittedCount = useRef(totalAttendees);

            useEffect(() => {
                if (timerRunning) {
                    const rateChanged = Math.abs(calculatedBurnRate - lastCommittedRate.current) > 0.01;
                    const countChanged = totalAttendees !== lastCommittedCount.current;
                    
                    if (rateChanged || countChanged) {
                        const handler = setTimeout(() => {
                            pushSegment('active', calculatedBurnRate);
                            lastCommittedRate.current = calculatedBurnRate;
                            lastCommittedCount.current = totalAttendees;
                        }, UI.RATE_CHANGE_DEBOUNCE_MS);
                        return () => clearTimeout(handler);
                    }
                } else {
                    lastCommittedRate.current = calculatedBurnRate;
                    lastCommittedCount.current = totalAttendees;
                }
            }, [calculatedBurnRate, totalAttendees, timerRunning]);

            const switchInputMode = (newMode) => {
                if (newMode === inputMode) return;
                if (newMode === 'detailed') {
                    const newRow = { id: Date.now(), label: 'Participants', rate: simpleInputs.rate, count: simpleInputs.count };
                    setDetailedRows([newRow]);
                } else {
                    const totalCount = detailedRows.reduce((sum, r) => sum + r.count, 0);
                    const totalCostVal = detailedRows.reduce((sum, r) => sum + (r.rate * r.count), 0);
                    const avgRate = totalCount > 0 ? Math.round(totalCostVal / totalCount) : 100;
                    setSimpleInputs({ count: totalCount, rate: avgRate });
                }
                setInputMode(newMode);
            };

            const handleKeyDown = (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                switch(e.key.toLowerCase()) {
                    case ' ': e.preventDefault(); toggleTimer(); break;
                    case 'r': resetMeeting(); break;
                    case 'f': setPresentationMode(prev => !prev); break;
                }
            };

            useEffect(() => {
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [timerRunning, presentationMode]);

            useEffect(() => {
                if(presentationMode) document.body.classList.add('presentation-active');
                else document.body.classList.remove('presentation-active');
            }, [presentationMode]);

            // Get current palette based on theme mode
            const currentPalette = useMemo(() => {
                const key = getCurrentPaletteKey();
                return customPalettes[key];
            }, [customPalettes, isDark, highContrast]);

            // Memoized chart colors for canvas rendering using custom palette
            const chartColors = useMemo(() => {
                const p = currentPalette;
                const hexToRgba = (hex, alpha) => {
                    const rgb = colorUtils.hexToRgb(hex);
                    return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
                };
                return {
                    text: p.textMuted,
                    textStrong: p.text,
                    grid: p.border,
                    gridLight: hexToRgba(p.border, 0.3),
                    line: p.success,
                    lineFill: hexToRgba(p.success, 0.15),
                    accent: p.accent,
                    projection: p.textMuted,
                    projectionFill: hexToRgba(p.textMuted, 0.1),
                    projectionLight: hexToRgba(p.textMuted, 0.3),
                    marker: p.success,
                    markerHover: p.success,
                    burnLine: p.warning,
                    burnFill: hexToRgba(p.warning, 0.1),
                };
            }, [currentPalette]);
            
            const handleCopy = () => {
                const text = `${t("meeting")}: ${title}\n${t("date")}: ${new Date().toLocaleDateString()}\n${t("duration")}: ${formatTime(billableDuration)}\n${t("cost")}: ${formatMoney(currentCost, currency)}\n${t("burnRate")}: ${formatMoney(calculatedBurnRate, currency)}${"/hr"}\n${t("attendees")}: ${totalAttendees}`;
                copyToClipboard(text);
                setCopySuccess(true);
                setTimeout(() => setCopySuccess(false), UI.COPY_SUCCESS_DURATION_MS);
            };

            const handleShare = (type) => {
                const state = {
                    title, currency, inputMode, overhead, simpleInputs, detailedRows,
                    isDark, highContrast, customPalettes, logoUri, schriftzugUri, locale
                };
                const url = generateShareUrl(state, {
                    minimal: type === 'minimal'
                });
                copyToClipboard(url);
                setShareMenuOpen(false);
                setShareSuccess(true);
                setTimeout(() => setShareSuccess(false), UI.COPY_SUCCESS_DURATION_MS);
            };

            const now = Date.now();
            const marks = getNextQuarterMarks(now);
            const msToTarget1 = Math.max(0, marks[0] - now);
            const costAtTarget1 = currentCost + (timerRunning ? (calculatedBurnRate / TIME.MS_PER_HOUR) * msToTarget1 : 0);
            
            const mainStyle = { backgroundColor: currentPalette.background, color: currentPalette.text };
            const surfaceStyle = { backgroundColor: currentPalette.surface, borderColor: currentPalette.border };
            const mutedStyle = { color: currentPalette.textMuted };
            const accentStyle = { backgroundColor: currentPalette.accent, color: '#ffffff' };

            return (
                <div className="flex flex-col h-full w-full overflow-hidden transition-colors duration-200 relative" style={mainStyle}>

                    {presentationMode && (
                        <>
                            {logoUri && (
                                <div className="absolute top-4 left-4 z-50">
                                    <img src={logoUri} alt="Logo" className="h-12 w-auto max-w-[150px] object-contain" />
                                </div>
                            )}
                            <div className="absolute top-4 right-4 z-50 flex gap-2">
                                <button onClick={() => setIsDark(!isDark)} className="p-3 rounded-full transition-colors border shadow-lg" style={{ ...surfaceStyle, color: currentPalette.textMuted }} title={t("toggleTheme")}>
                                    <Icon name="sun" size={20} className={isDark ? "block" : "hidden"} /><Icon name="moon" size={20} className={isDark ? "hidden" : "block"} />
                                </button>
                                <button onClick={() => setPresentationMode(false)} className="p-3 rounded-full transition-colors border shadow-lg hover:text-red-500" style={{ ...surfaceStyle, color: currentPalette.textMuted }} title={t("exitPresentation")}>
                                    <Icon name="log-out" size={20} />
                                </button>
                            </div>
                        </>
                    )}

                    {!presentationMode && (
                        <header className="flex flex-col md:flex-row md:items-center justify-between px-4 md:px-6 py-4 gap-4 border-b" style={{ borderColor: currentPalette.border }}>
                            <div className="flex items-center gap-4 w-full md:w-auto">
                                {logoUri ? (
                                    <img src={logoUri} alt="Logo" className="h-10 w-auto max-w-[120px] object-contain shrink-0" />
                                ) : (
                                    <div className="p-2 rounded-lg shadow-lg shrink-0" style={accentStyle}>
                                        <Icon name="calculator" />
                                    </div>
                                )}
                                {schriftzugUri ? (
                                    <img src={schriftzugUri} alt="Wordmark" className="h-8 w-auto max-w-[200px] object-contain" />
                                ) : (
                                    <input value={title} onChange={(e) => setTitle(e.target.value)} className="text-xl font-bold bg-transparent border-b border-transparent hover:border-slate-300 focus:border-blue-500 outline-none w-full md:w-64" style={{ color: currentPalette.text }} />
                                )}
                            </div>
                            <div className="flex items-center gap-3 w-full md:w-auto overflow-x-auto pb-2 md:pb-0">
                                <select value={currency} onChange={(e) => setCurrency(e.target.value)} className="p-2 rounded border shrink-0 focus:ring-2 focus:ring-blue-500" style={surfaceStyle}>
                                    <option value="USD">{t("currencyUSD")}</option>
                                    <option value="EUR">{t("currencyEUR")}</option>
                                    <option value="GBP">{t("currencyGBP")}</option>
                                </select>
                                <button onClick={() => setHighContrast(!highContrast)} title={t("highContrast")} className="p-2 rounded shrink-0 hover:opacity-70">
                                    <Icon name="eye" />
                                </button>
                                <button onClick={() => setIsDark(!isDark)} title={t("themeToggle")} className="p-2 rounded shrink-0 hover:opacity-70">
                                    <Icon name={isDark ? "sun" : "moon"} />
                                </button>
                                <button onClick={() => setPresentationMode(true)} className="flex items-center gap-2 px-4 py-2 rounded shadow-sm shrink-0" style={accentStyle}>
                                    <Icon name="presentation" size={16} /> <span className="whitespace-nowrap">{t("presentationMode")}</span>
                                </button>
                            </div>
                        </header>
                    )}

                    <main className="main-layout flex-1 min-h-0 overflow-y-auto overflow-x-hidden flex flex-col lg:flex-row relative">
                        <div className={`content-area shrink-0 lg:shrink lg:flex-1 flex flex-col gap-6 p-4 md:p-6 transition-all duration-500 relative ${presentationMode ? 'justify-center items-center scale-100 md:scale-105' : ''}`}>
                            <div className="text-center space-y-2">
                                <div className="uppercase tracking-widest text-sm font-semibold" style={mutedStyle}>{t("currentMeetingCost")}</div>
                                <div className={`font-bold tabular-nums leading-none tracking-tight ${presentationMode ? 'text-7xl md:text-9xl' : 'text-6xl md:text-8xl'}`} style={{ color: currentPalette.accent }}>
                                    {formatMoney(currentCost, currency)}
                                </div>
                            </div>

                            <div className="grid grid-cols-2 gap-4 md:gap-8 text-center max-w-2xl w-full mx-auto mt-4">
                                <div>
                                    <div className="text-sm uppercase font-semibold mb-1" style={mutedStyle}>{t("billableTime")}</div>
                                    <div className="text-2xl md:text-4xl font-mono tabular-nums">
                                        {formatTime(billableDuration)}
                                    </div>
                                </div>
                                <div>
                                    <div className="text-sm uppercase font-semibold mb-1" style={mutedStyle}>{t("burnRatePerHour")}</div>
                                    <div className="text-2xl md:text-4xl tabular-nums" style={{ color: timerRunning ? currentPalette.warning : currentPalette.text }}>
                                        {formatMoney(calculatedBurnRate, currency)}
                                    </div>
                                </div>
                            </div>

                            {presentationMode && (
                                <div className="mt-8 w-full max-w-4xl flex flex-col gap-6">
                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6 text-center">
                                        <div className="p-4 rounded-lg flex flex-col justify-between items-center border" style={surfaceStyle}>
                                            <div className="text-xs uppercase opacity-70 mb-1">{t("participants")}</div>
                                            <div className="flex items-center gap-4">
                                                {inputMode === 'simple' && (
                                                    <button onClick={() => setSimpleInputs(p => ({...p, count: Math.max(1, p.count - 1)}))} className="w-12 h-12 rounded-lg flex items-center justify-center transition-colors hover:opacity-70" style={{ backgroundColor: currentPalette.border, color: currentPalette.textMuted }}><Icon name="minus" size={20}/></button>
                                                )}
                                                <div className="text-4xl font-bold tabular-nums">{totalAttendees}</div>
                                                {inputMode === 'simple' && (
                                                    <button onClick={() => setSimpleInputs(p => ({...p, count: p.count + 1}))} className="w-12 h-12 rounded-lg flex items-center justify-center transition-colors hover:opacity-70" style={{ backgroundColor: currentPalette.border, color: currentPalette.textMuted }}><Icon name="plus" size={20}/></button>
                                                )}
                                            </div>
                                        </div>

                                        <div className="p-4 rounded-lg border" style={surfaceStyle}>
                                            <div className="text-xs uppercase opacity-70 mb-1">{t("estimatedAt")} {formatClockTime(new Date(marks[0]))}</div>
                                            <div className="text-3xl font-bold" style={mutedStyle}>
                                                {formatMoney(costAtTarget1, currency)}
                                            </div>
                                        </div>

                                        <button onClick={toggleTimer} className={`p-4 rounded-lg flex flex-col items-center justify-center gap-2 cursor-pointer transition-colors hover:opacity-80 ${timerRunning ? 'bg-green-900/20 text-green-600 hover:bg-green-900/30' : 'bg-red-900/20 text-red-600 hover:bg-red-900/30'}`}>
                                            <div className={`w-3 h-3 rounded-full ${timerRunning ? 'bg-green-500 animate-pulse' : 'bg-red-500'}`}></div>
                                            <span className="font-bold uppercase tracking-wider">{timerRunning ? t("running") : t("paused")}</span>
                                            <span className="text-[10px] uppercase opacity-70">{t("clickToToggle")}</span>
                                        </button>
                                    </div>

                                    <div className="grid grid-cols-1 xl:grid-cols-2 gap-4 w-full">
                                        <div className="h-40 rounded-lg border overflow-hidden" style={surfaceStyle}>
                                            <div className="h-full w-full relative">
                                                <div className="absolute top-1 left-2 text-[10px] uppercase font-semibold opacity-50">{t("costHistoryProjection")}</div>
                                                <CostHistoryChart segments={segments} currentCost={currentCost} currentBurnRate={calculatedBurnRate} currency={currency} chartColors={chartColors} startTime={startTime} timerRunning={timerRunning} />
                                            </div>
                                        </div>
                                        <div className="h-40 rounded-lg border overflow-hidden" style={surfaceStyle}>
                                            <BurnRateChart segments={segments} currentBurnRate={timerRunning ? calculatedBurnRate : 0} currency={currency} chartColors={chartColors} startTime={startTime} timerRunning={timerRunning} label={t("burnRateHistory")} />
                                        </div>
                                    </div>
                                </div>
                            )}

                            {!presentationMode && (
                                <div className="flex flex-col md:flex-row justify-center gap-4 mt-4">
                                    <button onClick={toggleTimer} className={`px-8 py-4 rounded-xl text-xl font-bold shadow-lg transform transition-all hover:scale-105 active:scale-95 flex items-center justify-center gap-3 ${timerRunning ? 'bg-amber-100 text-amber-700 border-2 border-amber-500 hover:bg-amber-200' : ''}`} style={timerRunning ? {} : { backgroundColor: currentPalette.success, color: '#ffffff' }}>
                                        <Icon name={timerRunning ? "pause" : "play"} />
                                        {timerRunning ? t("pause") : (startTime ? t("resume") : t("start"))}
                                    </button>
                                    <button onClick={resetMeeting} className="px-6 py-4 rounded-xl text-lg font-semibold border-2 hover:text-red-500 transition-colors flex items-center justify-center" style={surfaceStyle}>
                                        <Icon name="rotate-ccw" />
                                    </button>
                                </div>
                            )}

                            {!presentationMode && (
                                <div className="mt-auto p-4 rounded-xl border" style={surfaceStyle}>
                                    <div className="grid grid-cols-1 xl:grid-cols-2 gap-4">
                                        <div>
                                            <h3 className="text-sm font-semibold uppercase mb-2 flex items-center gap-2" style={mutedStyle}>
                                                <Icon name="trending-up" size={16}/> {t("costHistoryProjection")}
                                            </h3>
                                            <div className="h-48 w-full">
                                                <CostHistoryChart segments={segments} currentCost={currentCost} currentBurnRate={calculatedBurnRate} currency={currency} chartColors={chartColors} startTime={startTime} timerRunning={timerRunning} />
                                            </div>
                                        </div>
                                        <div>
                                            <h3 className="text-sm font-semibold uppercase mb-2 flex items-center gap-2" style={mutedStyle}>
                                                <Icon name="activity" size={16}/> {t("burnRateHistory")}
                                            </h3>
                                            <div className="h-48 w-full">
                                                <BurnRateChart segments={segments} currentBurnRate={timerRunning ? calculatedBurnRate : 0} currency={currency} chartColors={chartColors} startTime={startTime} timerRunning={timerRunning} label={t("burnRateHistory")} />
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>

                        {!presentationMode && (
                            <div className="settings-sidebar shrink-0 lg:shrink w-full lg:w-96 flex flex-col gap-4 p-4 md:p-6 lg:pt-6 relative">
                                <div className="shrink-0 rounded-lg border overflow-hidden" style={surfaceStyle}>
                                    <button onClick={() => setShowAgenda(!showAgenda)} className="w-full px-4 py-3 flex justify-between items-center text-sm font-semibold hover:opacity-70" style={mutedStyle}>
                                        <span>{t("agendaRoiCheck")}</span>
                                        <Icon name={showAgenda ? "chevron-up" : "chevron-down"} size={16} />
                                    </button>
                                    {showAgenda && (
                                        <div className="p-4 space-y-3 text-sm">
                                            <label className="flex items-center gap-2 cursor-pointer"><input type="checkbox" className="rounded" style={{ accentColor: currentPalette.accent }} /><span>{t("goalDefined")}</span></label>
                                            <label className="flex items-center gap-2 cursor-pointer"><input type="checkbox" className="rounded" style={{ accentColor: currentPalette.accent }} /><span>{t("decisionRequired")}</span></label>
                                            <label className="flex items-center gap-2 cursor-pointer"><input type="checkbox" className="rounded" style={{ accentColor: currentPalette.accent }} /><span>{t("alternativesConsidered")}</span></label>
                                        </div>
                                    )}
                                </div>

                                <div className="shrink-0 rounded-xl border flex flex-col shadow-sm" style={surfaceStyle}>
                                    <div className="flex" style={{ borderBottom: `1px solid ${currentPalette.border}` }}>
                                        <button onClick={() => switchInputMode('simple')} className="flex-1 py-3 text-sm font-medium" style={inputMode === 'simple' ? { color: currentPalette.accent, borderBottom: `2px solid ${currentPalette.accent}` } : mutedStyle}>{t("simple")}</button>
                                        <button onClick={() => switchInputMode('detailed')} className="flex-1 py-3 text-sm font-medium" style={inputMode === 'detailed' ? { color: currentPalette.accent, borderBottom: `2px solid ${currentPalette.accent}` } : mutedStyle}>{t("detailed")}</button>
                                    </div>

                                    <div className="p-5 flex-1 overflow-auto">
                                        <div className="mb-6">
                                            <label className="block text-xs font-bold uppercase mb-1" style={mutedStyle}>{t("overhead")}</label>
                                            <div className="flex gap-2">
                                                {[1.0, 1.3, 1.5, 2.0].map(v => (
                                                    <button key={v} onClick={() => setOverhead(v)} className={`flex-1 py-1 text-xs rounded border ${overhead === v ? 'bg-blue-100 border-blue-500 text-blue-700' : 'border-slate-200 text-slate-500'}`}>{v}x</button>
                                                ))}
                                            </div>
                                        </div>

                                        {inputMode === 'simple' ? (
                                            <div className="space-y-6">
                                                <div>
                                                    <label className="block text-sm font-medium mb-1" style={mutedStyle}>{t("avgHourlyRate")} ({currency})</label>
                                                    <input type="number" value={simpleInputs.rate} onChange={(e) => setSimpleInputs({...simpleInputs, rate: Number(e.target.value)})} className="w-full p-2 rounded border text-lg font-mono" style={surfaceStyle} />
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium mb-1" style={mutedStyle}>{t("attendeeCount")}</label>
                                                    <div className="flex items-center gap-2">
                                                        <button onClick={() => setSimpleInputs(prev => ({...prev, count: Math.max(1, prev.count - 1)}))} className="w-12 h-12 flex items-center justify-center rounded text-xl font-bold transition-colors hover:opacity-70" style={{ backgroundColor: currentPalette.border, color: currentPalette.textMuted }}><Icon name="minus" size={20}/></button>
                                                        <input type="number" value={simpleInputs.count} onChange={(e) => setSimpleInputs({...simpleInputs, count: Math.max(1, Number(e.target.value))})} className="flex-1 min-w-0 p-2 text-center rounded border text-3xl font-bold font-mono" style={surfaceStyle} />
                                                        <button onClick={() => setSimpleInputs(prev => ({...prev, count: prev.count + 1}))} className="w-12 h-12 flex items-center justify-center rounded text-xl font-bold transition-colors hover:opacity-70" style={{ backgroundColor: currentPalette.accent, color: '#ffffff' }}><Icon name="plus" size={20}/></button>
                                                    </div>
                                                </div>
                                            </div>
                                        ) : (
                                            <div className="space-y-3">
                                                {detailedRows.map((row, idx) => (
                                                    <div key={row.id} className="flex gap-2 items-center p-2 rounded border" style={{ backgroundColor: currentPalette.background, borderColor: currentPalette.border }}>
                                                        <div className="flex-1">
                                                            <input type="text" placeholder="Role" value={row.label} onChange={(e) => { const newRows = [...detailedRows]; newRows[idx].label = e.target.value; setDetailedRows(newRows); }} className="w-full bg-transparent text-sm font-bold outline-none" />
                                                            <div className="flex items-center gap-1 text-xs" style={mutedStyle}>
                                                                <span>{currency}</span>
                                                                <input type="number" value={row.rate} onChange={(e) => { const newRows = [...detailedRows]; newRows[idx].rate = Number(e.target.value); setDetailedRows(newRows); }} className="w-16 bg-transparent border-b outline-none" style={{ borderColor: currentPalette.border }} />
                                                                <span>/hr</span>
                                                            </div>
                                                        </div>
                                                        <div className="flex items-center gap-1">
                                                            <button onClick={() => { const newRows = [...detailedRows]; newRows[idx].count = Math.max(0, newRows[idx].count - 1); setDetailedRows(newRows); }} className="w-8 h-8 rounded flex items-center justify-center font-bold hover:opacity-70" style={{ backgroundColor: currentPalette.border }}>-</button>
                                                            <span className="w-8 text-center font-mono font-bold">{row.count}</span>
                                                            <button onClick={() => { const newRows = [...detailedRows]; newRows[idx].count = newRows[idx].count + 1; setDetailedRows(newRows); }} className="w-8 h-8 rounded flex items-center justify-center font-bold hover:opacity-70" style={{ backgroundColor: currentPalette.accent, color: '#ffffff' }}>+</button>
                                                        </div>
                                                        <button onClick={() => setDetailedRows(detailedRows.filter(r => r.id !== row.id))} className="px-1 hover:text-red-500" style={mutedStyle}><Icon name="trash-2" size={14}/></button>
                                                    </div>
                                                ))}
                                                <button onClick={() => setDetailedRows([...detailedRows, { id: Date.now(), label: t("newRole"), rate: 100, count: 1 }])} className="w-full py-2 border-2 border-dashed rounded text-sm font-bold hover:opacity-70" style={{ borderColor: currentPalette.border, color: currentPalette.textMuted }}>{t("addRole")}</button>
                                            </div>
                                        )}
                                    </div>

                                    <div className="p-4 rounded-b-xl" style={{ borderTop: `1px solid ${currentPalette.border}`, backgroundColor: currentPalette.background }}>
                                        <div className="flex justify-between items-center text-sm">
                                            <span style={mutedStyle}>{t("activeRate")}</span>
                                            <span className="font-bold tabular-nums" style={{ color: timerRunning ? currentPalette.warning : currentPalette.text }}>
                                                {formatMoney(calculatedBurnRate, currency)} / hr
                                            </span>
                                        </div>
                                    </div>
                                </div>
                                
                                {!presentationMode && (
                                    <div className="shrink-0 rounded-lg border overflow-hidden" style={surfaceStyle}>
                                        <div className="px-4 py-3 text-sm font-semibold border-b" style={{ color: currentPalette.textMuted, borderColor: currentPalette.border }}>
                                            <Icon name="palette" size={14} className="inline mr-2" />{t("corporateDesign")}
                                        </div>
                                        <div className="p-4 space-y-4">
                                            <div>
                                                <label className="block text-xs font-bold uppercase mb-2" style={mutedStyle}>{t("colorPalettes")}</label>
                                                {[
                                                    { key: 'light', label: t('paletteLight') },
                                                    { key: 'lightContrast', label: t('paletteLightContrast') },
                                                    { key: 'dark', label: t('paletteDark') },
                                                    { key: 'darkContrast', label: t('paletteDarkContrast') }
                                                ].map(({ key: paletteKey, label: paletteLabel }) => (
                                                    <details key={paletteKey} className="mb-2 rounded border" style={{ borderColor: currentPalette.border, backgroundColor: paletteKey === getCurrentPaletteKey() ? currentPalette.background : 'transparent' }}>
                                                        <summary className="px-3 py-2 cursor-pointer text-sm font-medium flex items-center justify-between" style={{ color: paletteKey === getCurrentPaletteKey() ? currentPalette.accent : currentPalette.text }}>
                                                            <span>{paletteLabel} {paletteKey === getCurrentPaletteKey() && <span className="text-xs ml-1">({t('activeRate').split(' ')[0]})</span>}</span>
                                                        </summary>
                                                        <div className="px-3 pb-3 space-y-2">
                                                            <div className="grid grid-cols-2 gap-2">
                                                                {PALETTE_KEYS.map(colorKey => (
                                                                    <ColorPicker
                                                                        key={colorKey}
                                                                        color={customPalettes[paletteKey][colorKey]}
                                                                        onChange={(v) => updatePaletteColor(paletteKey, colorKey, v)}
                                                                        label={t(`color${colorKey.charAt(0).toUpperCase() + colorKey.slice(1)}`)}
                                                                        isDark={isDark}
                                                                        t={t}
                                                                    />
                                                                ))}
                                                            </div>
                                                            <button
                                                                onClick={() => resetPalette(paletteKey)}
                                                                className="w-full mt-2 px-3 py-1.5 text-xs rounded border hover:opacity-70"
                                                                style={{ borderColor: currentPalette.border, color: currentPalette.textMuted }}
                                                            >
                                                                <Icon name="rotate-ccw" size={12} className="inline mr-1" />{t("resetPalette")}
                                                            </button>
                                                        </div>
                                                    </details>
                                                ))}
                                            </div>
                                            <div>
                                                <label className="block text-xs font-bold uppercase mb-1" style={mutedStyle}>{t("logoUrl")}</label>
                                                <input
                                                    type="url"
                                                    value={logoUri}
                                                    onChange={(e) => setLogoUri(e.target.value)}
                                                    placeholder="https://..."
                                                    className="w-full p-2 text-sm rounded border focus:ring-2 focus:ring-blue-500 outline-none"
                                                    style={{ backgroundColor: currentPalette.background, borderColor: currentPalette.border, color: currentPalette.text }}
                                                />
                                            </div>
                                            <div>
                                                <label className="block text-xs font-bold uppercase mb-1" style={mutedStyle}>{t("wordmarkUrl")}</label>
                                                <input
                                                    type="url"
                                                    value={schriftzugUri}
                                                    onChange={(e) => setSchriftzugUri(e.target.value)}
                                                    placeholder="https://..."
                                                    className="w-full p-2 text-sm rounded border focus:ring-2 focus:ring-blue-500 outline-none"
                                                    style={{ backgroundColor: currentPalette.background, borderColor: currentPalette.border, color: currentPalette.text }}
                                                />
                                            </div>
                                        </div>
                                    </div>
                                )}

                                <button onClick={handleCopy} className="shrink-0 w-full flex justify-center items-center gap-2 relative overflow-hidden px-4 py-2 rounded font-medium transition-all focus:ring-2 focus:outline-none hover:opacity-80" style={{ backgroundColor: currentPalette.accent, color: '#ffffff' }}>
                                    <Icon name={copySuccess ? "check" : "copy"} size={16} style={{ color: copySuccess ? currentPalette.success : '#ffffff' }} />
                                    {copySuccess ? t("copied") : t("copySnapshot")}
                                </button>

                                <div className="shrink-0 relative">
                                    <button
                                        onClick={() => setShareMenuOpen(!shareMenuOpen)}
                                        className="w-full flex justify-center items-center gap-2 px-4 py-2 rounded font-medium transition-all focus:ring-2 focus:outline-none hover:opacity-80 border"
                                        style={{ borderColor: currentPalette.accent, color: currentPalette.accent, backgroundColor: 'transparent' }}
                                    >
                                        <Icon name={shareSuccess ? "check" : "share-2"} size={16} style={{ color: shareSuccess ? currentPalette.success : currentPalette.accent }} />
                                        {shareSuccess ? t("linkCopied") : t("shareLink")}
                                        <Icon name="chevron-down" size={14} style={{ marginLeft: 'auto' }} />
                                    </button>
                                    {shareMenuOpen && (
                                        <div className="absolute bottom-full left-0 right-0 mb-1 rounded-lg border shadow-lg overflow-hidden z-50" style={surfaceStyle}>
                                            <button
                                                onClick={() => handleShare('minimal')}
                                                className="w-full px-3 py-2 text-sm text-left hover:opacity-70 flex items-center gap-2"
                                                style={{ color: currentPalette.text }}
                                            >
                                                <Icon name="zap" size={14} style={mutedStyle} />
                                                {t("shareLinkMinimal")}
                                            </button>
                                            <button
                                                onClick={() => handleShare('readable')}
                                                className="w-full px-3 py-2 text-sm text-left hover:opacity-70 flex items-center gap-2 border-t"
                                                style={{ color: currentPalette.text, borderColor: currentPalette.border }}
                                            >
                                                <Icon name="file-text" size={14} style={mutedStyle} />
                                                {t("shareLinkReadable")}
                                            </button>
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}
                    </main>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>